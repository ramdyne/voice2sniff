/* 
 * h245.cxx
 *
 * Source for decoding the H.245 protocol
 *
 * H.323 for Ethereal
 *
 * Copyright (c) 2002 Koninklijke Philips NV
 *
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.0 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is H.323 for Ethereal.
 *
 * The Initial Developer of the Original Code is Koninklijke Philips NV.
 *
 * All Rights Reserved.
 *
 * Contributor(s): ______________________________________.
 *
 *
 */

//
// h245.cxx
//
// Code automatically generated by asnparse.
//

#ifdef __GNUC__
#pragma implementation "h245.h"
#endif


#ifdef USE_FOR_ETHEREAL

extern "C" {

#  ifdef HAVE_CONFIG_H
#    include "config.h"
#  endif

#  include "plugins/plugin_api.h"

#  include "moduleinfo.h"

#  ifdef HAVE_SYS_TYPES_H
#    include <sys/types.h>
#  endif

#  include <string.h>
#  include <ctype.h>
#  include <time.h>

#  include <gmodule.h>
#  ifdef HAVE_NETINET_IN_H
#    include <netinet/in.h>
#  endif
#  include <epan/packet.h>
#  include "packet-h225.h"

//#  include "plugins/plugin_api_defs.h"
//#  include "packet-rtp.h"
//#  include "packet-rtcp.h"
}

extern "C++" {
#  include <stdio.h>
#  include <string.h>
#  include "h245_container.h"
#  include "mini_ptlib/include/mini_ptlib.h"
#  include "h245.h"
}
#endif//USE_FOR_ETHEREAL

#ifndef USE_FOR_ETHEREAL
#  include <ptlib.h>
#  include "h245.h"
#endif //USE_FOR_ETHEREAL

#define new PNEW
static H245_Integer_Container* hCont;

void setH245Container( H245_Integer_Container* cont )
{
  hCont = cont;
}

//
// MultimediaSystemControlMessage
//

H245_MultimediaSystemControlMessage::H245_MultimediaSystemControlMessage(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "request "
        "response "
        "command "
        "indication "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultimediaSystemControlMessage::operator H245_RequestMessage &() const
#else
H245_MultimediaSystemControlMessage::operator H245_RequestMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestMessage::Class()), PInvalidCast);
#endif
  return *(H245_RequestMessage *)choice;
}


H245_MultimediaSystemControlMessage::operator const H245_RequestMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestMessage::Class()), PInvalidCast);
#endif
  return *(H245_RequestMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultimediaSystemControlMessage::operator H245_ResponseMessage &() const
#else
H245_MultimediaSystemControlMessage::operator H245_ResponseMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ResponseMessage::Class()), PInvalidCast);
#endif
  return *(H245_ResponseMessage *)choice;
}


H245_MultimediaSystemControlMessage::operator const H245_ResponseMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ResponseMessage::Class()), PInvalidCast);
#endif
  return *(H245_ResponseMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultimediaSystemControlMessage::operator H245_CommandMessage &() const
#else
H245_MultimediaSystemControlMessage::operator H245_CommandMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_CommandMessage::Class()), PInvalidCast);
#endif
  return *(H245_CommandMessage *)choice;
}


H245_MultimediaSystemControlMessage::operator const H245_CommandMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_CommandMessage::Class()), PInvalidCast);
#endif
  return *(H245_CommandMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultimediaSystemControlMessage::operator H245_IndicationMessage &() const
#else
H245_MultimediaSystemControlMessage::operator H245_IndicationMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_IndicationMessage::Class()), PInvalidCast);
#endif
  return *(H245_IndicationMessage *)choice;
}


H245_MultimediaSystemControlMessage::operator const H245_IndicationMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_IndicationMessage::Class()), PInvalidCast);
#endif
  return *(H245_IndicationMessage *)choice;
}


BOOL H245_MultimediaSystemControlMessage::CreateObject()
{
  switch (tag) {
    case e_request :
      choice = new H245_RequestMessage();
      return TRUE;
    case e_response :
      choice = new H245_ResponseMessage();
      return TRUE;
    case e_command :
      choice = new H245_CommandMessage();
      return TRUE;
    case e_indication :
      choice = new H245_IndicationMessage();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_MultimediaSystemControlMessage::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultimediaSystemControlMessage::Class()), PInvalidCast);
#endif
  return new H245_MultimediaSystemControlMessage(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultimediaSystemControlMessage::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_request :
        ( ( H245_RequestMessage * ) choice )->preShowEthereal();
        break;
      case e_response :
        ( ( H245_ResponseMessage * ) choice )->preShowEthereal();
        break;
      case e_command :
        ( ( H245_CommandMessage * ) choice )->preShowEthereal();
        break;
      case e_indication :
        ( ( H245_IndicationMessage * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_MultimediaSystemControlMessage::getSummary( void ) 
{
  if ( choice != NULL )
    return choice->getSummary();
  else 
    return PString( "MultimediaSystemControlMessage" );
}

void H245_MultimediaSystemControlMessage::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_MultimediaSystemControlMessage_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// RequestMessage
//

H245_RequestMessage::H245_RequestMessage(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 11, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "masterSlaveDetermination "
        "terminalCapabilitySet "
        "openLogicalChannel "
        "closeLogicalChannel "
        "requestChannelClose "
        "multiplexEntrySend "
        "requestMultiplexEntry "
        "requestMode "
        "roundTripDelayRequest "
        "maintenanceLoopRequest "
        "communicationModeRequest "
        "conferenceRequest "
        "multilinkRequest "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_NonStandardMessage &() const
#else
H245_RequestMessage::operator H245_NonStandardMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardMessage::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


H245_RequestMessage::operator const H245_NonStandardMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardMessage::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_MasterSlaveDetermination &() const
#else
H245_RequestMessage::operator H245_MasterSlaveDetermination &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MasterSlaveDetermination::Class()), PInvalidCast);
#endif
  return *(H245_MasterSlaveDetermination *)choice;
}


H245_RequestMessage::operator const H245_MasterSlaveDetermination &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MasterSlaveDetermination::Class()), PInvalidCast);
#endif
  return *(H245_MasterSlaveDetermination *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_TerminalCapabilitySet &() const
#else
H245_RequestMessage::operator H245_TerminalCapabilitySet &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_TerminalCapabilitySet::Class()), PInvalidCast);
#endif
  return *(H245_TerminalCapabilitySet *)choice;
}


H245_RequestMessage::operator const H245_TerminalCapabilitySet &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_TerminalCapabilitySet::Class()), PInvalidCast);
#endif
  return *(H245_TerminalCapabilitySet *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_OpenLogicalChannel &() const
#else
H245_RequestMessage::operator H245_OpenLogicalChannel &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_OpenLogicalChannel::Class()), PInvalidCast);
#endif
  return *(H245_OpenLogicalChannel *)choice;
}


H245_RequestMessage::operator const H245_OpenLogicalChannel &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_OpenLogicalChannel::Class()), PInvalidCast);
#endif
  return *(H245_OpenLogicalChannel *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_CloseLogicalChannel &() const
#else
H245_RequestMessage::operator H245_CloseLogicalChannel &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_CloseLogicalChannel::Class()), PInvalidCast);
#endif
  return *(H245_CloseLogicalChannel *)choice;
}


H245_RequestMessage::operator const H245_CloseLogicalChannel &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_CloseLogicalChannel::Class()), PInvalidCast);
#endif
  return *(H245_CloseLogicalChannel *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_RequestChannelClose &() const
#else
H245_RequestMessage::operator H245_RequestChannelClose &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestChannelClose::Class()), PInvalidCast);
#endif
  return *(H245_RequestChannelClose *)choice;
}


H245_RequestMessage::operator const H245_RequestChannelClose &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestChannelClose::Class()), PInvalidCast);
#endif
  return *(H245_RequestChannelClose *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_MultiplexEntrySend &() const
#else
H245_RequestMessage::operator H245_MultiplexEntrySend &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultiplexEntrySend::Class()), PInvalidCast);
#endif
  return *(H245_MultiplexEntrySend *)choice;
}


H245_RequestMessage::operator const H245_MultiplexEntrySend &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultiplexEntrySend::Class()), PInvalidCast);
#endif
  return *(H245_MultiplexEntrySend *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_RequestMultiplexEntry &() const
#else
H245_RequestMessage::operator H245_RequestMultiplexEntry &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestMultiplexEntry::Class()), PInvalidCast);
#endif
  return *(H245_RequestMultiplexEntry *)choice;
}


H245_RequestMessage::operator const H245_RequestMultiplexEntry &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestMultiplexEntry::Class()), PInvalidCast);
#endif
  return *(H245_RequestMultiplexEntry *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_RequestMode &() const
#else
H245_RequestMessage::operator H245_RequestMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestMode::Class()), PInvalidCast);
#endif
  return *(H245_RequestMode *)choice;
}


H245_RequestMessage::operator const H245_RequestMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestMode::Class()), PInvalidCast);
#endif
  return *(H245_RequestMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_RoundTripDelayRequest &() const
#else
H245_RequestMessage::operator H245_RoundTripDelayRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RoundTripDelayRequest::Class()), PInvalidCast);
#endif
  return *(H245_RoundTripDelayRequest *)choice;
}


H245_RequestMessage::operator const H245_RoundTripDelayRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RoundTripDelayRequest::Class()), PInvalidCast);
#endif
  return *(H245_RoundTripDelayRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_MaintenanceLoopRequest &() const
#else
H245_RequestMessage::operator H245_MaintenanceLoopRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MaintenanceLoopRequest::Class()), PInvalidCast);
#endif
  return *(H245_MaintenanceLoopRequest *)choice;
}


H245_RequestMessage::operator const H245_MaintenanceLoopRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MaintenanceLoopRequest::Class()), PInvalidCast);
#endif
  return *(H245_MaintenanceLoopRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_CommunicationModeRequest &() const
#else
H245_RequestMessage::operator H245_CommunicationModeRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_CommunicationModeRequest::Class()), PInvalidCast);
#endif
  return *(H245_CommunicationModeRequest *)choice;
}


H245_RequestMessage::operator const H245_CommunicationModeRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_CommunicationModeRequest::Class()), PInvalidCast);
#endif
  return *(H245_CommunicationModeRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_ConferenceRequest &() const
#else
H245_RequestMessage::operator H245_ConferenceRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceRequest::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceRequest *)choice;
}


H245_RequestMessage::operator const H245_ConferenceRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceRequest::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_MultilinkRequest &() const
#else
H245_RequestMessage::operator H245_MultilinkRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkRequest::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkRequest *)choice;
}


H245_RequestMessage::operator const H245_MultilinkRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkRequest::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkRequest *)choice;
}


BOOL H245_RequestMessage::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardMessage();
      return TRUE;
    case e_masterSlaveDetermination :
      choice = new H245_MasterSlaveDetermination();
      return TRUE;
    case e_terminalCapabilitySet :
      choice = new H245_TerminalCapabilitySet();
      return TRUE;
    case e_openLogicalChannel :
      choice = new H245_OpenLogicalChannel();
      return TRUE;
    case e_closeLogicalChannel :
      choice = new H245_CloseLogicalChannel();
      return TRUE;
    case e_requestChannelClose :
      choice = new H245_RequestChannelClose();
      return TRUE;
    case e_multiplexEntrySend :
      choice = new H245_MultiplexEntrySend();
      return TRUE;
    case e_requestMultiplexEntry :
      choice = new H245_RequestMultiplexEntry();
      return TRUE;
    case e_requestMode :
      choice = new H245_RequestMode();
      return TRUE;
    case e_roundTripDelayRequest :
      choice = new H245_RoundTripDelayRequest();
      return TRUE;
    case e_maintenanceLoopRequest :
      choice = new H245_MaintenanceLoopRequest();
      return TRUE;
    case e_communicationModeRequest :
      choice = new H245_CommunicationModeRequest();
      return TRUE;
    case e_conferenceRequest :
      choice = new H245_ConferenceRequest();
      return TRUE;
    case e_multilinkRequest :
      choice = new H245_MultilinkRequest();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_RequestMessage::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestMessage::Class()), PInvalidCast);
#endif
  return new H245_RequestMessage(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RequestMessage::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardMessage * ) choice )->preShowEthereal();
        break;
      case e_masterSlaveDetermination :
        ( ( H245_MasterSlaveDetermination * ) choice )->preShowEthereal();
        break;
      case e_terminalCapabilitySet :
        ( ( H245_TerminalCapabilitySet * ) choice )->preShowEthereal();
        break;
      case e_openLogicalChannel :
        ( ( H245_OpenLogicalChannel * ) choice )->preShowEthereal();
        break;
      case e_closeLogicalChannel :
        ( ( H245_CloseLogicalChannel * ) choice )->preShowEthereal();
        break;
      case e_requestChannelClose :
        ( ( H245_RequestChannelClose * ) choice )->preShowEthereal();
        break;
      case e_multiplexEntrySend :
        ( ( H245_MultiplexEntrySend * ) choice )->preShowEthereal();
        break;
      case e_requestMultiplexEntry :
        ( ( H245_RequestMultiplexEntry * ) choice )->preShowEthereal();
        break;
      case e_requestMode :
        ( ( H245_RequestMode * ) choice )->preShowEthereal();
        break;
      case e_roundTripDelayRequest :
        ( ( H245_RoundTripDelayRequest * ) choice )->preShowEthereal();
        break;
      case e_maintenanceLoopRequest :
        ( ( H245_MaintenanceLoopRequest * ) choice )->preShowEthereal();
        break;
      case e_communicationModeRequest :
        ( ( H245_CommunicationModeRequest * ) choice )->preShowEthereal();
        break;
      case e_conferenceRequest :
        ( ( H245_ConferenceRequest * ) choice )->preShowEthereal();
        break;
      case e_multilinkRequest :
        ( ( H245_MultilinkRequest * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_RequestMessage::getSummary( void ) 
{
  if ( choice != NULL )
    return /*PString( "REQ : " ) +*/ choice->getSummary();
  else 
    return PString( "RequestMessage" );
}

void H245_RequestMessage::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_RequestMessage_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ResponseMessage
//

H245_ResponseMessage::H245_ResponseMessage(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 19, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "masterSlaveDeterminationAck "
        "masterSlaveDeterminationReject "
        "terminalCapabilitySetAck "
        "terminalCapabilitySetReject "
        "openLogicalChannelAck "
        "openLogicalChannelReject "
        "closeLogicalChannelAck "
        "requestChannelCloseAck "
        "requestChannelCloseReject "
        "multiplexEntrySendAck "
        "multiplexEntrySendReject "
        "requestMultiplexEntryAck "
        "requestMultiplexEntryReject "
        "requestModeAck "
        "requestModeReject "
        "roundTripDelayResponse "
        "maintenanceLoopAck "
        "maintenanceLoopReject "
        "communicationModeResponse "
        "conferenceResponse "
        "multilinkResponse "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_NonStandardMessage &() const
#else
H245_ResponseMessage::operator H245_NonStandardMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardMessage::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


H245_ResponseMessage::operator const H245_NonStandardMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardMessage::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_MasterSlaveDeterminationAck &() const
#else
H245_ResponseMessage::operator H245_MasterSlaveDeterminationAck &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MasterSlaveDeterminationAck::Class()), PInvalidCast);
#endif
  return *(H245_MasterSlaveDeterminationAck *)choice;
}


H245_ResponseMessage::operator const H245_MasterSlaveDeterminationAck &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MasterSlaveDeterminationAck::Class()), PInvalidCast);
#endif
  return *(H245_MasterSlaveDeterminationAck *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_MasterSlaveDeterminationReject &() const
#else
H245_ResponseMessage::operator H245_MasterSlaveDeterminationReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MasterSlaveDeterminationReject::Class()), PInvalidCast);
#endif
  return *(H245_MasterSlaveDeterminationReject *)choice;
}


H245_ResponseMessage::operator const H245_MasterSlaveDeterminationReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MasterSlaveDeterminationReject::Class()), PInvalidCast);
#endif
  return *(H245_MasterSlaveDeterminationReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_TerminalCapabilitySetAck &() const
#else
H245_ResponseMessage::operator H245_TerminalCapabilitySetAck &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_TerminalCapabilitySetAck::Class()), PInvalidCast);
#endif
  return *(H245_TerminalCapabilitySetAck *)choice;
}


H245_ResponseMessage::operator const H245_TerminalCapabilitySetAck &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_TerminalCapabilitySetAck::Class()), PInvalidCast);
#endif
  return *(H245_TerminalCapabilitySetAck *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_TerminalCapabilitySetReject &() const
#else
H245_ResponseMessage::operator H245_TerminalCapabilitySetReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_TerminalCapabilitySetReject::Class()), PInvalidCast);
#endif
  return *(H245_TerminalCapabilitySetReject *)choice;
}


H245_ResponseMessage::operator const H245_TerminalCapabilitySetReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_TerminalCapabilitySetReject::Class()), PInvalidCast);
#endif
  return *(H245_TerminalCapabilitySetReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_OpenLogicalChannelAck &() const
#else
H245_ResponseMessage::operator H245_OpenLogicalChannelAck &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_OpenLogicalChannelAck::Class()), PInvalidCast);
#endif
  return *(H245_OpenLogicalChannelAck *)choice;
}


H245_ResponseMessage::operator const H245_OpenLogicalChannelAck &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_OpenLogicalChannelAck::Class()), PInvalidCast);
#endif
  return *(H245_OpenLogicalChannelAck *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_OpenLogicalChannelReject &() const
#else
H245_ResponseMessage::operator H245_OpenLogicalChannelReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_OpenLogicalChannelReject::Class()), PInvalidCast);
#endif
  return *(H245_OpenLogicalChannelReject *)choice;
}


H245_ResponseMessage::operator const H245_OpenLogicalChannelReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_OpenLogicalChannelReject::Class()), PInvalidCast);
#endif
  return *(H245_OpenLogicalChannelReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_CloseLogicalChannelAck &() const
#else
H245_ResponseMessage::operator H245_CloseLogicalChannelAck &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_CloseLogicalChannelAck::Class()), PInvalidCast);
#endif
  return *(H245_CloseLogicalChannelAck *)choice;
}


H245_ResponseMessage::operator const H245_CloseLogicalChannelAck &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_CloseLogicalChannelAck::Class()), PInvalidCast);
#endif
  return *(H245_CloseLogicalChannelAck *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_RequestChannelCloseAck &() const
#else
H245_ResponseMessage::operator H245_RequestChannelCloseAck &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestChannelCloseAck::Class()), PInvalidCast);
#endif
  return *(H245_RequestChannelCloseAck *)choice;
}


H245_ResponseMessage::operator const H245_RequestChannelCloseAck &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestChannelCloseAck::Class()), PInvalidCast);
#endif
  return *(H245_RequestChannelCloseAck *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_RequestChannelCloseReject &() const
#else
H245_ResponseMessage::operator H245_RequestChannelCloseReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestChannelCloseReject::Class()), PInvalidCast);
#endif
  return *(H245_RequestChannelCloseReject *)choice;
}


H245_ResponseMessage::operator const H245_RequestChannelCloseReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestChannelCloseReject::Class()), PInvalidCast);
#endif
  return *(H245_RequestChannelCloseReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_MultiplexEntrySendAck &() const
#else
H245_ResponseMessage::operator H245_MultiplexEntrySendAck &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultiplexEntrySendAck::Class()), PInvalidCast);
#endif
  return *(H245_MultiplexEntrySendAck *)choice;
}


H245_ResponseMessage::operator const H245_MultiplexEntrySendAck &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultiplexEntrySendAck::Class()), PInvalidCast);
#endif
  return *(H245_MultiplexEntrySendAck *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_MultiplexEntrySendReject &() const
#else
H245_ResponseMessage::operator H245_MultiplexEntrySendReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultiplexEntrySendReject::Class()), PInvalidCast);
#endif
  return *(H245_MultiplexEntrySendReject *)choice;
}


H245_ResponseMessage::operator const H245_MultiplexEntrySendReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultiplexEntrySendReject::Class()), PInvalidCast);
#endif
  return *(H245_MultiplexEntrySendReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_RequestMultiplexEntryAck &() const
#else
H245_ResponseMessage::operator H245_RequestMultiplexEntryAck &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestMultiplexEntryAck::Class()), PInvalidCast);
#endif
  return *(H245_RequestMultiplexEntryAck *)choice;
}


H245_ResponseMessage::operator const H245_RequestMultiplexEntryAck &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestMultiplexEntryAck::Class()), PInvalidCast);
#endif
  return *(H245_RequestMultiplexEntryAck *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_RequestMultiplexEntryReject &() const
#else
H245_ResponseMessage::operator H245_RequestMultiplexEntryReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestMultiplexEntryReject::Class()), PInvalidCast);
#endif
  return *(H245_RequestMultiplexEntryReject *)choice;
}


H245_ResponseMessage::operator const H245_RequestMultiplexEntryReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestMultiplexEntryReject::Class()), PInvalidCast);
#endif
  return *(H245_RequestMultiplexEntryReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_RequestModeAck &() const
#else
H245_ResponseMessage::operator H245_RequestModeAck &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestModeAck::Class()), PInvalidCast);
#endif
  return *(H245_RequestModeAck *)choice;
}


H245_ResponseMessage::operator const H245_RequestModeAck &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestModeAck::Class()), PInvalidCast);
#endif
  return *(H245_RequestModeAck *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_RequestModeReject &() const
#else
H245_ResponseMessage::operator H245_RequestModeReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestModeReject::Class()), PInvalidCast);
#endif
  return *(H245_RequestModeReject *)choice;
}


H245_ResponseMessage::operator const H245_RequestModeReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestModeReject::Class()), PInvalidCast);
#endif
  return *(H245_RequestModeReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_RoundTripDelayResponse &() const
#else
H245_ResponseMessage::operator H245_RoundTripDelayResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RoundTripDelayResponse::Class()), PInvalidCast);
#endif
  return *(H245_RoundTripDelayResponse *)choice;
}


H245_ResponseMessage::operator const H245_RoundTripDelayResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RoundTripDelayResponse::Class()), PInvalidCast);
#endif
  return *(H245_RoundTripDelayResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_MaintenanceLoopAck &() const
#else
H245_ResponseMessage::operator H245_MaintenanceLoopAck &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MaintenanceLoopAck::Class()), PInvalidCast);
#endif
  return *(H245_MaintenanceLoopAck *)choice;
}


H245_ResponseMessage::operator const H245_MaintenanceLoopAck &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MaintenanceLoopAck::Class()), PInvalidCast);
#endif
  return *(H245_MaintenanceLoopAck *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_MaintenanceLoopReject &() const
#else
H245_ResponseMessage::operator H245_MaintenanceLoopReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MaintenanceLoopReject::Class()), PInvalidCast);
#endif
  return *(H245_MaintenanceLoopReject *)choice;
}


H245_ResponseMessage::operator const H245_MaintenanceLoopReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MaintenanceLoopReject::Class()), PInvalidCast);
#endif
  return *(H245_MaintenanceLoopReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_CommunicationModeResponse &() const
#else
H245_ResponseMessage::operator H245_CommunicationModeResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_CommunicationModeResponse::Class()), PInvalidCast);
#endif
  return *(H245_CommunicationModeResponse *)choice;
}


H245_ResponseMessage::operator const H245_CommunicationModeResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_CommunicationModeResponse::Class()), PInvalidCast);
#endif
  return *(H245_CommunicationModeResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_ConferenceResponse &() const
#else
H245_ResponseMessage::operator H245_ConferenceResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse *)choice;
}


H245_ResponseMessage::operator const H245_ConferenceResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_MultilinkResponse &() const
#else
H245_ResponseMessage::operator H245_MultilinkResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkResponse::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkResponse *)choice;
}


H245_ResponseMessage::operator const H245_MultilinkResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkResponse::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkResponse *)choice;
}


BOOL H245_ResponseMessage::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardMessage();
      return TRUE;
    case e_masterSlaveDeterminationAck :
      choice = new H245_MasterSlaveDeterminationAck();
      return TRUE;
    case e_masterSlaveDeterminationReject :
      choice = new H245_MasterSlaveDeterminationReject();
      return TRUE;
    case e_terminalCapabilitySetAck :
      choice = new H245_TerminalCapabilitySetAck();
      return TRUE;
    case e_terminalCapabilitySetReject :
      choice = new H245_TerminalCapabilitySetReject();
      return TRUE;
    case e_openLogicalChannelAck :
      choice = new H245_OpenLogicalChannelAck();
      return TRUE;
    case e_openLogicalChannelReject :
      choice = new H245_OpenLogicalChannelReject();
      return TRUE;
    case e_closeLogicalChannelAck :
      choice = new H245_CloseLogicalChannelAck();
      return TRUE;
    case e_requestChannelCloseAck :
      choice = new H245_RequestChannelCloseAck();
      return TRUE;
    case e_requestChannelCloseReject :
      choice = new H245_RequestChannelCloseReject();
      return TRUE;
    case e_multiplexEntrySendAck :
      choice = new H245_MultiplexEntrySendAck();
      return TRUE;
    case e_multiplexEntrySendReject :
      choice = new H245_MultiplexEntrySendReject();
      return TRUE;
    case e_requestMultiplexEntryAck :
      choice = new H245_RequestMultiplexEntryAck();
      return TRUE;
    case e_requestMultiplexEntryReject :
      choice = new H245_RequestMultiplexEntryReject();
      return TRUE;
    case e_requestModeAck :
      choice = new H245_RequestModeAck();
      return TRUE;
    case e_requestModeReject :
      choice = new H245_RequestModeReject();
      return TRUE;
    case e_roundTripDelayResponse :
      choice = new H245_RoundTripDelayResponse();
      return TRUE;
    case e_maintenanceLoopAck :
      choice = new H245_MaintenanceLoopAck();
      return TRUE;
    case e_maintenanceLoopReject :
      choice = new H245_MaintenanceLoopReject();
      return TRUE;
    case e_communicationModeResponse :
      choice = new H245_CommunicationModeResponse();
      return TRUE;
    case e_conferenceResponse :
      choice = new H245_ConferenceResponse();
      return TRUE;
    case e_multilinkResponse :
      choice = new H245_MultilinkResponse();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_ResponseMessage::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ResponseMessage::Class()), PInvalidCast);
#endif
  return new H245_ResponseMessage(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ResponseMessage::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardMessage * ) choice )->preShowEthereal();
        break;
      case e_masterSlaveDeterminationAck :
        ( ( H245_MasterSlaveDeterminationAck * ) choice )->preShowEthereal();
        break;
      case e_masterSlaveDeterminationReject :
        ( ( H245_MasterSlaveDeterminationReject * ) choice )->preShowEthereal();
        break;
      case e_terminalCapabilitySetAck :
        ( ( H245_TerminalCapabilitySetAck * ) choice )->preShowEthereal();
        break;
      case e_terminalCapabilitySetReject :
        ( ( H245_TerminalCapabilitySetReject * ) choice )->preShowEthereal();
        break;
      case e_openLogicalChannelAck :
        ( ( H245_OpenLogicalChannelAck * ) choice )->preShowEthereal();
        break;
      case e_openLogicalChannelReject :
        ( ( H245_OpenLogicalChannelReject * ) choice )->preShowEthereal();
        break;
      case e_closeLogicalChannelAck :
        ( ( H245_CloseLogicalChannelAck * ) choice )->preShowEthereal();
        break;
      case e_requestChannelCloseAck :
        ( ( H245_RequestChannelCloseAck * ) choice )->preShowEthereal();
        break;
      case e_requestChannelCloseReject :
        ( ( H245_RequestChannelCloseReject * ) choice )->preShowEthereal();
        break;
      case e_multiplexEntrySendAck :
        ( ( H245_MultiplexEntrySendAck * ) choice )->preShowEthereal();
        break;
      case e_multiplexEntrySendReject :
        ( ( H245_MultiplexEntrySendReject * ) choice )->preShowEthereal();
        break;
      case e_requestMultiplexEntryAck :
        ( ( H245_RequestMultiplexEntryAck * ) choice )->preShowEthereal();
        break;
      case e_requestMultiplexEntryReject :
        ( ( H245_RequestMultiplexEntryReject * ) choice )->preShowEthereal();
        break;
      case e_requestModeAck :
        ( ( H245_RequestModeAck * ) choice )->preShowEthereal();
        break;
      case e_requestModeReject :
        ( ( H245_RequestModeReject * ) choice )->preShowEthereal();
        break;
      case e_roundTripDelayResponse :
        ( ( H245_RoundTripDelayResponse * ) choice )->preShowEthereal();
        break;
      case e_maintenanceLoopAck :
        ( ( H245_MaintenanceLoopAck * ) choice )->preShowEthereal();
        break;
      case e_maintenanceLoopReject :
        ( ( H245_MaintenanceLoopReject * ) choice )->preShowEthereal();
        break;
      case e_communicationModeResponse :
        ( ( H245_CommunicationModeResponse * ) choice )->preShowEthereal();
        break;
      case e_conferenceResponse :
        ( ( H245_ConferenceResponse * ) choice )->preShowEthereal();
        break;
      case e_multilinkResponse :
        ( ( H245_MultilinkResponse * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_ResponseMessage::getSummary( void ) 
{
  if ( choice != NULL )
    return /*PString( "RES : " ) +*/ choice->getSummary();
  else 
    return PString( "ResponseMessage" );
}

void H245_ResponseMessage::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_ResponseMessage_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// CommandMessage
//

H245_CommandMessage::H245_CommandMessage(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 7, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "maintenanceLoopOffCommand "
        "sendTerminalCapabilitySet "
        "encryptionCommand "
        "flowControlCommand "
        "endSessionCommand "
        "miscellaneousCommand "
        "communicationModeCommand "
        "conferenceCommand "
        "h223MultiplexReconfiguration "
        "newATMVCCommand "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_NonStandardMessage &() const
#else
H245_CommandMessage::operator H245_NonStandardMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardMessage::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


H245_CommandMessage::operator const H245_NonStandardMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardMessage::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_MaintenanceLoopOffCommand &() const
#else
H245_CommandMessage::operator H245_MaintenanceLoopOffCommand &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MaintenanceLoopOffCommand::Class()), PInvalidCast);
#endif
  return *(H245_MaintenanceLoopOffCommand *)choice;
}


H245_CommandMessage::operator const H245_MaintenanceLoopOffCommand &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MaintenanceLoopOffCommand::Class()), PInvalidCast);
#endif
  return *(H245_MaintenanceLoopOffCommand *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_SendTerminalCapabilitySet &() const
#else
H245_CommandMessage::operator H245_SendTerminalCapabilitySet &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_SendTerminalCapabilitySet::Class()), PInvalidCast);
#endif
  return *(H245_SendTerminalCapabilitySet *)choice;
}


H245_CommandMessage::operator const H245_SendTerminalCapabilitySet &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_SendTerminalCapabilitySet::Class()), PInvalidCast);
#endif
  return *(H245_SendTerminalCapabilitySet *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_EncryptionCommand &() const
#else
H245_CommandMessage::operator H245_EncryptionCommand &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_EncryptionCommand::Class()), PInvalidCast);
#endif
  return *(H245_EncryptionCommand *)choice;
}


H245_CommandMessage::operator const H245_EncryptionCommand &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_EncryptionCommand::Class()), PInvalidCast);
#endif
  return *(H245_EncryptionCommand *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_FlowControlCommand &() const
#else
H245_CommandMessage::operator H245_FlowControlCommand &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_FlowControlCommand::Class()), PInvalidCast);
#endif
  return *(H245_FlowControlCommand *)choice;
}


H245_CommandMessage::operator const H245_FlowControlCommand &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_FlowControlCommand::Class()), PInvalidCast);
#endif
  return *(H245_FlowControlCommand *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_EndSessionCommand &() const
#else
H245_CommandMessage::operator H245_EndSessionCommand &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_EndSessionCommand::Class()), PInvalidCast);
#endif
  return *(H245_EndSessionCommand *)choice;
}


H245_CommandMessage::operator const H245_EndSessionCommand &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_EndSessionCommand::Class()), PInvalidCast);
#endif
  return *(H245_EndSessionCommand *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_MiscellaneousCommand &() const
#else
H245_CommandMessage::operator H245_MiscellaneousCommand &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MiscellaneousCommand::Class()), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand *)choice;
}


H245_CommandMessage::operator const H245_MiscellaneousCommand &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MiscellaneousCommand::Class()), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_CommunicationModeCommand &() const
#else
H245_CommandMessage::operator H245_CommunicationModeCommand &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_CommunicationModeCommand::Class()), PInvalidCast);
#endif
  return *(H245_CommunicationModeCommand *)choice;
}


H245_CommandMessage::operator const H245_CommunicationModeCommand &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_CommunicationModeCommand::Class()), PInvalidCast);
#endif
  return *(H245_CommunicationModeCommand *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_ConferenceCommand &() const
#else
H245_CommandMessage::operator H245_ConferenceCommand &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceCommand::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceCommand *)choice;
}


H245_CommandMessage::operator const H245_ConferenceCommand &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceCommand::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceCommand *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_H223MultiplexReconfiguration &() const
#else
H245_CommandMessage::operator H245_H223MultiplexReconfiguration &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223MultiplexReconfiguration::Class()), PInvalidCast);
#endif
  return *(H245_H223MultiplexReconfiguration *)choice;
}


H245_CommandMessage::operator const H245_H223MultiplexReconfiguration &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223MultiplexReconfiguration::Class()), PInvalidCast);
#endif
  return *(H245_H223MultiplexReconfiguration *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_NewATMVCCommand &() const
#else
H245_CommandMessage::operator H245_NewATMVCCommand &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NewATMVCCommand::Class()), PInvalidCast);
#endif
  return *(H245_NewATMVCCommand *)choice;
}


H245_CommandMessage::operator const H245_NewATMVCCommand &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NewATMVCCommand::Class()), PInvalidCast);
#endif
  return *(H245_NewATMVCCommand *)choice;
}


BOOL H245_CommandMessage::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardMessage();
      return TRUE;
    case e_maintenanceLoopOffCommand :
      choice = new H245_MaintenanceLoopOffCommand();
      return TRUE;
    case e_sendTerminalCapabilitySet :
      choice = new H245_SendTerminalCapabilitySet();
      return TRUE;
    case e_encryptionCommand :
      choice = new H245_EncryptionCommand();
      return TRUE;
    case e_flowControlCommand :
      choice = new H245_FlowControlCommand();
      return TRUE;
    case e_endSessionCommand :
      choice = new H245_EndSessionCommand();
      return TRUE;
    case e_miscellaneousCommand :
      choice = new H245_MiscellaneousCommand();
      return TRUE;
    case e_communicationModeCommand :
      choice = new H245_CommunicationModeCommand();
      return TRUE;
    case e_conferenceCommand :
      choice = new H245_ConferenceCommand();
      return TRUE;
    case e_h223MultiplexReconfiguration :
      choice = new H245_H223MultiplexReconfiguration();
      return TRUE;
    case e_newATMVCCommand :
      choice = new H245_NewATMVCCommand();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_CommandMessage::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CommandMessage::Class()), PInvalidCast);
#endif
  return new H245_CommandMessage(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CommandMessage::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardMessage * ) choice )->preShowEthereal();
        break;
      case e_maintenanceLoopOffCommand :
        ( ( H245_MaintenanceLoopOffCommand * ) choice )->preShowEthereal();
        break;
      case e_sendTerminalCapabilitySet :
        ( ( H245_SendTerminalCapabilitySet * ) choice )->preShowEthereal();
        break;
      case e_encryptionCommand :
        ( ( H245_EncryptionCommand * ) choice )->preShowEthereal();
        break;
      case e_flowControlCommand :
        ( ( H245_FlowControlCommand * ) choice )->preShowEthereal();
        break;
      case e_endSessionCommand :
        ( ( H245_EndSessionCommand * ) choice )->preShowEthereal();
        break;
      case e_miscellaneousCommand :
        ( ( H245_MiscellaneousCommand * ) choice )->preShowEthereal();
        break;
      case e_communicationModeCommand :
        ( ( H245_CommunicationModeCommand * ) choice )->preShowEthereal();
        break;
      case e_conferenceCommand :
        ( ( H245_ConferenceCommand * ) choice )->preShowEthereal();
        break;
      case e_h223MultiplexReconfiguration :
        ( ( H245_H223MultiplexReconfiguration * ) choice )->preShowEthereal();
        break;
      case e_newATMVCCommand :
        ( ( H245_NewATMVCCommand * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_CommandMessage::getSummary( void ) 
{
  if ( choice != NULL )
    return /*PString( "COM : " ) +*/ choice->getSummary();
  else 
    return PString( "CommandMessage" );
}

void H245_CommandMessage::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_CommandMessage_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// IndicationMessage
//

H245_IndicationMessage::H245_IndicationMessage(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 14, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "functionNotUnderstood "
        "masterSlaveDeterminationRelease "
        "terminalCapabilitySetRelease "
        "openLogicalChannelConfirm "
        "requestChannelCloseRelease "
        "multiplexEntrySendRelease "
        "requestMultiplexEntryRelease "
        "requestModeRelease "
        "miscellaneousIndication "
        "jitterIndication "
        "h223SkewIndication "
        "newATMVCIndication "
        "userInput "
        "h2250MaximumSkewIndication "
        "mcLocationIndication "
        "conferenceIndication "
        "vendorIdentification "
        "functionNotSupported "
        "multilinkIndication "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_NonStandardMessage &() const
#else
H245_IndicationMessage::operator H245_NonStandardMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardMessage::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


H245_IndicationMessage::operator const H245_NonStandardMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardMessage::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_FunctionNotUnderstood &() const
#else
H245_IndicationMessage::operator H245_FunctionNotUnderstood &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_FunctionNotUnderstood::Class()), PInvalidCast);
#endif
  return *(H245_FunctionNotUnderstood *)choice;
}


H245_IndicationMessage::operator const H245_FunctionNotUnderstood &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_FunctionNotUnderstood::Class()), PInvalidCast);
#endif
  return *(H245_FunctionNotUnderstood *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_MasterSlaveDeterminationRelease &() const
#else
H245_IndicationMessage::operator H245_MasterSlaveDeterminationRelease &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MasterSlaveDeterminationRelease::Class()), PInvalidCast);
#endif
  return *(H245_MasterSlaveDeterminationRelease *)choice;
}


H245_IndicationMessage::operator const H245_MasterSlaveDeterminationRelease &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MasterSlaveDeterminationRelease::Class()), PInvalidCast);
#endif
  return *(H245_MasterSlaveDeterminationRelease *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_TerminalCapabilitySetRelease &() const
#else
H245_IndicationMessage::operator H245_TerminalCapabilitySetRelease &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_TerminalCapabilitySetRelease::Class()), PInvalidCast);
#endif
  return *(H245_TerminalCapabilitySetRelease *)choice;
}


H245_IndicationMessage::operator const H245_TerminalCapabilitySetRelease &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_TerminalCapabilitySetRelease::Class()), PInvalidCast);
#endif
  return *(H245_TerminalCapabilitySetRelease *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_OpenLogicalChannelConfirm &() const
#else
H245_IndicationMessage::operator H245_OpenLogicalChannelConfirm &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_OpenLogicalChannelConfirm::Class()), PInvalidCast);
#endif
  return *(H245_OpenLogicalChannelConfirm *)choice;
}


H245_IndicationMessage::operator const H245_OpenLogicalChannelConfirm &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_OpenLogicalChannelConfirm::Class()), PInvalidCast);
#endif
  return *(H245_OpenLogicalChannelConfirm *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_RequestChannelCloseRelease &() const
#else
H245_IndicationMessage::operator H245_RequestChannelCloseRelease &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestChannelCloseRelease::Class()), PInvalidCast);
#endif
  return *(H245_RequestChannelCloseRelease *)choice;
}


H245_IndicationMessage::operator const H245_RequestChannelCloseRelease &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestChannelCloseRelease::Class()), PInvalidCast);
#endif
  return *(H245_RequestChannelCloseRelease *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_MultiplexEntrySendRelease &() const
#else
H245_IndicationMessage::operator H245_MultiplexEntrySendRelease &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultiplexEntrySendRelease::Class()), PInvalidCast);
#endif
  return *(H245_MultiplexEntrySendRelease *)choice;
}


H245_IndicationMessage::operator const H245_MultiplexEntrySendRelease &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultiplexEntrySendRelease::Class()), PInvalidCast);
#endif
  return *(H245_MultiplexEntrySendRelease *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_RequestMultiplexEntryRelease &() const
#else
H245_IndicationMessage::operator H245_RequestMultiplexEntryRelease &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestMultiplexEntryRelease::Class()), PInvalidCast);
#endif
  return *(H245_RequestMultiplexEntryRelease *)choice;
}


H245_IndicationMessage::operator const H245_RequestMultiplexEntryRelease &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestMultiplexEntryRelease::Class()), PInvalidCast);
#endif
  return *(H245_RequestMultiplexEntryRelease *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_RequestModeRelease &() const
#else
H245_IndicationMessage::operator H245_RequestModeRelease &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestModeRelease::Class()), PInvalidCast);
#endif
  return *(H245_RequestModeRelease *)choice;
}


H245_IndicationMessage::operator const H245_RequestModeRelease &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestModeRelease::Class()), PInvalidCast);
#endif
  return *(H245_RequestModeRelease *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_MiscellaneousIndication &() const
#else
H245_IndicationMessage::operator H245_MiscellaneousIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MiscellaneousIndication::Class()), PInvalidCast);
#endif
  return *(H245_MiscellaneousIndication *)choice;
}


H245_IndicationMessage::operator const H245_MiscellaneousIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MiscellaneousIndication::Class()), PInvalidCast);
#endif
  return *(H245_MiscellaneousIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_JitterIndication &() const
#else
H245_IndicationMessage::operator H245_JitterIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_JitterIndication::Class()), PInvalidCast);
#endif
  return *(H245_JitterIndication *)choice;
}


H245_IndicationMessage::operator const H245_JitterIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_JitterIndication::Class()), PInvalidCast);
#endif
  return *(H245_JitterIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_H223SkewIndication &() const
#else
H245_IndicationMessage::operator H245_H223SkewIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223SkewIndication::Class()), PInvalidCast);
#endif
  return *(H245_H223SkewIndication *)choice;
}


H245_IndicationMessage::operator const H245_H223SkewIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223SkewIndication::Class()), PInvalidCast);
#endif
  return *(H245_H223SkewIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_NewATMVCIndication &() const
#else
H245_IndicationMessage::operator H245_NewATMVCIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NewATMVCIndication::Class()), PInvalidCast);
#endif
  return *(H245_NewATMVCIndication *)choice;
}


H245_IndicationMessage::operator const H245_NewATMVCIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NewATMVCIndication::Class()), PInvalidCast);
#endif
  return *(H245_NewATMVCIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_UserInputIndication &() const
#else
H245_IndicationMessage::operator H245_UserInputIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_UserInputIndication::Class()), PInvalidCast);
#endif
  return *(H245_UserInputIndication *)choice;
}


H245_IndicationMessage::operator const H245_UserInputIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_UserInputIndication::Class()), PInvalidCast);
#endif
  return *(H245_UserInputIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_H2250MaximumSkewIndication &() const
#else
H245_IndicationMessage::operator H245_H2250MaximumSkewIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H2250MaximumSkewIndication::Class()), PInvalidCast);
#endif
  return *(H245_H2250MaximumSkewIndication *)choice;
}


H245_IndicationMessage::operator const H245_H2250MaximumSkewIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H2250MaximumSkewIndication::Class()), PInvalidCast);
#endif
  return *(H245_H2250MaximumSkewIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_MCLocationIndication &() const
#else
H245_IndicationMessage::operator H245_MCLocationIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MCLocationIndication::Class()), PInvalidCast);
#endif
  return *(H245_MCLocationIndication *)choice;
}


H245_IndicationMessage::operator const H245_MCLocationIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MCLocationIndication::Class()), PInvalidCast);
#endif
  return *(H245_MCLocationIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_ConferenceIndication &() const
#else
H245_IndicationMessage::operator H245_ConferenceIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceIndication::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceIndication *)choice;
}


H245_IndicationMessage::operator const H245_ConferenceIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceIndication::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_VendorIdentification &() const
#else
H245_IndicationMessage::operator H245_VendorIdentification &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_VendorIdentification::Class()), PInvalidCast);
#endif
  return *(H245_VendorIdentification *)choice;
}


H245_IndicationMessage::operator const H245_VendorIdentification &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_VendorIdentification::Class()), PInvalidCast);
#endif
  return *(H245_VendorIdentification *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_FunctionNotSupported &() const
#else
H245_IndicationMessage::operator H245_FunctionNotSupported &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_FunctionNotSupported::Class()), PInvalidCast);
#endif
  return *(H245_FunctionNotSupported *)choice;
}


H245_IndicationMessage::operator const H245_FunctionNotSupported &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_FunctionNotSupported::Class()), PInvalidCast);
#endif
  return *(H245_FunctionNotSupported *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_MultilinkIndication &() const
#else
H245_IndicationMessage::operator H245_MultilinkIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkIndication::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkIndication *)choice;
}


H245_IndicationMessage::operator const H245_MultilinkIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkIndication::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkIndication *)choice;
}


BOOL H245_IndicationMessage::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardMessage();
      return TRUE;
    case e_functionNotUnderstood :
      choice = new H245_FunctionNotUnderstood();
      return TRUE;
    case e_masterSlaveDeterminationRelease :
      choice = new H245_MasterSlaveDeterminationRelease();
      return TRUE;
    case e_terminalCapabilitySetRelease :
      choice = new H245_TerminalCapabilitySetRelease();
      return TRUE;
    case e_openLogicalChannelConfirm :
      choice = new H245_OpenLogicalChannelConfirm();
      return TRUE;
    case e_requestChannelCloseRelease :
      choice = new H245_RequestChannelCloseRelease();
      return TRUE;
    case e_multiplexEntrySendRelease :
      choice = new H245_MultiplexEntrySendRelease();
      return TRUE;
    case e_requestMultiplexEntryRelease :
      choice = new H245_RequestMultiplexEntryRelease();
      return TRUE;
    case e_requestModeRelease :
      choice = new H245_RequestModeRelease();
      return TRUE;
    case e_miscellaneousIndication :
      choice = new H245_MiscellaneousIndication();
      return TRUE;
    case e_jitterIndication :
      choice = new H245_JitterIndication();
      return TRUE;
    case e_h223SkewIndication :
      choice = new H245_H223SkewIndication();
      return TRUE;
    case e_newATMVCIndication :
      choice = new H245_NewATMVCIndication();
      return TRUE;
    case e_userInput :
      choice = new H245_UserInputIndication();
      return TRUE;
    case e_h2250MaximumSkewIndication :
      choice = new H245_H2250MaximumSkewIndication();
      return TRUE;
    case e_mcLocationIndication :
      choice = new H245_MCLocationIndication();
      return TRUE;
    case e_conferenceIndication :
      choice = new H245_ConferenceIndication();
      return TRUE;
    case e_vendorIdentification :
      choice = new H245_VendorIdentification();
      return TRUE;
    case e_functionNotSupported :
      choice = new H245_FunctionNotSupported();
      return TRUE;
    case e_multilinkIndication :
      choice = new H245_MultilinkIndication();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_IndicationMessage::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IndicationMessage::Class()), PInvalidCast);
#endif
  return new H245_IndicationMessage(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_IndicationMessage::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardMessage * ) choice )->preShowEthereal();
        break;
      case e_functionNotUnderstood :
        ( ( H245_FunctionNotUnderstood * ) choice )->preShowEthereal();
        break;
      case e_masterSlaveDeterminationRelease :
        ( ( H245_MasterSlaveDeterminationRelease * ) choice )->preShowEthereal();
        break;
      case e_terminalCapabilitySetRelease :
        ( ( H245_TerminalCapabilitySetRelease * ) choice )->preShowEthereal();
        break;
      case e_openLogicalChannelConfirm :
        ( ( H245_OpenLogicalChannelConfirm * ) choice )->preShowEthereal();
        break;
      case e_requestChannelCloseRelease :
        ( ( H245_RequestChannelCloseRelease * ) choice )->preShowEthereal();
        break;
      case e_multiplexEntrySendRelease :
        ( ( H245_MultiplexEntrySendRelease * ) choice )->preShowEthereal();
        break;
      case e_requestMultiplexEntryRelease :
        ( ( H245_RequestMultiplexEntryRelease * ) choice )->preShowEthereal();
        break;
      case e_requestModeRelease :
        ( ( H245_RequestModeRelease * ) choice )->preShowEthereal();
        break;
      case e_miscellaneousIndication :
        ( ( H245_MiscellaneousIndication * ) choice )->preShowEthereal();
        break;
      case e_jitterIndication :
        ( ( H245_JitterIndication * ) choice )->preShowEthereal();
        break;
      case e_h223SkewIndication :
        ( ( H245_H223SkewIndication * ) choice )->preShowEthereal();
        break;
      case e_newATMVCIndication :
        ( ( H245_NewATMVCIndication * ) choice )->preShowEthereal();
        break;
      case e_userInput :
        ( ( H245_UserInputIndication * ) choice )->preShowEthereal();
        break;
      case e_h2250MaximumSkewIndication :
        ( ( H245_H2250MaximumSkewIndication * ) choice )->preShowEthereal();
        break;
      case e_mcLocationIndication :
        ( ( H245_MCLocationIndication * ) choice )->preShowEthereal();
        break;
      case e_conferenceIndication :
        ( ( H245_ConferenceIndication * ) choice )->preShowEthereal();
        break;
      case e_vendorIdentification :
        ( ( H245_VendorIdentification * ) choice )->preShowEthereal();
        break;
      case e_functionNotSupported :
        ( ( H245_FunctionNotSupported * ) choice )->preShowEthereal();
        break;
      case e_multilinkIndication :
        ( ( H245_MultilinkIndication * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_IndicationMessage::getSummary( void ) 
{
  if ( choice != NULL )
    return /*PString( "IND : " ) +*/ choice->getSummary();
  else 
    return PString( "IndicationMessage" );
}

void H245_IndicationMessage::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_IndicationMessage_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// SequenceNumber
//

H245_SequenceNumber::H245_SequenceNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


H245_SequenceNumber & H245_SequenceNumber::operator=(int v)
{
  SetValue(v);
  return *this;
}


H245_SequenceNumber & H245_SequenceNumber::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H245_SequenceNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_SequenceNumber::Class()), PInvalidCast);
#endif
  return new H245_SequenceNumber(*this);
}


//
// NonStandardIdentifier
//

H245_NonStandardIdentifier::H245_NonStandardIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
      , "object "
        "h221NonStandard "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_NonStandardIdentifier::operator H245_NonStandardIdentifier_h221NonStandard &() const
#else
H245_NonStandardIdentifier::operator H245_NonStandardIdentifier_h221NonStandard &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardIdentifier_h221NonStandard::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardIdentifier_h221NonStandard *)choice;
}


H245_NonStandardIdentifier::operator const H245_NonStandardIdentifier_h221NonStandard &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardIdentifier_h221NonStandard::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardIdentifier_h221NonStandard *)choice;
}


BOOL H245_NonStandardIdentifier::CreateObject()
{
  switch (tag) {
    case e_object :
      choice = new PASN_ObjectId();
      return TRUE;
    case e_h221NonStandard :
      choice = new H245_NonStandardIdentifier_h221NonStandard();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_NonStandardIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NonStandardIdentifier::Class()), PInvalidCast);
#endif
  return new H245_NonStandardIdentifier(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NonStandardIdentifier::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_object :
        ( ( PASN_ObjectId * ) choice )->preShowEthereal();
        break;
      case e_h221NonStandard :
        ( ( H245_NonStandardIdentifier_h221NonStandard * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_NonStandardIdentifier::getSummary( void ) 
{
  return PString( "NonStandardIdentifier" );
}

void H245_NonStandardIdentifier::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "object" ) == 0 ) {
      char* pstring = ( ( PASN_ObjectId* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_NonStandardIdentifier_object, tvb, offset + ( ( PASN_ObjectId* ) choice) ->GetStartByte(), ( ( PASN_ObjectId* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_NonStandardIdentifier_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// MasterSlaveDetermination
//

H245_MasterSlaveDetermination::H245_MasterSlaveDetermination(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_terminalType.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
  m_statusDeterminationNumber.SetConstraints(PASN_Object::FixedConstraint, 0, 16777215);
}


#ifndef PASN_NOPRINTON
void H245_MasterSlaveDetermination::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "terminalType = " << setprecision(indent) << m_terminalType << '\n';
  strm << setw(indent+28) << "statusDeterminationNumber = " << setprecision(indent) << m_statusDeterminationNumber << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MasterSlaveDetermination::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MasterSlaveDetermination::Class()), PInvalidCast);
#endif
  const H245_MasterSlaveDetermination & other = (const H245_MasterSlaveDetermination &)obj;

  Comparison result;

  if ((result = m_terminalType.Compare(other.m_terminalType)) != EqualTo)
    return result;
  if ((result = m_statusDeterminationNumber.Compare(other.m_statusDeterminationNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MasterSlaveDetermination::GetDataLength() const
{
  return m_terminalType.GetObjectLength() +
         m_statusDeterminationNumber.GetObjectLength();
}


BOOL H245_MasterSlaveDetermination::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_terminalType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_statusDeterminationNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MasterSlaveDetermination::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminalType.Encode(strm);
  m_statusDeterminationNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_terminalType.Encode(strm);
  m_statusDeterminationNumber.Encode(strm);
}


PObject * H245_MasterSlaveDetermination::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MasterSlaveDetermination::Class()), PInvalidCast);
#endif
  return new H245_MasterSlaveDetermination(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MasterSlaveDetermination::preShowEthereal( void )
{
  m_terminalType.preShowEthereal( );
  m_statusDeterminationNumber.preShowEthereal( );
}

PString H245_MasterSlaveDetermination::getSummary( void ) 
{
  return PString( "MasterSlaveDetermination" );
}

void H245_MasterSlaveDetermination::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_MasterSlaveDetermination_terminalType, tvb, offset + m_terminalType.GetStartByte(), m_terminalType.GetByteLength() , m_terminalType.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_MasterSlaveDetermination_statusDeterminationNumber, tvb, offset + m_statusDeterminationNumber.GetStartByte(), m_statusDeterminationNumber.GetByteLength() , m_statusDeterminationNumber.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// MasterSlaveDeterminationRelease
//

H245_MasterSlaveDeterminationRelease::H245_MasterSlaveDeterminationRelease(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MasterSlaveDeterminationRelease::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << "}";
}
#endif


PINDEX H245_MasterSlaveDeterminationRelease::GetDataLength() const
{
  return 0;
}


BOOL H245_MasterSlaveDeterminationRelease::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MasterSlaveDeterminationRelease::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * H245_MasterSlaveDeterminationRelease::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MasterSlaveDeterminationRelease::Class()), PInvalidCast);
#endif
  return new H245_MasterSlaveDeterminationRelease(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MasterSlaveDeterminationRelease::preShowEthereal( void )
{
}

PString H245_MasterSlaveDeterminationRelease::getSummary( void ) 
{
  return PString( "MasterSlaveDeterminationRelease" );
}

void H245_MasterSlaveDeterminationRelease::showEthereal( proto_tree *, tvbuff_t *, unsigned int ) const
{
}
#endif  //USE_FOR_ETHEREAL

//
// AlternativeCapabilitySet
//

H245_AlternativeCapabilitySet::H245_AlternativeCapabilitySet(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


PASN_Object * H245_AlternativeCapabilitySet::CreateObject() const
{
  return new H245_CapabilityTableEntryNumber;
}


H245_CapabilityTableEntryNumber & H245_AlternativeCapabilitySet::operator[](PINDEX i) const
{
  return (H245_CapabilityTableEntryNumber &)array[i];
}


PObject * H245_AlternativeCapabilitySet::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_AlternativeCapabilitySet::Class()), PInvalidCast);
#endif
  return new H245_AlternativeCapabilitySet(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_AlternativeCapabilitySet::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_CapabilityTableEntryNumber& ) array[i] ).preShowEthereal();
  }
}

PString H245_AlternativeCapabilitySet::getSummary( void ) 
{
  return PString( "AlternativeCapabilitySet" );
}

void H245_AlternativeCapabilitySet::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  for (int i=0; i < array.GetSize(); i++ ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_AlternativeCapabilitySet_array, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), ( (PASN_Integer& ) array[i] ).GetValue() );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// CapabilityTableEntryNumber
//

H245_CapabilityTableEntryNumber::H245_CapabilityTableEntryNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


H245_CapabilityTableEntryNumber & H245_CapabilityTableEntryNumber::operator=(int v)
{
  SetValue(v);
  return *this;
}


H245_CapabilityTableEntryNumber & H245_CapabilityTableEntryNumber::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H245_CapabilityTableEntryNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CapabilityTableEntryNumber::Class()), PInvalidCast);
#endif
  return new H245_CapabilityTableEntryNumber(*this);
}


//
// CapabilityDescriptorNumber
//

H245_CapabilityDescriptorNumber::H245_CapabilityDescriptorNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


H245_CapabilityDescriptorNumber & H245_CapabilityDescriptorNumber::operator=(int v)
{
  SetValue(v);
  return *this;
}


H245_CapabilityDescriptorNumber & H245_CapabilityDescriptorNumber::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H245_CapabilityDescriptorNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CapabilityDescriptorNumber::Class()), PInvalidCast);
#endif
  return new H245_CapabilityDescriptorNumber(*this);
}


//
// TerminalCapabilitySetAck
//

H245_TerminalCapabilitySetAck::H245_TerminalCapabilitySetAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_TerminalCapabilitySetAck::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_TerminalCapabilitySetAck::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_TerminalCapabilitySetAck::Class()), PInvalidCast);
#endif
  const H245_TerminalCapabilitySetAck & other = (const H245_TerminalCapabilitySetAck &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_TerminalCapabilitySetAck::GetDataLength() const
{
  return m_sequenceNumber.GetObjectLength();
}


BOOL H245_TerminalCapabilitySetAck::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sequenceNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_TerminalCapabilitySetAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_sequenceNumber.Encode(strm);
}


PObject * H245_TerminalCapabilitySetAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TerminalCapabilitySetAck::Class()), PInvalidCast);
#endif
  return new H245_TerminalCapabilitySetAck(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_TerminalCapabilitySetAck::preShowEthereal( void )
{
  m_sequenceNumber.preShowEthereal( );
}

PString H245_TerminalCapabilitySetAck::getSummary( void ) 
{
  return PString( "TerminalCapabilitySetAck" );
}

void H245_TerminalCapabilitySetAck::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_TerminalCapabilitySetAck_sequenceNumber, tvb, offset + m_sequenceNumber.GetStartByte(), m_sequenceNumber.GetByteLength() , m_sequenceNumber.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// TerminalCapabilitySetRelease
//

H245_TerminalCapabilitySetRelease::H245_TerminalCapabilitySetRelease(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_TerminalCapabilitySetRelease::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << "}";
}
#endif


PINDEX H245_TerminalCapabilitySetRelease::GetDataLength() const
{
  return 0;
}


BOOL H245_TerminalCapabilitySetRelease::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_TerminalCapabilitySetRelease::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * H245_TerminalCapabilitySetRelease::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TerminalCapabilitySetRelease::Class()), PInvalidCast);
#endif
  return new H245_TerminalCapabilitySetRelease(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_TerminalCapabilitySetRelease::preShowEthereal( void )
{
}

PString H245_TerminalCapabilitySetRelease::getSummary( void ) 
{
  return PString( "TerminalCapabilitySetRelease" );
}

void H245_TerminalCapabilitySetRelease::showEthereal( proto_tree *, tvbuff_t *, unsigned int ) const
{
}
#endif  //USE_FOR_ETHEREAL

//
// Capability
//

H245_Capability::H245_Capability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 12, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "receiveVideoCapability "
        "transmitVideoCapability "
        "receiveAndTransmitVideoCapability "
        "receiveAudioCapability "
        "transmitAudioCapability "
        "receiveAndTransmitAudioCapability "
        "receiveDataApplicationCapability "
        "transmitDataApplicationCapability "
        "receiveAndTransmitDataApplicationCapability "
        "h233EncryptionTransmitCapability "
        "h233EncryptionReceiveCapability "
        "conferenceCapability "
        "h235SecurityCapability "
        "maxPendingReplacementFor "
        "receiveUserInputCapability "
        "transmitUserInputCapability "
        "receiveAndTransmitUserInputCapability "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_NonStandardParameter &() const
#else
H245_Capability::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_Capability::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_VideoCapability &() const
#else
H245_Capability::operator H245_VideoCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_VideoCapability::Class()), PInvalidCast);
#endif
  return *(H245_VideoCapability *)choice;
}


H245_Capability::operator const H245_VideoCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_VideoCapability::Class()), PInvalidCast);
#endif
  return *(H245_VideoCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_AudioCapability &() const
#else
H245_Capability::operator H245_AudioCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_AudioCapability::Class()), PInvalidCast);
#endif
  return *(H245_AudioCapability *)choice;
}


H245_Capability::operator const H245_AudioCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_AudioCapability::Class()), PInvalidCast);
#endif
  return *(H245_AudioCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_DataApplicationCapability &() const
#else
H245_Capability::operator H245_DataApplicationCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataApplicationCapability::Class()), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability *)choice;
}


H245_Capability::operator const H245_DataApplicationCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataApplicationCapability::Class()), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_Capability_h233EncryptionReceiveCapability &() const
#else
H245_Capability::operator H245_Capability_h233EncryptionReceiveCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_Capability_h233EncryptionReceiveCapability::Class()), PInvalidCast);
#endif
  return *(H245_Capability_h233EncryptionReceiveCapability *)choice;
}


H245_Capability::operator const H245_Capability_h233EncryptionReceiveCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_Capability_h233EncryptionReceiveCapability::Class()), PInvalidCast);
#endif
  return *(H245_Capability_h233EncryptionReceiveCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_ConferenceCapability &() const
#else
H245_Capability::operator H245_ConferenceCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceCapability::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceCapability *)choice;
}


H245_Capability::operator const H245_ConferenceCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceCapability::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_H235SecurityCapability &() const
#else
H245_Capability::operator H245_H235SecurityCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H235SecurityCapability::Class()), PInvalidCast);
#endif
  return *(H245_H235SecurityCapability *)choice;
}


H245_Capability::operator const H245_H235SecurityCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H235SecurityCapability::Class()), PInvalidCast);
#endif
  return *(H245_H235SecurityCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_UserInputCapability &() const
#else
H245_Capability::operator H245_UserInputCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_UserInputCapability::Class()), PInvalidCast);
#endif
  return *(H245_UserInputCapability *)choice;
}


H245_Capability::operator const H245_UserInputCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_UserInputCapability::Class()), PInvalidCast);
#endif
  return *(H245_UserInputCapability *)choice;
}


BOOL H245_Capability::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_receiveVideoCapability :
    case e_transmitVideoCapability :
    case e_receiveAndTransmitVideoCapability :
      choice = new H245_VideoCapability();
      return TRUE;
    case e_receiveAudioCapability :
    case e_transmitAudioCapability :
    case e_receiveAndTransmitAudioCapability :
      choice = new H245_AudioCapability();
      return TRUE;
    case e_receiveDataApplicationCapability :
    case e_transmitDataApplicationCapability :
    case e_receiveAndTransmitDataApplicationCapability :
      choice = new H245_DataApplicationCapability();
      return TRUE;
    case e_h233EncryptionTransmitCapability :
      choice = new PASN_Boolean();
      return TRUE;
    case e_h233EncryptionReceiveCapability :
      choice = new H245_Capability_h233EncryptionReceiveCapability();
      return TRUE;
    case e_conferenceCapability :
      choice = new H245_ConferenceCapability();
      return TRUE;
    case e_h235SecurityCapability :
      choice = new H245_H235SecurityCapability();
      return TRUE;
    case e_maxPendingReplacementFor :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 255);
      return TRUE;
    case e_receiveUserInputCapability :
    case e_transmitUserInputCapability :
    case e_receiveAndTransmitUserInputCapability :
      choice = new H245_UserInputCapability();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_Capability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_Capability::Class()), PInvalidCast);
#endif
  return new H245_Capability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_Capability::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_receiveVideoCapability :
        ( ( H245_VideoCapability * ) choice )->preShowEthereal();
        break;
      case e_transmitVideoCapability :
        ( ( H245_VideoCapability * ) choice )->preShowEthereal();
        break;
      case e_receiveAndTransmitVideoCapability :
        ( ( H245_VideoCapability * ) choice )->preShowEthereal();
        break;
      case e_receiveAudioCapability :
        ( ( H245_AudioCapability * ) choice )->preShowEthereal();
        break;
      case e_transmitAudioCapability :
        ( ( H245_AudioCapability * ) choice )->preShowEthereal();
        break;
      case e_receiveAndTransmitAudioCapability :
        ( ( H245_AudioCapability * ) choice )->preShowEthereal();
        break;
      case e_receiveDataApplicationCapability :
        ( ( H245_DataApplicationCapability * ) choice )->preShowEthereal();
        break;
      case e_transmitDataApplicationCapability :
        ( ( H245_DataApplicationCapability * ) choice )->preShowEthereal();
        break;
      case e_receiveAndTransmitDataApplicationCapability :
        ( ( H245_DataApplicationCapability * ) choice )->preShowEthereal();
        break;
      case e_h233EncryptionTransmitCapability :
        ( ( PASN_Boolean * ) choice )->preShowEthereal();
        break;
      case e_h233EncryptionReceiveCapability :
        ( ( H245_Capability_h233EncryptionReceiveCapability * ) choice )->preShowEthereal();
        break;
      case e_conferenceCapability :
        ( ( H245_ConferenceCapability * ) choice )->preShowEthereal();
        break;
      case e_h235SecurityCapability :
        ( ( H245_H235SecurityCapability * ) choice )->preShowEthereal();
        break;
      case e_maxPendingReplacementFor :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_receiveUserInputCapability :
        ( ( H245_UserInputCapability * ) choice )->preShowEthereal();
        break;
      case e_transmitUserInputCapability :
        ( ( H245_UserInputCapability * ) choice )->preShowEthereal();
        break;
      case e_receiveAndTransmitUserInputCapability :
        ( ( H245_UserInputCapability * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_Capability::getSummary( void ) 
{
  return PString( "Capability" );
}

void H245_Capability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "h233EncryptionTransmitCapability" ) == 0 ) {
    proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_Capability_h233EncryptionTransmitCapability, tvb, offset + ( ( PASN_Boolean* ) choice) ->GetStartByte(), ( ( PASN_Boolean* ) choice) ->GetByteLength(),  ( ( PASN_Boolean* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "maxPendingReplacementFor" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_Capability_maxPendingReplacementFor, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_Capability_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// MultiplexCapability
//

H245_MultiplexCapability::H245_MultiplexCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "h222Capability "
        "h223Capability "
        "v76Capability "
        "h2250Capability "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultiplexCapability::operator H245_NonStandardParameter &() const
#else
H245_MultiplexCapability::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_MultiplexCapability::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultiplexCapability::operator H245_H222Capability &() const
#else
H245_MultiplexCapability::operator H245_H222Capability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H222Capability::Class()), PInvalidCast);
#endif
  return *(H245_H222Capability *)choice;
}


H245_MultiplexCapability::operator const H245_H222Capability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H222Capability::Class()), PInvalidCast);
#endif
  return *(H245_H222Capability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultiplexCapability::operator H245_H223Capability &() const
#else
H245_MultiplexCapability::operator H245_H223Capability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223Capability::Class()), PInvalidCast);
#endif
  return *(H245_H223Capability *)choice;
}


H245_MultiplexCapability::operator const H245_H223Capability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223Capability::Class()), PInvalidCast);
#endif
  return *(H245_H223Capability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultiplexCapability::operator H245_V76Capability &() const
#else
H245_MultiplexCapability::operator H245_V76Capability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_V76Capability::Class()), PInvalidCast);
#endif
  return *(H245_V76Capability *)choice;
}


H245_MultiplexCapability::operator const H245_V76Capability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_V76Capability::Class()), PInvalidCast);
#endif
  return *(H245_V76Capability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultiplexCapability::operator H245_H2250Capability &() const
#else
H245_MultiplexCapability::operator H245_H2250Capability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H2250Capability::Class()), PInvalidCast);
#endif
  return *(H245_H2250Capability *)choice;
}


H245_MultiplexCapability::operator const H245_H2250Capability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H2250Capability::Class()), PInvalidCast);
#endif
  return *(H245_H2250Capability *)choice;
}


BOOL H245_MultiplexCapability::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_h222Capability :
      choice = new H245_H222Capability();
      return TRUE;
    case e_h223Capability :
      choice = new H245_H223Capability();
      return TRUE;
    case e_v76Capability :
      choice = new H245_V76Capability();
      return TRUE;
    case e_h2250Capability :
      choice = new H245_H2250Capability();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_MultiplexCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexCapability::Class()), PInvalidCast);
#endif
  return new H245_MultiplexCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultiplexCapability::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_h222Capability :
        ( ( H245_H222Capability * ) choice )->preShowEthereal();
        break;
      case e_h223Capability :
        ( ( H245_H223Capability * ) choice )->preShowEthereal();
        break;
      case e_v76Capability :
        ( ( H245_V76Capability * ) choice )->preShowEthereal();
        break;
      case e_h2250Capability :
        ( ( H245_H2250Capability * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_MultiplexCapability::getSummary( void ) 
{
  return PString( "MultiplexCapability" );
}

void H245_MultiplexCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_MultiplexCapability_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H223AnnexCCapability
//

H245_H223AnnexCCapability::H245_H223AnnexCCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_maximumAL1MPDUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_maximumAL2MSDUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_maximumAL3MSDUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_H223AnnexCCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "videoWithAL1M = " << setprecision(indent) << m_videoWithAL1M << '\n';
  strm << setw(indent+16) << "videoWithAL2M = " << setprecision(indent) << m_videoWithAL2M << '\n';
  strm << setw(indent+16) << "videoWithAL3M = " << setprecision(indent) << m_videoWithAL3M << '\n';
  strm << setw(indent+16) << "audioWithAL1M = " << setprecision(indent) << m_audioWithAL1M << '\n';
  strm << setw(indent+16) << "audioWithAL2M = " << setprecision(indent) << m_audioWithAL2M << '\n';
  strm << setw(indent+16) << "audioWithAL3M = " << setprecision(indent) << m_audioWithAL3M << '\n';
  strm << setw(indent+15) << "dataWithAL1M = " << setprecision(indent) << m_dataWithAL1M << '\n';
  strm << setw(indent+15) << "dataWithAL2M = " << setprecision(indent) << m_dataWithAL2M << '\n';
  strm << setw(indent+15) << "dataWithAL3M = " << setprecision(indent) << m_dataWithAL3M << '\n';
  strm << setw(indent+20) << "alpduInterleaving = " << setprecision(indent) << m_alpduInterleaving << '\n';
  strm << setw(indent+21) << "maximumAL1MPDUSize = " << setprecision(indent) << m_maximumAL1MPDUSize << '\n';
  strm << setw(indent+21) << "maximumAL2MSDUSize = " << setprecision(indent) << m_maximumAL2MSDUSize << '\n';
  strm << setw(indent+21) << "maximumAL3MSDUSize = " << setprecision(indent) << m_maximumAL3MSDUSize << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H223AnnexCCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H223AnnexCCapability::Class()), PInvalidCast);
#endif
  const H245_H223AnnexCCapability & other = (const H245_H223AnnexCCapability &)obj;

  Comparison result;

  if ((result = m_videoWithAL1M.Compare(other.m_videoWithAL1M)) != EqualTo)
    return result;
  if ((result = m_videoWithAL2M.Compare(other.m_videoWithAL2M)) != EqualTo)
    return result;
  if ((result = m_videoWithAL3M.Compare(other.m_videoWithAL3M)) != EqualTo)
    return result;
  if ((result = m_audioWithAL1M.Compare(other.m_audioWithAL1M)) != EqualTo)
    return result;
  if ((result = m_audioWithAL2M.Compare(other.m_audioWithAL2M)) != EqualTo)
    return result;
  if ((result = m_audioWithAL3M.Compare(other.m_audioWithAL3M)) != EqualTo)
    return result;
  if ((result = m_dataWithAL1M.Compare(other.m_dataWithAL1M)) != EqualTo)
    return result;
  if ((result = m_dataWithAL2M.Compare(other.m_dataWithAL2M)) != EqualTo)
    return result;
  if ((result = m_dataWithAL3M.Compare(other.m_dataWithAL3M)) != EqualTo)
    return result;
  if ((result = m_alpduInterleaving.Compare(other.m_alpduInterleaving)) != EqualTo)
    return result;
  if ((result = m_maximumAL1MPDUSize.Compare(other.m_maximumAL1MPDUSize)) != EqualTo)
    return result;
  if ((result = m_maximumAL2MSDUSize.Compare(other.m_maximumAL2MSDUSize)) != EqualTo)
    return result;
  if ((result = m_maximumAL3MSDUSize.Compare(other.m_maximumAL3MSDUSize)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223AnnexCCapability::GetDataLength() const
{
  return m_videoWithAL1M.GetObjectLength() +
         m_videoWithAL2M.GetObjectLength() +
         m_videoWithAL3M.GetObjectLength() +
         m_audioWithAL1M.GetObjectLength() +
         m_audioWithAL2M.GetObjectLength() +
         m_audioWithAL3M.GetObjectLength() +
         m_dataWithAL1M.GetObjectLength() +
         m_dataWithAL2M.GetObjectLength() +
         m_dataWithAL3M.GetObjectLength() +
         m_alpduInterleaving.GetObjectLength() +
         m_maximumAL1MPDUSize.GetObjectLength() +
         m_maximumAL2MSDUSize.GetObjectLength() +
         m_maximumAL3MSDUSize.GetObjectLength();
}


BOOL H245_H223AnnexCCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_videoWithAL1M.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_videoWithAL2M.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_videoWithAL3M.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioWithAL1M.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioWithAL2M.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioWithAL3M.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_dataWithAL1M.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_dataWithAL2M.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_dataWithAL3M.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_alpduInterleaving.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maximumAL1MPDUSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maximumAL2MSDUSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maximumAL3MSDUSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H223AnnexCCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_videoWithAL1M.Encode(strm);
  m_videoWithAL2M.Encode(strm);
  m_videoWithAL3M.Encode(strm);
  m_audioWithAL1M.Encode(strm);
  m_audioWithAL2M.Encode(strm);
  m_audioWithAL3M.Encode(strm);
  m_dataWithAL1M.Encode(strm);
  m_dataWithAL2M.Encode(strm);
  m_dataWithAL3M.Encode(strm);
  m_alpduInterleaving.Encode(strm);
  m_maximumAL1MPDUSize.Encode(strm);
  m_maximumAL2MSDUSize.Encode(strm);
  m_maximumAL3MSDUSize.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_videoWithAL1M.Encode(strm);
  m_videoWithAL2M.Encode(strm);
  m_videoWithAL3M.Encode(strm);
  m_audioWithAL1M.Encode(strm);
  m_audioWithAL2M.Encode(strm);
  m_audioWithAL3M.Encode(strm);
  m_dataWithAL1M.Encode(strm);
  m_dataWithAL2M.Encode(strm);
  m_dataWithAL3M.Encode(strm);
  m_alpduInterleaving.Encode(strm);
  m_maximumAL1MPDUSize.Encode(strm);
  m_maximumAL2MSDUSize.Encode(strm);
  m_maximumAL3MSDUSize.Encode(strm);
}


PObject * H245_H223AnnexCCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AnnexCCapability::Class()), PInvalidCast);
#endif
  return new H245_H223AnnexCCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223AnnexCCapability::preShowEthereal( void )
{
  m_videoWithAL1M.preShowEthereal( );
  m_videoWithAL2M.preShowEthereal( );
  m_videoWithAL3M.preShowEthereal( );
  m_audioWithAL1M.preShowEthereal( );
  m_audioWithAL2M.preShowEthereal( );
  m_audioWithAL3M.preShowEthereal( );
  m_dataWithAL1M.preShowEthereal( );
  m_dataWithAL2M.preShowEthereal( );
  m_dataWithAL3M.preShowEthereal( );
  m_alpduInterleaving.preShowEthereal( );
  m_maximumAL1MPDUSize.preShowEthereal( );
  m_maximumAL2MSDUSize.preShowEthereal( );
  m_maximumAL3MSDUSize.preShowEthereal( );
}

PString H245_H223AnnexCCapability::getSummary( void ) 
{
  return PString( "H223AnnexCCapability" );
}

void H245_H223AnnexCCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H223AnnexCCapability_videoWithAL1M, tvb, offset + m_videoWithAL1M.GetStartByte(), m_videoWithAL1M.GetByteLength() , m_videoWithAL1M.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H223AnnexCCapability_videoWithAL2M, tvb, offset + m_videoWithAL2M.GetStartByte(), m_videoWithAL2M.GetByteLength() , m_videoWithAL2M.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H223AnnexCCapability_videoWithAL3M, tvb, offset + m_videoWithAL3M.GetStartByte(), m_videoWithAL3M.GetByteLength() , m_videoWithAL3M.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H223AnnexCCapability_audioWithAL1M, tvb, offset + m_audioWithAL1M.GetStartByte(), m_audioWithAL1M.GetByteLength() , m_audioWithAL1M.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H223AnnexCCapability_audioWithAL2M, tvb, offset + m_audioWithAL2M.GetStartByte(), m_audioWithAL2M.GetByteLength() , m_audioWithAL2M.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H223AnnexCCapability_audioWithAL3M, tvb, offset + m_audioWithAL3M.GetStartByte(), m_audioWithAL3M.GetByteLength() , m_audioWithAL3M.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H223AnnexCCapability_dataWithAL1M, tvb, offset + m_dataWithAL1M.GetStartByte(), m_dataWithAL1M.GetByteLength() , m_dataWithAL1M.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H223AnnexCCapability_dataWithAL2M, tvb, offset + m_dataWithAL2M.GetStartByte(), m_dataWithAL2M.GetByteLength() , m_dataWithAL2M.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H223AnnexCCapability_dataWithAL3M, tvb, offset + m_dataWithAL3M.GetStartByte(), m_dataWithAL3M.GetByteLength() , m_dataWithAL3M.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H223AnnexCCapability_alpduInterleaving, tvb, offset + m_alpduInterleaving.GetStartByte(), m_alpduInterleaving.GetByteLength() , m_alpduInterleaving.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_H223AnnexCCapability_maximumAL1MPDUSize, tvb, offset + m_maximumAL1MPDUSize.GetStartByte(), m_maximumAL1MPDUSize.GetByteLength() , m_maximumAL1MPDUSize.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_H223AnnexCCapability_maximumAL2MSDUSize, tvb, offset + m_maximumAL2MSDUSize.GetStartByte(), m_maximumAL2MSDUSize.GetByteLength() , m_maximumAL2MSDUSize.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_H223AnnexCCapability_maximumAL3MSDUSize, tvb, offset + m_maximumAL3MSDUSize.GetStartByte(), m_maximumAL3MSDUSize.GetByteLength() , m_maximumAL3MSDUSize.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// V75Capability
//

H245_V75Capability::H245_V75Capability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_V75Capability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "audioHeader = " << setprecision(indent) << m_audioHeader << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_V75Capability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_V75Capability::Class()), PInvalidCast);
#endif
  const H245_V75Capability & other = (const H245_V75Capability &)obj;

  Comparison result;

  if ((result = m_audioHeader.Compare(other.m_audioHeader)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_V75Capability::GetDataLength() const
{
  return m_audioHeader.GetObjectLength();
}


BOOL H245_V75Capability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioHeader.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_V75Capability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_audioHeader.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_audioHeader.Encode(strm);
}


PObject * H245_V75Capability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_V75Capability::Class()), PInvalidCast);
#endif
  return new H245_V75Capability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_V75Capability::preShowEthereal( void )
{
  m_audioHeader.preShowEthereal( );
}

PString H245_V75Capability::getSummary( void ) 
{
  return PString( "V75Capability" );
}

void H245_V75Capability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_V75Capability_audioHeader, tvb, offset + m_audioHeader.GetStartByte(), m_audioHeader.GetByteLength() , m_audioHeader.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// QOSMode
//

H245_QOSMode::H245_QOSMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "guaranteedQOS "
        "controlledLoad "
#endif
    )
{
}


BOOL H245_QOSMode::CreateObject()
{
  switch (tag) {
    case e_guaranteedQOS :
    case e_controlledLoad :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_QOSMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_QOSMode::Class()), PInvalidCast);
#endif
  return new H245_QOSMode(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_QOSMode::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_guaranteedQOS :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_controlledLoad :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_QOSMode::getSummary( void ) 
{
  return PString( "QOSMode" );
}

void H245_QOSMode::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "guaranteedQOS" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_QOSMode_guaranteedQOS, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "controlledLoad" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_QOSMode_controlledLoad, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ATMParameters
//

H245_ATMParameters::H245_ATMParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_maxNTUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_ATMParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "maxNTUSize = " << setprecision(indent) << m_maxNTUSize << '\n';
  strm << setw(indent+9) << "atmUBR = " << setprecision(indent) << m_atmUBR << '\n';
  strm << setw(indent+11) << "atmrtVBR = " << setprecision(indent) << m_atmrtVBR << '\n';
  strm << setw(indent+12) << "atmnrtVBR = " << setprecision(indent) << m_atmnrtVBR << '\n';
  strm << setw(indent+9) << "atmABR = " << setprecision(indent) << m_atmABR << '\n';
  strm << setw(indent+9) << "atmCBR = " << setprecision(indent) << m_atmCBR << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_ATMParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_ATMParameters::Class()), PInvalidCast);
#endif
  const H245_ATMParameters & other = (const H245_ATMParameters &)obj;

  Comparison result;

  if ((result = m_maxNTUSize.Compare(other.m_maxNTUSize)) != EqualTo)
    return result;
  if ((result = m_atmUBR.Compare(other.m_atmUBR)) != EqualTo)
    return result;
  if ((result = m_atmrtVBR.Compare(other.m_atmrtVBR)) != EqualTo)
    return result;
  if ((result = m_atmnrtVBR.Compare(other.m_atmnrtVBR)) != EqualTo)
    return result;
  if ((result = m_atmABR.Compare(other.m_atmABR)) != EqualTo)
    return result;
  if ((result = m_atmCBR.Compare(other.m_atmCBR)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ATMParameters::GetDataLength() const
{
  return m_maxNTUSize.GetObjectLength() +
         m_atmUBR.GetObjectLength() +
         m_atmrtVBR.GetObjectLength() +
         m_atmnrtVBR.GetObjectLength() +
         m_atmABR.GetObjectLength() +
         m_atmCBR.GetObjectLength();
}


BOOL H245_ATMParameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maxNTUSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_atmUBR.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_atmrtVBR.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_atmnrtVBR.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_atmABR.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_atmCBR.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_ATMParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_maxNTUSize.Encode(strm);
  m_atmUBR.Encode(strm);
  m_atmrtVBR.Encode(strm);
  m_atmnrtVBR.Encode(strm);
  m_atmABR.Encode(strm);
  m_atmCBR.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_maxNTUSize.Encode(strm);
  m_atmUBR.Encode(strm);
  m_atmrtVBR.Encode(strm);
  m_atmnrtVBR.Encode(strm);
  m_atmABR.Encode(strm);
  m_atmCBR.Encode(strm);
}


PObject * H245_ATMParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ATMParameters::Class()), PInvalidCast);
#endif
  return new H245_ATMParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ATMParameters::preShowEthereal( void )
{
  m_maxNTUSize.preShowEthereal( );
  m_atmUBR.preShowEthereal( );
  m_atmrtVBR.preShowEthereal( );
  m_atmnrtVBR.preShowEthereal( );
  m_atmABR.preShowEthereal( );
  m_atmCBR.preShowEthereal( );
}

PString H245_ATMParameters::getSummary( void ) 
{
  return PString( "ATMParameters" );
}

void H245_ATMParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_ATMParameters_maxNTUSize, tvb, offset + m_maxNTUSize.GetStartByte(), m_maxNTUSize.GetByteLength() , m_maxNTUSize.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_ATMParameters_atmUBR, tvb, offset + m_atmUBR.GetStartByte(), m_atmUBR.GetByteLength() , m_atmUBR.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_ATMParameters_atmrtVBR, tvb, offset + m_atmrtVBR.GetStartByte(), m_atmrtVBR.GetByteLength() , m_atmrtVBR.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_ATMParameters_atmnrtVBR, tvb, offset + m_atmnrtVBR.GetStartByte(), m_atmnrtVBR.GetByteLength() , m_atmnrtVBR.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_ATMParameters_atmABR, tvb, offset + m_atmABR.GetStartByte(), m_atmABR.GetByteLength() , m_atmABR.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_ATMParameters_atmCBR, tvb, offset + m_atmCBR.GetStartByte(), m_atmCBR.GetByteLength() , m_atmCBR.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// MediaTransportType
//

H245_MediaTransportType::H245_MediaTransportType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "ip_UDP "
        "ip_TCP "
        "atm_AAL5_UNIDIR "
        "atm_AAL5_BIDIR "
#endif
    )
{
}


BOOL H245_MediaTransportType::CreateObject()
{
  switch (tag) {
    case e_ip_UDP :
    case e_ip_TCP :
    case e_atm_AAL5_UNIDIR :
    case e_atm_AAL5_BIDIR :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_MediaTransportType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MediaTransportType::Class()), PInvalidCast);
#endif
  return new H245_MediaTransportType(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MediaTransportType::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_ip_UDP :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_ip_TCP :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_atm_AAL5_UNIDIR :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_atm_AAL5_BIDIR :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_MediaTransportType::getSummary( void ) 
{
  return PString( "MediaTransportType" );
}

void H245_MediaTransportType::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "ip_UDP" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_MediaTransportType_ip_UDP, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "ip_TCP" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_MediaTransportType_ip_TCP, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "atm_AAL5_UNIDIR" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_MediaTransportType_atm_AAL5_UNIDIR, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "atm_AAL5_BIDIR" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_MediaTransportType_atm_AAL5_BIDIR, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// MediaChannelCapability
//

H245_MediaChannelCapability::H245_MediaChannelCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MediaChannelCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_mediaTransport))
    strm << setw(indent+17) << "mediaTransport = " << setprecision(indent) << m_mediaTransport << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MediaChannelCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MediaChannelCapability::Class()), PInvalidCast);
#endif
  const H245_MediaChannelCapability & other = (const H245_MediaChannelCapability &)obj;

  Comparison result;

  if ((result = m_mediaTransport.Compare(other.m_mediaTransport)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MediaChannelCapability::GetDataLength() const
{
  return m_mediaTransport.GetObjectLength();
}


BOOL H245_MediaChannelCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_mediaTransport ) && !m_mediaTransport.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MediaChannelCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_mediaTransport))
    m_mediaTransport.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_mediaTransport))
    m_mediaTransport.Encode(strm);
}


PObject * H245_MediaChannelCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MediaChannelCapability::Class()), PInvalidCast);
#endif
  return new H245_MediaChannelCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MediaChannelCapability::preShowEthereal( void )
{
  if ( HasOptionalField( e_mediaTransport ) ) 
      m_mediaTransport.preShowEthereal( );
}

PString H245_MediaChannelCapability::getSummary( void ) 
{
  return PString( "MediaChannelCapability" );
}

void H245_MediaChannelCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_mediaTransport ) ) {
    proto_tree *mediaTransport_tree = (proto_tree*) NULL;
    proto_item *mediaTransport_ti = (proto_item*) NULL;
    mediaTransport_ti = proto_tree_add_text( tree, tvb, offset + m_mediaTransport.GetStartByte(), m_mediaTransport.GetByteLength(), "mediaTransport (%s)", ( const char* ) m_mediaTransport.GetTagName() );
    mediaTransport_tree = proto_item_add_subtree( mediaTransport_ti, hCont->h245_0.ett_h245_MediaChannelCapability_mediaTransport );
    m_mediaTransport.showEthereal( mediaTransport_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// RedundancyEncodingMethod
//

H245_RedundancyEncodingMethod::H245_RedundancyEncodingMethod(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "rtpAudioRedundancyEncoding "
        "rtpH263VideoRedundancyEncoding "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RedundancyEncodingMethod::operator H245_NonStandardParameter &() const
#else
H245_RedundancyEncodingMethod::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_RedundancyEncodingMethod::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RedundancyEncodingMethod::operator H245_RTPH263VideoRedundancyEncoding &() const
#else
H245_RedundancyEncodingMethod::operator H245_RTPH263VideoRedundancyEncoding &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RTPH263VideoRedundancyEncoding::Class()), PInvalidCast);
#endif
  return *(H245_RTPH263VideoRedundancyEncoding *)choice;
}


H245_RedundancyEncodingMethod::operator const H245_RTPH263VideoRedundancyEncoding &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RTPH263VideoRedundancyEncoding::Class()), PInvalidCast);
#endif
  return *(H245_RTPH263VideoRedundancyEncoding *)choice;
}


BOOL H245_RedundancyEncodingMethod::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_rtpAudioRedundancyEncoding :
      choice = new PASN_Null();
      return TRUE;
    case e_rtpH263VideoRedundancyEncoding :
      choice = new H245_RTPH263VideoRedundancyEncoding();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_RedundancyEncodingMethod::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RedundancyEncodingMethod::Class()), PInvalidCast);
#endif
  return new H245_RedundancyEncodingMethod(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RedundancyEncodingMethod::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_rtpAudioRedundancyEncoding :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_rtpH263VideoRedundancyEncoding :
        ( ( H245_RTPH263VideoRedundancyEncoding * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_RedundancyEncodingMethod::getSummary( void ) 
{
  return PString( "RedundancyEncodingMethod" );
}

void H245_RedundancyEncodingMethod::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "rtpAudioRedundancyEncoding" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_RedundancyEncodingMethod_rtpAudioRedundancyEncoding, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_RedundancyEncodingMethod_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// VideoCapability
//

H245_VideoCapability::H245_VideoCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "h261VideoCapability "
        "h262VideoCapability "
        "h263VideoCapability "
        "is11172VideoCapability "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VideoCapability::operator H245_NonStandardParameter &() const
#else
H245_VideoCapability::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_VideoCapability::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VideoCapability::operator H245_H261VideoCapability &() const
#else
H245_VideoCapability::operator H245_H261VideoCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H261VideoCapability::Class()), PInvalidCast);
#endif
  return *(H245_H261VideoCapability *)choice;
}


H245_VideoCapability::operator const H245_H261VideoCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H261VideoCapability::Class()), PInvalidCast);
#endif
  return *(H245_H261VideoCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VideoCapability::operator H245_H262VideoCapability &() const
#else
H245_VideoCapability::operator H245_H262VideoCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H262VideoCapability::Class()), PInvalidCast);
#endif
  return *(H245_H262VideoCapability *)choice;
}


H245_VideoCapability::operator const H245_H262VideoCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H262VideoCapability::Class()), PInvalidCast);
#endif
  return *(H245_H262VideoCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VideoCapability::operator H245_H263VideoCapability &() const
#else
H245_VideoCapability::operator H245_H263VideoCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H263VideoCapability::Class()), PInvalidCast);
#endif
  return *(H245_H263VideoCapability *)choice;
}


H245_VideoCapability::operator const H245_H263VideoCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H263VideoCapability::Class()), PInvalidCast);
#endif
  return *(H245_H263VideoCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VideoCapability::operator H245_IS11172VideoCapability &() const
#else
H245_VideoCapability::operator H245_IS11172VideoCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_IS11172VideoCapability::Class()), PInvalidCast);
#endif
  return *(H245_IS11172VideoCapability *)choice;
}


H245_VideoCapability::operator const H245_IS11172VideoCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_IS11172VideoCapability::Class()), PInvalidCast);
#endif
  return *(H245_IS11172VideoCapability *)choice;
}


BOOL H245_VideoCapability::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_h261VideoCapability :
      choice = new H245_H261VideoCapability();
      return TRUE;
    case e_h262VideoCapability :
      choice = new H245_H262VideoCapability();
      return TRUE;
    case e_h263VideoCapability :
      choice = new H245_H263VideoCapability();
      return TRUE;
    case e_is11172VideoCapability :
      choice = new H245_IS11172VideoCapability();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_VideoCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_VideoCapability::Class()), PInvalidCast);
#endif
  return new H245_VideoCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_VideoCapability::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_h261VideoCapability :
        ( ( H245_H261VideoCapability * ) choice )->preShowEthereal();
        break;
      case e_h262VideoCapability :
        ( ( H245_H262VideoCapability * ) choice )->preShowEthereal();
        break;
      case e_h263VideoCapability :
        ( ( H245_H263VideoCapability * ) choice )->preShowEthereal();
        break;
      case e_is11172VideoCapability :
        ( ( H245_IS11172VideoCapability * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_VideoCapability::getSummary( void ) 
{
  return PString( "VideoCapability" );
}

void H245_VideoCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_VideoCapability_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H261VideoCapability
//

H245_H261VideoCapability::H245_H261VideoCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_qcifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 4);
  m_cifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 4);
  m_maxBitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 19200);
}


#ifndef PASN_NOPRINTON
void H245_H261VideoCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_qcifMPI))
    strm << setw(indent+10) << "qcifMPI = " << setprecision(indent) << m_qcifMPI << '\n';
  if (HasOptionalField(e_cifMPI))
    strm << setw(indent+9) << "cifMPI = " << setprecision(indent) << m_cifMPI << '\n';
  strm << setw(indent+36) << "temporalSpatialTradeOffCapability = " << setprecision(indent) << m_temporalSpatialTradeOffCapability << '\n';
  strm << setw(indent+13) << "maxBitRate = " << setprecision(indent) << m_maxBitRate << '\n';
  strm << setw(indent+25) << "stillImageTransmission = " << setprecision(indent) << m_stillImageTransmission << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H261VideoCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H261VideoCapability::Class()), PInvalidCast);
#endif
  const H245_H261VideoCapability & other = (const H245_H261VideoCapability &)obj;

  Comparison result;

  if ((result = m_qcifMPI.Compare(other.m_qcifMPI)) != EqualTo)
    return result;
  if ((result = m_cifMPI.Compare(other.m_cifMPI)) != EqualTo)
    return result;
  if ((result = m_temporalSpatialTradeOffCapability.Compare(other.m_temporalSpatialTradeOffCapability)) != EqualTo)
    return result;
  if ((result = m_maxBitRate.Compare(other.m_maxBitRate)) != EqualTo)
    return result;
  if ((result = m_stillImageTransmission.Compare(other.m_stillImageTransmission)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H261VideoCapability::GetDataLength() const
{
  return m_qcifMPI.GetObjectLength() +
         m_cifMPI.GetObjectLength() +
         m_temporalSpatialTradeOffCapability.GetObjectLength() +
         m_maxBitRate.GetObjectLength() +
         m_stillImageTransmission.GetObjectLength();
}


BOOL H245_H261VideoCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_qcifMPI ) && !m_qcifMPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_cifMPI ) && !m_cifMPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_temporalSpatialTradeOffCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maxBitRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_stillImageTransmission.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H261VideoCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_qcifMPI))
    m_qcifMPI.Encode(strm);
  if (HasOptionalField(e_cifMPI))
    m_cifMPI.Encode(strm);
  m_temporalSpatialTradeOffCapability.Encode(strm);
  m_maxBitRate.Encode(strm);
  m_stillImageTransmission.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_qcifMPI))
    m_qcifMPI.Encode(strm);
  if (HasOptionalField(e_cifMPI))
    m_cifMPI.Encode(strm);
  m_temporalSpatialTradeOffCapability.Encode(strm);
  m_maxBitRate.Encode(strm);
  m_stillImageTransmission.Encode(strm);
}


PObject * H245_H261VideoCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H261VideoCapability::Class()), PInvalidCast);
#endif
  return new H245_H261VideoCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H261VideoCapability::preShowEthereal( void )
{
  if ( HasOptionalField( e_qcifMPI ) ) 
      m_qcifMPI.preShowEthereal( );
  if ( HasOptionalField( e_cifMPI ) ) 
      m_cifMPI.preShowEthereal( );
  m_temporalSpatialTradeOffCapability.preShowEthereal( );
  m_maxBitRate.preShowEthereal( );
  m_stillImageTransmission.preShowEthereal( );
}

PString H245_H261VideoCapability::getSummary( void ) 
{
  return PString( "H261VideoCapability" );
}

void H245_H261VideoCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_qcifMPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_H261VideoCapability_qcifMPI, tvb, offset + m_qcifMPI.GetStartByte(), m_qcifMPI.GetByteLength() , m_qcifMPI.GetValue() );
  }

  if ( HasOptionalField( e_cifMPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_H261VideoCapability_cifMPI, tvb, offset + m_cifMPI.GetStartByte(), m_cifMPI.GetByteLength() , m_cifMPI.GetValue() );
  }

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H261VideoCapability_temporalSpatialTradeOffCapability, tvb, offset + m_temporalSpatialTradeOffCapability.GetStartByte(), m_temporalSpatialTradeOffCapability.GetByteLength() , m_temporalSpatialTradeOffCapability.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_H261VideoCapability_maxBitRate, tvb, offset + m_maxBitRate.GetStartByte(), m_maxBitRate.GetByteLength() , m_maxBitRate.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H261VideoCapability_stillImageTransmission, tvb, offset + m_stillImageTransmission.GetStartByte(), m_stillImageTransmission.GetByteLength() , m_stillImageTransmission.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// H262VideoCapability
//

H245_H262VideoCapability::H245_H262VideoCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 6, TRUE, 0)
{
  m_videoBitRate.SetConstraints(PASN_Object::FixedConstraint, 0, 1073741823);
  m_vbvBufferSize.SetConstraints(PASN_Object::FixedConstraint, 0, 262143);
  m_samplesPerLine.SetConstraints(PASN_Object::FixedConstraint, 0, 16383);
  m_linesPerFrame.SetConstraints(PASN_Object::FixedConstraint, 0, 16383);
  m_framesPerSecond.SetConstraints(PASN_Object::FixedConstraint, 0, 15);
  m_luminanceSampleRate.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H245_H262VideoCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+25) << "profileAndLevel_SPatML = " << setprecision(indent) << m_profileAndLevel_SPatML << '\n';
  strm << setw(indent+25) << "profileAndLevel_MPatLL = " << setprecision(indent) << m_profileAndLevel_MPatLL << '\n';
  strm << setw(indent+25) << "profileAndLevel_MPatML = " << setprecision(indent) << m_profileAndLevel_MPatML << '\n';
  strm << setw(indent+27) << "profileAndLevel_MPatH_14 = " << setprecision(indent) << m_profileAndLevel_MPatH_14 << '\n';
  strm << setw(indent+25) << "profileAndLevel_MPatHL = " << setprecision(indent) << m_profileAndLevel_MPatHL << '\n';
  strm << setw(indent+26) << "profileAndLevel_SNRatLL = " << setprecision(indent) << m_profileAndLevel_SNRatLL << '\n';
  strm << setw(indent+26) << "profileAndLevel_SNRatML = " << setprecision(indent) << m_profileAndLevel_SNRatML << '\n';
  strm << setw(indent+32) << "profileAndLevel_SpatialatH_14 = " << setprecision(indent) << m_profileAndLevel_SpatialatH_14 << '\n';
  strm << setw(indent+25) << "profileAndLevel_HPatML = " << setprecision(indent) << m_profileAndLevel_HPatML << '\n';
  strm << setw(indent+27) << "profileAndLevel_HPatH_14 = " << setprecision(indent) << m_profileAndLevel_HPatH_14 << '\n';
  strm << setw(indent+25) << "profileAndLevel_HPatHL = " << setprecision(indent) << m_profileAndLevel_HPatHL << '\n';
  if (HasOptionalField(e_videoBitRate))
    strm << setw(indent+15) << "videoBitRate = " << setprecision(indent) << m_videoBitRate << '\n';
  if (HasOptionalField(e_vbvBufferSize))
    strm << setw(indent+16) << "vbvBufferSize = " << setprecision(indent) << m_vbvBufferSize << '\n';
  if (HasOptionalField(e_samplesPerLine))
    strm << setw(indent+17) << "samplesPerLine = " << setprecision(indent) << m_samplesPerLine << '\n';
  if (HasOptionalField(e_linesPerFrame))
    strm << setw(indent+16) << "linesPerFrame = " << setprecision(indent) << m_linesPerFrame << '\n';
  if (HasOptionalField(e_framesPerSecond))
    strm << setw(indent+18) << "framesPerSecond = " << setprecision(indent) << m_framesPerSecond << '\n';
  if (HasOptionalField(e_luminanceSampleRate))
    strm << setw(indent+22) << "luminanceSampleRate = " << setprecision(indent) << m_luminanceSampleRate << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H262VideoCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H262VideoCapability::Class()), PInvalidCast);
#endif
  const H245_H262VideoCapability & other = (const H245_H262VideoCapability &)obj;

  Comparison result;

  if ((result = m_profileAndLevel_SPatML.Compare(other.m_profileAndLevel_SPatML)) != EqualTo)
    return result;
  if ((result = m_profileAndLevel_MPatLL.Compare(other.m_profileAndLevel_MPatLL)) != EqualTo)
    return result;
  if ((result = m_profileAndLevel_MPatML.Compare(other.m_profileAndLevel_MPatML)) != EqualTo)
    return result;
  if ((result = m_profileAndLevel_MPatH_14.Compare(other.m_profileAndLevel_MPatH_14)) != EqualTo)
    return result;
  if ((result = m_profileAndLevel_MPatHL.Compare(other.m_profileAndLevel_MPatHL)) != EqualTo)
    return result;
  if ((result = m_profileAndLevel_SNRatLL.Compare(other.m_profileAndLevel_SNRatLL)) != EqualTo)
    return result;
  if ((result = m_profileAndLevel_SNRatML.Compare(other.m_profileAndLevel_SNRatML)) != EqualTo)
    return result;
  if ((result = m_profileAndLevel_SpatialatH_14.Compare(other.m_profileAndLevel_SpatialatH_14)) != EqualTo)
    return result;
  if ((result = m_profileAndLevel_HPatML.Compare(other.m_profileAndLevel_HPatML)) != EqualTo)
    return result;
  if ((result = m_profileAndLevel_HPatH_14.Compare(other.m_profileAndLevel_HPatH_14)) != EqualTo)
    return result;
  if ((result = m_profileAndLevel_HPatHL.Compare(other.m_profileAndLevel_HPatHL)) != EqualTo)
    return result;
  if ((result = m_videoBitRate.Compare(other.m_videoBitRate)) != EqualTo)
    return result;
  if ((result = m_vbvBufferSize.Compare(other.m_vbvBufferSize)) != EqualTo)
    return result;
  if ((result = m_samplesPerLine.Compare(other.m_samplesPerLine)) != EqualTo)
    return result;
  if ((result = m_linesPerFrame.Compare(other.m_linesPerFrame)) != EqualTo)
    return result;
  if ((result = m_framesPerSecond.Compare(other.m_framesPerSecond)) != EqualTo)
    return result;
  if ((result = m_luminanceSampleRate.Compare(other.m_luminanceSampleRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H262VideoCapability::GetDataLength() const
{
  return m_profileAndLevel_SPatML.GetObjectLength() +
         m_profileAndLevel_MPatLL.GetObjectLength() +
         m_profileAndLevel_MPatML.GetObjectLength() +
         m_profileAndLevel_MPatH_14.GetObjectLength() +
         m_profileAndLevel_MPatHL.GetObjectLength() +
         m_profileAndLevel_SNRatLL.GetObjectLength() +
         m_profileAndLevel_SNRatML.GetObjectLength() +
         m_profileAndLevel_SpatialatH_14.GetObjectLength() +
         m_profileAndLevel_HPatML.GetObjectLength() +
         m_profileAndLevel_HPatH_14.GetObjectLength() +
         m_profileAndLevel_HPatHL.GetObjectLength() +
         m_videoBitRate.GetObjectLength() +
         m_vbvBufferSize.GetObjectLength() +
         m_samplesPerLine.GetObjectLength() +
         m_linesPerFrame.GetObjectLength() +
         m_framesPerSecond.GetObjectLength() +
         m_luminanceSampleRate.GetObjectLength();
}


BOOL H245_H262VideoCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_profileAndLevel_SPatML.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_profileAndLevel_MPatLL.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_profileAndLevel_MPatML.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_profileAndLevel_MPatH_14.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_profileAndLevel_MPatHL.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_profileAndLevel_SNRatLL.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_profileAndLevel_SNRatML.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_profileAndLevel_SpatialatH_14.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_profileAndLevel_HPatML.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_profileAndLevel_HPatH_14.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_profileAndLevel_HPatHL.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_videoBitRate ) && !m_videoBitRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_vbvBufferSize ) && !m_vbvBufferSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_samplesPerLine ) && !m_samplesPerLine.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_linesPerFrame ) && !m_linesPerFrame.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_framesPerSecond ) && !m_framesPerSecond.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_luminanceSampleRate ) && !m_luminanceSampleRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H262VideoCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_profileAndLevel_SPatML.Encode(strm);
  m_profileAndLevel_MPatLL.Encode(strm);
  m_profileAndLevel_MPatML.Encode(strm);
  m_profileAndLevel_MPatH_14.Encode(strm);
  m_profileAndLevel_MPatHL.Encode(strm);
  m_profileAndLevel_SNRatLL.Encode(strm);
  m_profileAndLevel_SNRatML.Encode(strm);
  m_profileAndLevel_SpatialatH_14.Encode(strm);
  m_profileAndLevel_HPatML.Encode(strm);
  m_profileAndLevel_HPatH_14.Encode(strm);
  m_profileAndLevel_HPatHL.Encode(strm);
  if (HasOptionalField(e_videoBitRate))
    m_videoBitRate.Encode(strm);
  if (HasOptionalField(e_vbvBufferSize))
    m_vbvBufferSize.Encode(strm);
  if (HasOptionalField(e_samplesPerLine))
    m_samplesPerLine.Encode(strm);
  if (HasOptionalField(e_linesPerFrame))
    m_linesPerFrame.Encode(strm);
  if (HasOptionalField(e_framesPerSecond))
    m_framesPerSecond.Encode(strm);
  if (HasOptionalField(e_luminanceSampleRate))
    m_luminanceSampleRate.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_profileAndLevel_SPatML.Encode(strm);
  m_profileAndLevel_MPatLL.Encode(strm);
  m_profileAndLevel_MPatML.Encode(strm);
  m_profileAndLevel_MPatH_14.Encode(strm);
  m_profileAndLevel_MPatHL.Encode(strm);
  m_profileAndLevel_SNRatLL.Encode(strm);
  m_profileAndLevel_SNRatML.Encode(strm);
  m_profileAndLevel_SpatialatH_14.Encode(strm);
  m_profileAndLevel_HPatML.Encode(strm);
  m_profileAndLevel_HPatH_14.Encode(strm);
  m_profileAndLevel_HPatHL.Encode(strm);
  if (HasOptionalField(e_videoBitRate))
    m_videoBitRate.Encode(strm);
  if (HasOptionalField(e_vbvBufferSize))
    m_vbvBufferSize.Encode(strm);
  if (HasOptionalField(e_samplesPerLine))
    m_samplesPerLine.Encode(strm);
  if (HasOptionalField(e_linesPerFrame))
    m_linesPerFrame.Encode(strm);
  if (HasOptionalField(e_framesPerSecond))
    m_framesPerSecond.Encode(strm);
  if (HasOptionalField(e_luminanceSampleRate))
    m_luminanceSampleRate.Encode(strm);
}


PObject * H245_H262VideoCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H262VideoCapability::Class()), PInvalidCast);
#endif
  return new H245_H262VideoCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H262VideoCapability::preShowEthereal( void )
{
  m_profileAndLevel_SPatML.preShowEthereal( );
  m_profileAndLevel_MPatLL.preShowEthereal( );
  m_profileAndLevel_MPatML.preShowEthereal( );
  m_profileAndLevel_MPatH_14.preShowEthereal( );
  m_profileAndLevel_MPatHL.preShowEthereal( );
  m_profileAndLevel_SNRatLL.preShowEthereal( );
  m_profileAndLevel_SNRatML.preShowEthereal( );
  m_profileAndLevel_SpatialatH_14.preShowEthereal( );
  m_profileAndLevel_HPatML.preShowEthereal( );
  m_profileAndLevel_HPatH_14.preShowEthereal( );
  m_profileAndLevel_HPatHL.preShowEthereal( );
  if ( HasOptionalField( e_videoBitRate ) ) 
      m_videoBitRate.preShowEthereal( );
  if ( HasOptionalField( e_vbvBufferSize ) ) 
      m_vbvBufferSize.preShowEthereal( );
  if ( HasOptionalField( e_samplesPerLine ) ) 
      m_samplesPerLine.preShowEthereal( );
  if ( HasOptionalField( e_linesPerFrame ) ) 
      m_linesPerFrame.preShowEthereal( );
  if ( HasOptionalField( e_framesPerSecond ) ) 
      m_framesPerSecond.preShowEthereal( );
  if ( HasOptionalField( e_luminanceSampleRate ) ) 
      m_luminanceSampleRate.preShowEthereal( );
}

PString H245_H262VideoCapability::getSummary( void ) 
{
  return PString( "H262VideoCapability" );
}

void H245_H262VideoCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H262VideoCapability_profileAndLevel_SPatML, tvb, offset + m_profileAndLevel_SPatML.GetStartByte(), m_profileAndLevel_SPatML.GetByteLength() , m_profileAndLevel_SPatML.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H262VideoCapability_profileAndLevel_MPatLL, tvb, offset + m_profileAndLevel_MPatLL.GetStartByte(), m_profileAndLevel_MPatLL.GetByteLength() , m_profileAndLevel_MPatLL.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H262VideoCapability_profileAndLevel_MPatML, tvb, offset + m_profileAndLevel_MPatML.GetStartByte(), m_profileAndLevel_MPatML.GetByteLength() , m_profileAndLevel_MPatML.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H262VideoCapability_profileAndLevel_MPatH_14, tvb, offset + m_profileAndLevel_MPatH_14.GetStartByte(), m_profileAndLevel_MPatH_14.GetByteLength() , m_profileAndLevel_MPatH_14.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H262VideoCapability_profileAndLevel_MPatHL, tvb, offset + m_profileAndLevel_MPatHL.GetStartByte(), m_profileAndLevel_MPatHL.GetByteLength() , m_profileAndLevel_MPatHL.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H262VideoCapability_profileAndLevel_SNRatLL, tvb, offset + m_profileAndLevel_SNRatLL.GetStartByte(), m_profileAndLevel_SNRatLL.GetByteLength() , m_profileAndLevel_SNRatLL.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H262VideoCapability_profileAndLevel_SNRatML, tvb, offset + m_profileAndLevel_SNRatML.GetStartByte(), m_profileAndLevel_SNRatML.GetByteLength() , m_profileAndLevel_SNRatML.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H262VideoCapability_profileAndLevel_SpatialatH_14, tvb, offset + m_profileAndLevel_SpatialatH_14.GetStartByte(), m_profileAndLevel_SpatialatH_14.GetByteLength() , m_profileAndLevel_SpatialatH_14.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H262VideoCapability_profileAndLevel_HPatML, tvb, offset + m_profileAndLevel_HPatML.GetStartByte(), m_profileAndLevel_HPatML.GetByteLength() , m_profileAndLevel_HPatML.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H262VideoCapability_profileAndLevel_HPatH_14, tvb, offset + m_profileAndLevel_HPatH_14.GetStartByte(), m_profileAndLevel_HPatH_14.GetByteLength() , m_profileAndLevel_HPatH_14.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H262VideoCapability_profileAndLevel_HPatHL, tvb, offset + m_profileAndLevel_HPatHL.GetStartByte(), m_profileAndLevel_HPatHL.GetByteLength() , m_profileAndLevel_HPatHL.GetValue() );

  if ( HasOptionalField( e_videoBitRate ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_H262VideoCapability_videoBitRate, tvb, offset + m_videoBitRate.GetStartByte(), m_videoBitRate.GetByteLength() , m_videoBitRate.GetValue() );
  }

  if ( HasOptionalField( e_vbvBufferSize ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_H262VideoCapability_vbvBufferSize, tvb, offset + m_vbvBufferSize.GetStartByte(), m_vbvBufferSize.GetByteLength() , m_vbvBufferSize.GetValue() );
  }

  if ( HasOptionalField( e_samplesPerLine ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_H262VideoCapability_samplesPerLine, tvb, offset + m_samplesPerLine.GetStartByte(), m_samplesPerLine.GetByteLength() , m_samplesPerLine.GetValue() );
  }

  if ( HasOptionalField( e_linesPerFrame ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_H262VideoCapability_linesPerFrame, tvb, offset + m_linesPerFrame.GetStartByte(), m_linesPerFrame.GetByteLength() , m_linesPerFrame.GetValue() );
  }

  if ( HasOptionalField( e_framesPerSecond ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_H262VideoCapability_framesPerSecond, tvb, offset + m_framesPerSecond.GetStartByte(), m_framesPerSecond.GetByteLength() , m_framesPerSecond.GetValue() );
  }

  if ( HasOptionalField( e_luminanceSampleRate ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_H262VideoCapability_luminanceSampleRate, tvb, offset + m_luminanceSampleRate.GetStartByte(), m_luminanceSampleRate.GetByteLength() , m_luminanceSampleRate.GetValue() );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// TransparencyParameters
//

H245_TransparencyParameters::H245_TransparencyParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_presentationOrder.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
  m_offset_x.SetConstraints(PASN_Object::FixedConstraint, -262144, 262143);
  m_offset_y.SetConstraints(PASN_Object::FixedConstraint, -262144, 262143);
  m_scale_x.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
  m_scale_y.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
}


#ifndef PASN_NOPRINTON
void H245_TransparencyParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+20) << "presentationOrder = " << setprecision(indent) << m_presentationOrder << '\n';
  strm << setw(indent+11) << "offset_x = " << setprecision(indent) << m_offset_x << '\n';
  strm << setw(indent+11) << "offset_y = " << setprecision(indent) << m_offset_y << '\n';
  strm << setw(indent+10) << "scale_x = " << setprecision(indent) << m_scale_x << '\n';
  strm << setw(indent+10) << "scale_y = " << setprecision(indent) << m_scale_y << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_TransparencyParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_TransparencyParameters::Class()), PInvalidCast);
#endif
  const H245_TransparencyParameters & other = (const H245_TransparencyParameters &)obj;

  Comparison result;

  if ((result = m_presentationOrder.Compare(other.m_presentationOrder)) != EqualTo)
    return result;
  if ((result = m_offset_x.Compare(other.m_offset_x)) != EqualTo)
    return result;
  if ((result = m_offset_y.Compare(other.m_offset_y)) != EqualTo)
    return result;
  if ((result = m_scale_x.Compare(other.m_scale_x)) != EqualTo)
    return result;
  if ((result = m_scale_y.Compare(other.m_scale_y)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_TransparencyParameters::GetDataLength() const
{
  return m_presentationOrder.GetObjectLength() +
         m_offset_x.GetObjectLength() +
         m_offset_y.GetObjectLength() +
         m_scale_x.GetObjectLength() +
         m_scale_y.GetObjectLength();
}


BOOL H245_TransparencyParameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_presentationOrder.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_offset_x.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_offset_y.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_scale_x.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_scale_y.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_TransparencyParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_presentationOrder.Encode(strm);
  m_offset_x.Encode(strm);
  m_offset_y.Encode(strm);
  m_scale_x.Encode(strm);
  m_scale_y.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_presentationOrder.Encode(strm);
  m_offset_x.Encode(strm);
  m_offset_y.Encode(strm);
  m_scale_x.Encode(strm);
  m_scale_y.Encode(strm);
}


PObject * H245_TransparencyParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TransparencyParameters::Class()), PInvalidCast);
#endif
  return new H245_TransparencyParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_TransparencyParameters::preShowEthereal( void )
{
  m_presentationOrder.preShowEthereal( );
  m_offset_x.preShowEthereal( );
  m_offset_y.preShowEthereal( );
  m_scale_x.preShowEthereal( );
  m_scale_y.preShowEthereal( );
}

PString H245_TransparencyParameters::getSummary( void ) 
{
  return PString( "TransparencyParameters" );
}

void H245_TransparencyParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_TransparencyParameters_presentationOrder, tvb, offset + m_presentationOrder.GetStartByte(), m_presentationOrder.GetByteLength() , m_presentationOrder.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_TransparencyParameters_offset_x, tvb, offset + m_offset_x.GetStartByte(), m_offset_x.GetByteLength() , m_offset_x.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_TransparencyParameters_offset_y, tvb, offset + m_offset_y.GetStartByte(), m_offset_y.GetByteLength() , m_offset_y.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_TransparencyParameters_scale_x, tvb, offset + m_scale_x.GetStartByte(), m_scale_x.GetByteLength() , m_scale_x.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_TransparencyParameters_scale_y, tvb, offset + m_scale_y.GetStartByte(), m_scale_y.GetByteLength() , m_scale_y.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// CustomPictureClockFrequency
//

H245_CustomPictureClockFrequency::H245_CustomPictureClockFrequency(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 5, TRUE, 0)
{
  m_clockConversionCode.SetConstraints(PASN_Object::FixedConstraint, 1000, 1001);
  m_clockDivisor.SetConstraints(PASN_Object::FixedConstraint, 1, 127);
  m_sqcifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 2048);
  m_qcifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 2048);
  m_cifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 2048);
  m_cif4MPI.SetConstraints(PASN_Object::FixedConstraint, 1, 2048);
  m_cif16MPI.SetConstraints(PASN_Object::FixedConstraint, 1, 2048);
}


#ifndef PASN_NOPRINTON
void H245_CustomPictureClockFrequency::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "clockConversionCode = " << setprecision(indent) << m_clockConversionCode << '\n';
  strm << setw(indent+15) << "clockDivisor = " << setprecision(indent) << m_clockDivisor << '\n';
  if (HasOptionalField(e_sqcifMPI))
    strm << setw(indent+11) << "sqcifMPI = " << setprecision(indent) << m_sqcifMPI << '\n';
  if (HasOptionalField(e_qcifMPI))
    strm << setw(indent+10) << "qcifMPI = " << setprecision(indent) << m_qcifMPI << '\n';
  if (HasOptionalField(e_cifMPI))
    strm << setw(indent+9) << "cifMPI = " << setprecision(indent) << m_cifMPI << '\n';
  if (HasOptionalField(e_cif4MPI))
    strm << setw(indent+10) << "cif4MPI = " << setprecision(indent) << m_cif4MPI << '\n';
  if (HasOptionalField(e_cif16MPI))
    strm << setw(indent+11) << "cif16MPI = " << setprecision(indent) << m_cif16MPI << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_CustomPictureClockFrequency::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_CustomPictureClockFrequency::Class()), PInvalidCast);
#endif
  const H245_CustomPictureClockFrequency & other = (const H245_CustomPictureClockFrequency &)obj;

  Comparison result;

  if ((result = m_clockConversionCode.Compare(other.m_clockConversionCode)) != EqualTo)
    return result;
  if ((result = m_clockDivisor.Compare(other.m_clockDivisor)) != EqualTo)
    return result;
  if ((result = m_sqcifMPI.Compare(other.m_sqcifMPI)) != EqualTo)
    return result;
  if ((result = m_qcifMPI.Compare(other.m_qcifMPI)) != EqualTo)
    return result;
  if ((result = m_cifMPI.Compare(other.m_cifMPI)) != EqualTo)
    return result;
  if ((result = m_cif4MPI.Compare(other.m_cif4MPI)) != EqualTo)
    return result;
  if ((result = m_cif16MPI.Compare(other.m_cif16MPI)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_CustomPictureClockFrequency::GetDataLength() const
{
  return m_clockConversionCode.GetObjectLength() +
         m_clockDivisor.GetObjectLength() +
         m_sqcifMPI.GetObjectLength() +
         m_qcifMPI.GetObjectLength() +
         m_cifMPI.GetObjectLength() +
         m_cif4MPI.GetObjectLength() +
         m_cif16MPI.GetObjectLength();
}


BOOL H245_CustomPictureClockFrequency::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_clockConversionCode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_clockDivisor.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_sqcifMPI ) && !m_sqcifMPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_qcifMPI ) && !m_qcifMPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_cifMPI ) && !m_cifMPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_cif4MPI ) && !m_cif4MPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_cif16MPI ) && !m_cif16MPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_CustomPictureClockFrequency::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_clockConversionCode.Encode(strm);
  m_clockDivisor.Encode(strm);
  if (HasOptionalField(e_sqcifMPI))
    m_sqcifMPI.Encode(strm);
  if (HasOptionalField(e_qcifMPI))
    m_qcifMPI.Encode(strm);
  if (HasOptionalField(e_cifMPI))
    m_cifMPI.Encode(strm);
  if (HasOptionalField(e_cif4MPI))
    m_cif4MPI.Encode(strm);
  if (HasOptionalField(e_cif16MPI))
    m_cif16MPI.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_clockConversionCode.Encode(strm);
  m_clockDivisor.Encode(strm);
  if (HasOptionalField(e_sqcifMPI))
    m_sqcifMPI.Encode(strm);
  if (HasOptionalField(e_qcifMPI))
    m_qcifMPI.Encode(strm);
  if (HasOptionalField(e_cifMPI))
    m_cifMPI.Encode(strm);
  if (HasOptionalField(e_cif4MPI))
    m_cif4MPI.Encode(strm);
  if (HasOptionalField(e_cif16MPI))
    m_cif16MPI.Encode(strm);
}


PObject * H245_CustomPictureClockFrequency::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CustomPictureClockFrequency::Class()), PInvalidCast);
#endif
  return new H245_CustomPictureClockFrequency(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CustomPictureClockFrequency::preShowEthereal( void )
{
  m_clockConversionCode.preShowEthereal( );
  m_clockDivisor.preShowEthereal( );
  if ( HasOptionalField( e_sqcifMPI ) ) 
      m_sqcifMPI.preShowEthereal( );
  if ( HasOptionalField( e_qcifMPI ) ) 
      m_qcifMPI.preShowEthereal( );
  if ( HasOptionalField( e_cifMPI ) ) 
      m_cifMPI.preShowEthereal( );
  if ( HasOptionalField( e_cif4MPI ) ) 
      m_cif4MPI.preShowEthereal( );
  if ( HasOptionalField( e_cif16MPI ) ) 
      m_cif16MPI.preShowEthereal( );
}

PString H245_CustomPictureClockFrequency::getSummary( void ) 
{
  return PString( "CustomPictureClockFrequency" );
}

void H245_CustomPictureClockFrequency::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_CustomPictureClockFrequency_clockConversionCode, tvb, offset + m_clockConversionCode.GetStartByte(), m_clockConversionCode.GetByteLength() , m_clockConversionCode.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_CustomPictureClockFrequency_clockDivisor, tvb, offset + m_clockDivisor.GetStartByte(), m_clockDivisor.GetByteLength() , m_clockDivisor.GetValue() );

  if ( HasOptionalField( e_sqcifMPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_CustomPictureClockFrequency_sqcifMPI, tvb, offset + m_sqcifMPI.GetStartByte(), m_sqcifMPI.GetByteLength() , m_sqcifMPI.GetValue() );
  }

  if ( HasOptionalField( e_qcifMPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_CustomPictureClockFrequency_qcifMPI, tvb, offset + m_qcifMPI.GetStartByte(), m_qcifMPI.GetByteLength() , m_qcifMPI.GetValue() );
  }

  if ( HasOptionalField( e_cifMPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_CustomPictureClockFrequency_cifMPI, tvb, offset + m_cifMPI.GetStartByte(), m_cifMPI.GetByteLength() , m_cifMPI.GetValue() );
  }

  if ( HasOptionalField( e_cif4MPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_CustomPictureClockFrequency_cif4MPI, tvb, offset + m_cif4MPI.GetStartByte(), m_cif4MPI.GetByteLength() , m_cif4MPI.GetValue() );
  }

  if ( HasOptionalField( e_cif16MPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_CustomPictureClockFrequency_cif16MPI, tvb, offset + m_cif16MPI.GetStartByte(), m_cif16MPI.GetByteLength() , m_cif16MPI.GetValue() );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// H263ModeComboFlags
//

H245_H263ModeComboFlags::H245_H263ModeComboFlags(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_H263ModeComboFlags::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "unrestrictedVector = " << setprecision(indent) << m_unrestrictedVector << '\n';
  strm << setw(indent+19) << "arithmeticCoding = " << setprecision(indent) << m_arithmeticCoding << '\n';
  strm << setw(indent+21) << "advancedPrediction = " << setprecision(indent) << m_advancedPrediction << '\n';
  strm << setw(indent+11) << "pbFrames = " << setprecision(indent) << m_pbFrames << '\n';
  strm << setw(indent+26) << "advancedIntraCodingMode = " << setprecision(indent) << m_advancedIntraCodingMode << '\n';
  strm << setw(indent+23) << "deblockingFilterMode = " << setprecision(indent) << m_deblockingFilterMode << '\n';
  strm << setw(indent+25) << "unlimitedMotionVectors = " << setprecision(indent) << m_unlimitedMotionVectors << '\n';
  strm << setw(indent+24) << "slicesInOrder_NonRect = " << setprecision(indent) << m_slicesInOrder_NonRect << '\n';
  strm << setw(indent+21) << "slicesInOrder_Rect = " << setprecision(indent) << m_slicesInOrder_Rect << '\n';
  strm << setw(indent+24) << "slicesNoOrder_NonRect = " << setprecision(indent) << m_slicesNoOrder_NonRect << '\n';
  strm << setw(indent+21) << "slicesNoOrder_Rect = " << setprecision(indent) << m_slicesNoOrder_Rect << '\n';
  strm << setw(indent+23) << "improvedPBFramesMode = " << setprecision(indent) << m_improvedPBFramesMode << '\n';
  strm << setw(indent+21) << "referencePicSelect = " << setprecision(indent) << m_referencePicSelect << '\n';
  strm << setw(indent+31) << "dynamicPictureResizingByFour = " << setprecision(indent) << m_dynamicPictureResizingByFour << '\n';
  strm << setw(indent+37) << "dynamicPictureResizingSixteenthPel = " << setprecision(indent) << m_dynamicPictureResizingSixteenthPel << '\n';
  strm << setw(indent+24) << "dynamicWarpingHalfPel = " << setprecision(indent) << m_dynamicWarpingHalfPel << '\n';
  strm << setw(indent+29) << "dynamicWarpingSixteenthPel = " << setprecision(indent) << m_dynamicWarpingSixteenthPel << '\n';
  strm << setw(indent+26) << "reducedResolutionUpdate = " << setprecision(indent) << m_reducedResolutionUpdate << '\n';
  strm << setw(indent+29) << "independentSegmentDecoding = " << setprecision(indent) << m_independentSegmentDecoding << '\n';
  strm << setw(indent+24) << "alternateInterVLCMode = " << setprecision(indent) << m_alternateInterVLCMode << '\n';
  strm << setw(indent+27) << "modifiedQuantizationMode = " << setprecision(indent) << m_modifiedQuantizationMode << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H263ModeComboFlags::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H263ModeComboFlags::Class()), PInvalidCast);
#endif
  const H245_H263ModeComboFlags & other = (const H245_H263ModeComboFlags &)obj;

  Comparison result;

  if ((result = m_unrestrictedVector.Compare(other.m_unrestrictedVector)) != EqualTo)
    return result;
  if ((result = m_arithmeticCoding.Compare(other.m_arithmeticCoding)) != EqualTo)
    return result;
  if ((result = m_advancedPrediction.Compare(other.m_advancedPrediction)) != EqualTo)
    return result;
  if ((result = m_pbFrames.Compare(other.m_pbFrames)) != EqualTo)
    return result;
  if ((result = m_advancedIntraCodingMode.Compare(other.m_advancedIntraCodingMode)) != EqualTo)
    return result;
  if ((result = m_deblockingFilterMode.Compare(other.m_deblockingFilterMode)) != EqualTo)
    return result;
  if ((result = m_unlimitedMotionVectors.Compare(other.m_unlimitedMotionVectors)) != EqualTo)
    return result;
  if ((result = m_slicesInOrder_NonRect.Compare(other.m_slicesInOrder_NonRect)) != EqualTo)
    return result;
  if ((result = m_slicesInOrder_Rect.Compare(other.m_slicesInOrder_Rect)) != EqualTo)
    return result;
  if ((result = m_slicesNoOrder_NonRect.Compare(other.m_slicesNoOrder_NonRect)) != EqualTo)
    return result;
  if ((result = m_slicesNoOrder_Rect.Compare(other.m_slicesNoOrder_Rect)) != EqualTo)
    return result;
  if ((result = m_improvedPBFramesMode.Compare(other.m_improvedPBFramesMode)) != EqualTo)
    return result;
  if ((result = m_referencePicSelect.Compare(other.m_referencePicSelect)) != EqualTo)
    return result;
  if ((result = m_dynamicPictureResizingByFour.Compare(other.m_dynamicPictureResizingByFour)) != EqualTo)
    return result;
  if ((result = m_dynamicPictureResizingSixteenthPel.Compare(other.m_dynamicPictureResizingSixteenthPel)) != EqualTo)
    return result;
  if ((result = m_dynamicWarpingHalfPel.Compare(other.m_dynamicWarpingHalfPel)) != EqualTo)
    return result;
  if ((result = m_dynamicWarpingSixteenthPel.Compare(other.m_dynamicWarpingSixteenthPel)) != EqualTo)
    return result;
  if ((result = m_reducedResolutionUpdate.Compare(other.m_reducedResolutionUpdate)) != EqualTo)
    return result;
  if ((result = m_independentSegmentDecoding.Compare(other.m_independentSegmentDecoding)) != EqualTo)
    return result;
  if ((result = m_alternateInterVLCMode.Compare(other.m_alternateInterVLCMode)) != EqualTo)
    return result;
  if ((result = m_modifiedQuantizationMode.Compare(other.m_modifiedQuantizationMode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H263ModeComboFlags::GetDataLength() const
{
  return m_unrestrictedVector.GetObjectLength() +
         m_arithmeticCoding.GetObjectLength() +
         m_advancedPrediction.GetObjectLength() +
         m_pbFrames.GetObjectLength() +
         m_advancedIntraCodingMode.GetObjectLength() +
         m_deblockingFilterMode.GetObjectLength() +
         m_unlimitedMotionVectors.GetObjectLength() +
         m_slicesInOrder_NonRect.GetObjectLength() +
         m_slicesInOrder_Rect.GetObjectLength() +
         m_slicesNoOrder_NonRect.GetObjectLength() +
         m_slicesNoOrder_Rect.GetObjectLength() +
         m_improvedPBFramesMode.GetObjectLength() +
         m_referencePicSelect.GetObjectLength() +
         m_dynamicPictureResizingByFour.GetObjectLength() +
         m_dynamicPictureResizingSixteenthPel.GetObjectLength() +
         m_dynamicWarpingHalfPel.GetObjectLength() +
         m_dynamicWarpingSixteenthPel.GetObjectLength() +
         m_reducedResolutionUpdate.GetObjectLength() +
         m_independentSegmentDecoding.GetObjectLength() +
         m_alternateInterVLCMode.GetObjectLength() +
         m_modifiedQuantizationMode.GetObjectLength();
}


BOOL H245_H263ModeComboFlags::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_unrestrictedVector.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_arithmeticCoding.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_advancedPrediction.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_pbFrames.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_advancedIntraCodingMode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_deblockingFilterMode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_unlimitedMotionVectors.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_slicesInOrder_NonRect.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_slicesInOrder_Rect.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_slicesNoOrder_NonRect.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_slicesNoOrder_Rect.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_improvedPBFramesMode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_referencePicSelect.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_dynamicPictureResizingByFour.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_dynamicPictureResizingSixteenthPel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_dynamicWarpingHalfPel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_dynamicWarpingSixteenthPel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_reducedResolutionUpdate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_independentSegmentDecoding.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_alternateInterVLCMode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_modifiedQuantizationMode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H263ModeComboFlags::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_unrestrictedVector.Encode(strm);
  m_arithmeticCoding.Encode(strm);
  m_advancedPrediction.Encode(strm);
  m_pbFrames.Encode(strm);
  m_advancedIntraCodingMode.Encode(strm);
  m_deblockingFilterMode.Encode(strm);
  m_unlimitedMotionVectors.Encode(strm);
  m_slicesInOrder_NonRect.Encode(strm);
  m_slicesInOrder_Rect.Encode(strm);
  m_slicesNoOrder_NonRect.Encode(strm);
  m_slicesNoOrder_Rect.Encode(strm);
  m_improvedPBFramesMode.Encode(strm);
  m_referencePicSelect.Encode(strm);
  m_dynamicPictureResizingByFour.Encode(strm);
  m_dynamicPictureResizingSixteenthPel.Encode(strm);
  m_dynamicWarpingHalfPel.Encode(strm);
  m_dynamicWarpingSixteenthPel.Encode(strm);
  m_reducedResolutionUpdate.Encode(strm);
  m_independentSegmentDecoding.Encode(strm);
  m_alternateInterVLCMode.Encode(strm);
  m_modifiedQuantizationMode.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_unrestrictedVector.Encode(strm);
  m_arithmeticCoding.Encode(strm);
  m_advancedPrediction.Encode(strm);
  m_pbFrames.Encode(strm);
  m_advancedIntraCodingMode.Encode(strm);
  m_deblockingFilterMode.Encode(strm);
  m_unlimitedMotionVectors.Encode(strm);
  m_slicesInOrder_NonRect.Encode(strm);
  m_slicesInOrder_Rect.Encode(strm);
  m_slicesNoOrder_NonRect.Encode(strm);
  m_slicesNoOrder_Rect.Encode(strm);
  m_improvedPBFramesMode.Encode(strm);
  m_referencePicSelect.Encode(strm);
  m_dynamicPictureResizingByFour.Encode(strm);
  m_dynamicPictureResizingSixteenthPel.Encode(strm);
  m_dynamicWarpingHalfPel.Encode(strm);
  m_dynamicWarpingSixteenthPel.Encode(strm);
  m_reducedResolutionUpdate.Encode(strm);
  m_independentSegmentDecoding.Encode(strm);
  m_alternateInterVLCMode.Encode(strm);
  m_modifiedQuantizationMode.Encode(strm);
}


PObject * H245_H263ModeComboFlags::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H263ModeComboFlags::Class()), PInvalidCast);
#endif
  return new H245_H263ModeComboFlags(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H263ModeComboFlags::preShowEthereal( void )
{
  m_unrestrictedVector.preShowEthereal( );
  m_arithmeticCoding.preShowEthereal( );
  m_advancedPrediction.preShowEthereal( );
  m_pbFrames.preShowEthereal( );
  m_advancedIntraCodingMode.preShowEthereal( );
  m_deblockingFilterMode.preShowEthereal( );
  m_unlimitedMotionVectors.preShowEthereal( );
  m_slicesInOrder_NonRect.preShowEthereal( );
  m_slicesInOrder_Rect.preShowEthereal( );
  m_slicesNoOrder_NonRect.preShowEthereal( );
  m_slicesNoOrder_Rect.preShowEthereal( );
  m_improvedPBFramesMode.preShowEthereal( );
  m_referencePicSelect.preShowEthereal( );
  m_dynamicPictureResizingByFour.preShowEthereal( );
  m_dynamicPictureResizingSixteenthPel.preShowEthereal( );
  m_dynamicWarpingHalfPel.preShowEthereal( );
  m_dynamicWarpingSixteenthPel.preShowEthereal( );
  m_reducedResolutionUpdate.preShowEthereal( );
  m_independentSegmentDecoding.preShowEthereal( );
  m_alternateInterVLCMode.preShowEthereal( );
  m_modifiedQuantizationMode.preShowEthereal( );
}

PString H245_H263ModeComboFlags::getSummary( void ) 
{
  return PString( "H263ModeComboFlags" );
}

void H245_H263ModeComboFlags::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H263ModeComboFlags_unrestrictedVector, tvb, offset + m_unrestrictedVector.GetStartByte(), m_unrestrictedVector.GetByteLength() , m_unrestrictedVector.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H263ModeComboFlags_arithmeticCoding, tvb, offset + m_arithmeticCoding.GetStartByte(), m_arithmeticCoding.GetByteLength() , m_arithmeticCoding.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H263ModeComboFlags_advancedPrediction, tvb, offset + m_advancedPrediction.GetStartByte(), m_advancedPrediction.GetByteLength() , m_advancedPrediction.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H263ModeComboFlags_pbFrames, tvb, offset + m_pbFrames.GetStartByte(), m_pbFrames.GetByteLength() , m_pbFrames.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H263ModeComboFlags_advancedIntraCodingMode, tvb, offset + m_advancedIntraCodingMode.GetStartByte(), m_advancedIntraCodingMode.GetByteLength() , m_advancedIntraCodingMode.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H263ModeComboFlags_deblockingFilterMode, tvb, offset + m_deblockingFilterMode.GetStartByte(), m_deblockingFilterMode.GetByteLength() , m_deblockingFilterMode.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H263ModeComboFlags_unlimitedMotionVectors, tvb, offset + m_unlimitedMotionVectors.GetStartByte(), m_unlimitedMotionVectors.GetByteLength() , m_unlimitedMotionVectors.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H263ModeComboFlags_slicesInOrder_NonRect, tvb, offset + m_slicesInOrder_NonRect.GetStartByte(), m_slicesInOrder_NonRect.GetByteLength() , m_slicesInOrder_NonRect.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H263ModeComboFlags_slicesInOrder_Rect, tvb, offset + m_slicesInOrder_Rect.GetStartByte(), m_slicesInOrder_Rect.GetByteLength() , m_slicesInOrder_Rect.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H263ModeComboFlags_slicesNoOrder_NonRect, tvb, offset + m_slicesNoOrder_NonRect.GetStartByte(), m_slicesNoOrder_NonRect.GetByteLength() , m_slicesNoOrder_NonRect.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H263ModeComboFlags_slicesNoOrder_Rect, tvb, offset + m_slicesNoOrder_Rect.GetStartByte(), m_slicesNoOrder_Rect.GetByteLength() , m_slicesNoOrder_Rect.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H263ModeComboFlags_improvedPBFramesMode, tvb, offset + m_improvedPBFramesMode.GetStartByte(), m_improvedPBFramesMode.GetByteLength() , m_improvedPBFramesMode.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H263ModeComboFlags_referencePicSelect, tvb, offset + m_referencePicSelect.GetStartByte(), m_referencePicSelect.GetByteLength() , m_referencePicSelect.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H263ModeComboFlags_dynamicPictureResizingByFour, tvb, offset + m_dynamicPictureResizingByFour.GetStartByte(), m_dynamicPictureResizingByFour.GetByteLength() , m_dynamicPictureResizingByFour.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H263ModeComboFlags_dynamicPictureResizingSixteenthPel, tvb, offset + m_dynamicPictureResizingSixteenthPel.GetStartByte(), m_dynamicPictureResizingSixteenthPel.GetByteLength() , m_dynamicPictureResizingSixteenthPel.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H263ModeComboFlags_dynamicWarpingHalfPel, tvb, offset + m_dynamicWarpingHalfPel.GetStartByte(), m_dynamicWarpingHalfPel.GetByteLength() , m_dynamicWarpingHalfPel.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H263ModeComboFlags_dynamicWarpingSixteenthPel, tvb, offset + m_dynamicWarpingSixteenthPel.GetStartByte(), m_dynamicWarpingSixteenthPel.GetByteLength() , m_dynamicWarpingSixteenthPel.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H263ModeComboFlags_reducedResolutionUpdate, tvb, offset + m_reducedResolutionUpdate.GetStartByte(), m_reducedResolutionUpdate.GetByteLength() , m_reducedResolutionUpdate.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H263ModeComboFlags_independentSegmentDecoding, tvb, offset + m_independentSegmentDecoding.GetStartByte(), m_independentSegmentDecoding.GetByteLength() , m_independentSegmentDecoding.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H263ModeComboFlags_alternateInterVLCMode, tvb, offset + m_alternateInterVLCMode.GetStartByte(), m_alternateInterVLCMode.GetByteLength() , m_alternateInterVLCMode.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H263ModeComboFlags_modifiedQuantizationMode, tvb, offset + m_modifiedQuantizationMode.GetStartByte(), m_modifiedQuantizationMode.GetByteLength() , m_modifiedQuantizationMode.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// IS11172VideoCapability
//

H245_IS11172VideoCapability::H245_IS11172VideoCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 6, TRUE, 0)
{
  m_videoBitRate.SetConstraints(PASN_Object::FixedConstraint, 0, 1073741823);
  m_vbvBufferSize.SetConstraints(PASN_Object::FixedConstraint, 0, 262143);
  m_samplesPerLine.SetConstraints(PASN_Object::FixedConstraint, 0, 16383);
  m_linesPerFrame.SetConstraints(PASN_Object::FixedConstraint, 0, 16383);
  m_pictureRate.SetConstraints(PASN_Object::FixedConstraint, 0, 15);
  m_luminanceSampleRate.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H245_IS11172VideoCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "constrainedBitstream = " << setprecision(indent) << m_constrainedBitstream << '\n';
  if (HasOptionalField(e_videoBitRate))
    strm << setw(indent+15) << "videoBitRate = " << setprecision(indent) << m_videoBitRate << '\n';
  if (HasOptionalField(e_vbvBufferSize))
    strm << setw(indent+16) << "vbvBufferSize = " << setprecision(indent) << m_vbvBufferSize << '\n';
  if (HasOptionalField(e_samplesPerLine))
    strm << setw(indent+17) << "samplesPerLine = " << setprecision(indent) << m_samplesPerLine << '\n';
  if (HasOptionalField(e_linesPerFrame))
    strm << setw(indent+16) << "linesPerFrame = " << setprecision(indent) << m_linesPerFrame << '\n';
  if (HasOptionalField(e_pictureRate))
    strm << setw(indent+14) << "pictureRate = " << setprecision(indent) << m_pictureRate << '\n';
  if (HasOptionalField(e_luminanceSampleRate))
    strm << setw(indent+22) << "luminanceSampleRate = " << setprecision(indent) << m_luminanceSampleRate << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_IS11172VideoCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_IS11172VideoCapability::Class()), PInvalidCast);
#endif
  const H245_IS11172VideoCapability & other = (const H245_IS11172VideoCapability &)obj;

  Comparison result;

  if ((result = m_constrainedBitstream.Compare(other.m_constrainedBitstream)) != EqualTo)
    return result;
  if ((result = m_videoBitRate.Compare(other.m_videoBitRate)) != EqualTo)
    return result;
  if ((result = m_vbvBufferSize.Compare(other.m_vbvBufferSize)) != EqualTo)
    return result;
  if ((result = m_samplesPerLine.Compare(other.m_samplesPerLine)) != EqualTo)
    return result;
  if ((result = m_linesPerFrame.Compare(other.m_linesPerFrame)) != EqualTo)
    return result;
  if ((result = m_pictureRate.Compare(other.m_pictureRate)) != EqualTo)
    return result;
  if ((result = m_luminanceSampleRate.Compare(other.m_luminanceSampleRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_IS11172VideoCapability::GetDataLength() const
{
  return m_constrainedBitstream.GetObjectLength() +
         m_videoBitRate.GetObjectLength() +
         m_vbvBufferSize.GetObjectLength() +
         m_samplesPerLine.GetObjectLength() +
         m_linesPerFrame.GetObjectLength() +
         m_pictureRate.GetObjectLength() +
         m_luminanceSampleRate.GetObjectLength();
}


BOOL H245_IS11172VideoCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_constrainedBitstream.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_videoBitRate ) && !m_videoBitRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_vbvBufferSize ) && !m_vbvBufferSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_samplesPerLine ) && !m_samplesPerLine.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_linesPerFrame ) && !m_linesPerFrame.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_pictureRate ) && !m_pictureRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_luminanceSampleRate ) && !m_luminanceSampleRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_IS11172VideoCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_constrainedBitstream.Encode(strm);
  if (HasOptionalField(e_videoBitRate))
    m_videoBitRate.Encode(strm);
  if (HasOptionalField(e_vbvBufferSize))
    m_vbvBufferSize.Encode(strm);
  if (HasOptionalField(e_samplesPerLine))
    m_samplesPerLine.Encode(strm);
  if (HasOptionalField(e_linesPerFrame))
    m_linesPerFrame.Encode(strm);
  if (HasOptionalField(e_pictureRate))
    m_pictureRate.Encode(strm);
  if (HasOptionalField(e_luminanceSampleRate))
    m_luminanceSampleRate.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_constrainedBitstream.Encode(strm);
  if (HasOptionalField(e_videoBitRate))
    m_videoBitRate.Encode(strm);
  if (HasOptionalField(e_vbvBufferSize))
    m_vbvBufferSize.Encode(strm);
  if (HasOptionalField(e_samplesPerLine))
    m_samplesPerLine.Encode(strm);
  if (HasOptionalField(e_linesPerFrame))
    m_linesPerFrame.Encode(strm);
  if (HasOptionalField(e_pictureRate))
    m_pictureRate.Encode(strm);
  if (HasOptionalField(e_luminanceSampleRate))
    m_luminanceSampleRate.Encode(strm);
}


PObject * H245_IS11172VideoCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS11172VideoCapability::Class()), PInvalidCast);
#endif
  return new H245_IS11172VideoCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_IS11172VideoCapability::preShowEthereal( void )
{
  m_constrainedBitstream.preShowEthereal( );
  if ( HasOptionalField( e_videoBitRate ) ) 
      m_videoBitRate.preShowEthereal( );
  if ( HasOptionalField( e_vbvBufferSize ) ) 
      m_vbvBufferSize.preShowEthereal( );
  if ( HasOptionalField( e_samplesPerLine ) ) 
      m_samplesPerLine.preShowEthereal( );
  if ( HasOptionalField( e_linesPerFrame ) ) 
      m_linesPerFrame.preShowEthereal( );
  if ( HasOptionalField( e_pictureRate ) ) 
      m_pictureRate.preShowEthereal( );
  if ( HasOptionalField( e_luminanceSampleRate ) ) 
      m_luminanceSampleRate.preShowEthereal( );
}

PString H245_IS11172VideoCapability::getSummary( void ) 
{
  return PString( "IS11172VideoCapability" );
}

void H245_IS11172VideoCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS11172VideoCapability_constrainedBitstream, tvb, offset + m_constrainedBitstream.GetStartByte(), m_constrainedBitstream.GetByteLength() , m_constrainedBitstream.GetValue() );

  if ( HasOptionalField( e_videoBitRate ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_IS11172VideoCapability_videoBitRate, tvb, offset + m_videoBitRate.GetStartByte(), m_videoBitRate.GetByteLength() , m_videoBitRate.GetValue() );
  }

  if ( HasOptionalField( e_vbvBufferSize ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_IS11172VideoCapability_vbvBufferSize, tvb, offset + m_vbvBufferSize.GetStartByte(), m_vbvBufferSize.GetByteLength() , m_vbvBufferSize.GetValue() );
  }

  if ( HasOptionalField( e_samplesPerLine ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_IS11172VideoCapability_samplesPerLine, tvb, offset + m_samplesPerLine.GetStartByte(), m_samplesPerLine.GetByteLength() , m_samplesPerLine.GetValue() );
  }

  if ( HasOptionalField( e_linesPerFrame ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_IS11172VideoCapability_linesPerFrame, tvb, offset + m_linesPerFrame.GetStartByte(), m_linesPerFrame.GetByteLength() , m_linesPerFrame.GetValue() );
  }

  if ( HasOptionalField( e_pictureRate ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_IS11172VideoCapability_pictureRate, tvb, offset + m_pictureRate.GetStartByte(), m_pictureRate.GetByteLength() , m_pictureRate.GetValue() );
  }

  if ( HasOptionalField( e_luminanceSampleRate ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_IS11172VideoCapability_luminanceSampleRate, tvb, offset + m_luminanceSampleRate.GetStartByte(), m_luminanceSampleRate.GetByteLength() , m_luminanceSampleRate.GetValue() );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// AudioCapability
//

H245_AudioCapability::H245_AudioCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 14, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "g711Alaw64k "
        "g711Alaw56k "
        "g711Ulaw64k "
        "g711Ulaw56k "
        "g722_64k "
        "g722_56k "
        "g722_48k "
        "g7231 "
        "g728 "
        "g729 "
        "g729AnnexA "
        "is11172AudioCapability "
        "is13818AudioCapability "
        "g729wAnnexB "
        "g729AnnexAwAnnexB "
        "g7231AnnexCCapability "
        "gsmFullRate "
        "gsmHalfRate "
        "gsmEnhancedFullRate "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioCapability::operator H245_NonStandardParameter &() const
#else
H245_AudioCapability::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_AudioCapability::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioCapability::operator H245_AudioCapability_g7231 &() const
#else
H245_AudioCapability::operator H245_AudioCapability_g7231 &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_AudioCapability_g7231::Class()), PInvalidCast);
#endif
  return *(H245_AudioCapability_g7231 *)choice;
}


H245_AudioCapability::operator const H245_AudioCapability_g7231 &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_AudioCapability_g7231::Class()), PInvalidCast);
#endif
  return *(H245_AudioCapability_g7231 *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioCapability::operator H245_IS11172AudioCapability &() const
#else
H245_AudioCapability::operator H245_IS11172AudioCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_IS11172AudioCapability::Class()), PInvalidCast);
#endif
  return *(H245_IS11172AudioCapability *)choice;
}


H245_AudioCapability::operator const H245_IS11172AudioCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_IS11172AudioCapability::Class()), PInvalidCast);
#endif
  return *(H245_IS11172AudioCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioCapability::operator H245_IS13818AudioCapability &() const
#else
H245_AudioCapability::operator H245_IS13818AudioCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_IS13818AudioCapability::Class()), PInvalidCast);
#endif
  return *(H245_IS13818AudioCapability *)choice;
}


H245_AudioCapability::operator const H245_IS13818AudioCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_IS13818AudioCapability::Class()), PInvalidCast);
#endif
  return *(H245_IS13818AudioCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioCapability::operator H245_G7231AnnexCCapability &() const
#else
H245_AudioCapability::operator H245_G7231AnnexCCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_G7231AnnexCCapability::Class()), PInvalidCast);
#endif
  return *(H245_G7231AnnexCCapability *)choice;
}


H245_AudioCapability::operator const H245_G7231AnnexCCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_G7231AnnexCCapability::Class()), PInvalidCast);
#endif
  return *(H245_G7231AnnexCCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioCapability::operator H245_GSMAudioCapability &() const
#else
H245_AudioCapability::operator H245_GSMAudioCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_GSMAudioCapability::Class()), PInvalidCast);
#endif
  return *(H245_GSMAudioCapability *)choice;
}


H245_AudioCapability::operator const H245_GSMAudioCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_GSMAudioCapability::Class()), PInvalidCast);
#endif
  return *(H245_GSMAudioCapability *)choice;
}


BOOL H245_AudioCapability::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_g711Alaw64k :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g711Alaw56k :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g711Ulaw64k :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g711Ulaw56k :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g722_64k :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g722_56k :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g722_48k :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g7231 :
      choice = new H245_AudioCapability_g7231();
      return TRUE;
    case e_g728 :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g729 :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g729AnnexA :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_is11172AudioCapability :
      choice = new H245_IS11172AudioCapability();
      return TRUE;
    case e_is13818AudioCapability :
      choice = new H245_IS13818AudioCapability();
      return TRUE;
    case e_g729wAnnexB :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g729AnnexAwAnnexB :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g7231AnnexCCapability :
      choice = new H245_G7231AnnexCCapability();
      return TRUE;
    case e_gsmFullRate :
    case e_gsmHalfRate :
    case e_gsmEnhancedFullRate :
      choice = new H245_GSMAudioCapability();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_AudioCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_AudioCapability::Class()), PInvalidCast);
#endif
  return new H245_AudioCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_AudioCapability::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_g711Alaw64k :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_g711Alaw56k :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_g711Ulaw64k :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_g711Ulaw56k :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_g722_64k :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_g722_56k :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_g722_48k :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_g7231 :
        ( ( H245_AudioCapability_g7231 * ) choice )->preShowEthereal();
        break;
      case e_g728 :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_g729 :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_g729AnnexA :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_is11172AudioCapability :
        ( ( H245_IS11172AudioCapability * ) choice )->preShowEthereal();
        break;
      case e_is13818AudioCapability :
        ( ( H245_IS13818AudioCapability * ) choice )->preShowEthereal();
        break;
      case e_g729wAnnexB :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_g729AnnexAwAnnexB :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_g7231AnnexCCapability :
        ( ( H245_G7231AnnexCCapability * ) choice )->preShowEthereal();
        break;
      case e_gsmFullRate :
        ( ( H245_GSMAudioCapability * ) choice )->preShowEthereal();
        break;
      case e_gsmHalfRate :
        ( ( H245_GSMAudioCapability * ) choice )->preShowEthereal();
        break;
      case e_gsmEnhancedFullRate :
        ( ( H245_GSMAudioCapability * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_AudioCapability::getSummary( void ) 
{
  return PString( "AudioCapability" );
}

void H245_AudioCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "g711Alaw64k" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_AudioCapability_g711Alaw64k, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "g711Alaw56k" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_AudioCapability_g711Alaw56k, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "g711Ulaw64k" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_AudioCapability_g711Ulaw64k, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "g711Ulaw56k" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_AudioCapability_g711Ulaw56k, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "g722_64k" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_AudioCapability_g722_64k, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "g722_56k" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_AudioCapability_g722_56k, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "g722_48k" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_AudioCapability_g722_48k, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "g728" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_AudioCapability_g728, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "g729" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_AudioCapability_g729, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "g729AnnexA" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_AudioCapability_g729AnnexA, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "g729wAnnexB" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_AudioCapability_g729wAnnexB, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "g729AnnexAwAnnexB" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_AudioCapability_g729AnnexAwAnnexB, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_AudioCapability_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// IS11172AudioCapability
//

H245_IS11172AudioCapability::H245_IS11172AudioCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_bitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 448);
}


#ifndef PASN_NOPRINTON
void H245_IS11172AudioCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "audioLayer1 = " << setprecision(indent) << m_audioLayer1 << '\n';
  strm << setw(indent+14) << "audioLayer2 = " << setprecision(indent) << m_audioLayer2 << '\n';
  strm << setw(indent+14) << "audioLayer3 = " << setprecision(indent) << m_audioLayer3 << '\n';
  strm << setw(indent+19) << "audioSampling32k = " << setprecision(indent) << m_audioSampling32k << '\n';
  strm << setw(indent+20) << "audioSampling44k1 = " << setprecision(indent) << m_audioSampling44k1 << '\n';
  strm << setw(indent+19) << "audioSampling48k = " << setprecision(indent) << m_audioSampling48k << '\n';
  strm << setw(indent+16) << "singleChannel = " << setprecision(indent) << m_singleChannel << '\n';
  strm << setw(indent+14) << "twoChannels = " << setprecision(indent) << m_twoChannels << '\n';
  strm << setw(indent+10) << "bitRate = " << setprecision(indent) << m_bitRate << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_IS11172AudioCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_IS11172AudioCapability::Class()), PInvalidCast);
#endif
  const H245_IS11172AudioCapability & other = (const H245_IS11172AudioCapability &)obj;

  Comparison result;

  if ((result = m_audioLayer1.Compare(other.m_audioLayer1)) != EqualTo)
    return result;
  if ((result = m_audioLayer2.Compare(other.m_audioLayer2)) != EqualTo)
    return result;
  if ((result = m_audioLayer3.Compare(other.m_audioLayer3)) != EqualTo)
    return result;
  if ((result = m_audioSampling32k.Compare(other.m_audioSampling32k)) != EqualTo)
    return result;
  if ((result = m_audioSampling44k1.Compare(other.m_audioSampling44k1)) != EqualTo)
    return result;
  if ((result = m_audioSampling48k.Compare(other.m_audioSampling48k)) != EqualTo)
    return result;
  if ((result = m_singleChannel.Compare(other.m_singleChannel)) != EqualTo)
    return result;
  if ((result = m_twoChannels.Compare(other.m_twoChannels)) != EqualTo)
    return result;
  if ((result = m_bitRate.Compare(other.m_bitRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_IS11172AudioCapability::GetDataLength() const
{
  return m_audioLayer1.GetObjectLength() +
         m_audioLayer2.GetObjectLength() +
         m_audioLayer3.GetObjectLength() +
         m_audioSampling32k.GetObjectLength() +
         m_audioSampling44k1.GetObjectLength() +
         m_audioSampling48k.GetObjectLength() +
         m_singleChannel.GetObjectLength() +
         m_twoChannels.GetObjectLength() +
         m_bitRate.GetObjectLength();
}


BOOL H245_IS11172AudioCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioLayer1.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioLayer2.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioLayer3.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioSampling32k.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioSampling44k1.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioSampling48k.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_singleChannel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_twoChannels.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bitRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_IS11172AudioCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_audioLayer1.Encode(strm);
  m_audioLayer2.Encode(strm);
  m_audioLayer3.Encode(strm);
  m_audioSampling32k.Encode(strm);
  m_audioSampling44k1.Encode(strm);
  m_audioSampling48k.Encode(strm);
  m_singleChannel.Encode(strm);
  m_twoChannels.Encode(strm);
  m_bitRate.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_audioLayer1.Encode(strm);
  m_audioLayer2.Encode(strm);
  m_audioLayer3.Encode(strm);
  m_audioSampling32k.Encode(strm);
  m_audioSampling44k1.Encode(strm);
  m_audioSampling48k.Encode(strm);
  m_singleChannel.Encode(strm);
  m_twoChannels.Encode(strm);
  m_bitRate.Encode(strm);
}


PObject * H245_IS11172AudioCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS11172AudioCapability::Class()), PInvalidCast);
#endif
  return new H245_IS11172AudioCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_IS11172AudioCapability::preShowEthereal( void )
{
  m_audioLayer1.preShowEthereal( );
  m_audioLayer2.preShowEthereal( );
  m_audioLayer3.preShowEthereal( );
  m_audioSampling32k.preShowEthereal( );
  m_audioSampling44k1.preShowEthereal( );
  m_audioSampling48k.preShowEthereal( );
  m_singleChannel.preShowEthereal( );
  m_twoChannels.preShowEthereal( );
  m_bitRate.preShowEthereal( );
}

PString H245_IS11172AudioCapability::getSummary( void ) 
{
  return PString( "IS11172AudioCapability" );
}

void H245_IS11172AudioCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS11172AudioCapability_audioLayer1, tvb, offset + m_audioLayer1.GetStartByte(), m_audioLayer1.GetByteLength() , m_audioLayer1.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS11172AudioCapability_audioLayer2, tvb, offset + m_audioLayer2.GetStartByte(), m_audioLayer2.GetByteLength() , m_audioLayer2.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS11172AudioCapability_audioLayer3, tvb, offset + m_audioLayer3.GetStartByte(), m_audioLayer3.GetByteLength() , m_audioLayer3.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS11172AudioCapability_audioSampling32k, tvb, offset + m_audioSampling32k.GetStartByte(), m_audioSampling32k.GetByteLength() , m_audioSampling32k.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS11172AudioCapability_audioSampling44k1, tvb, offset + m_audioSampling44k1.GetStartByte(), m_audioSampling44k1.GetByteLength() , m_audioSampling44k1.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS11172AudioCapability_audioSampling48k, tvb, offset + m_audioSampling48k.GetStartByte(), m_audioSampling48k.GetByteLength() , m_audioSampling48k.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS11172AudioCapability_singleChannel, tvb, offset + m_singleChannel.GetStartByte(), m_singleChannel.GetByteLength() , m_singleChannel.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS11172AudioCapability_twoChannels, tvb, offset + m_twoChannels.GetStartByte(), m_twoChannels.GetByteLength() , m_twoChannels.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_IS11172AudioCapability_bitRate, tvb, offset + m_bitRate.GetStartByte(), m_bitRate.GetByteLength() , m_bitRate.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// IS13818AudioCapability
//

H245_IS13818AudioCapability::H245_IS13818AudioCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_bitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 1130);
}


#ifndef PASN_NOPRINTON
void H245_IS13818AudioCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "audioLayer1 = " << setprecision(indent) << m_audioLayer1 << '\n';
  strm << setw(indent+14) << "audioLayer2 = " << setprecision(indent) << m_audioLayer2 << '\n';
  strm << setw(indent+14) << "audioLayer3 = " << setprecision(indent) << m_audioLayer3 << '\n';
  strm << setw(indent+19) << "audioSampling16k = " << setprecision(indent) << m_audioSampling16k << '\n';
  strm << setw(indent+21) << "audioSampling22k05 = " << setprecision(indent) << m_audioSampling22k05 << '\n';
  strm << setw(indent+19) << "audioSampling24k = " << setprecision(indent) << m_audioSampling24k << '\n';
  strm << setw(indent+19) << "audioSampling32k = " << setprecision(indent) << m_audioSampling32k << '\n';
  strm << setw(indent+20) << "audioSampling44k1 = " << setprecision(indent) << m_audioSampling44k1 << '\n';
  strm << setw(indent+19) << "audioSampling48k = " << setprecision(indent) << m_audioSampling48k << '\n';
  strm << setw(indent+16) << "singleChannel = " << setprecision(indent) << m_singleChannel << '\n';
  strm << setw(indent+14) << "twoChannels = " << setprecision(indent) << m_twoChannels << '\n';
  strm << setw(indent+19) << "threeChannels2_1 = " << setprecision(indent) << m_threeChannels2_1 << '\n';
  strm << setw(indent+19) << "threeChannels3_0 = " << setprecision(indent) << m_threeChannels3_0 << '\n';
  strm << setw(indent+22) << "fourChannels2_0_2_0 = " << setprecision(indent) << m_fourChannels2_0_2_0 << '\n';
  strm << setw(indent+18) << "fourChannels2_2 = " << setprecision(indent) << m_fourChannels2_2 << '\n';
  strm << setw(indent+18) << "fourChannels3_1 = " << setprecision(indent) << m_fourChannels3_1 << '\n';
  strm << setw(indent+22) << "fiveChannels3_0_2_0 = " << setprecision(indent) << m_fiveChannels3_0_2_0 << '\n';
  strm << setw(indent+18) << "fiveChannels3_2 = " << setprecision(indent) << m_fiveChannels3_2 << '\n';
  strm << setw(indent+26) << "lowFrequencyEnhancement = " << setprecision(indent) << m_lowFrequencyEnhancement << '\n';
  strm << setw(indent+15) << "multilingual = " << setprecision(indent) << m_multilingual << '\n';
  strm << setw(indent+10) << "bitRate = " << setprecision(indent) << m_bitRate << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_IS13818AudioCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_IS13818AudioCapability::Class()), PInvalidCast);
#endif
  const H245_IS13818AudioCapability & other = (const H245_IS13818AudioCapability &)obj;

  Comparison result;

  if ((result = m_audioLayer1.Compare(other.m_audioLayer1)) != EqualTo)
    return result;
  if ((result = m_audioLayer2.Compare(other.m_audioLayer2)) != EqualTo)
    return result;
  if ((result = m_audioLayer3.Compare(other.m_audioLayer3)) != EqualTo)
    return result;
  if ((result = m_audioSampling16k.Compare(other.m_audioSampling16k)) != EqualTo)
    return result;
  if ((result = m_audioSampling22k05.Compare(other.m_audioSampling22k05)) != EqualTo)
    return result;
  if ((result = m_audioSampling24k.Compare(other.m_audioSampling24k)) != EqualTo)
    return result;
  if ((result = m_audioSampling32k.Compare(other.m_audioSampling32k)) != EqualTo)
    return result;
  if ((result = m_audioSampling44k1.Compare(other.m_audioSampling44k1)) != EqualTo)
    return result;
  if ((result = m_audioSampling48k.Compare(other.m_audioSampling48k)) != EqualTo)
    return result;
  if ((result = m_singleChannel.Compare(other.m_singleChannel)) != EqualTo)
    return result;
  if ((result = m_twoChannels.Compare(other.m_twoChannels)) != EqualTo)
    return result;
  if ((result = m_threeChannels2_1.Compare(other.m_threeChannels2_1)) != EqualTo)
    return result;
  if ((result = m_threeChannels3_0.Compare(other.m_threeChannels3_0)) != EqualTo)
    return result;
  if ((result = m_fourChannels2_0_2_0.Compare(other.m_fourChannels2_0_2_0)) != EqualTo)
    return result;
  if ((result = m_fourChannels2_2.Compare(other.m_fourChannels2_2)) != EqualTo)
    return result;
  if ((result = m_fourChannels3_1.Compare(other.m_fourChannels3_1)) != EqualTo)
    return result;
  if ((result = m_fiveChannels3_0_2_0.Compare(other.m_fiveChannels3_0_2_0)) != EqualTo)
    return result;
  if ((result = m_fiveChannels3_2.Compare(other.m_fiveChannels3_2)) != EqualTo)
    return result;
  if ((result = m_lowFrequencyEnhancement.Compare(other.m_lowFrequencyEnhancement)) != EqualTo)
    return result;
  if ((result = m_multilingual.Compare(other.m_multilingual)) != EqualTo)
    return result;
  if ((result = m_bitRate.Compare(other.m_bitRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_IS13818AudioCapability::GetDataLength() const
{
  return m_audioLayer1.GetObjectLength() +
         m_audioLayer2.GetObjectLength() +
         m_audioLayer3.GetObjectLength() +
         m_audioSampling16k.GetObjectLength() +
         m_audioSampling22k05.GetObjectLength() +
         m_audioSampling24k.GetObjectLength() +
         m_audioSampling32k.GetObjectLength() +
         m_audioSampling44k1.GetObjectLength() +
         m_audioSampling48k.GetObjectLength() +
         m_singleChannel.GetObjectLength() +
         m_twoChannels.GetObjectLength() +
         m_threeChannels2_1.GetObjectLength() +
         m_threeChannels3_0.GetObjectLength() +
         m_fourChannels2_0_2_0.GetObjectLength() +
         m_fourChannels2_2.GetObjectLength() +
         m_fourChannels3_1.GetObjectLength() +
         m_fiveChannels3_0_2_0.GetObjectLength() +
         m_fiveChannels3_2.GetObjectLength() +
         m_lowFrequencyEnhancement.GetObjectLength() +
         m_multilingual.GetObjectLength() +
         m_bitRate.GetObjectLength();
}


BOOL H245_IS13818AudioCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioLayer1.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioLayer2.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioLayer3.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioSampling16k.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioSampling22k05.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioSampling24k.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioSampling32k.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioSampling44k1.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioSampling48k.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_singleChannel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_twoChannels.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_threeChannels2_1.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_threeChannels3_0.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_fourChannels2_0_2_0.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_fourChannels2_2.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_fourChannels3_1.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_fiveChannels3_0_2_0.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_fiveChannels3_2.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_lowFrequencyEnhancement.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_multilingual.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bitRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_IS13818AudioCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_audioLayer1.Encode(strm);
  m_audioLayer2.Encode(strm);
  m_audioLayer3.Encode(strm);
  m_audioSampling16k.Encode(strm);
  m_audioSampling22k05.Encode(strm);
  m_audioSampling24k.Encode(strm);
  m_audioSampling32k.Encode(strm);
  m_audioSampling44k1.Encode(strm);
  m_audioSampling48k.Encode(strm);
  m_singleChannel.Encode(strm);
  m_twoChannels.Encode(strm);
  m_threeChannels2_1.Encode(strm);
  m_threeChannels3_0.Encode(strm);
  m_fourChannels2_0_2_0.Encode(strm);
  m_fourChannels2_2.Encode(strm);
  m_fourChannels3_1.Encode(strm);
  m_fiveChannels3_0_2_0.Encode(strm);
  m_fiveChannels3_2.Encode(strm);
  m_lowFrequencyEnhancement.Encode(strm);
  m_multilingual.Encode(strm);
  m_bitRate.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_audioLayer1.Encode(strm);
  m_audioLayer2.Encode(strm);
  m_audioLayer3.Encode(strm);
  m_audioSampling16k.Encode(strm);
  m_audioSampling22k05.Encode(strm);
  m_audioSampling24k.Encode(strm);
  m_audioSampling32k.Encode(strm);
  m_audioSampling44k1.Encode(strm);
  m_audioSampling48k.Encode(strm);
  m_singleChannel.Encode(strm);
  m_twoChannels.Encode(strm);
  m_threeChannels2_1.Encode(strm);
  m_threeChannels3_0.Encode(strm);
  m_fourChannels2_0_2_0.Encode(strm);
  m_fourChannels2_2.Encode(strm);
  m_fourChannels3_1.Encode(strm);
  m_fiveChannels3_0_2_0.Encode(strm);
  m_fiveChannels3_2.Encode(strm);
  m_lowFrequencyEnhancement.Encode(strm);
  m_multilingual.Encode(strm);
  m_bitRate.Encode(strm);
}


PObject * H245_IS13818AudioCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS13818AudioCapability::Class()), PInvalidCast);
#endif
  return new H245_IS13818AudioCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_IS13818AudioCapability::preShowEthereal( void )
{
  m_audioLayer1.preShowEthereal( );
  m_audioLayer2.preShowEthereal( );
  m_audioLayer3.preShowEthereal( );
  m_audioSampling16k.preShowEthereal( );
  m_audioSampling22k05.preShowEthereal( );
  m_audioSampling24k.preShowEthereal( );
  m_audioSampling32k.preShowEthereal( );
  m_audioSampling44k1.preShowEthereal( );
  m_audioSampling48k.preShowEthereal( );
  m_singleChannel.preShowEthereal( );
  m_twoChannels.preShowEthereal( );
  m_threeChannels2_1.preShowEthereal( );
  m_threeChannels3_0.preShowEthereal( );
  m_fourChannels2_0_2_0.preShowEthereal( );
  m_fourChannels2_2.preShowEthereal( );
  m_fourChannels3_1.preShowEthereal( );
  m_fiveChannels3_0_2_0.preShowEthereal( );
  m_fiveChannels3_2.preShowEthereal( );
  m_lowFrequencyEnhancement.preShowEthereal( );
  m_multilingual.preShowEthereal( );
  m_bitRate.preShowEthereal( );
}

PString H245_IS13818AudioCapability::getSummary( void ) 
{
  return PString( "IS13818AudioCapability" );
}

void H245_IS13818AudioCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS13818AudioCapability_audioLayer1, tvb, offset + m_audioLayer1.GetStartByte(), m_audioLayer1.GetByteLength() , m_audioLayer1.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS13818AudioCapability_audioLayer2, tvb, offset + m_audioLayer2.GetStartByte(), m_audioLayer2.GetByteLength() , m_audioLayer2.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS13818AudioCapability_audioLayer3, tvb, offset + m_audioLayer3.GetStartByte(), m_audioLayer3.GetByteLength() , m_audioLayer3.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS13818AudioCapability_audioSampling16k, tvb, offset + m_audioSampling16k.GetStartByte(), m_audioSampling16k.GetByteLength() , m_audioSampling16k.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS13818AudioCapability_audioSampling22k05, tvb, offset + m_audioSampling22k05.GetStartByte(), m_audioSampling22k05.GetByteLength() , m_audioSampling22k05.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS13818AudioCapability_audioSampling24k, tvb, offset + m_audioSampling24k.GetStartByte(), m_audioSampling24k.GetByteLength() , m_audioSampling24k.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS13818AudioCapability_audioSampling32k, tvb, offset + m_audioSampling32k.GetStartByte(), m_audioSampling32k.GetByteLength() , m_audioSampling32k.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS13818AudioCapability_audioSampling44k1, tvb, offset + m_audioSampling44k1.GetStartByte(), m_audioSampling44k1.GetByteLength() , m_audioSampling44k1.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS13818AudioCapability_audioSampling48k, tvb, offset + m_audioSampling48k.GetStartByte(), m_audioSampling48k.GetByteLength() , m_audioSampling48k.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS13818AudioCapability_singleChannel, tvb, offset + m_singleChannel.GetStartByte(), m_singleChannel.GetByteLength() , m_singleChannel.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS13818AudioCapability_twoChannels, tvb, offset + m_twoChannels.GetStartByte(), m_twoChannels.GetByteLength() , m_twoChannels.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS13818AudioCapability_threeChannels2_1, tvb, offset + m_threeChannels2_1.GetStartByte(), m_threeChannels2_1.GetByteLength() , m_threeChannels2_1.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS13818AudioCapability_threeChannels3_0, tvb, offset + m_threeChannels3_0.GetStartByte(), m_threeChannels3_0.GetByteLength() , m_threeChannels3_0.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS13818AudioCapability_fourChannels2_0_2_0, tvb, offset + m_fourChannels2_0_2_0.GetStartByte(), m_fourChannels2_0_2_0.GetByteLength() , m_fourChannels2_0_2_0.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS13818AudioCapability_fourChannels2_2, tvb, offset + m_fourChannels2_2.GetStartByte(), m_fourChannels2_2.GetByteLength() , m_fourChannels2_2.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS13818AudioCapability_fourChannels3_1, tvb, offset + m_fourChannels3_1.GetStartByte(), m_fourChannels3_1.GetByteLength() , m_fourChannels3_1.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS13818AudioCapability_fiveChannels3_0_2_0, tvb, offset + m_fiveChannels3_0_2_0.GetStartByte(), m_fiveChannels3_0_2_0.GetByteLength() , m_fiveChannels3_0_2_0.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS13818AudioCapability_fiveChannels3_2, tvb, offset + m_fiveChannels3_2.GetStartByte(), m_fiveChannels3_2.GetByteLength() , m_fiveChannels3_2.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS13818AudioCapability_lowFrequencyEnhancement, tvb, offset + m_lowFrequencyEnhancement.GetStartByte(), m_lowFrequencyEnhancement.GetByteLength() , m_lowFrequencyEnhancement.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS13818AudioCapability_multilingual, tvb, offset + m_multilingual.GetStartByte(), m_multilingual.GetByteLength() , m_multilingual.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_IS13818AudioCapability_bitRate, tvb, offset + m_bitRate.GetStartByte(), m_bitRate.GetByteLength() , m_bitRate.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// GSMAudioCapability
//

H245_GSMAudioCapability::H245_GSMAudioCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_audioUnitSize.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_GSMAudioCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "audioUnitSize = " << setprecision(indent) << m_audioUnitSize << '\n';
  strm << setw(indent+15) << "comfortNoise = " << setprecision(indent) << m_comfortNoise << '\n';
  strm << setw(indent+12) << "scrambled = " << setprecision(indent) << m_scrambled << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_GSMAudioCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_GSMAudioCapability::Class()), PInvalidCast);
#endif
  const H245_GSMAudioCapability & other = (const H245_GSMAudioCapability &)obj;

  Comparison result;

  if ((result = m_audioUnitSize.Compare(other.m_audioUnitSize)) != EqualTo)
    return result;
  if ((result = m_comfortNoise.Compare(other.m_comfortNoise)) != EqualTo)
    return result;
  if ((result = m_scrambled.Compare(other.m_scrambled)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_GSMAudioCapability::GetDataLength() const
{
  return m_audioUnitSize.GetObjectLength() +
         m_comfortNoise.GetObjectLength() +
         m_scrambled.GetObjectLength();
}


BOOL H245_GSMAudioCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioUnitSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_comfortNoise.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_scrambled.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_GSMAudioCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_audioUnitSize.Encode(strm);
  m_comfortNoise.Encode(strm);
  m_scrambled.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_audioUnitSize.Encode(strm);
  m_comfortNoise.Encode(strm);
  m_scrambled.Encode(strm);
}


PObject * H245_GSMAudioCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_GSMAudioCapability::Class()), PInvalidCast);
#endif
  return new H245_GSMAudioCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_GSMAudioCapability::preShowEthereal( void )
{
  m_audioUnitSize.preShowEthereal( );
  m_comfortNoise.preShowEthereal( );
  m_scrambled.preShowEthereal( );
}

PString H245_GSMAudioCapability::getSummary( void ) 
{
  return PString( "GSMAudioCapability" );
}

void H245_GSMAudioCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_GSMAudioCapability_audioUnitSize, tvb, offset + m_audioUnitSize.GetStartByte(), m_audioUnitSize.GetByteLength() , m_audioUnitSize.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_GSMAudioCapability_comfortNoise, tvb, offset + m_comfortNoise.GetStartByte(), m_comfortNoise.GetByteLength() , m_comfortNoise.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_GSMAudioCapability_scrambled, tvb, offset + m_scrambled.GetStartByte(), m_scrambled.GetByteLength() , m_scrambled.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// DataProtocolCapability
//

H245_DataProtocolCapability::H245_DataProtocolCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 7, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "v14buffered "
        "v42lapm "
        "hdlcFrameTunnelling "
        "h310SeparateVCStack "
        "h310SingleVCStack "
        "transparent "
        "segmentationAndReassembly "
        "hdlcFrameTunnelingwSAR "
        "v120 "
        "separateLANStack "
        "v76wCompression "
        "tcp "
        "udp "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataProtocolCapability::operator H245_NonStandardParameter &() const
#else
H245_DataProtocolCapability::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_DataProtocolCapability::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataProtocolCapability::operator H245_DataProtocolCapability_v76wCompression &() const
#else
H245_DataProtocolCapability::operator H245_DataProtocolCapability_v76wCompression &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataProtocolCapability_v76wCompression::Class()), PInvalidCast);
#endif
  return *(H245_DataProtocolCapability_v76wCompression *)choice;
}


H245_DataProtocolCapability::operator const H245_DataProtocolCapability_v76wCompression &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataProtocolCapability_v76wCompression::Class()), PInvalidCast);
#endif
  return *(H245_DataProtocolCapability_v76wCompression *)choice;
}


BOOL H245_DataProtocolCapability::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_v14buffered :
    case e_v42lapm :
    case e_hdlcFrameTunnelling :
    case e_h310SeparateVCStack :
    case e_h310SingleVCStack :
    case e_transparent :
    case e_segmentationAndReassembly :
    case e_hdlcFrameTunnelingwSAR :
    case e_v120 :
    case e_separateLANStack :
    case e_tcp :
    case e_udp :
      choice = new PASN_Null();
      return TRUE;
    case e_v76wCompression :
      choice = new H245_DataProtocolCapability_v76wCompression();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_DataProtocolCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataProtocolCapability::Class()), PInvalidCast);
#endif
  return new H245_DataProtocolCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_DataProtocolCapability::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_v14buffered :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_v42lapm :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_hdlcFrameTunnelling :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_h310SeparateVCStack :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_h310SingleVCStack :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_transparent :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_segmentationAndReassembly :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_hdlcFrameTunnelingwSAR :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_v120 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_separateLANStack :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_v76wCompression :
        ( ( H245_DataProtocolCapability_v76wCompression * ) choice )->preShowEthereal();
        break;
      case e_tcp :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_udp :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_DataProtocolCapability::getSummary( void ) 
{
  return PString( "DataProtocolCapability" );
}

void H245_DataProtocolCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "v14buffered" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_DataProtocolCapability_v14buffered, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "v42lapm" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_DataProtocolCapability_v42lapm, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "hdlcFrameTunnelling" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_DataProtocolCapability_hdlcFrameTunnelling, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "h310SeparateVCStack" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_DataProtocolCapability_h310SeparateVCStack, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "h310SingleVCStack" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_DataProtocolCapability_h310SingleVCStack, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "transparent" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_DataProtocolCapability_transparent, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "segmentationAndReassembly" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_DataProtocolCapability_segmentationAndReassembly, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "hdlcFrameTunnelingwSAR" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_DataProtocolCapability_hdlcFrameTunnelingwSAR, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "v120" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_DataProtocolCapability_v120, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "separateLANStack" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_DataProtocolCapability_separateLANStack, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "tcp" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_DataProtocolCapability_tcp, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "udp" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_DataProtocolCapability_udp, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_DataProtocolCapability_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// CompressionType
//

H245_CompressionType::H245_CompressionType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
      , "v42bis "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CompressionType::operator H245_V42bis &() const
#else
H245_CompressionType::operator H245_V42bis &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_V42bis::Class()), PInvalidCast);
#endif
  return *(H245_V42bis *)choice;
}


H245_CompressionType::operator const H245_V42bis &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_V42bis::Class()), PInvalidCast);
#endif
  return *(H245_V42bis *)choice;
}


BOOL H245_CompressionType::CreateObject()
{
  switch (tag) {
    case e_v42bis :
      choice = new H245_V42bis();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_CompressionType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CompressionType::Class()), PInvalidCast);
#endif
  return new H245_CompressionType(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CompressionType::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_v42bis :
        ( ( H245_V42bis * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_CompressionType::getSummary( void ) 
{
  return PString( "CompressionType" );
}

void H245_CompressionType::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_CompressionType_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// V42bis
//

H245_V42bis::H245_V42bis(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_numberOfCodewords.SetConstraints(PASN_Object::FixedConstraint, 1, 65536);
  m_maximumStringLength.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_V42bis::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+20) << "numberOfCodewords = " << setprecision(indent) << m_numberOfCodewords << '\n';
  strm << setw(indent+22) << "maximumStringLength = " << setprecision(indent) << m_maximumStringLength << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_V42bis::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_V42bis::Class()), PInvalidCast);
#endif
  const H245_V42bis & other = (const H245_V42bis &)obj;

  Comparison result;

  if ((result = m_numberOfCodewords.Compare(other.m_numberOfCodewords)) != EqualTo)
    return result;
  if ((result = m_maximumStringLength.Compare(other.m_maximumStringLength)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_V42bis::GetDataLength() const
{
  return m_numberOfCodewords.GetObjectLength() +
         m_maximumStringLength.GetObjectLength();
}


BOOL H245_V42bis::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_numberOfCodewords.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maximumStringLength.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_V42bis::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_numberOfCodewords.Encode(strm);
  m_maximumStringLength.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_numberOfCodewords.Encode(strm);
  m_maximumStringLength.Encode(strm);
}


PObject * H245_V42bis::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_V42bis::Class()), PInvalidCast);
#endif
  return new H245_V42bis(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_V42bis::preShowEthereal( void )
{
  m_numberOfCodewords.preShowEthereal( );
  m_maximumStringLength.preShowEthereal( );
}

PString H245_V42bis::getSummary( void ) 
{
  return PString( "V42bis" );
}

void H245_V42bis::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_V42bis_numberOfCodewords, tvb, offset + m_numberOfCodewords.GetStartByte(), m_numberOfCodewords.GetByteLength() , m_numberOfCodewords.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_V42bis_maximumStringLength, tvb, offset + m_maximumStringLength.GetStartByte(), m_maximumStringLength.GetByteLength() , m_maximumStringLength.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// T84Profile
//

H245_T84Profile::H245_T84Profile(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
      , "t84Unrestricted "
        "t84Restricted "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_T84Profile::operator H245_T84Profile_t84Restricted &() const
#else
H245_T84Profile::operator H245_T84Profile_t84Restricted &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_T84Profile_t84Restricted::Class()), PInvalidCast);
#endif
  return *(H245_T84Profile_t84Restricted *)choice;
}


H245_T84Profile::operator const H245_T84Profile_t84Restricted &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_T84Profile_t84Restricted::Class()), PInvalidCast);
#endif
  return *(H245_T84Profile_t84Restricted *)choice;
}


BOOL H245_T84Profile::CreateObject()
{
  switch (tag) {
    case e_t84Unrestricted :
      choice = new PASN_Null();
      return TRUE;
    case e_t84Restricted :
      choice = new H245_T84Profile_t84Restricted();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_T84Profile::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_T84Profile::Class()), PInvalidCast);
#endif
  return new H245_T84Profile(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_T84Profile::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_t84Unrestricted :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_t84Restricted :
        ( ( H245_T84Profile_t84Restricted * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_T84Profile::getSummary( void ) 
{
  return PString( "T84Profile" );
}

void H245_T84Profile::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "t84Unrestricted" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_T84Profile_t84Unrestricted, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_T84Profile_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// T38FaxProfile
//

H245_T38FaxProfile::H245_T38FaxProfile(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_T38FaxProfile::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "fillBitRemoval = " << setprecision(indent) << m_fillBitRemoval << '\n';
  strm << setw(indent+18) << "transcodingJBIG = " << setprecision(indent) << m_transcodingJBIG << '\n';
  strm << setw(indent+17) << "transcodingMMR = " << setprecision(indent) << m_transcodingMMR << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_T38FaxProfile::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_T38FaxProfile::Class()), PInvalidCast);
#endif
  const H245_T38FaxProfile & other = (const H245_T38FaxProfile &)obj;

  Comparison result;

  if ((result = m_fillBitRemoval.Compare(other.m_fillBitRemoval)) != EqualTo)
    return result;
  if ((result = m_transcodingJBIG.Compare(other.m_transcodingJBIG)) != EqualTo)
    return result;
  if ((result = m_transcodingMMR.Compare(other.m_transcodingMMR)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_T38FaxProfile::GetDataLength() const
{
  return m_fillBitRemoval.GetObjectLength() +
         m_transcodingJBIG.GetObjectLength() +
         m_transcodingMMR.GetObjectLength();
}


BOOL H245_T38FaxProfile::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_fillBitRemoval.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_transcodingJBIG.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_transcodingMMR.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_T38FaxProfile::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_fillBitRemoval.Encode(strm);
  m_transcodingJBIG.Encode(strm);
  m_transcodingMMR.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_fillBitRemoval.Encode(strm);
  m_transcodingJBIG.Encode(strm);
  m_transcodingMMR.Encode(strm);
}


PObject * H245_T38FaxProfile::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_T38FaxProfile::Class()), PInvalidCast);
#endif
  return new H245_T38FaxProfile(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_T38FaxProfile::preShowEthereal( void )
{
  m_fillBitRemoval.preShowEthereal( );
  m_transcodingJBIG.preShowEthereal( );
  m_transcodingMMR.preShowEthereal( );
}

PString H245_T38FaxProfile::getSummary( void ) 
{
  return PString( "T38FaxProfile" );
}

void H245_T38FaxProfile::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_T38FaxProfile_fillBitRemoval, tvb, offset + m_fillBitRemoval.GetStartByte(), m_fillBitRemoval.GetByteLength() , m_fillBitRemoval.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_T38FaxProfile_transcodingJBIG, tvb, offset + m_transcodingJBIG.GetStartByte(), m_transcodingJBIG.GetByteLength() , m_transcodingJBIG.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_T38FaxProfile_transcodingMMR, tvb, offset + m_transcodingMMR.GetStartByte(), m_transcodingMMR.GetByteLength() , m_transcodingMMR.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// EncryptionCapability
//

H245_EncryptionCapability::H245_EncryptionCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


PASN_Object * H245_EncryptionCapability::CreateObject() const
{
  return new H245_MediaEncryptionAlgorithm;
}


H245_MediaEncryptionAlgorithm & H245_EncryptionCapability::operator[](PINDEX i) const
{
  return (H245_MediaEncryptionAlgorithm &)array[i];
}


PObject * H245_EncryptionCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EncryptionCapability::Class()), PInvalidCast);
#endif
  return new H245_EncryptionCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_EncryptionCapability::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_MediaEncryptionAlgorithm& ) array[i] ).preShowEthereal();
  }
}

PString H245_EncryptionCapability::getSummary( void ) 
{
  return PString( "EncryptionCapability" );
}

void H245_EncryptionCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *EncryptionCapability_tree = (proto_tree*) NULL;
  proto_item *EncryptionCapability_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    EncryptionCapability_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (%s)", i, (const char*) ( ( PASN_Choice* ) &( array[i] ) )->GetTagName() );
    EncryptionCapability_tree = proto_item_add_subtree( EncryptionCapability_ti, hCont->h245_0.ett_h245_EncryptionCapability );
    array[i].showEthereal( EncryptionCapability_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// MediaEncryptionAlgorithm
//

H245_MediaEncryptionAlgorithm::H245_MediaEncryptionAlgorithm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "algorithm "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MediaEncryptionAlgorithm::operator H245_NonStandardParameter &() const
#else
H245_MediaEncryptionAlgorithm::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_MediaEncryptionAlgorithm::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


BOOL H245_MediaEncryptionAlgorithm::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_algorithm :
      choice = new PASN_ObjectId();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_MediaEncryptionAlgorithm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MediaEncryptionAlgorithm::Class()), PInvalidCast);
#endif
  return new H245_MediaEncryptionAlgorithm(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MediaEncryptionAlgorithm::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_algorithm :
        ( ( PASN_ObjectId * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_MediaEncryptionAlgorithm::getSummary( void ) 
{
  return PString( "MediaEncryptionAlgorithm" );
}

void H245_MediaEncryptionAlgorithm::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "algorithm" ) == 0 ) {
      char* pstring = ( ( PASN_ObjectId* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_MediaEncryptionAlgorithm_algorithm, tvb, offset + ( ( PASN_ObjectId* ) choice) ->GetStartByte(), ( ( PASN_ObjectId* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_MediaEncryptionAlgorithm_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// UserInputCapability
//

H245_UserInputCapability::H245_UserInputCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 6, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "basicString "
        "iA5String "
        "generalString "
        "dtmf "
        "hookflash "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UserInputCapability::operator H245_ArrayOf_NonStandardParameter &() const
#else
H245_UserInputCapability::operator H245_ArrayOf_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ArrayOf_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_ArrayOf_NonStandardParameter *)choice;
}


H245_UserInputCapability::operator const H245_ArrayOf_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ArrayOf_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_ArrayOf_NonStandardParameter *)choice;
}


BOOL H245_UserInputCapability::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_ArrayOf_NonStandardParameter();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 16);
      return TRUE;
    case e_basicString :
    case e_iA5String :
    case e_generalString :
    case e_dtmf :
    case e_hookflash :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_UserInputCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UserInputCapability::Class()), PInvalidCast);
#endif
  return new H245_UserInputCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_UserInputCapability::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_ArrayOf_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_basicString :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_iA5String :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_generalString :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_dtmf :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_hookflash :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_UserInputCapability::getSummary( void ) 
{
  return PString( "UserInputCapability" );
}

void H245_UserInputCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "basicString" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_UserInputCapability_basicString, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "iA5String" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_UserInputCapability_iA5String, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "generalString" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_UserInputCapability_generalString, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "dtmf" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_UserInputCapability_dtmf, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "hookflash" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_UserInputCapability_hookflash, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_UserInputCapability_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// LogicalChannelNumber
//

H245_LogicalChannelNumber::H245_LogicalChannelNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


H245_LogicalChannelNumber & H245_LogicalChannelNumber::operator=(int v)
{
  SetValue(v);
  return *this;
}


H245_LogicalChannelNumber & H245_LogicalChannelNumber::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H245_LogicalChannelNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_LogicalChannelNumber::Class()), PInvalidCast);
#endif
  return new H245_LogicalChannelNumber(*this);
}


//
// V75Parameters
//

H245_V75Parameters::H245_V75Parameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_V75Parameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "audioHeaderPresent = " << setprecision(indent) << m_audioHeaderPresent << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_V75Parameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_V75Parameters::Class()), PInvalidCast);
#endif
  const H245_V75Parameters & other = (const H245_V75Parameters &)obj;

  Comparison result;

  if ((result = m_audioHeaderPresent.Compare(other.m_audioHeaderPresent)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_V75Parameters::GetDataLength() const
{
  return m_audioHeaderPresent.GetObjectLength();
}


BOOL H245_V75Parameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioHeaderPresent.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_V75Parameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_audioHeaderPresent.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_audioHeaderPresent.Encode(strm);
}


PObject * H245_V75Parameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_V75Parameters::Class()), PInvalidCast);
#endif
  return new H245_V75Parameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_V75Parameters::preShowEthereal( void )
{
  m_audioHeaderPresent.preShowEthereal( );
}

PString H245_V75Parameters::getSummary( void ) 
{
  return PString( "V75Parameters" );
}

void H245_V75Parameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_V75Parameters_audioHeaderPresent, tvb, offset + m_audioHeaderPresent.GetStartByte(), m_audioHeaderPresent.GetByteLength() , m_audioHeaderPresent.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// DataType
//

H245_DataType::H245_DataType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 6, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "nullData "
        "videoData "
        "audioData "
        "data "
        "encryptionData "
        "h235Control "
        "h235Media "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataType::operator H245_NonStandardParameter &() const
#else
H245_DataType::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_DataType::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataType::operator H245_VideoCapability &() const
#else
H245_DataType::operator H245_VideoCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_VideoCapability::Class()), PInvalidCast);
#endif
  return *(H245_VideoCapability *)choice;
}


H245_DataType::operator const H245_VideoCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_VideoCapability::Class()), PInvalidCast);
#endif
  return *(H245_VideoCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataType::operator H245_AudioCapability &() const
#else
H245_DataType::operator H245_AudioCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_AudioCapability::Class()), PInvalidCast);
#endif
  return *(H245_AudioCapability *)choice;
}


H245_DataType::operator const H245_AudioCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_AudioCapability::Class()), PInvalidCast);
#endif
  return *(H245_AudioCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataType::operator H245_DataApplicationCapability &() const
#else
H245_DataType::operator H245_DataApplicationCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataApplicationCapability::Class()), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability *)choice;
}


H245_DataType::operator const H245_DataApplicationCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataApplicationCapability::Class()), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataType::operator H245_EncryptionMode &() const
#else
H245_DataType::operator H245_EncryptionMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_EncryptionMode::Class()), PInvalidCast);
#endif
  return *(H245_EncryptionMode *)choice;
}


H245_DataType::operator const H245_EncryptionMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_EncryptionMode::Class()), PInvalidCast);
#endif
  return *(H245_EncryptionMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataType::operator H245_H235Media &() const
#else
H245_DataType::operator H245_H235Media &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H235Media::Class()), PInvalidCast);
#endif
  return *(H245_H235Media *)choice;
}


H245_DataType::operator const H245_H235Media &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H235Media::Class()), PInvalidCast);
#endif
  return *(H245_H235Media *)choice;
}


BOOL H245_DataType::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
    case e_h235Control :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_nullData :
      choice = new PASN_Null();
      return TRUE;
    case e_videoData :
      choice = new H245_VideoCapability();
      return TRUE;
    case e_audioData :
      choice = new H245_AudioCapability();
      return TRUE;
    case e_data :
      choice = new H245_DataApplicationCapability();
      return TRUE;
    case e_encryptionData :
      choice = new H245_EncryptionMode();
      return TRUE;
    case e_h235Media :
      choice = new H245_H235Media();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_DataType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataType::Class()), PInvalidCast);
#endif
  return new H245_DataType(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_DataType::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_nullData :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_videoData :
        ( ( H245_VideoCapability * ) choice )->preShowEthereal();
        break;
      case e_audioData :
        ( ( H245_AudioCapability * ) choice )->preShowEthereal();
        break;
      case e_data :
        ( ( H245_DataApplicationCapability * ) choice )->preShowEthereal();
        break;
      case e_encryptionData :
        ( ( H245_EncryptionMode * ) choice )->preShowEthereal();
        break;
      case e_h235Control :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_h235Media :
        ( ( H245_H235Media * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_DataType::getSummary( void ) 
{
  return PString( "DataType" );
}

void H245_DataType::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "nullData" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_DataType_nullData, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_DataType_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H222LogicalChannelParameters
//

H245_H222LogicalChannelParameters::H245_H222LogicalChannelParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
  m_resourceID.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_subChannelID.SetConstraints(PASN_Object::FixedConstraint, 0, 8191);
  m_pcr_pid.SetConstraints(PASN_Object::FixedConstraint, 0, 8191);
}


#ifndef PASN_NOPRINTON
void H245_H222LogicalChannelParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "resourceID = " << setprecision(indent) << m_resourceID << '\n';
  strm << setw(indent+15) << "subChannelID = " << setprecision(indent) << m_subChannelID << '\n';
  if (HasOptionalField(e_pcr_pid))
    strm << setw(indent+10) << "pcr_pid = " << setprecision(indent) << m_pcr_pid << '\n';
  if (HasOptionalField(e_programDescriptors))
    strm << setw(indent+21) << "programDescriptors = " << setprecision(indent) << m_programDescriptors << '\n';
  if (HasOptionalField(e_streamDescriptors))
    strm << setw(indent+20) << "streamDescriptors = " << setprecision(indent) << m_streamDescriptors << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H222LogicalChannelParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H222LogicalChannelParameters::Class()), PInvalidCast);
#endif
  const H245_H222LogicalChannelParameters & other = (const H245_H222LogicalChannelParameters &)obj;

  Comparison result;

  if ((result = m_resourceID.Compare(other.m_resourceID)) != EqualTo)
    return result;
  if ((result = m_subChannelID.Compare(other.m_subChannelID)) != EqualTo)
    return result;
  if ((result = m_pcr_pid.Compare(other.m_pcr_pid)) != EqualTo)
    return result;
  if ((result = m_programDescriptors.Compare(other.m_programDescriptors)) != EqualTo)
    return result;
  if ((result = m_streamDescriptors.Compare(other.m_streamDescriptors)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H222LogicalChannelParameters::GetDataLength() const
{
  return m_resourceID.GetObjectLength() +
         m_subChannelID.GetObjectLength() +
         m_pcr_pid.GetObjectLength() +
         m_programDescriptors.GetObjectLength() +
         m_streamDescriptors.GetObjectLength();
}


BOOL H245_H222LogicalChannelParameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_resourceID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_subChannelID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_pcr_pid ) && !m_pcr_pid.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_programDescriptors ) && !m_programDescriptors.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_streamDescriptors ) && !m_streamDescriptors.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H222LogicalChannelParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_resourceID.Encode(strm);
  m_subChannelID.Encode(strm);
  if (HasOptionalField(e_pcr_pid))
    m_pcr_pid.Encode(strm);
  if (HasOptionalField(e_programDescriptors))
    m_programDescriptors.Encode(strm);
  if (HasOptionalField(e_streamDescriptors))
    m_streamDescriptors.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_resourceID.Encode(strm);
  m_subChannelID.Encode(strm);
  if (HasOptionalField(e_pcr_pid))
    m_pcr_pid.Encode(strm);
  if (HasOptionalField(e_programDescriptors))
    m_programDescriptors.Encode(strm);
  if (HasOptionalField(e_streamDescriptors))
    m_streamDescriptors.Encode(strm);
}


PObject * H245_H222LogicalChannelParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H222LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return new H245_H222LogicalChannelParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H222LogicalChannelParameters::preShowEthereal( void )
{
  m_resourceID.preShowEthereal( );
  m_subChannelID.preShowEthereal( );
  if ( HasOptionalField( e_pcr_pid ) ) 
      m_pcr_pid.preShowEthereal( );
  if ( HasOptionalField( e_programDescriptors ) ) 
      m_programDescriptors.preShowEthereal( );
  if ( HasOptionalField( e_streamDescriptors ) ) 
      m_streamDescriptors.preShowEthereal( );
}

PString H245_H222LogicalChannelParameters::getSummary( void ) 
{
  return PString( "H222LogicalChannelParameters" );
}

void H245_H222LogicalChannelParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_H222LogicalChannelParameters_resourceID, tvb, offset + m_resourceID.GetStartByte(), m_resourceID.GetByteLength() , m_resourceID.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_H222LogicalChannelParameters_subChannelID, tvb, offset + m_subChannelID.GetStartByte(), m_subChannelID.GetByteLength() , m_subChannelID.GetValue() );

  if ( HasOptionalField( e_pcr_pid ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_H222LogicalChannelParameters_pcr_pid, tvb, offset + m_pcr_pid.GetStartByte(), m_pcr_pid.GetByteLength() , m_pcr_pid.GetValue() );
  }

  if ( HasOptionalField( e_programDescriptors ) ) {
    char* pprogramDescriptors = m_programDescriptors.getValue();
    proto_tree_add_string( tree, hCont->h245_0.hf_h245_H222LogicalChannelParameters_programDescriptors, tvb, offset + m_programDescriptors.GetStartByte(), m_programDescriptors.GetByteLength() , pprogramDescriptors );
    delete[] pprogramDescriptors;
  }

  if ( HasOptionalField( e_streamDescriptors ) ) {
    char* pstreamDescriptors = m_streamDescriptors.getValue();
    proto_tree_add_string( tree, hCont->h245_0.hf_h245_H222LogicalChannelParameters_streamDescriptors, tvb, offset + m_streamDescriptors.GetStartByte(), m_streamDescriptors.GetByteLength() , pstreamDescriptors );
    delete[] pstreamDescriptors;
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CRCLength
//

H245_CRCLength::H245_CRCLength(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "crc8bit "
        "crc16bit "
        "crc32bit "
#endif
    )
{
}


BOOL H245_CRCLength::CreateObject()
{
  switch (tag) {
    case e_crc8bit :
    case e_crc16bit :
    case e_crc32bit :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_CRCLength::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CRCLength::Class()), PInvalidCast);
#endif
  return new H245_CRCLength(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CRCLength::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_crc8bit :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_crc16bit :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_crc32bit :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_CRCLength::getSummary( void ) 
{
  return PString( "CRCLength" );
}

void H245_CRCLength::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "crc8bit" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_CRCLength_crc8bit, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "crc16bit" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_CRCLength_crc16bit, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "crc32bit" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_CRCLength_crc32bit, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// RedundancyEncoding
//

H245_RedundancyEncoding::H245_RedundancyEncoding(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RedundancyEncoding::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+27) << "redundancyEncodingMethod = " << setprecision(indent) << m_redundancyEncodingMethod << '\n';
  if (HasOptionalField(e_secondaryEncoding))
    strm << setw(indent+20) << "secondaryEncoding = " << setprecision(indent) << m_secondaryEncoding << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RedundancyEncoding::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RedundancyEncoding::Class()), PInvalidCast);
#endif
  const H245_RedundancyEncoding & other = (const H245_RedundancyEncoding &)obj;

  Comparison result;

  if ((result = m_redundancyEncodingMethod.Compare(other.m_redundancyEncodingMethod)) != EqualTo)
    return result;
  if ((result = m_secondaryEncoding.Compare(other.m_secondaryEncoding)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RedundancyEncoding::GetDataLength() const
{
  return m_redundancyEncodingMethod.GetObjectLength() +
         m_secondaryEncoding.GetObjectLength();
}


BOOL H245_RedundancyEncoding::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_redundancyEncodingMethod.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_secondaryEncoding ) && !m_secondaryEncoding.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RedundancyEncoding::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_redundancyEncodingMethod.Encode(strm);
  if (HasOptionalField(e_secondaryEncoding))
    m_secondaryEncoding.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_redundancyEncodingMethod.Encode(strm);
  if (HasOptionalField(e_secondaryEncoding))
    m_secondaryEncoding.Encode(strm);
}


PObject * H245_RedundancyEncoding::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RedundancyEncoding::Class()), PInvalidCast);
#endif
  return new H245_RedundancyEncoding(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RedundancyEncoding::preShowEthereal( void )
{
  m_redundancyEncodingMethod.preShowEthereal( );
  if ( HasOptionalField( e_secondaryEncoding ) ) 
      m_secondaryEncoding.preShowEthereal( );
}

PString H245_RedundancyEncoding::getSummary( void ) 
{
  return PString( "RedundancyEncoding" );
}

void H245_RedundancyEncoding::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *redundancyEncodingMethod_tree = (proto_tree*) NULL;
  proto_item *redundancyEncodingMethod_ti = (proto_item*) NULL;
  redundancyEncodingMethod_ti = proto_tree_add_text( tree, tvb, offset + m_redundancyEncodingMethod.GetStartByte(), m_redundancyEncodingMethod.GetByteLength(), "redundancyEncodingMethod (%s)", ( const char* ) m_redundancyEncodingMethod.GetTagName() );
  redundancyEncodingMethod_tree = proto_item_add_subtree( redundancyEncodingMethod_ti, hCont->h245_0.ett_h245_RedundancyEncoding_redundancyEncodingMethod );

  m_redundancyEncodingMethod.showEthereal( redundancyEncodingMethod_tree, tvb, offset );

  if ( HasOptionalField( e_secondaryEncoding ) ) {
    proto_tree *secondaryEncoding_tree = (proto_tree*) NULL;
    proto_item *secondaryEncoding_ti = (proto_item*) NULL;
    secondaryEncoding_ti = proto_tree_add_text( tree, tvb, offset + m_secondaryEncoding.GetStartByte(), m_secondaryEncoding.GetByteLength(), "secondaryEncoding (%s)", ( const char* ) m_secondaryEncoding.GetTagName() );
    secondaryEncoding_tree = proto_item_add_subtree( secondaryEncoding_ti, hCont->h245_0.ett_h245_RedundancyEncoding_secondaryEncoding );
    m_secondaryEncoding.showEthereal( secondaryEncoding_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// TransportAddress
//

H245_TransportAddress::H245_TransportAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "unicastAddress "
        "multicastAddress "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_TransportAddress::operator H245_UnicastAddress &() const
#else
H245_TransportAddress::operator H245_UnicastAddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_UnicastAddress::Class()), PInvalidCast);
#endif
  return *(H245_UnicastAddress *)choice;
}


H245_TransportAddress::operator const H245_UnicastAddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_UnicastAddress::Class()), PInvalidCast);
#endif
  return *(H245_UnicastAddress *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_TransportAddress::operator H245_MulticastAddress &() const
#else
H245_TransportAddress::operator H245_MulticastAddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MulticastAddress::Class()), PInvalidCast);
#endif
  return *(H245_MulticastAddress *)choice;
}


H245_TransportAddress::operator const H245_MulticastAddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MulticastAddress::Class()), PInvalidCast);
#endif
  return *(H245_MulticastAddress *)choice;
}


BOOL H245_TransportAddress::CreateObject()
{
  switch (tag) {
    case e_unicastAddress :
      choice = new H245_UnicastAddress();
      return TRUE;
    case e_multicastAddress :
      choice = new H245_MulticastAddress();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_TransportAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TransportAddress::Class()), PInvalidCast);
#endif
  return new H245_TransportAddress(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_TransportAddress::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_unicastAddress :
        ( ( H245_UnicastAddress * ) choice )->preShowEthereal();
        break;
      case e_multicastAddress :
        ( ( H245_MulticastAddress * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_TransportAddress::getSummary( void ) 
{
  return PString( "TransportAddress" );
}

void H245_TransportAddress::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_TransportAddress_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// UnicastAddress
//

H245_UnicastAddress::H245_UnicastAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
      , "iPAddress "
        "iPXAddress "
        "iP6Address "
        "netBios "
        "iPSourceRouteAddress "
        "nsap "
        "nonStandardAddress "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UnicastAddress::operator H245_UnicastAddress_iPAddress &() const
#else
H245_UnicastAddress::operator H245_UnicastAddress_iPAddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_UnicastAddress_iPAddress::Class()), PInvalidCast);
#endif
  return *(H245_UnicastAddress_iPAddress *)choice;
}


H245_UnicastAddress::operator const H245_UnicastAddress_iPAddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_UnicastAddress_iPAddress::Class()), PInvalidCast);
#endif
  return *(H245_UnicastAddress_iPAddress *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UnicastAddress::operator H245_UnicastAddress_iPXAddress &() const
#else
H245_UnicastAddress::operator H245_UnicastAddress_iPXAddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_UnicastAddress_iPXAddress::Class()), PInvalidCast);
#endif
  return *(H245_UnicastAddress_iPXAddress *)choice;
}


H245_UnicastAddress::operator const H245_UnicastAddress_iPXAddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_UnicastAddress_iPXAddress::Class()), PInvalidCast);
#endif
  return *(H245_UnicastAddress_iPXAddress *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UnicastAddress::operator H245_UnicastAddress_iP6Address &() const
#else
H245_UnicastAddress::operator H245_UnicastAddress_iP6Address &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_UnicastAddress_iP6Address::Class()), PInvalidCast);
#endif
  return *(H245_UnicastAddress_iP6Address *)choice;
}


H245_UnicastAddress::operator const H245_UnicastAddress_iP6Address &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_UnicastAddress_iP6Address::Class()), PInvalidCast);
#endif
  return *(H245_UnicastAddress_iP6Address *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UnicastAddress::operator H245_UnicastAddress_iPSourceRouteAddress &() const
#else
H245_UnicastAddress::operator H245_UnicastAddress_iPSourceRouteAddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_UnicastAddress_iPSourceRouteAddress::Class()), PInvalidCast);
#endif
  return *(H245_UnicastAddress_iPSourceRouteAddress *)choice;
}


H245_UnicastAddress::operator const H245_UnicastAddress_iPSourceRouteAddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_UnicastAddress_iPSourceRouteAddress::Class()), PInvalidCast);
#endif
  return *(H245_UnicastAddress_iPSourceRouteAddress *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UnicastAddress::operator H245_NonStandardParameter &() const
#else
H245_UnicastAddress::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_UnicastAddress::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


BOOL H245_UnicastAddress::CreateObject()
{
  switch (tag) {
    case e_iPAddress :
      choice = new H245_UnicastAddress_iPAddress();
      return TRUE;
    case e_iPXAddress :
      choice = new H245_UnicastAddress_iPXAddress();
      return TRUE;
    case e_iP6Address :
      choice = new H245_UnicastAddress_iP6Address();
      return TRUE;
    case e_netBios :
      choice = new PASN_OctetString();
      choice->SetConstraints(PASN_Object::FixedConstraint, 16, 16);
      return TRUE;
    case e_iPSourceRouteAddress :
      choice = new H245_UnicastAddress_iPSourceRouteAddress();
      return TRUE;
    case e_nsap :
      choice = new PASN_OctetString();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 20);
      return TRUE;
    case e_nonStandardAddress :
      choice = new H245_NonStandardParameter();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_UnicastAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UnicastAddress::Class()), PInvalidCast);
#endif
  return new H245_UnicastAddress(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_UnicastAddress::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_iPAddress :
        ( ( H245_UnicastAddress_iPAddress * ) choice )->preShowEthereal();
        break;
      case e_iPXAddress :
        ( ( H245_UnicastAddress_iPXAddress * ) choice )->preShowEthereal();
        break;
      case e_iP6Address :
        ( ( H245_UnicastAddress_iP6Address * ) choice )->preShowEthereal();
        break;
      case e_netBios :
        ( ( PASN_OctetString * ) choice )->preShowEthereal();
        break;
      case e_iPSourceRouteAddress :
        ( ( H245_UnicastAddress_iPSourceRouteAddress * ) choice )->preShowEthereal();
        break;
      case e_nsap :
        ( ( PASN_OctetString * ) choice )->preShowEthereal();
        break;
      case e_nonStandardAddress :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_UnicastAddress::getSummary( void ) 
{
  return PString( "UnicastAddress" );
}

void H245_UnicastAddress::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "netBios" ) == 0 ) {
      char* pstring = ( ( PASN_OctetString* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_UnicastAddress_netBios, tvb, offset + ( ( PASN_OctetString* ) choice) ->GetStartByte(), ( ( PASN_OctetString* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    if ( strcmp( GetTagName(), "nsap" ) == 0 ) {
      char* pstring = ( ( PASN_OctetString* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_UnicastAddress_nsap, tvb, offset + ( ( PASN_OctetString* ) choice) ->GetStartByte(), ( ( PASN_OctetString* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_UnicastAddress_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// MulticastAddress
//

H245_MulticastAddress::H245_MulticastAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "iPAddress "
        "iP6Address "
        "nsap "
        "nonStandardAddress "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MulticastAddress::operator H245_MulticastAddress_iPAddress &() const
#else
H245_MulticastAddress::operator H245_MulticastAddress_iPAddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MulticastAddress_iPAddress::Class()), PInvalidCast);
#endif
  return *(H245_MulticastAddress_iPAddress *)choice;
}


H245_MulticastAddress::operator const H245_MulticastAddress_iPAddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MulticastAddress_iPAddress::Class()), PInvalidCast);
#endif
  return *(H245_MulticastAddress_iPAddress *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MulticastAddress::operator H245_MulticastAddress_iP6Address &() const
#else
H245_MulticastAddress::operator H245_MulticastAddress_iP6Address &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MulticastAddress_iP6Address::Class()), PInvalidCast);
#endif
  return *(H245_MulticastAddress_iP6Address *)choice;
}


H245_MulticastAddress::operator const H245_MulticastAddress_iP6Address &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MulticastAddress_iP6Address::Class()), PInvalidCast);
#endif
  return *(H245_MulticastAddress_iP6Address *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MulticastAddress::operator H245_NonStandardParameter &() const
#else
H245_MulticastAddress::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_MulticastAddress::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


BOOL H245_MulticastAddress::CreateObject()
{
  switch (tag) {
    case e_iPAddress :
      choice = new H245_MulticastAddress_iPAddress();
      return TRUE;
    case e_iP6Address :
      choice = new H245_MulticastAddress_iP6Address();
      return TRUE;
    case e_nsap :
      choice = new PASN_OctetString();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 20);
      return TRUE;
    case e_nonStandardAddress :
      choice = new H245_NonStandardParameter();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_MulticastAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MulticastAddress::Class()), PInvalidCast);
#endif
  return new H245_MulticastAddress(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MulticastAddress::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_iPAddress :
        ( ( H245_MulticastAddress_iPAddress * ) choice )->preShowEthereal();
        break;
      case e_iP6Address :
        ( ( H245_MulticastAddress_iP6Address * ) choice )->preShowEthereal();
        break;
      case e_nsap :
        ( ( PASN_OctetString * ) choice )->preShowEthereal();
        break;
      case e_nonStandardAddress :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_MulticastAddress::getSummary( void ) 
{
  return PString( "MulticastAddress" );
}

void H245_MulticastAddress::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "nsap" ) == 0 ) {
      char* pstring = ( ( PASN_OctetString* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_MulticastAddress_nsap, tvb, offset + ( ( PASN_OctetString* ) choice) ->GetStartByte(), ( ( PASN_OctetString* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_MulticastAddress_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// EscrowData
//

H245_EscrowData::H245_EscrowData(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_escrowValue.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H245_EscrowData::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "escrowID = " << setprecision(indent) << m_escrowID << '\n';
  strm << setw(indent+14) << "escrowValue = " << setprecision(indent) << m_escrowValue << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_EscrowData::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_EscrowData::Class()), PInvalidCast);
#endif
  const H245_EscrowData & other = (const H245_EscrowData &)obj;

  Comparison result;

  if ((result = m_escrowID.Compare(other.m_escrowID)) != EqualTo)
    return result;
  if ((result = m_escrowValue.Compare(other.m_escrowValue)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_EscrowData::GetDataLength() const
{
  return m_escrowID.GetObjectLength() +
         m_escrowValue.GetObjectLength();
}


BOOL H245_EscrowData::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_escrowID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_escrowValue.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_EscrowData::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_escrowID.Encode(strm);
  m_escrowValue.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_escrowID.Encode(strm);
  m_escrowValue.Encode(strm);
}


PObject * H245_EscrowData::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EscrowData::Class()), PInvalidCast);
#endif
  return new H245_EscrowData(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_EscrowData::preShowEthereal( void )
{
  m_escrowID.preShowEthereal( );
  m_escrowValue.preShowEthereal( );
}

PString H245_EscrowData::getSummary( void ) 
{
  return PString( "EscrowData" );
}

void H245_EscrowData::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pescrowID = m_escrowID.getValue();
  proto_tree_add_string( tree, hCont->h245_0.hf_h245_EscrowData_escrowID, tvb, offset + m_escrowID.GetStartByte(), m_escrowID.GetByteLength() , pescrowID );
  delete[] pescrowID;

  char* pescrowValue = m_escrowValue.getValue();
  proto_tree_add_string( tree, hCont->h245_0.hf_h245_EscrowData_escrowValue, tvb, offset + m_escrowValue.GetStartByte(), m_escrowValue.GetByteLength() , pescrowValue );
  delete[] pescrowValue;

}
#endif  //USE_FOR_ETHEREAL

//
// OpenLogicalChannelConfirm
//

H245_OpenLogicalChannelConfirm::H245_OpenLogicalChannelConfirm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_OpenLogicalChannelConfirm::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+30) << "forwardLogicalChannelNumber = " << setprecision(indent) << m_forwardLogicalChannelNumber << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_OpenLogicalChannelConfirm::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_OpenLogicalChannelConfirm::Class()), PInvalidCast);
#endif
  const H245_OpenLogicalChannelConfirm & other = (const H245_OpenLogicalChannelConfirm &)obj;

  Comparison result;

  if ((result = m_forwardLogicalChannelNumber.Compare(other.m_forwardLogicalChannelNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_OpenLogicalChannelConfirm::GetDataLength() const
{
  return m_forwardLogicalChannelNumber.GetObjectLength();
}


BOOL H245_OpenLogicalChannelConfirm::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_forwardLogicalChannelNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_OpenLogicalChannelConfirm::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardLogicalChannelNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_forwardLogicalChannelNumber.Encode(strm);
}


PObject * H245_OpenLogicalChannelConfirm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannelConfirm::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannelConfirm(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_OpenLogicalChannelConfirm::preShowEthereal( void )
{
  m_forwardLogicalChannelNumber.preShowEthereal( );
}

PString H245_OpenLogicalChannelConfirm::getSummary( void ) 
{
  return PString( "OpenLogicalChannelConfirm" );
}

void H245_OpenLogicalChannelConfirm::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_OpenLogicalChannelConfirm_forwardLogicalChannelNumber, tvb, offset + m_forwardLogicalChannelNumber.GetStartByte(), m_forwardLogicalChannelNumber.GetByteLength() , m_forwardLogicalChannelNumber.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// CloseLogicalChannelAck
//

H245_CloseLogicalChannelAck::H245_CloseLogicalChannelAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_CloseLogicalChannelAck::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+30) << "forwardLogicalChannelNumber = " << setprecision(indent) << m_forwardLogicalChannelNumber << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_CloseLogicalChannelAck::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_CloseLogicalChannelAck::Class()), PInvalidCast);
#endif
  const H245_CloseLogicalChannelAck & other = (const H245_CloseLogicalChannelAck &)obj;

  Comparison result;

  if ((result = m_forwardLogicalChannelNumber.Compare(other.m_forwardLogicalChannelNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_CloseLogicalChannelAck::GetDataLength() const
{
  return m_forwardLogicalChannelNumber.GetObjectLength();
}


BOOL H245_CloseLogicalChannelAck::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_forwardLogicalChannelNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_CloseLogicalChannelAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardLogicalChannelNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_forwardLogicalChannelNumber.Encode(strm);
}


PObject * H245_CloseLogicalChannelAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CloseLogicalChannelAck::Class()), PInvalidCast);
#endif
  return new H245_CloseLogicalChannelAck(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CloseLogicalChannelAck::preShowEthereal( void )
{
  m_forwardLogicalChannelNumber.preShowEthereal( );
}

PString H245_CloseLogicalChannelAck::getSummary( void ) 
{
  return PString( "CloseLogicalChannelAck" );
}

void H245_CloseLogicalChannelAck::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_CloseLogicalChannelAck_forwardLogicalChannelNumber, tvb, offset + m_forwardLogicalChannelNumber.GetStartByte(), m_forwardLogicalChannelNumber.GetByteLength() , m_forwardLogicalChannelNumber.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// RequestChannelCloseAck
//

H245_RequestChannelCloseAck::H245_RequestChannelCloseAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RequestChannelCloseAck::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+30) << "forwardLogicalChannelNumber = " << setprecision(indent) << m_forwardLogicalChannelNumber << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RequestChannelCloseAck::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RequestChannelCloseAck::Class()), PInvalidCast);
#endif
  const H245_RequestChannelCloseAck & other = (const H245_RequestChannelCloseAck &)obj;

  Comparison result;

  if ((result = m_forwardLogicalChannelNumber.Compare(other.m_forwardLogicalChannelNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestChannelCloseAck::GetDataLength() const
{
  return m_forwardLogicalChannelNumber.GetObjectLength();
}


BOOL H245_RequestChannelCloseAck::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_forwardLogicalChannelNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RequestChannelCloseAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardLogicalChannelNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_forwardLogicalChannelNumber.Encode(strm);
}


PObject * H245_RequestChannelCloseAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestChannelCloseAck::Class()), PInvalidCast);
#endif
  return new H245_RequestChannelCloseAck(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RequestChannelCloseAck::preShowEthereal( void )
{
  m_forwardLogicalChannelNumber.preShowEthereal( );
}

PString H245_RequestChannelCloseAck::getSummary( void ) 
{
  return PString( "RequestChannelCloseAck" );
}

void H245_RequestChannelCloseAck::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_RequestChannelCloseAck_forwardLogicalChannelNumber, tvb, offset + m_forwardLogicalChannelNumber.GetStartByte(), m_forwardLogicalChannelNumber.GetByteLength() , m_forwardLogicalChannelNumber.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// RequestChannelCloseRelease
//

H245_RequestChannelCloseRelease::H245_RequestChannelCloseRelease(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RequestChannelCloseRelease::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+30) << "forwardLogicalChannelNumber = " << setprecision(indent) << m_forwardLogicalChannelNumber << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RequestChannelCloseRelease::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RequestChannelCloseRelease::Class()), PInvalidCast);
#endif
  const H245_RequestChannelCloseRelease & other = (const H245_RequestChannelCloseRelease &)obj;

  Comparison result;

  if ((result = m_forwardLogicalChannelNumber.Compare(other.m_forwardLogicalChannelNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestChannelCloseRelease::GetDataLength() const
{
  return m_forwardLogicalChannelNumber.GetObjectLength();
}


BOOL H245_RequestChannelCloseRelease::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_forwardLogicalChannelNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RequestChannelCloseRelease::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardLogicalChannelNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_forwardLogicalChannelNumber.Encode(strm);
}


PObject * H245_RequestChannelCloseRelease::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestChannelCloseRelease::Class()), PInvalidCast);
#endif
  return new H245_RequestChannelCloseRelease(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RequestChannelCloseRelease::preShowEthereal( void )
{
  m_forwardLogicalChannelNumber.preShowEthereal( );
}

PString H245_RequestChannelCloseRelease::getSummary( void ) 
{
  return PString( "RequestChannelCloseRelease" );
}

void H245_RequestChannelCloseRelease::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_RequestChannelCloseRelease_forwardLogicalChannelNumber, tvb, offset + m_forwardLogicalChannelNumber.GetStartByte(), m_forwardLogicalChannelNumber.GetByteLength() , m_forwardLogicalChannelNumber.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// MultiplexTableEntryNumber
//

H245_MultiplexTableEntryNumber::H245_MultiplexTableEntryNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 15);
}


H245_MultiplexTableEntryNumber & H245_MultiplexTableEntryNumber::operator=(int v)
{
  SetValue(v);
  return *this;
}


H245_MultiplexTableEntryNumber & H245_MultiplexTableEntryNumber::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H245_MultiplexTableEntryNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexTableEntryNumber::Class()), PInvalidCast);
#endif
  return new H245_MultiplexTableEntryNumber(*this);
}


//
// RequestModeRelease
//

H245_RequestModeRelease::H245_RequestModeRelease(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RequestModeRelease::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << "}";
}
#endif


PINDEX H245_RequestModeRelease::GetDataLength() const
{
  return 0;
}


BOOL H245_RequestModeRelease::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RequestModeRelease::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * H245_RequestModeRelease::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestModeRelease::Class()), PInvalidCast);
#endif
  return new H245_RequestModeRelease(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RequestModeRelease::preShowEthereal( void )
{
}

PString H245_RequestModeRelease::getSummary( void ) 
{
  return PString( "RequestModeRelease" );
}

void H245_RequestModeRelease::showEthereal( proto_tree *, tvbuff_t *, unsigned int ) const
{
}
#endif  //USE_FOR_ETHEREAL

//
// ModeDescription
//

H245_ModeDescription::H245_ModeDescription(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


PASN_Object * H245_ModeDescription::CreateObject() const
{
  return new H245_ModeElement;
}


H245_ModeElement & H245_ModeDescription::operator[](PINDEX i) const
{
  return (H245_ModeElement &)array[i];
}


PObject * H245_ModeDescription::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ModeDescription::Class()), PInvalidCast);
#endif
  return new H245_ModeDescription(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ModeDescription::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_ModeElement& ) array[i] ).preShowEthereal();
  }
}

PString H245_ModeDescription::getSummary( void ) 
{
  return PString( "ModeDescription" );
}

void H245_ModeDescription::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ModeDescription_tree = (proto_tree*) NULL;
  proto_item *ModeDescription_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ModeDescription_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (ModeElement)", i );
    ModeDescription_tree = proto_item_add_subtree( ModeDescription_ti, hCont->h245_0.ett_h245_ModeDescription );
    array[i].showEthereal( ModeDescription_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// V76ModeParameters
//

H245_V76ModeParameters::H245_V76ModeParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "suspendResumewAddress "
        "suspendResumewoAddress "
#endif
    )
{
}


BOOL H245_V76ModeParameters::CreateObject()
{
  switch (tag) {
    case e_suspendResumewAddress :
    case e_suspendResumewoAddress :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_V76ModeParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_V76ModeParameters::Class()), PInvalidCast);
#endif
  return new H245_V76ModeParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_V76ModeParameters::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_suspendResumewAddress :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_suspendResumewoAddress :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_V76ModeParameters::getSummary( void ) 
{
  return PString( "V76ModeParameters" );
}

void H245_V76ModeParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "suspendResumewAddress" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_V76ModeParameters_suspendResumewAddress, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "suspendResumewoAddress" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_V76ModeParameters_suspendResumewoAddress, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// VideoMode
//

H245_VideoMode::H245_VideoMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "h261VideoMode "
        "h262VideoMode "
        "h263VideoMode "
        "is11172VideoMode "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VideoMode::operator H245_NonStandardParameter &() const
#else
H245_VideoMode::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_VideoMode::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VideoMode::operator H245_H261VideoMode &() const
#else
H245_VideoMode::operator H245_H261VideoMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H261VideoMode::Class()), PInvalidCast);
#endif
  return *(H245_H261VideoMode *)choice;
}


H245_VideoMode::operator const H245_H261VideoMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H261VideoMode::Class()), PInvalidCast);
#endif
  return *(H245_H261VideoMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VideoMode::operator H245_H262VideoMode &() const
#else
H245_VideoMode::operator H245_H262VideoMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H262VideoMode::Class()), PInvalidCast);
#endif
  return *(H245_H262VideoMode *)choice;
}


H245_VideoMode::operator const H245_H262VideoMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H262VideoMode::Class()), PInvalidCast);
#endif
  return *(H245_H262VideoMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VideoMode::operator H245_H263VideoMode &() const
#else
H245_VideoMode::operator H245_H263VideoMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H263VideoMode::Class()), PInvalidCast);
#endif
  return *(H245_H263VideoMode *)choice;
}


H245_VideoMode::operator const H245_H263VideoMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H263VideoMode::Class()), PInvalidCast);
#endif
  return *(H245_H263VideoMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VideoMode::operator H245_IS11172VideoMode &() const
#else
H245_VideoMode::operator H245_IS11172VideoMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_IS11172VideoMode::Class()), PInvalidCast);
#endif
  return *(H245_IS11172VideoMode *)choice;
}


H245_VideoMode::operator const H245_IS11172VideoMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_IS11172VideoMode::Class()), PInvalidCast);
#endif
  return *(H245_IS11172VideoMode *)choice;
}


BOOL H245_VideoMode::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_h261VideoMode :
      choice = new H245_H261VideoMode();
      return TRUE;
    case e_h262VideoMode :
      choice = new H245_H262VideoMode();
      return TRUE;
    case e_h263VideoMode :
      choice = new H245_H263VideoMode();
      return TRUE;
    case e_is11172VideoMode :
      choice = new H245_IS11172VideoMode();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_VideoMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_VideoMode::Class()), PInvalidCast);
#endif
  return new H245_VideoMode(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_VideoMode::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_h261VideoMode :
        ( ( H245_H261VideoMode * ) choice )->preShowEthereal();
        break;
      case e_h262VideoMode :
        ( ( H245_H262VideoMode * ) choice )->preShowEthereal();
        break;
      case e_h263VideoMode :
        ( ( H245_H263VideoMode * ) choice )->preShowEthereal();
        break;
      case e_is11172VideoMode :
        ( ( H245_IS11172VideoMode * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_VideoMode::getSummary( void ) 
{
  return PString( "VideoMode" );
}

void H245_VideoMode::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_VideoMode_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// IS11172VideoMode
//

H245_IS11172VideoMode::H245_IS11172VideoMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 6, TRUE, 0)
{
  m_videoBitRate.SetConstraints(PASN_Object::FixedConstraint, 0, 1073741823);
  m_vbvBufferSize.SetConstraints(PASN_Object::FixedConstraint, 0, 262143);
  m_samplesPerLine.SetConstraints(PASN_Object::FixedConstraint, 0, 16383);
  m_linesPerFrame.SetConstraints(PASN_Object::FixedConstraint, 0, 16383);
  m_pictureRate.SetConstraints(PASN_Object::FixedConstraint, 0, 15);
  m_luminanceSampleRate.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H245_IS11172VideoMode::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "constrainedBitstream = " << setprecision(indent) << m_constrainedBitstream << '\n';
  if (HasOptionalField(e_videoBitRate))
    strm << setw(indent+15) << "videoBitRate = " << setprecision(indent) << m_videoBitRate << '\n';
  if (HasOptionalField(e_vbvBufferSize))
    strm << setw(indent+16) << "vbvBufferSize = " << setprecision(indent) << m_vbvBufferSize << '\n';
  if (HasOptionalField(e_samplesPerLine))
    strm << setw(indent+17) << "samplesPerLine = " << setprecision(indent) << m_samplesPerLine << '\n';
  if (HasOptionalField(e_linesPerFrame))
    strm << setw(indent+16) << "linesPerFrame = " << setprecision(indent) << m_linesPerFrame << '\n';
  if (HasOptionalField(e_pictureRate))
    strm << setw(indent+14) << "pictureRate = " << setprecision(indent) << m_pictureRate << '\n';
  if (HasOptionalField(e_luminanceSampleRate))
    strm << setw(indent+22) << "luminanceSampleRate = " << setprecision(indent) << m_luminanceSampleRate << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_IS11172VideoMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_IS11172VideoMode::Class()), PInvalidCast);
#endif
  const H245_IS11172VideoMode & other = (const H245_IS11172VideoMode &)obj;

  Comparison result;

  if ((result = m_constrainedBitstream.Compare(other.m_constrainedBitstream)) != EqualTo)
    return result;
  if ((result = m_videoBitRate.Compare(other.m_videoBitRate)) != EqualTo)
    return result;
  if ((result = m_vbvBufferSize.Compare(other.m_vbvBufferSize)) != EqualTo)
    return result;
  if ((result = m_samplesPerLine.Compare(other.m_samplesPerLine)) != EqualTo)
    return result;
  if ((result = m_linesPerFrame.Compare(other.m_linesPerFrame)) != EqualTo)
    return result;
  if ((result = m_pictureRate.Compare(other.m_pictureRate)) != EqualTo)
    return result;
  if ((result = m_luminanceSampleRate.Compare(other.m_luminanceSampleRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_IS11172VideoMode::GetDataLength() const
{
  return m_constrainedBitstream.GetObjectLength() +
         m_videoBitRate.GetObjectLength() +
         m_vbvBufferSize.GetObjectLength() +
         m_samplesPerLine.GetObjectLength() +
         m_linesPerFrame.GetObjectLength() +
         m_pictureRate.GetObjectLength() +
         m_luminanceSampleRate.GetObjectLength();
}


BOOL H245_IS11172VideoMode::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_constrainedBitstream.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_videoBitRate ) && !m_videoBitRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_vbvBufferSize ) && !m_vbvBufferSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_samplesPerLine ) && !m_samplesPerLine.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_linesPerFrame ) && !m_linesPerFrame.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_pictureRate ) && !m_pictureRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_luminanceSampleRate ) && !m_luminanceSampleRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_IS11172VideoMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_constrainedBitstream.Encode(strm);
  if (HasOptionalField(e_videoBitRate))
    m_videoBitRate.Encode(strm);
  if (HasOptionalField(e_vbvBufferSize))
    m_vbvBufferSize.Encode(strm);
  if (HasOptionalField(e_samplesPerLine))
    m_samplesPerLine.Encode(strm);
  if (HasOptionalField(e_linesPerFrame))
    m_linesPerFrame.Encode(strm);
  if (HasOptionalField(e_pictureRate))
    m_pictureRate.Encode(strm);
  if (HasOptionalField(e_luminanceSampleRate))
    m_luminanceSampleRate.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_constrainedBitstream.Encode(strm);
  if (HasOptionalField(e_videoBitRate))
    m_videoBitRate.Encode(strm);
  if (HasOptionalField(e_vbvBufferSize))
    m_vbvBufferSize.Encode(strm);
  if (HasOptionalField(e_samplesPerLine))
    m_samplesPerLine.Encode(strm);
  if (HasOptionalField(e_linesPerFrame))
    m_linesPerFrame.Encode(strm);
  if (HasOptionalField(e_pictureRate))
    m_pictureRate.Encode(strm);
  if (HasOptionalField(e_luminanceSampleRate))
    m_luminanceSampleRate.Encode(strm);
}


PObject * H245_IS11172VideoMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS11172VideoMode::Class()), PInvalidCast);
#endif
  return new H245_IS11172VideoMode(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_IS11172VideoMode::preShowEthereal( void )
{
  m_constrainedBitstream.preShowEthereal( );
  if ( HasOptionalField( e_videoBitRate ) ) 
      m_videoBitRate.preShowEthereal( );
  if ( HasOptionalField( e_vbvBufferSize ) ) 
      m_vbvBufferSize.preShowEthereal( );
  if ( HasOptionalField( e_samplesPerLine ) ) 
      m_samplesPerLine.preShowEthereal( );
  if ( HasOptionalField( e_linesPerFrame ) ) 
      m_linesPerFrame.preShowEthereal( );
  if ( HasOptionalField( e_pictureRate ) ) 
      m_pictureRate.preShowEthereal( );
  if ( HasOptionalField( e_luminanceSampleRate ) ) 
      m_luminanceSampleRate.preShowEthereal( );
}

PString H245_IS11172VideoMode::getSummary( void ) 
{
  return PString( "IS11172VideoMode" );
}

void H245_IS11172VideoMode::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_IS11172VideoMode_constrainedBitstream, tvb, offset + m_constrainedBitstream.GetStartByte(), m_constrainedBitstream.GetByteLength() , m_constrainedBitstream.GetValue() );

  if ( HasOptionalField( e_videoBitRate ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_IS11172VideoMode_videoBitRate, tvb, offset + m_videoBitRate.GetStartByte(), m_videoBitRate.GetByteLength() , m_videoBitRate.GetValue() );
  }

  if ( HasOptionalField( e_vbvBufferSize ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_IS11172VideoMode_vbvBufferSize, tvb, offset + m_vbvBufferSize.GetStartByte(), m_vbvBufferSize.GetByteLength() , m_vbvBufferSize.GetValue() );
  }

  if ( HasOptionalField( e_samplesPerLine ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_IS11172VideoMode_samplesPerLine, tvb, offset + m_samplesPerLine.GetStartByte(), m_samplesPerLine.GetByteLength() , m_samplesPerLine.GetValue() );
  }

  if ( HasOptionalField( e_linesPerFrame ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_IS11172VideoMode_linesPerFrame, tvb, offset + m_linesPerFrame.GetStartByte(), m_linesPerFrame.GetByteLength() , m_linesPerFrame.GetValue() );
  }

  if ( HasOptionalField( e_pictureRate ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_IS11172VideoMode_pictureRate, tvb, offset + m_pictureRate.GetStartByte(), m_pictureRate.GetByteLength() , m_pictureRate.GetValue() );
  }

  if ( HasOptionalField( e_luminanceSampleRate ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_IS11172VideoMode_luminanceSampleRate, tvb, offset + m_luminanceSampleRate.GetStartByte(), m_luminanceSampleRate.GetByteLength() , m_luminanceSampleRate.GetValue() );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// AudioMode
//

H245_AudioMode::H245_AudioMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 14, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "g711Alaw64k "
        "g711Alaw56k "
        "g711Ulaw64k "
        "g711Ulaw56k "
        "g722_64k "
        "g722_56k "
        "g722_48k "
        "g728 "
        "g729 "
        "g729AnnexA "
        "g7231 "
        "is11172AudioMode "
        "is13818AudioMode "
        "g729wAnnexB "
        "g729AnnexAwAnnexB "
        "g7231AnnexCMode "
        "gsmFullRate "
        "gsmHalfRate "
        "gsmEnhancedFullRate "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioMode::operator H245_NonStandardParameter &() const
#else
H245_AudioMode::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_AudioMode::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioMode::operator H245_AudioMode_g7231 &() const
#else
H245_AudioMode::operator H245_AudioMode_g7231 &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_AudioMode_g7231::Class()), PInvalidCast);
#endif
  return *(H245_AudioMode_g7231 *)choice;
}


H245_AudioMode::operator const H245_AudioMode_g7231 &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_AudioMode_g7231::Class()), PInvalidCast);
#endif
  return *(H245_AudioMode_g7231 *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioMode::operator H245_IS11172AudioMode &() const
#else
H245_AudioMode::operator H245_IS11172AudioMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_IS11172AudioMode::Class()), PInvalidCast);
#endif
  return *(H245_IS11172AudioMode *)choice;
}


H245_AudioMode::operator const H245_IS11172AudioMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_IS11172AudioMode::Class()), PInvalidCast);
#endif
  return *(H245_IS11172AudioMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioMode::operator H245_IS13818AudioMode &() const
#else
H245_AudioMode::operator H245_IS13818AudioMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_IS13818AudioMode::Class()), PInvalidCast);
#endif
  return *(H245_IS13818AudioMode *)choice;
}


H245_AudioMode::operator const H245_IS13818AudioMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_IS13818AudioMode::Class()), PInvalidCast);
#endif
  return *(H245_IS13818AudioMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioMode::operator H245_G7231AnnexCMode &() const
#else
H245_AudioMode::operator H245_G7231AnnexCMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_G7231AnnexCMode::Class()), PInvalidCast);
#endif
  return *(H245_G7231AnnexCMode *)choice;
}


H245_AudioMode::operator const H245_G7231AnnexCMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_G7231AnnexCMode::Class()), PInvalidCast);
#endif
  return *(H245_G7231AnnexCMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioMode::operator H245_GSMAudioCapability &() const
#else
H245_AudioMode::operator H245_GSMAudioCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_GSMAudioCapability::Class()), PInvalidCast);
#endif
  return *(H245_GSMAudioCapability *)choice;
}


H245_AudioMode::operator const H245_GSMAudioCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_GSMAudioCapability::Class()), PInvalidCast);
#endif
  return *(H245_GSMAudioCapability *)choice;
}


BOOL H245_AudioMode::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_g711Alaw64k :
    case e_g711Alaw56k :
    case e_g711Ulaw64k :
    case e_g711Ulaw56k :
    case e_g722_64k :
    case e_g722_56k :
    case e_g722_48k :
    case e_g728 :
    case e_g729 :
    case e_g729AnnexA :
      choice = new PASN_Null();
      return TRUE;
    case e_g7231 :
      choice = new H245_AudioMode_g7231();
      return TRUE;
    case e_is11172AudioMode :
      choice = new H245_IS11172AudioMode();
      return TRUE;
    case e_is13818AudioMode :
      choice = new H245_IS13818AudioMode();
      return TRUE;
    case e_g729wAnnexB :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g729AnnexAwAnnexB :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g7231AnnexCMode :
      choice = new H245_G7231AnnexCMode();
      return TRUE;
    case e_gsmFullRate :
    case e_gsmHalfRate :
    case e_gsmEnhancedFullRate :
      choice = new H245_GSMAudioCapability();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_AudioMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_AudioMode::Class()), PInvalidCast);
#endif
  return new H245_AudioMode(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_AudioMode::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_g711Alaw64k :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_g711Alaw56k :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_g711Ulaw64k :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_g711Ulaw56k :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_g722_64k :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_g722_56k :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_g722_48k :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_g728 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_g729 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_g729AnnexA :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_g7231 :
        ( ( H245_AudioMode_g7231 * ) choice )->preShowEthereal();
        break;
      case e_is11172AudioMode :
        ( ( H245_IS11172AudioMode * ) choice )->preShowEthereal();
        break;
      case e_is13818AudioMode :
        ( ( H245_IS13818AudioMode * ) choice )->preShowEthereal();
        break;
      case e_g729wAnnexB :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_g729AnnexAwAnnexB :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_g7231AnnexCMode :
        ( ( H245_G7231AnnexCMode * ) choice )->preShowEthereal();
        break;
      case e_gsmFullRate :
        ( ( H245_GSMAudioCapability * ) choice )->preShowEthereal();
        break;
      case e_gsmHalfRate :
        ( ( H245_GSMAudioCapability * ) choice )->preShowEthereal();
        break;
      case e_gsmEnhancedFullRate :
        ( ( H245_GSMAudioCapability * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_AudioMode::getSummary( void ) 
{
  return PString( "AudioMode" );
}

void H245_AudioMode::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "g711Alaw64k" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_AudioMode_g711Alaw64k, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "g711Alaw56k" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_AudioMode_g711Alaw56k, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "g711Ulaw64k" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_AudioMode_g711Ulaw64k, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "g711Ulaw56k" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_AudioMode_g711Ulaw56k, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "g722_64k" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_AudioMode_g722_64k, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "g722_56k" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_AudioMode_g722_56k, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "g722_48k" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_AudioMode_g722_48k, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "g728" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_AudioMode_g728, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "g729" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_AudioMode_g729, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "g729AnnexA" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_AudioMode_g729AnnexA, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "g729wAnnexB" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_AudioMode_g729wAnnexB, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "g729AnnexAwAnnexB" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_AudioMode_g729AnnexAwAnnexB, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_AudioMode_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// EncryptionMode
//

H245_EncryptionMode::H245_EncryptionMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "h233Encryption "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_EncryptionMode::operator H245_NonStandardParameter &() const
#else
H245_EncryptionMode::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_EncryptionMode::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


BOOL H245_EncryptionMode::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_h233Encryption :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_EncryptionMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EncryptionMode::Class()), PInvalidCast);
#endif
  return new H245_EncryptionMode(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_EncryptionMode::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_h233Encryption :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_EncryptionMode::getSummary( void ) 
{
  return PString( "EncryptionMode" );
}

void H245_EncryptionMode::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "h233Encryption" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_EncryptionMode_h233Encryption, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_EncryptionMode_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// RoundTripDelayRequest
//

H245_RoundTripDelayRequest::H245_RoundTripDelayRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RoundTripDelayRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RoundTripDelayRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RoundTripDelayRequest::Class()), PInvalidCast);
#endif
  const H245_RoundTripDelayRequest & other = (const H245_RoundTripDelayRequest &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RoundTripDelayRequest::GetDataLength() const
{
  return m_sequenceNumber.GetObjectLength();
}


BOOL H245_RoundTripDelayRequest::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sequenceNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RoundTripDelayRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_sequenceNumber.Encode(strm);
}


PObject * H245_RoundTripDelayRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RoundTripDelayRequest::Class()), PInvalidCast);
#endif
  return new H245_RoundTripDelayRequest(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RoundTripDelayRequest::preShowEthereal( void )
{
  m_sequenceNumber.preShowEthereal( );
}

PString H245_RoundTripDelayRequest::getSummary( void ) 
{
  return PString( "RoundTripDelayRequest" );
}

void H245_RoundTripDelayRequest::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_RoundTripDelayRequest_sequenceNumber, tvb, offset + m_sequenceNumber.GetStartByte(), m_sequenceNumber.GetByteLength() , m_sequenceNumber.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// RoundTripDelayResponse
//

H245_RoundTripDelayResponse::H245_RoundTripDelayResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RoundTripDelayResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RoundTripDelayResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RoundTripDelayResponse::Class()), PInvalidCast);
#endif
  const H245_RoundTripDelayResponse & other = (const H245_RoundTripDelayResponse &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RoundTripDelayResponse::GetDataLength() const
{
  return m_sequenceNumber.GetObjectLength();
}


BOOL H245_RoundTripDelayResponse::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sequenceNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RoundTripDelayResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_sequenceNumber.Encode(strm);
}


PObject * H245_RoundTripDelayResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RoundTripDelayResponse::Class()), PInvalidCast);
#endif
  return new H245_RoundTripDelayResponse(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RoundTripDelayResponse::preShowEthereal( void )
{
  m_sequenceNumber.preShowEthereal( );
}

PString H245_RoundTripDelayResponse::getSummary( void ) 
{
  return PString( "RoundTripDelayResponse" );
}

void H245_RoundTripDelayResponse::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_RoundTripDelayResponse_sequenceNumber, tvb, offset + m_sequenceNumber.GetStartByte(), m_sequenceNumber.GetByteLength() , m_sequenceNumber.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// MaintenanceLoopOffCommand
//

H245_MaintenanceLoopOffCommand::H245_MaintenanceLoopOffCommand(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MaintenanceLoopOffCommand::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << "}";
}
#endif


PINDEX H245_MaintenanceLoopOffCommand::GetDataLength() const
{
  return 0;
}


BOOL H245_MaintenanceLoopOffCommand::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MaintenanceLoopOffCommand::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * H245_MaintenanceLoopOffCommand::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MaintenanceLoopOffCommand::Class()), PInvalidCast);
#endif
  return new H245_MaintenanceLoopOffCommand(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MaintenanceLoopOffCommand::preShowEthereal( void )
{
}

PString H245_MaintenanceLoopOffCommand::getSummary( void ) 
{
  return PString( "MaintenanceLoopOffCommand" );
}

void H245_MaintenanceLoopOffCommand::showEthereal( proto_tree *, tvbuff_t *, unsigned int ) const
{
}
#endif  //USE_FOR_ETHEREAL

//
// CommunicationModeRequest
//

H245_CommunicationModeRequest::H245_CommunicationModeRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_CommunicationModeRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << "}";
}
#endif


PINDEX H245_CommunicationModeRequest::GetDataLength() const
{
  return 0;
}


BOOL H245_CommunicationModeRequest::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_CommunicationModeRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * H245_CommunicationModeRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CommunicationModeRequest::Class()), PInvalidCast);
#endif
  return new H245_CommunicationModeRequest(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CommunicationModeRequest::preShowEthereal( void )
{
}

PString H245_CommunicationModeRequest::getSummary( void ) 
{
  return PString( "CommunicationModeRequest" );
}

void H245_CommunicationModeRequest::showEthereal( proto_tree *, tvbuff_t *, unsigned int ) const
{
}
#endif  //USE_FOR_ETHEREAL

//
// CommunicationModeResponse
//

H245_CommunicationModeResponse::H245_CommunicationModeResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
      , "communicationModeTable "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommunicationModeResponse::operator H245_ArrayOf_CommunicationModeTableEntry &() const
#else
H245_CommunicationModeResponse::operator H245_ArrayOf_CommunicationModeTableEntry &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ArrayOf_CommunicationModeTableEntry::Class()), PInvalidCast);
#endif
  return *(H245_ArrayOf_CommunicationModeTableEntry *)choice;
}


H245_CommunicationModeResponse::operator const H245_ArrayOf_CommunicationModeTableEntry &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ArrayOf_CommunicationModeTableEntry::Class()), PInvalidCast);
#endif
  return *(H245_ArrayOf_CommunicationModeTableEntry *)choice;
}


BOOL H245_CommunicationModeResponse::CreateObject()
{
  switch (tag) {
    case e_communicationModeTable :
      choice = new H245_ArrayOf_CommunicationModeTableEntry();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_CommunicationModeResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CommunicationModeResponse::Class()), PInvalidCast);
#endif
  return new H245_CommunicationModeResponse(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CommunicationModeResponse::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_communicationModeTable :
        ( ( H245_ArrayOf_CommunicationModeTableEntry * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_CommunicationModeResponse::getSummary( void ) 
{
  return PString( "CommunicationModeResponse" );
}

void H245_CommunicationModeResponse::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_CommunicationModeResponse_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ConferenceRequest
//

H245_ConferenceRequest::H245_ConferenceRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 8, TRUE
#ifndef PASN_NOPRINTON
      , "terminalListRequest "
        "makeMeChair "
        "cancelMakeMeChair "
        "dropTerminal "
        "requestTerminalID "
        "enterH243Password "
        "enterH243TerminalID "
        "enterH243ConferenceID "
        "enterExtensionAddress "
        "requestChairTokenOwner "
        "requestTerminalCertificate "
        "broadcastMyLogicalChannel "
        "makeTerminalBroadcaster "
        "sendThisSource "
        "requestAllTerminalIDs "
        "remoteMCRequest "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceRequest::operator H245_TerminalLabel &() const
#else
H245_ConferenceRequest::operator H245_TerminalLabel &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_TerminalLabel::Class()), PInvalidCast);
#endif
  return *(H245_TerminalLabel *)choice;
}


H245_ConferenceRequest::operator const H245_TerminalLabel &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_TerminalLabel::Class()), PInvalidCast);
#endif
  return *(H245_TerminalLabel *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceRequest::operator H245_ConferenceRequest_requestTerminalCertificate &() const
#else
H245_ConferenceRequest::operator H245_ConferenceRequest_requestTerminalCertificate &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceRequest_requestTerminalCertificate::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceRequest_requestTerminalCertificate *)choice;
}


H245_ConferenceRequest::operator const H245_ConferenceRequest_requestTerminalCertificate &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceRequest_requestTerminalCertificate::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceRequest_requestTerminalCertificate *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceRequest::operator H245_LogicalChannelNumber &() const
#else
H245_ConferenceRequest::operator H245_LogicalChannelNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_LogicalChannelNumber::Class()), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


H245_ConferenceRequest::operator const H245_LogicalChannelNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_LogicalChannelNumber::Class()), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceRequest::operator H245_RemoteMCRequest &() const
#else
H245_ConferenceRequest::operator H245_RemoteMCRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RemoteMCRequest::Class()), PInvalidCast);
#endif
  return *(H245_RemoteMCRequest *)choice;
}


H245_ConferenceRequest::operator const H245_RemoteMCRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RemoteMCRequest::Class()), PInvalidCast);
#endif
  return *(H245_RemoteMCRequest *)choice;
}


BOOL H245_ConferenceRequest::CreateObject()
{
  switch (tag) {
    case e_terminalListRequest :
    case e_makeMeChair :
    case e_cancelMakeMeChair :
    case e_enterH243Password :
    case e_enterH243TerminalID :
    case e_enterH243ConferenceID :
    case e_enterExtensionAddress :
    case e_requestChairTokenOwner :
    case e_requestAllTerminalIDs :
      choice = new PASN_Null();
      return TRUE;
    case e_dropTerminal :
    case e_requestTerminalID :
    case e_makeTerminalBroadcaster :
    case e_sendThisSource :
      choice = new H245_TerminalLabel();
      return TRUE;
    case e_requestTerminalCertificate :
      choice = new H245_ConferenceRequest_requestTerminalCertificate();
      return TRUE;
    case e_broadcastMyLogicalChannel :
      choice = new H245_LogicalChannelNumber();
      return TRUE;
    case e_remoteMCRequest :
      choice = new H245_RemoteMCRequest();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_ConferenceRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceRequest::Class()), PInvalidCast);
#endif
  return new H245_ConferenceRequest(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ConferenceRequest::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_terminalListRequest :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_makeMeChair :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_cancelMakeMeChair :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_dropTerminal :
        ( ( H245_TerminalLabel * ) choice )->preShowEthereal();
        break;
      case e_requestTerminalID :
        ( ( H245_TerminalLabel * ) choice )->preShowEthereal();
        break;
      case e_enterH243Password :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_enterH243TerminalID :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_enterH243ConferenceID :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_enterExtensionAddress :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_requestChairTokenOwner :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_requestTerminalCertificate :
        ( ( H245_ConferenceRequest_requestTerminalCertificate * ) choice )->preShowEthereal();
        break;
      case e_broadcastMyLogicalChannel :
        ( ( H245_LogicalChannelNumber * ) choice )->preShowEthereal();
        break;
      case e_makeTerminalBroadcaster :
        ( ( H245_TerminalLabel * ) choice )->preShowEthereal();
        break;
      case e_sendThisSource :
        ( ( H245_TerminalLabel * ) choice )->preShowEthereal();
        break;
      case e_requestAllTerminalIDs :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_remoteMCRequest :
        ( ( H245_RemoteMCRequest * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_ConferenceRequest::getSummary( void ) 
{
  return PString( "ConferenceRequest" );
}

void H245_ConferenceRequest::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "terminalListRequest" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_ConferenceRequest_terminalListRequest, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "makeMeChair" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_ConferenceRequest_makeMeChair, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "cancelMakeMeChair" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_ConferenceRequest_cancelMakeMeChair, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "enterH243Password" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_ConferenceRequest_enterH243Password, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "enterH243TerminalID" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_ConferenceRequest_enterH243TerminalID, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "enterH243ConferenceID" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_ConferenceRequest_enterH243ConferenceID, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "enterExtensionAddress" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_ConferenceRequest_enterExtensionAddress, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "requestChairTokenOwner" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_ConferenceRequest_requestChairTokenOwner, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "broadcastMyLogicalChannel" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_ConferenceRequest_broadcastMyLogicalChannel, tvb, offset + ( ( H245_LogicalChannelNumber* ) choice) ->GetStartByte(), ( ( H245_LogicalChannelNumber* ) choice) ->GetByteLength(),  ( ( H245_LogicalChannelNumber* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "requestAllTerminalIDs" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_ConferenceRequest_requestAllTerminalIDs, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_ConferenceRequest_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// CertSelectionCriteria
//

H245_CertSelectionCriteria::H245_CertSelectionCriteria(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 16);
}


PASN_Object * H245_CertSelectionCriteria::CreateObject() const
{
  return new H245_Criteria;
}


H245_Criteria & H245_CertSelectionCriteria::operator[](PINDEX i) const
{
  return (H245_Criteria &)array[i];
}


PObject * H245_CertSelectionCriteria::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CertSelectionCriteria::Class()), PInvalidCast);
#endif
  return new H245_CertSelectionCriteria(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CertSelectionCriteria::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_Criteria& ) array[i] ).preShowEthereal();
  }
}

PString H245_CertSelectionCriteria::getSummary( void ) 
{
  return PString( "CertSelectionCriteria" );
}

void H245_CertSelectionCriteria::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *CertSelectionCriteria_tree = (proto_tree*) NULL;
  proto_item *CertSelectionCriteria_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    CertSelectionCriteria_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (Criteria)", i );
    CertSelectionCriteria_tree = proto_item_add_subtree( CertSelectionCriteria_ti, hCont->h245_0.ett_h245_CertSelectionCriteria );
    array[i].showEthereal( CertSelectionCriteria_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// Criteria
//

H245_Criteria::H245_Criteria(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_value.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H245_Criteria::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+8) << "field = " << setprecision(indent) << m_field << '\n';
  strm << setw(indent+8) << "value = " << setprecision(indent) << m_value << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_Criteria::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_Criteria::Class()), PInvalidCast);
#endif
  const H245_Criteria & other = (const H245_Criteria &)obj;

  Comparison result;

  if ((result = m_field.Compare(other.m_field)) != EqualTo)
    return result;
  if ((result = m_value.Compare(other.m_value)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_Criteria::GetDataLength() const
{
  return m_field.GetObjectLength() +
         m_value.GetObjectLength();
}


BOOL H245_Criteria::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_field.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_value.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_Criteria::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_field.Encode(strm);
  m_value.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_field.Encode(strm);
  m_value.Encode(strm);
}


PObject * H245_Criteria::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_Criteria::Class()), PInvalidCast);
#endif
  return new H245_Criteria(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_Criteria::preShowEthereal( void )
{
  m_field.preShowEthereal( );
  m_value.preShowEthereal( );
}

PString H245_Criteria::getSummary( void ) 
{
  return PString( "Criteria" );
}

void H245_Criteria::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pfield = m_field.getValue();
  proto_tree_add_string( tree, hCont->h245_0.hf_h245_Criteria_field, tvb, offset + m_field.GetStartByte(), m_field.GetByteLength() , pfield );
  delete[] pfield;

  char* pvalue = m_value.getValue();
  proto_tree_add_string( tree, hCont->h245_0.hf_h245_Criteria_value, tvb, offset + m_value.GetStartByte(), m_value.GetByteLength() , pvalue );
  delete[] pvalue;

}
#endif  //USE_FOR_ETHEREAL

//
// McuNumber
//

H245_McuNumber::H245_McuNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 192);
}


H245_McuNumber & H245_McuNumber::operator=(int v)
{
  SetValue(v);
  return *this;
}


H245_McuNumber & H245_McuNumber::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H245_McuNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_McuNumber::Class()), PInvalidCast);
#endif
  return new H245_McuNumber(*this);
}


//
// TerminalNumber
//

H245_TerminalNumber::H245_TerminalNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 192);
}


H245_TerminalNumber & H245_TerminalNumber::operator=(int v)
{
  SetValue(v);
  return *this;
}


H245_TerminalNumber & H245_TerminalNumber::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H245_TerminalNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TerminalNumber::Class()), PInvalidCast);
#endif
  return new H245_TerminalNumber(*this);
}


//
// ConferenceResponse
//

H245_ConferenceResponse::H245_ConferenceResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 8, TRUE
#ifndef PASN_NOPRINTON
      , "mCTerminalIDResponse "
        "terminalIDResponse "
        "conferenceIDResponse "
        "passwordResponse "
        "terminalListResponse "
        "videoCommandReject "
        "terminalDropReject "
        "makeMeChairResponse "
        "extensionAddressResponse "
        "chairTokenOwnerResponse "
        "terminalCertificateResponse "
        "broadcastMyLogicalChannelResponse "
        "makeTerminalBroadcasterResponse "
        "sendThisSourceResponse "
        "requestAllTerminalIDsResponse "
        "remoteMCResponse "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ConferenceResponse_mCTerminalIDResponse &() const
#else
H245_ConferenceResponse::operator H245_ConferenceResponse_mCTerminalIDResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse_mCTerminalIDResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_mCTerminalIDResponse *)choice;
}


H245_ConferenceResponse::operator const H245_ConferenceResponse_mCTerminalIDResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse_mCTerminalIDResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_mCTerminalIDResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ConferenceResponse_terminalIDResponse &() const
#else
H245_ConferenceResponse::operator H245_ConferenceResponse_terminalIDResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse_terminalIDResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_terminalIDResponse *)choice;
}


H245_ConferenceResponse::operator const H245_ConferenceResponse_terminalIDResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse_terminalIDResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_terminalIDResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ConferenceResponse_conferenceIDResponse &() const
#else
H245_ConferenceResponse::operator H245_ConferenceResponse_conferenceIDResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse_conferenceIDResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_conferenceIDResponse *)choice;
}


H245_ConferenceResponse::operator const H245_ConferenceResponse_conferenceIDResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse_conferenceIDResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_conferenceIDResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ConferenceResponse_passwordResponse &() const
#else
H245_ConferenceResponse::operator H245_ConferenceResponse_passwordResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse_passwordResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_passwordResponse *)choice;
}


H245_ConferenceResponse::operator const H245_ConferenceResponse_passwordResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse_passwordResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_passwordResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ArrayOf_TerminalLabel &() const
#else
H245_ConferenceResponse::operator H245_ArrayOf_TerminalLabel &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ArrayOf_TerminalLabel::Class()), PInvalidCast);
#endif
  return *(H245_ArrayOf_TerminalLabel *)choice;
}


H245_ConferenceResponse::operator const H245_ArrayOf_TerminalLabel &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ArrayOf_TerminalLabel::Class()), PInvalidCast);
#endif
  return *(H245_ArrayOf_TerminalLabel *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ConferenceResponse_makeMeChairResponse &() const
#else
H245_ConferenceResponse::operator H245_ConferenceResponse_makeMeChairResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse_makeMeChairResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_makeMeChairResponse *)choice;
}


H245_ConferenceResponse::operator const H245_ConferenceResponse_makeMeChairResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse_makeMeChairResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_makeMeChairResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ConferenceResponse_extensionAddressResponse &() const
#else
H245_ConferenceResponse::operator H245_ConferenceResponse_extensionAddressResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse_extensionAddressResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_extensionAddressResponse *)choice;
}


H245_ConferenceResponse::operator const H245_ConferenceResponse_extensionAddressResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse_extensionAddressResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_extensionAddressResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ConferenceResponse_chairTokenOwnerResponse &() const
#else
H245_ConferenceResponse::operator H245_ConferenceResponse_chairTokenOwnerResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse_chairTokenOwnerResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_chairTokenOwnerResponse *)choice;
}


H245_ConferenceResponse::operator const H245_ConferenceResponse_chairTokenOwnerResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse_chairTokenOwnerResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_chairTokenOwnerResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ConferenceResponse_terminalCertificateResponse &() const
#else
H245_ConferenceResponse::operator H245_ConferenceResponse_terminalCertificateResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse_terminalCertificateResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_terminalCertificateResponse *)choice;
}


H245_ConferenceResponse::operator const H245_ConferenceResponse_terminalCertificateResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse_terminalCertificateResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_terminalCertificateResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ConferenceResponse_broadcastMyLogicalChannelResponse &() const
#else
H245_ConferenceResponse::operator H245_ConferenceResponse_broadcastMyLogicalChannelResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse_broadcastMyLogicalChannelResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_broadcastMyLogicalChannelResponse *)choice;
}


H245_ConferenceResponse::operator const H245_ConferenceResponse_broadcastMyLogicalChannelResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse_broadcastMyLogicalChannelResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_broadcastMyLogicalChannelResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ConferenceResponse_makeTerminalBroadcasterResponse &() const
#else
H245_ConferenceResponse::operator H245_ConferenceResponse_makeTerminalBroadcasterResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse_makeTerminalBroadcasterResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_makeTerminalBroadcasterResponse *)choice;
}


H245_ConferenceResponse::operator const H245_ConferenceResponse_makeTerminalBroadcasterResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse_makeTerminalBroadcasterResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_makeTerminalBroadcasterResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ConferenceResponse_sendThisSourceResponse &() const
#else
H245_ConferenceResponse::operator H245_ConferenceResponse_sendThisSourceResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse_sendThisSourceResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_sendThisSourceResponse *)choice;
}


H245_ConferenceResponse::operator const H245_ConferenceResponse_sendThisSourceResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ConferenceResponse_sendThisSourceResponse::Class()), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_sendThisSourceResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_RequestAllTerminalIDsResponse &() const
#else
H245_ConferenceResponse::operator H245_RequestAllTerminalIDsResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestAllTerminalIDsResponse::Class()), PInvalidCast);
#endif
  return *(H245_RequestAllTerminalIDsResponse *)choice;
}


H245_ConferenceResponse::operator const H245_RequestAllTerminalIDsResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestAllTerminalIDsResponse::Class()), PInvalidCast);
#endif
  return *(H245_RequestAllTerminalIDsResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_RemoteMCResponse &() const
#else
H245_ConferenceResponse::operator H245_RemoteMCResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RemoteMCResponse::Class()), PInvalidCast);
#endif
  return *(H245_RemoteMCResponse *)choice;
}


H245_ConferenceResponse::operator const H245_RemoteMCResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RemoteMCResponse::Class()), PInvalidCast);
#endif
  return *(H245_RemoteMCResponse *)choice;
}


BOOL H245_ConferenceResponse::CreateObject()
{
  switch (tag) {
    case e_mCTerminalIDResponse :
      choice = new H245_ConferenceResponse_mCTerminalIDResponse();
      return TRUE;
    case e_terminalIDResponse :
      choice = new H245_ConferenceResponse_terminalIDResponse();
      return TRUE;
    case e_conferenceIDResponse :
      choice = new H245_ConferenceResponse_conferenceIDResponse();
      return TRUE;
    case e_passwordResponse :
      choice = new H245_ConferenceResponse_passwordResponse();
      return TRUE;
    case e_terminalListResponse :
      choice = new H245_ArrayOf_TerminalLabel();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_videoCommandReject :
    case e_terminalDropReject :
      choice = new PASN_Null();
      return TRUE;
    case e_makeMeChairResponse :
      choice = new H245_ConferenceResponse_makeMeChairResponse();
      return TRUE;
    case e_extensionAddressResponse :
      choice = new H245_ConferenceResponse_extensionAddressResponse();
      return TRUE;
    case e_chairTokenOwnerResponse :
      choice = new H245_ConferenceResponse_chairTokenOwnerResponse();
      return TRUE;
    case e_terminalCertificateResponse :
      choice = new H245_ConferenceResponse_terminalCertificateResponse();
      return TRUE;
    case e_broadcastMyLogicalChannelResponse :
      choice = new H245_ConferenceResponse_broadcastMyLogicalChannelResponse();
      return TRUE;
    case e_makeTerminalBroadcasterResponse :
      choice = new H245_ConferenceResponse_makeTerminalBroadcasterResponse();
      return TRUE;
    case e_sendThisSourceResponse :
      choice = new H245_ConferenceResponse_sendThisSourceResponse();
      return TRUE;
    case e_requestAllTerminalIDsResponse :
      choice = new H245_RequestAllTerminalIDsResponse();
      return TRUE;
    case e_remoteMCResponse :
      choice = new H245_RemoteMCResponse();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_ConferenceResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ConferenceResponse::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_mCTerminalIDResponse :
        ( ( H245_ConferenceResponse_mCTerminalIDResponse * ) choice )->preShowEthereal();
        break;
      case e_terminalIDResponse :
        ( ( H245_ConferenceResponse_terminalIDResponse * ) choice )->preShowEthereal();
        break;
      case e_conferenceIDResponse :
        ( ( H245_ConferenceResponse_conferenceIDResponse * ) choice )->preShowEthereal();
        break;
      case e_passwordResponse :
        ( ( H245_ConferenceResponse_passwordResponse * ) choice )->preShowEthereal();
        break;
      case e_terminalListResponse :
        ( ( H245_ArrayOf_TerminalLabel * ) choice )->preShowEthereal();
        break;
      case e_videoCommandReject :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_terminalDropReject :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_makeMeChairResponse :
        ( ( H245_ConferenceResponse_makeMeChairResponse * ) choice )->preShowEthereal();
        break;
      case e_extensionAddressResponse :
        ( ( H245_ConferenceResponse_extensionAddressResponse * ) choice )->preShowEthereal();
        break;
      case e_chairTokenOwnerResponse :
        ( ( H245_ConferenceResponse_chairTokenOwnerResponse * ) choice )->preShowEthereal();
        break;
      case e_terminalCertificateResponse :
        ( ( H245_ConferenceResponse_terminalCertificateResponse * ) choice )->preShowEthereal();
        break;
      case e_broadcastMyLogicalChannelResponse :
        ( ( H245_ConferenceResponse_broadcastMyLogicalChannelResponse * ) choice )->preShowEthereal();
        break;
      case e_makeTerminalBroadcasterResponse :
        ( ( H245_ConferenceResponse_makeTerminalBroadcasterResponse * ) choice )->preShowEthereal();
        break;
      case e_sendThisSourceResponse :
        ( ( H245_ConferenceResponse_sendThisSourceResponse * ) choice )->preShowEthereal();
        break;
      case e_requestAllTerminalIDsResponse :
        ( ( H245_RequestAllTerminalIDsResponse * ) choice )->preShowEthereal();
        break;
      case e_remoteMCResponse :
        ( ( H245_RemoteMCResponse * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_ConferenceResponse::getSummary( void ) 
{
  return PString( "ConferenceResponse" );
}

void H245_ConferenceResponse::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "videoCommandReject" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_ConferenceResponse_videoCommandReject, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "terminalDropReject" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_ConferenceResponse_terminalDropReject, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_ConferenceResponse_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// TerminalID
//

H245_TerminalID::H245_TerminalID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_OctetString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 128);
}


H245_TerminalID & H245_TerminalID::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H245_TerminalID & H245_TerminalID::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H245_TerminalID & H245_TerminalID::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H245_TerminalID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TerminalID::Class()), PInvalidCast);
#endif
  return new H245_TerminalID(*this);
}


//
// ConferenceID
//

H245_ConferenceID::H245_ConferenceID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_OctetString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 32);
}


H245_ConferenceID & H245_ConferenceID::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H245_ConferenceID & H245_ConferenceID::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H245_ConferenceID & H245_ConferenceID::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H245_ConferenceID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceID::Class()), PInvalidCast);
#endif
  return new H245_ConferenceID(*this);
}


//
// Password
//

H245_Password::H245_Password(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_OctetString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 32);
}


H245_Password & H245_Password::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H245_Password & H245_Password::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H245_Password & H245_Password::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H245_Password::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_Password::Class()), PInvalidCast);
#endif
  return new H245_Password(*this);
}


//
// RemoteMCRequest
//

H245_RemoteMCRequest::H245_RemoteMCRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "masterActivate "
        "slaveActivate "
        "deActivate "
#endif
    )
{
}


BOOL H245_RemoteMCRequest::CreateObject()
{
  switch (tag) {
    case e_masterActivate :
    case e_slaveActivate :
    case e_deActivate :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_RemoteMCRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RemoteMCRequest::Class()), PInvalidCast);
#endif
  return new H245_RemoteMCRequest(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RemoteMCRequest::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_masterActivate :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_slaveActivate :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_deActivate :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_RemoteMCRequest::getSummary( void ) 
{
  return PString( "RemoteMCRequest" );
}

void H245_RemoteMCRequest::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "masterActivate" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_RemoteMCRequest_masterActivate, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "slaveActivate" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_RemoteMCRequest_slaveActivate, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "deActivate" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_RemoteMCRequest_deActivate, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// RemoteMCResponse
//

H245_RemoteMCResponse::H245_RemoteMCResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "accept "
        "reject "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RemoteMCResponse::operator H245_RemoteMCResponse_reject &() const
#else
H245_RemoteMCResponse::operator H245_RemoteMCResponse_reject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RemoteMCResponse_reject::Class()), PInvalidCast);
#endif
  return *(H245_RemoteMCResponse_reject *)choice;
}


H245_RemoteMCResponse::operator const H245_RemoteMCResponse_reject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RemoteMCResponse_reject::Class()), PInvalidCast);
#endif
  return *(H245_RemoteMCResponse_reject *)choice;
}


BOOL H245_RemoteMCResponse::CreateObject()
{
  switch (tag) {
    case e_accept :
      choice = new PASN_Null();
      return TRUE;
    case e_reject :
      choice = new H245_RemoteMCResponse_reject();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_RemoteMCResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RemoteMCResponse::Class()), PInvalidCast);
#endif
  return new H245_RemoteMCResponse(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RemoteMCResponse::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_accept :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_reject :
        ( ( H245_RemoteMCResponse_reject * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_RemoteMCResponse::getSummary( void ) 
{
  return PString( "RemoteMCResponse" );
}

void H245_RemoteMCResponse::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "accept" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_RemoteMCResponse_accept, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_RemoteMCResponse_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// MultilinkRequest
//

H245_MultilinkRequest::H245_MultilinkRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "callInformation "
        "addConnection "
        "removeConnection "
        "maximumHeaderInterval "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkRequest::operator H245_NonStandardMessage &() const
#else
H245_MultilinkRequest::operator H245_NonStandardMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardMessage::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


H245_MultilinkRequest::operator const H245_NonStandardMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardMessage::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkRequest::operator H245_MultilinkRequest_callInformation &() const
#else
H245_MultilinkRequest::operator H245_MultilinkRequest_callInformation &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkRequest_callInformation::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkRequest_callInformation *)choice;
}


H245_MultilinkRequest::operator const H245_MultilinkRequest_callInformation &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkRequest_callInformation::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkRequest_callInformation *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkRequest::operator H245_MultilinkRequest_addConnection &() const
#else
H245_MultilinkRequest::operator H245_MultilinkRequest_addConnection &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkRequest_addConnection::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkRequest_addConnection *)choice;
}


H245_MultilinkRequest::operator const H245_MultilinkRequest_addConnection &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkRequest_addConnection::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkRequest_addConnection *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkRequest::operator H245_MultilinkRequest_removeConnection &() const
#else
H245_MultilinkRequest::operator H245_MultilinkRequest_removeConnection &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkRequest_removeConnection::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkRequest_removeConnection *)choice;
}


H245_MultilinkRequest::operator const H245_MultilinkRequest_removeConnection &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkRequest_removeConnection::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkRequest_removeConnection *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkRequest::operator H245_MultilinkRequest_maximumHeaderInterval &() const
#else
H245_MultilinkRequest::operator H245_MultilinkRequest_maximumHeaderInterval &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkRequest_maximumHeaderInterval::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkRequest_maximumHeaderInterval *)choice;
}


H245_MultilinkRequest::operator const H245_MultilinkRequest_maximumHeaderInterval &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkRequest_maximumHeaderInterval::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkRequest_maximumHeaderInterval *)choice;
}


BOOL H245_MultilinkRequest::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardMessage();
      return TRUE;
    case e_callInformation :
      choice = new H245_MultilinkRequest_callInformation();
      return TRUE;
    case e_addConnection :
      choice = new H245_MultilinkRequest_addConnection();
      return TRUE;
    case e_removeConnection :
      choice = new H245_MultilinkRequest_removeConnection();
      return TRUE;
    case e_maximumHeaderInterval :
      choice = new H245_MultilinkRequest_maximumHeaderInterval();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_MultilinkRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkRequest::Class()), PInvalidCast);
#endif
  return new H245_MultilinkRequest(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultilinkRequest::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardMessage * ) choice )->preShowEthereal();
        break;
      case e_callInformation :
        ( ( H245_MultilinkRequest_callInformation * ) choice )->preShowEthereal();
        break;
      case e_addConnection :
        ( ( H245_MultilinkRequest_addConnection * ) choice )->preShowEthereal();
        break;
      case e_removeConnection :
        ( ( H245_MultilinkRequest_removeConnection * ) choice )->preShowEthereal();
        break;
      case e_maximumHeaderInterval :
        ( ( H245_MultilinkRequest_maximumHeaderInterval * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_MultilinkRequest::getSummary( void ) 
{
  return PString( "MultilinkRequest" );
}

void H245_MultilinkRequest::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_MultilinkRequest_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// MultilinkResponse
//

H245_MultilinkResponse::H245_MultilinkResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "callInformation "
        "addConnection "
        "removeConnection "
        "maximumHeaderInterval "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkResponse::operator H245_NonStandardMessage &() const
#else
H245_MultilinkResponse::operator H245_NonStandardMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardMessage::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


H245_MultilinkResponse::operator const H245_NonStandardMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardMessage::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkResponse::operator H245_MultilinkResponse_callInformation &() const
#else
H245_MultilinkResponse::operator H245_MultilinkResponse_callInformation &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkResponse_callInformation::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkResponse_callInformation *)choice;
}


H245_MultilinkResponse::operator const H245_MultilinkResponse_callInformation &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkResponse_callInformation::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkResponse_callInformation *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkResponse::operator H245_MultilinkResponse_addConnection &() const
#else
H245_MultilinkResponse::operator H245_MultilinkResponse_addConnection &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkResponse_addConnection::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkResponse_addConnection *)choice;
}


H245_MultilinkResponse::operator const H245_MultilinkResponse_addConnection &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkResponse_addConnection::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkResponse_addConnection *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkResponse::operator H245_MultilinkResponse_removeConnection &() const
#else
H245_MultilinkResponse::operator H245_MultilinkResponse_removeConnection &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkResponse_removeConnection::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkResponse_removeConnection *)choice;
}


H245_MultilinkResponse::operator const H245_MultilinkResponse_removeConnection &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkResponse_removeConnection::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkResponse_removeConnection *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkResponse::operator H245_MultilinkResponse_maximumHeaderInterval &() const
#else
H245_MultilinkResponse::operator H245_MultilinkResponse_maximumHeaderInterval &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkResponse_maximumHeaderInterval::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkResponse_maximumHeaderInterval *)choice;
}


H245_MultilinkResponse::operator const H245_MultilinkResponse_maximumHeaderInterval &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkResponse_maximumHeaderInterval::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkResponse_maximumHeaderInterval *)choice;
}


BOOL H245_MultilinkResponse::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardMessage();
      return TRUE;
    case e_callInformation :
      choice = new H245_MultilinkResponse_callInformation();
      return TRUE;
    case e_addConnection :
      choice = new H245_MultilinkResponse_addConnection();
      return TRUE;
    case e_removeConnection :
      choice = new H245_MultilinkResponse_removeConnection();
      return TRUE;
    case e_maximumHeaderInterval :
      choice = new H245_MultilinkResponse_maximumHeaderInterval();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_MultilinkResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkResponse::Class()), PInvalidCast);
#endif
  return new H245_MultilinkResponse(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultilinkResponse::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardMessage * ) choice )->preShowEthereal();
        break;
      case e_callInformation :
        ( ( H245_MultilinkResponse_callInformation * ) choice )->preShowEthereal();
        break;
      case e_addConnection :
        ( ( H245_MultilinkResponse_addConnection * ) choice )->preShowEthereal();
        break;
      case e_removeConnection :
        ( ( H245_MultilinkResponse_removeConnection * ) choice )->preShowEthereal();
        break;
      case e_maximumHeaderInterval :
        ( ( H245_MultilinkResponse_maximumHeaderInterval * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_MultilinkResponse::getSummary( void ) 
{
  return PString( "MultilinkResponse" );
}

void H245_MultilinkResponse::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_MultilinkResponse_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// MultilinkIndication
//

H245_MultilinkIndication::H245_MultilinkIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "crcDesired "
        "excessiveError "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkIndication::operator H245_NonStandardMessage &() const
#else
H245_MultilinkIndication::operator H245_NonStandardMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardMessage::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


H245_MultilinkIndication::operator const H245_NonStandardMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardMessage::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkIndication::operator H245_MultilinkIndication_crcDesired &() const
#else
H245_MultilinkIndication::operator H245_MultilinkIndication_crcDesired &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkIndication_crcDesired::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkIndication_crcDesired *)choice;
}


H245_MultilinkIndication::operator const H245_MultilinkIndication_crcDesired &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkIndication_crcDesired::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkIndication_crcDesired *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkIndication::operator H245_MultilinkIndication_excessiveError &() const
#else
H245_MultilinkIndication::operator H245_MultilinkIndication_excessiveError &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkIndication_excessiveError::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkIndication_excessiveError *)choice;
}


H245_MultilinkIndication::operator const H245_MultilinkIndication_excessiveError &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkIndication_excessiveError::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkIndication_excessiveError *)choice;
}


BOOL H245_MultilinkIndication::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardMessage();
      return TRUE;
    case e_crcDesired :
      choice = new H245_MultilinkIndication_crcDesired();
      return TRUE;
    case e_excessiveError :
      choice = new H245_MultilinkIndication_excessiveError();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_MultilinkIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkIndication::Class()), PInvalidCast);
#endif
  return new H245_MultilinkIndication(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultilinkIndication::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardMessage * ) choice )->preShowEthereal();
        break;
      case e_crcDesired :
        ( ( H245_MultilinkIndication_crcDesired * ) choice )->preShowEthereal();
        break;
      case e_excessiveError :
        ( ( H245_MultilinkIndication_excessiveError * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_MultilinkIndication::getSummary( void ) 
{
  return PString( "MultilinkIndication" );
}

void H245_MultilinkIndication::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_MultilinkIndication_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// DiallingInformation
//

H245_DiallingInformation::H245_DiallingInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "differential "
        "infoNotAvailable "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DiallingInformation::operator H245_NonStandardMessage &() const
#else
H245_DiallingInformation::operator H245_NonStandardMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardMessage::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


H245_DiallingInformation::operator const H245_NonStandardMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardMessage::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DiallingInformation::operator H245_ArrayOf_DiallingInformationNumber &() const
#else
H245_DiallingInformation::operator H245_ArrayOf_DiallingInformationNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ArrayOf_DiallingInformationNumber::Class()), PInvalidCast);
#endif
  return *(H245_ArrayOf_DiallingInformationNumber *)choice;
}


H245_DiallingInformation::operator const H245_ArrayOf_DiallingInformationNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ArrayOf_DiallingInformationNumber::Class()), PInvalidCast);
#endif
  return *(H245_ArrayOf_DiallingInformationNumber *)choice;
}


BOOL H245_DiallingInformation::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardMessage();
      return TRUE;
    case e_differential :
      choice = new H245_ArrayOf_DiallingInformationNumber();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
      return TRUE;
    case e_infoNotAvailable :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_DiallingInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DiallingInformation::Class()), PInvalidCast);
#endif
  return new H245_DiallingInformation(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_DiallingInformation::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardMessage * ) choice )->preShowEthereal();
        break;
      case e_differential :
        ( ( H245_ArrayOf_DiallingInformationNumber * ) choice )->preShowEthereal();
        break;
      case e_infoNotAvailable :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_DiallingInformation::getSummary( void ) 
{
  return PString( "DiallingInformation" );
}

void H245_DiallingInformation::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "infoNotAvailable" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_DiallingInformation_infoNotAvailable, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_DiallingInformation_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// DiallingInformationNetworkType
//

H245_DiallingInformationNetworkType::H245_DiallingInformationNetworkType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "n_isdn "
        "gstn "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DiallingInformationNetworkType::operator H245_NonStandardMessage &() const
#else
H245_DiallingInformationNetworkType::operator H245_NonStandardMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardMessage::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


H245_DiallingInformationNetworkType::operator const H245_NonStandardMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardMessage::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


BOOL H245_DiallingInformationNetworkType::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardMessage();
      return TRUE;
    case e_n_isdn :
    case e_gstn :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_DiallingInformationNetworkType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DiallingInformationNetworkType::Class()), PInvalidCast);
#endif
  return new H245_DiallingInformationNetworkType(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_DiallingInformationNetworkType::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardMessage * ) choice )->preShowEthereal();
        break;
      case e_n_isdn :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_gstn :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_DiallingInformationNetworkType::getSummary( void ) 
{
  return PString( "DiallingInformationNetworkType" );
}

void H245_DiallingInformationNetworkType::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "n_isdn" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_DiallingInformationNetworkType_n_isdn, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "gstn" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_DiallingInformationNetworkType_gstn, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_DiallingInformationNetworkType_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ConnectionIdentifier
//

H245_ConnectionIdentifier::H245_ConnectionIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_channelTag.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
  m_sequenceNumber.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H245_ConnectionIdentifier::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "channelTag = " << setprecision(indent) << m_channelTag << '\n';
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_ConnectionIdentifier::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_ConnectionIdentifier::Class()), PInvalidCast);
#endif
  const H245_ConnectionIdentifier & other = (const H245_ConnectionIdentifier &)obj;

  Comparison result;

  if ((result = m_channelTag.Compare(other.m_channelTag)) != EqualTo)
    return result;
  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ConnectionIdentifier::GetDataLength() const
{
  return m_channelTag.GetObjectLength() +
         m_sequenceNumber.GetObjectLength();
}


BOOL H245_ConnectionIdentifier::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_channelTag.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sequenceNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_ConnectionIdentifier::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_channelTag.Encode(strm);
  m_sequenceNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_channelTag.Encode(strm);
  m_sequenceNumber.Encode(strm);
}


PObject * H245_ConnectionIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConnectionIdentifier::Class()), PInvalidCast);
#endif
  return new H245_ConnectionIdentifier(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ConnectionIdentifier::preShowEthereal( void )
{
  m_channelTag.preShowEthereal( );
  m_sequenceNumber.preShowEthereal( );
}

PString H245_ConnectionIdentifier::getSummary( void ) 
{
  return PString( "ConnectionIdentifier" );
}

void H245_ConnectionIdentifier::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_ConnectionIdentifier_channelTag, tvb, offset + m_channelTag.GetStartByte(), m_channelTag.GetByteLength() , m_channelTag.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_ConnectionIdentifier_sequenceNumber, tvb, offset + m_sequenceNumber.GetStartByte(), m_sequenceNumber.GetByteLength() , m_sequenceNumber.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// SendTerminalCapabilitySet
//

H245_SendTerminalCapabilitySet::H245_SendTerminalCapabilitySet(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "specificRequest "
        "genericRequest "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_SendTerminalCapabilitySet::operator H245_SendTerminalCapabilitySet_specificRequest &() const
#else
H245_SendTerminalCapabilitySet::operator H245_SendTerminalCapabilitySet_specificRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_SendTerminalCapabilitySet_specificRequest::Class()), PInvalidCast);
#endif
  return *(H245_SendTerminalCapabilitySet_specificRequest *)choice;
}


H245_SendTerminalCapabilitySet::operator const H245_SendTerminalCapabilitySet_specificRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_SendTerminalCapabilitySet_specificRequest::Class()), PInvalidCast);
#endif
  return *(H245_SendTerminalCapabilitySet_specificRequest *)choice;
}


BOOL H245_SendTerminalCapabilitySet::CreateObject()
{
  switch (tag) {
    case e_specificRequest :
      choice = new H245_SendTerminalCapabilitySet_specificRequest();
      return TRUE;
    case e_genericRequest :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_SendTerminalCapabilitySet::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_SendTerminalCapabilitySet::Class()), PInvalidCast);
#endif
  return new H245_SendTerminalCapabilitySet(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_SendTerminalCapabilitySet::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_specificRequest :
        ( ( H245_SendTerminalCapabilitySet_specificRequest * ) choice )->preShowEthereal();
        break;
      case e_genericRequest :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_SendTerminalCapabilitySet::getSummary( void ) 
{
  return PString( "SendTerminalCapabilitySet" );
}

void H245_SendTerminalCapabilitySet::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "genericRequest" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_SendTerminalCapabilitySet_genericRequest, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_SendTerminalCapabilitySet_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// EncryptionCommand
//

H245_EncryptionCommand::H245_EncryptionCommand(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "encryptionSE "
        "encryptionIVRequest "
        "encryptionAlgorithmID "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_EncryptionCommand::operator H245_EncryptionCommand_encryptionAlgorithmID &() const
#else
H245_EncryptionCommand::operator H245_EncryptionCommand_encryptionAlgorithmID &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_EncryptionCommand_encryptionAlgorithmID::Class()), PInvalidCast);
#endif
  return *(H245_EncryptionCommand_encryptionAlgorithmID *)choice;
}


H245_EncryptionCommand::operator const H245_EncryptionCommand_encryptionAlgorithmID &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_EncryptionCommand_encryptionAlgorithmID::Class()), PInvalidCast);
#endif
  return *(H245_EncryptionCommand_encryptionAlgorithmID *)choice;
}


BOOL H245_EncryptionCommand::CreateObject()
{
  switch (tag) {
    case e_encryptionSE :
      choice = new PASN_OctetString();
      return TRUE;
    case e_encryptionIVRequest :
      choice = new PASN_Null();
      return TRUE;
    case e_encryptionAlgorithmID :
      choice = new H245_EncryptionCommand_encryptionAlgorithmID();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_EncryptionCommand::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EncryptionCommand::Class()), PInvalidCast);
#endif
  return new H245_EncryptionCommand(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_EncryptionCommand::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_encryptionSE :
        ( ( PASN_OctetString * ) choice )->preShowEthereal();
        break;
      case e_encryptionIVRequest :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_encryptionAlgorithmID :
        ( ( H245_EncryptionCommand_encryptionAlgorithmID * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_EncryptionCommand::getSummary( void ) 
{
  return PString( "EncryptionCommand" );
}

void H245_EncryptionCommand::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "encryptionSE" ) == 0 ) {
      char* pstring = ( ( PASN_OctetString* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_EncryptionCommand_encryptionSE, tvb, offset + ( ( PASN_OctetString* ) choice) ->GetStartByte(), ( ( PASN_OctetString* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    if ( strcmp( GetTagName(), "encryptionIVRequest" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_EncryptionCommand_encryptionIVRequest, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_EncryptionCommand_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// EndSessionCommand
//

H245_EndSessionCommand::H245_EndSessionCommand(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "disconnect "
        "gstnOptions "
        "isdnOptions "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_EndSessionCommand::operator H245_NonStandardParameter &() const
#else
H245_EndSessionCommand::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_EndSessionCommand::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_EndSessionCommand::operator H245_EndSessionCommand_gstnOptions &() const
#else
H245_EndSessionCommand::operator H245_EndSessionCommand_gstnOptions &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_EndSessionCommand_gstnOptions::Class()), PInvalidCast);
#endif
  return *(H245_EndSessionCommand_gstnOptions *)choice;
}


H245_EndSessionCommand::operator const H245_EndSessionCommand_gstnOptions &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_EndSessionCommand_gstnOptions::Class()), PInvalidCast);
#endif
  return *(H245_EndSessionCommand_gstnOptions *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_EndSessionCommand::operator H245_EndSessionCommand_isdnOptions &() const
#else
H245_EndSessionCommand::operator H245_EndSessionCommand_isdnOptions &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_EndSessionCommand_isdnOptions::Class()), PInvalidCast);
#endif
  return *(H245_EndSessionCommand_isdnOptions *)choice;
}


H245_EndSessionCommand::operator const H245_EndSessionCommand_isdnOptions &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_EndSessionCommand_isdnOptions::Class()), PInvalidCast);
#endif
  return *(H245_EndSessionCommand_isdnOptions *)choice;
}


BOOL H245_EndSessionCommand::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_disconnect :
      choice = new PASN_Null();
      return TRUE;
    case e_gstnOptions :
      choice = new H245_EndSessionCommand_gstnOptions();
      return TRUE;
    case e_isdnOptions :
      choice = new H245_EndSessionCommand_isdnOptions();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_EndSessionCommand::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EndSessionCommand::Class()), PInvalidCast);
#endif
  return new H245_EndSessionCommand(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_EndSessionCommand::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_disconnect :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_gstnOptions :
        ( ( H245_EndSessionCommand_gstnOptions * ) choice )->preShowEthereal();
        break;
      case e_isdnOptions :
        ( ( H245_EndSessionCommand_isdnOptions * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_EndSessionCommand::getSummary( void ) 
{
  return PString( "EndSessionCommand" );
}

void H245_EndSessionCommand::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "disconnect" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_EndSessionCommand_disconnect, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_EndSessionCommand_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ConferenceCommand
//

H245_ConferenceCommand::H245_ConferenceCommand(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 7, TRUE
#ifndef PASN_NOPRINTON
      , "broadcastMyLogicalChannel "
        "cancelBroadcastMyLogicalChannel "
        "makeTerminalBroadcaster "
        "cancelMakeTerminalBroadcaster "
        "sendThisSource "
        "cancelSendThisSource "
        "dropConference "
        "substituteConferenceIDCommand "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceCommand::operator H245_LogicalChannelNumber &() const
#else
H245_ConferenceCommand::operator H245_LogicalChannelNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_LogicalChannelNumber::Class()), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


H245_ConferenceCommand::operator const H245_LogicalChannelNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_LogicalChannelNumber::Class()), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceCommand::operator H245_TerminalLabel &() const
#else
H245_ConferenceCommand::operator H245_TerminalLabel &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_TerminalLabel::Class()), PInvalidCast);
#endif
  return *(H245_TerminalLabel *)choice;
}


H245_ConferenceCommand::operator const H245_TerminalLabel &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_TerminalLabel::Class()), PInvalidCast);
#endif
  return *(H245_TerminalLabel *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceCommand::operator H245_SubstituteConferenceIDCommand &() const
#else
H245_ConferenceCommand::operator H245_SubstituteConferenceIDCommand &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_SubstituteConferenceIDCommand::Class()), PInvalidCast);
#endif
  return *(H245_SubstituteConferenceIDCommand *)choice;
}


H245_ConferenceCommand::operator const H245_SubstituteConferenceIDCommand &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_SubstituteConferenceIDCommand::Class()), PInvalidCast);
#endif
  return *(H245_SubstituteConferenceIDCommand *)choice;
}


BOOL H245_ConferenceCommand::CreateObject()
{
  switch (tag) {
    case e_broadcastMyLogicalChannel :
    case e_cancelBroadcastMyLogicalChannel :
      choice = new H245_LogicalChannelNumber();
      return TRUE;
    case e_makeTerminalBroadcaster :
    case e_sendThisSource :
      choice = new H245_TerminalLabel();
      return TRUE;
    case e_cancelMakeTerminalBroadcaster :
    case e_cancelSendThisSource :
    case e_dropConference :
      choice = new PASN_Null();
      return TRUE;
    case e_substituteConferenceIDCommand :
      choice = new H245_SubstituteConferenceIDCommand();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_ConferenceCommand::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceCommand::Class()), PInvalidCast);
#endif
  return new H245_ConferenceCommand(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ConferenceCommand::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_broadcastMyLogicalChannel :
        ( ( H245_LogicalChannelNumber * ) choice )->preShowEthereal();
        break;
      case e_cancelBroadcastMyLogicalChannel :
        ( ( H245_LogicalChannelNumber * ) choice )->preShowEthereal();
        break;
      case e_makeTerminalBroadcaster :
        ( ( H245_TerminalLabel * ) choice )->preShowEthereal();
        break;
      case e_cancelMakeTerminalBroadcaster :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_sendThisSource :
        ( ( H245_TerminalLabel * ) choice )->preShowEthereal();
        break;
      case e_cancelSendThisSource :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_dropConference :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_substituteConferenceIDCommand :
        ( ( H245_SubstituteConferenceIDCommand * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_ConferenceCommand::getSummary( void ) 
{
  return PString( "ConferenceCommand" );
}

void H245_ConferenceCommand::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "broadcastMyLogicalChannel" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_ConferenceCommand_broadcastMyLogicalChannel, tvb, offset + ( ( H245_LogicalChannelNumber* ) choice) ->GetStartByte(), ( ( H245_LogicalChannelNumber* ) choice) ->GetByteLength(),  ( ( H245_LogicalChannelNumber* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "cancelBroadcastMyLogicalChannel" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_ConferenceCommand_cancelBroadcastMyLogicalChannel, tvb, offset + ( ( H245_LogicalChannelNumber* ) choice) ->GetStartByte(), ( ( H245_LogicalChannelNumber* ) choice) ->GetByteLength(),  ( ( H245_LogicalChannelNumber* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "cancelMakeTerminalBroadcaster" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_ConferenceCommand_cancelMakeTerminalBroadcaster, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "cancelSendThisSource" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_ConferenceCommand_cancelSendThisSource, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "dropConference" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_ConferenceCommand_dropConference, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_ConferenceCommand_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// SubstituteConferenceIDCommand
//

H245_SubstituteConferenceIDCommand::H245_SubstituteConferenceIDCommand(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_conferenceIdentifier.SetConstraints(PASN_Object::FixedConstraint, 16, 16);
}


#ifndef PASN_NOPRINTON
void H245_SubstituteConferenceIDCommand::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "conferenceIdentifier = " << setprecision(indent) << m_conferenceIdentifier << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_SubstituteConferenceIDCommand::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_SubstituteConferenceIDCommand::Class()), PInvalidCast);
#endif
  const H245_SubstituteConferenceIDCommand & other = (const H245_SubstituteConferenceIDCommand &)obj;

  Comparison result;

  if ((result = m_conferenceIdentifier.Compare(other.m_conferenceIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_SubstituteConferenceIDCommand::GetDataLength() const
{
  return m_conferenceIdentifier.GetObjectLength();
}


BOOL H245_SubstituteConferenceIDCommand::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_conferenceIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_SubstituteConferenceIDCommand::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_conferenceIdentifier.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_conferenceIdentifier.Encode(strm);
}


PObject * H245_SubstituteConferenceIDCommand::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_SubstituteConferenceIDCommand::Class()), PInvalidCast);
#endif
  return new H245_SubstituteConferenceIDCommand(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_SubstituteConferenceIDCommand::preShowEthereal( void )
{
  m_conferenceIdentifier.preShowEthereal( );
}

PString H245_SubstituteConferenceIDCommand::getSummary( void ) 
{
  return PString( "SubstituteConferenceIDCommand" );
}

void H245_SubstituteConferenceIDCommand::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pconferenceIdentifier = m_conferenceIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h245_0.hf_h245_SubstituteConferenceIDCommand_conferenceIdentifier, tvb, offset + m_conferenceIdentifier.GetStartByte(), m_conferenceIdentifier.GetByteLength() , pconferenceIdentifier );
  delete[] pconferenceIdentifier;

}
#endif  //USE_FOR_ETHEREAL

//
// KeyProtectionMethod
//

H245_KeyProtectionMethod::H245_KeyProtectionMethod(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_KeyProtectionMethod::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "secureChannel = " << setprecision(indent) << m_secureChannel << '\n';
  strm << setw(indent+15) << "sharedSecret = " << setprecision(indent) << m_sharedSecret << '\n';
  strm << setw(indent+19) << "certProtectedKey = " << setprecision(indent) << m_certProtectedKey << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_KeyProtectionMethod::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_KeyProtectionMethod::Class()), PInvalidCast);
#endif
  const H245_KeyProtectionMethod & other = (const H245_KeyProtectionMethod &)obj;

  Comparison result;

  if ((result = m_secureChannel.Compare(other.m_secureChannel)) != EqualTo)
    return result;
  if ((result = m_sharedSecret.Compare(other.m_sharedSecret)) != EqualTo)
    return result;
  if ((result = m_certProtectedKey.Compare(other.m_certProtectedKey)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_KeyProtectionMethod::GetDataLength() const
{
  return m_secureChannel.GetObjectLength() +
         m_sharedSecret.GetObjectLength() +
         m_certProtectedKey.GetObjectLength();
}


BOOL H245_KeyProtectionMethod::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_secureChannel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sharedSecret.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_certProtectedKey.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_KeyProtectionMethod::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_secureChannel.Encode(strm);
  m_sharedSecret.Encode(strm);
  m_certProtectedKey.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_secureChannel.Encode(strm);
  m_sharedSecret.Encode(strm);
  m_certProtectedKey.Encode(strm);
}


PObject * H245_KeyProtectionMethod::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_KeyProtectionMethod::Class()), PInvalidCast);
#endif
  return new H245_KeyProtectionMethod(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_KeyProtectionMethod::preShowEthereal( void )
{
  m_secureChannel.preShowEthereal( );
  m_sharedSecret.preShowEthereal( );
  m_certProtectedKey.preShowEthereal( );
}

PString H245_KeyProtectionMethod::getSummary( void ) 
{
  return PString( "KeyProtectionMethod" );
}

void H245_KeyProtectionMethod::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_KeyProtectionMethod_secureChannel, tvb, offset + m_secureChannel.GetStartByte(), m_secureChannel.GetByteLength() , m_secureChannel.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_KeyProtectionMethod_sharedSecret, tvb, offset + m_sharedSecret.GetStartByte(), m_sharedSecret.GetByteLength() , m_sharedSecret.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_KeyProtectionMethod_certProtectedKey, tvb, offset + m_certProtectedKey.GetStartByte(), m_certProtectedKey.GetByteLength() , m_certProtectedKey.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// EncryptionUpdateRequest
//

H245_EncryptionUpdateRequest::H245_EncryptionUpdateRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_EncryptionUpdateRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_keyProtectionMethod))
    strm << setw(indent+22) << "keyProtectionMethod = " << setprecision(indent) << m_keyProtectionMethod << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_EncryptionUpdateRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_EncryptionUpdateRequest::Class()), PInvalidCast);
#endif
  const H245_EncryptionUpdateRequest & other = (const H245_EncryptionUpdateRequest &)obj;

  Comparison result;

  if ((result = m_keyProtectionMethod.Compare(other.m_keyProtectionMethod)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_EncryptionUpdateRequest::GetDataLength() const
{
  return m_keyProtectionMethod.GetObjectLength();
}


BOOL H245_EncryptionUpdateRequest::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_keyProtectionMethod ) && !m_keyProtectionMethod.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_EncryptionUpdateRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_keyProtectionMethod))
    m_keyProtectionMethod.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_keyProtectionMethod))
    m_keyProtectionMethod.Encode(strm);
}


PObject * H245_EncryptionUpdateRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EncryptionUpdateRequest::Class()), PInvalidCast);
#endif
  return new H245_EncryptionUpdateRequest(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_EncryptionUpdateRequest::preShowEthereal( void )
{
  if ( HasOptionalField( e_keyProtectionMethod ) ) 
      m_keyProtectionMethod.preShowEthereal( );
}

PString H245_EncryptionUpdateRequest::getSummary( void ) 
{
  return PString( "EncryptionUpdateRequest" );
}

void H245_EncryptionUpdateRequest::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_keyProtectionMethod ) ) {
    proto_tree *keyProtectionMethod_tree = (proto_tree*) NULL;
    proto_item *keyProtectionMethod_ti = (proto_item*) NULL;
    keyProtectionMethod_ti = proto_tree_add_text( tree, tvb, offset + m_keyProtectionMethod.GetStartByte(), m_keyProtectionMethod.GetByteLength(), "keyProtectionMethod (KeyProtectionMethod)" );
    keyProtectionMethod_tree = proto_item_add_subtree( keyProtectionMethod_ti, hCont->h245_0.ett_h245_EncryptionUpdateRequest_keyProtectionMethod );
    m_keyProtectionMethod.showEthereal( keyProtectionMethod_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// H223MultiplexReconfiguration
//

H245_H223MultiplexReconfiguration::H245_H223MultiplexReconfiguration(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "h223ModeChange "
        "h223AnnexADoubleFlag "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223MultiplexReconfiguration::operator H245_H223MultiplexReconfiguration_h223ModeChange &() const
#else
H245_H223MultiplexReconfiguration::operator H245_H223MultiplexReconfiguration_h223ModeChange &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223MultiplexReconfiguration_h223ModeChange::Class()), PInvalidCast);
#endif
  return *(H245_H223MultiplexReconfiguration_h223ModeChange *)choice;
}


H245_H223MultiplexReconfiguration::operator const H245_H223MultiplexReconfiguration_h223ModeChange &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223MultiplexReconfiguration_h223ModeChange::Class()), PInvalidCast);
#endif
  return *(H245_H223MultiplexReconfiguration_h223ModeChange *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223MultiplexReconfiguration::operator H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag &() const
#else
H245_H223MultiplexReconfiguration::operator H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag::Class()), PInvalidCast);
#endif
  return *(H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag *)choice;
}


H245_H223MultiplexReconfiguration::operator const H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag::Class()), PInvalidCast);
#endif
  return *(H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag *)choice;
}


BOOL H245_H223MultiplexReconfiguration::CreateObject()
{
  switch (tag) {
    case e_h223ModeChange :
      choice = new H245_H223MultiplexReconfiguration_h223ModeChange();
      return TRUE;
    case e_h223AnnexADoubleFlag :
      choice = new H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_H223MultiplexReconfiguration::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223MultiplexReconfiguration::Class()), PInvalidCast);
#endif
  return new H245_H223MultiplexReconfiguration(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223MultiplexReconfiguration::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_h223ModeChange :
        ( ( H245_H223MultiplexReconfiguration_h223ModeChange * ) choice )->preShowEthereal();
        break;
      case e_h223AnnexADoubleFlag :
        ( ( H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_H223MultiplexReconfiguration::getSummary( void ) 
{
  return PString( "H223MultiplexReconfiguration" );
}

void H245_H223MultiplexReconfiguration::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_H223MultiplexReconfiguration_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// FunctionNotUnderstood
//

H245_FunctionNotUnderstood::H245_FunctionNotUnderstood(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
      , "request "
        "response "
        "command "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_FunctionNotUnderstood::operator H245_RequestMessage &() const
#else
H245_FunctionNotUnderstood::operator H245_RequestMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestMessage::Class()), PInvalidCast);
#endif
  return *(H245_RequestMessage *)choice;
}


H245_FunctionNotUnderstood::operator const H245_RequestMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RequestMessage::Class()), PInvalidCast);
#endif
  return *(H245_RequestMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_FunctionNotUnderstood::operator H245_ResponseMessage &() const
#else
H245_FunctionNotUnderstood::operator H245_ResponseMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ResponseMessage::Class()), PInvalidCast);
#endif
  return *(H245_ResponseMessage *)choice;
}


H245_FunctionNotUnderstood::operator const H245_ResponseMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ResponseMessage::Class()), PInvalidCast);
#endif
  return *(H245_ResponseMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_FunctionNotUnderstood::operator H245_CommandMessage &() const
#else
H245_FunctionNotUnderstood::operator H245_CommandMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_CommandMessage::Class()), PInvalidCast);
#endif
  return *(H245_CommandMessage *)choice;
}


H245_FunctionNotUnderstood::operator const H245_CommandMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_CommandMessage::Class()), PInvalidCast);
#endif
  return *(H245_CommandMessage *)choice;
}


BOOL H245_FunctionNotUnderstood::CreateObject()
{
  switch (tag) {
    case e_request :
      choice = new H245_RequestMessage();
      return TRUE;
    case e_response :
      choice = new H245_ResponseMessage();
      return TRUE;
    case e_command :
      choice = new H245_CommandMessage();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_FunctionNotUnderstood::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FunctionNotUnderstood::Class()), PInvalidCast);
#endif
  return new H245_FunctionNotUnderstood(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_FunctionNotUnderstood::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_request :
        ( ( H245_RequestMessage * ) choice )->preShowEthereal();
        break;
      case e_response :
        ( ( H245_ResponseMessage * ) choice )->preShowEthereal();
        break;
      case e_command :
        ( ( H245_CommandMessage * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_FunctionNotUnderstood::getSummary( void ) 
{
  return PString( "FunctionNotUnderstood" );
}

void H245_FunctionNotUnderstood::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_FunctionNotUnderstood_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ConferenceIndication
//

H245_ConferenceIndication::H245_ConferenceIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 10, TRUE
#ifndef PASN_NOPRINTON
      , "sbeNumber "
        "terminalNumberAssign "
        "terminalJoinedConference "
        "terminalLeftConference "
        "seenByAtLeastOneOther "
        "cancelSeenByAtLeastOneOther "
        "seenByAll "
        "cancelSeenByAll "
        "terminalYouAreSeeing "
        "requestForFloor "
        "withdrawChairToken "
        "floorRequested "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceIndication::operator H245_TerminalLabel &() const
#else
H245_ConferenceIndication::operator H245_TerminalLabel &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_TerminalLabel::Class()), PInvalidCast);
#endif
  return *(H245_TerminalLabel *)choice;
}


H245_ConferenceIndication::operator const H245_TerminalLabel &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_TerminalLabel::Class()), PInvalidCast);
#endif
  return *(H245_TerminalLabel *)choice;
}


BOOL H245_ConferenceIndication::CreateObject()
{
  switch (tag) {
    case e_sbeNumber :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 9);
      return TRUE;
    case e_terminalNumberAssign :
    case e_terminalJoinedConference :
    case e_terminalLeftConference :
    case e_terminalYouAreSeeing :
    case e_floorRequested :
      choice = new H245_TerminalLabel();
      return TRUE;
    case e_seenByAtLeastOneOther :
    case e_cancelSeenByAtLeastOneOther :
    case e_seenByAll :
    case e_cancelSeenByAll :
    case e_requestForFloor :
    case e_withdrawChairToken :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_ConferenceIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceIndication::Class()), PInvalidCast);
#endif
  return new H245_ConferenceIndication(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ConferenceIndication::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_sbeNumber :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_terminalNumberAssign :
        ( ( H245_TerminalLabel * ) choice )->preShowEthereal();
        break;
      case e_terminalJoinedConference :
        ( ( H245_TerminalLabel * ) choice )->preShowEthereal();
        break;
      case e_terminalLeftConference :
        ( ( H245_TerminalLabel * ) choice )->preShowEthereal();
        break;
      case e_seenByAtLeastOneOther :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_cancelSeenByAtLeastOneOther :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_seenByAll :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_cancelSeenByAll :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_terminalYouAreSeeing :
        ( ( H245_TerminalLabel * ) choice )->preShowEthereal();
        break;
      case e_requestForFloor :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_withdrawChairToken :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_floorRequested :
        ( ( H245_TerminalLabel * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_ConferenceIndication::getSummary( void ) 
{
  return PString( "ConferenceIndication" );
}

void H245_ConferenceIndication::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "sbeNumber" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_ConferenceIndication_sbeNumber, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "seenByAtLeastOneOther" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_ConferenceIndication_seenByAtLeastOneOther, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "cancelSeenByAtLeastOneOther" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_ConferenceIndication_cancelSeenByAtLeastOneOther, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "seenByAll" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_ConferenceIndication_seenByAll, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "cancelSeenByAll" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_ConferenceIndication_cancelSeenByAll, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "requestForFloor" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_ConferenceIndication_requestForFloor, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "withdrawChairToken" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_ConferenceIndication_withdrawChairToken, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_ConferenceIndication_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H223SkewIndication
//

H245_H223SkewIndication::H245_H223SkewIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_skew.SetConstraints(PASN_Object::FixedConstraint, 0, 4095);
}


#ifndef PASN_NOPRINTON
void H245_H223SkewIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "logicalChannelNumber1 = " << setprecision(indent) << m_logicalChannelNumber1 << '\n';
  strm << setw(indent+24) << "logicalChannelNumber2 = " << setprecision(indent) << m_logicalChannelNumber2 << '\n';
  strm << setw(indent+7) << "skew = " << setprecision(indent) << m_skew << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H223SkewIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H223SkewIndication::Class()), PInvalidCast);
#endif
  const H245_H223SkewIndication & other = (const H245_H223SkewIndication &)obj;

  Comparison result;

  if ((result = m_logicalChannelNumber1.Compare(other.m_logicalChannelNumber1)) != EqualTo)
    return result;
  if ((result = m_logicalChannelNumber2.Compare(other.m_logicalChannelNumber2)) != EqualTo)
    return result;
  if ((result = m_skew.Compare(other.m_skew)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223SkewIndication::GetDataLength() const
{
  return m_logicalChannelNumber1.GetObjectLength() +
         m_logicalChannelNumber2.GetObjectLength() +
         m_skew.GetObjectLength();
}


BOOL H245_H223SkewIndication::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_logicalChannelNumber1.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_logicalChannelNumber2.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_skew.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H223SkewIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_logicalChannelNumber1.Encode(strm);
  m_logicalChannelNumber2.Encode(strm);
  m_skew.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_logicalChannelNumber1.Encode(strm);
  m_logicalChannelNumber2.Encode(strm);
  m_skew.Encode(strm);
}


PObject * H245_H223SkewIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223SkewIndication::Class()), PInvalidCast);
#endif
  return new H245_H223SkewIndication(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223SkewIndication::preShowEthereal( void )
{
  m_logicalChannelNumber1.preShowEthereal( );
  m_logicalChannelNumber2.preShowEthereal( );
  m_skew.preShowEthereal( );
}

PString H245_H223SkewIndication::getSummary( void ) 
{
  return PString( "H223SkewIndication" );
}

void H245_H223SkewIndication::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_H223SkewIndication_logicalChannelNumber1, tvb, offset + m_logicalChannelNumber1.GetStartByte(), m_logicalChannelNumber1.GetByteLength() , m_logicalChannelNumber1.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_H223SkewIndication_logicalChannelNumber2, tvb, offset + m_logicalChannelNumber2.GetStartByte(), m_logicalChannelNumber2.GetByteLength() , m_logicalChannelNumber2.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_H223SkewIndication_skew, tvb, offset + m_skew.GetStartByte(), m_skew.GetByteLength() , m_skew.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// H2250MaximumSkewIndication
//

H245_H2250MaximumSkewIndication::H245_H2250MaximumSkewIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_maximumSkew.SetConstraints(PASN_Object::FixedConstraint, 0, 4095);
}


#ifndef PASN_NOPRINTON
void H245_H2250MaximumSkewIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "logicalChannelNumber1 = " << setprecision(indent) << m_logicalChannelNumber1 << '\n';
  strm << setw(indent+24) << "logicalChannelNumber2 = " << setprecision(indent) << m_logicalChannelNumber2 << '\n';
  strm << setw(indent+14) << "maximumSkew = " << setprecision(indent) << m_maximumSkew << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H2250MaximumSkewIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H2250MaximumSkewIndication::Class()), PInvalidCast);
#endif
  const H245_H2250MaximumSkewIndication & other = (const H245_H2250MaximumSkewIndication &)obj;

  Comparison result;

  if ((result = m_logicalChannelNumber1.Compare(other.m_logicalChannelNumber1)) != EqualTo)
    return result;
  if ((result = m_logicalChannelNumber2.Compare(other.m_logicalChannelNumber2)) != EqualTo)
    return result;
  if ((result = m_maximumSkew.Compare(other.m_maximumSkew)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H2250MaximumSkewIndication::GetDataLength() const
{
  return m_logicalChannelNumber1.GetObjectLength() +
         m_logicalChannelNumber2.GetObjectLength() +
         m_maximumSkew.GetObjectLength();
}


BOOL H245_H2250MaximumSkewIndication::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_logicalChannelNumber1.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_logicalChannelNumber2.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maximumSkew.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H2250MaximumSkewIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_logicalChannelNumber1.Encode(strm);
  m_logicalChannelNumber2.Encode(strm);
  m_maximumSkew.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_logicalChannelNumber1.Encode(strm);
  m_logicalChannelNumber2.Encode(strm);
  m_maximumSkew.Encode(strm);
}


PObject * H245_H2250MaximumSkewIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H2250MaximumSkewIndication::Class()), PInvalidCast);
#endif
  return new H245_H2250MaximumSkewIndication(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H2250MaximumSkewIndication::preShowEthereal( void )
{
  m_logicalChannelNumber1.preShowEthereal( );
  m_logicalChannelNumber2.preShowEthereal( );
  m_maximumSkew.preShowEthereal( );
}

PString H245_H2250MaximumSkewIndication::getSummary( void ) 
{
  return PString( "H2250MaximumSkewIndication" );
}

void H245_H2250MaximumSkewIndication::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_H2250MaximumSkewIndication_logicalChannelNumber1, tvb, offset + m_logicalChannelNumber1.GetStartByte(), m_logicalChannelNumber1.GetByteLength() , m_logicalChannelNumber1.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_H2250MaximumSkewIndication_logicalChannelNumber2, tvb, offset + m_logicalChannelNumber2.GetStartByte(), m_logicalChannelNumber2.GetByteLength() , m_logicalChannelNumber2.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_H2250MaximumSkewIndication_maximumSkew, tvb, offset + m_maximumSkew.GetStartByte(), m_maximumSkew.GetByteLength() , m_maximumSkew.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// MCLocationIndication
//

H245_MCLocationIndication::H245_MCLocationIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MCLocationIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "signalAddress = " << setprecision(indent) << m_signalAddress << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MCLocationIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MCLocationIndication::Class()), PInvalidCast);
#endif
  const H245_MCLocationIndication & other = (const H245_MCLocationIndication &)obj;

  Comparison result;

  if ((result = m_signalAddress.Compare(other.m_signalAddress)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MCLocationIndication::GetDataLength() const
{
  return m_signalAddress.GetObjectLength();
}


BOOL H245_MCLocationIndication::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_signalAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MCLocationIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_signalAddress.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_signalAddress.Encode(strm);
}


PObject * H245_MCLocationIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MCLocationIndication::Class()), PInvalidCast);
#endif
  return new H245_MCLocationIndication(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MCLocationIndication::preShowEthereal( void )
{
  m_signalAddress.preShowEthereal( );
}

PString H245_MCLocationIndication::getSummary( void ) 
{
  return PString( "MCLocationIndication" );
}

void H245_MCLocationIndication::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *signalAddress_tree = (proto_tree*) NULL;
  proto_item *signalAddress_ti = (proto_item*) NULL;
  signalAddress_ti = proto_tree_add_text( tree, tvb, offset + m_signalAddress.GetStartByte(), m_signalAddress.GetByteLength(), "signalAddress (%s)", ( const char* ) m_signalAddress.GetTagName() );
  signalAddress_tree = proto_item_add_subtree( signalAddress_ti, hCont->h245_0.ett_h245_MCLocationIndication_signalAddress );

  m_signalAddress.showEthereal( signalAddress_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// VendorIdentification
//

H245_VendorIdentification::H245_VendorIdentification(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_productNumber.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
  m_versionNumber.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_VendorIdentification::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "vendor = " << setprecision(indent) << m_vendor << '\n';
  if (HasOptionalField(e_productNumber))
    strm << setw(indent+16) << "productNumber = " << setprecision(indent) << m_productNumber << '\n';
  if (HasOptionalField(e_versionNumber))
    strm << setw(indent+16) << "versionNumber = " << setprecision(indent) << m_versionNumber << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_VendorIdentification::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_VendorIdentification::Class()), PInvalidCast);
#endif
  const H245_VendorIdentification & other = (const H245_VendorIdentification &)obj;

  Comparison result;

  if ((result = m_vendor.Compare(other.m_vendor)) != EqualTo)
    return result;
  if ((result = m_productNumber.Compare(other.m_productNumber)) != EqualTo)
    return result;
  if ((result = m_versionNumber.Compare(other.m_versionNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_VendorIdentification::GetDataLength() const
{
  return m_vendor.GetObjectLength() +
         m_productNumber.GetObjectLength() +
         m_versionNumber.GetObjectLength();
}


BOOL H245_VendorIdentification::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_vendor.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_productNumber ) && !m_productNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_versionNumber ) && !m_versionNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_VendorIdentification::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_vendor.Encode(strm);
  if (HasOptionalField(e_productNumber))
    m_productNumber.Encode(strm);
  if (HasOptionalField(e_versionNumber))
    m_versionNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_vendor.Encode(strm);
  if (HasOptionalField(e_productNumber))
    m_productNumber.Encode(strm);
  if (HasOptionalField(e_versionNumber))
    m_versionNumber.Encode(strm);
}


PObject * H245_VendorIdentification::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_VendorIdentification::Class()), PInvalidCast);
#endif
  return new H245_VendorIdentification(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_VendorIdentification::preShowEthereal( void )
{
  m_vendor.preShowEthereal( );
  if ( HasOptionalField( e_productNumber ) ) 
      m_productNumber.preShowEthereal( );
  if ( HasOptionalField( e_versionNumber ) ) 
      m_versionNumber.preShowEthereal( );
}

PString H245_VendorIdentification::getSummary( void ) 
{
  return PString( "VendorIdentification" );
}

void H245_VendorIdentification::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *vendor_tree = (proto_tree*) NULL;
  proto_item *vendor_ti = (proto_item*) NULL;
  vendor_ti = proto_tree_add_text( tree, tvb, offset + m_vendor.GetStartByte(), m_vendor.GetByteLength(), "vendor (%s)", ( const char* ) m_vendor.GetTagName() );
  vendor_tree = proto_item_add_subtree( vendor_ti, hCont->h245_0.ett_h245_VendorIdentification_vendor );

  m_vendor.showEthereal( vendor_tree, tvb, offset );

  if ( HasOptionalField( e_productNumber ) ) {
    char* pproductNumber = m_productNumber.getValue();
    proto_tree_add_string( tree, hCont->h245_0.hf_h245_VendorIdentification_productNumber, tvb, offset + m_productNumber.GetStartByte(), m_productNumber.GetByteLength() , pproductNumber );
    delete[] pproductNumber;
  }

  if ( HasOptionalField( e_versionNumber ) ) {
    char* pversionNumber = m_versionNumber.getValue();
    proto_tree_add_string( tree, hCont->h245_0.hf_h245_VendorIdentification_versionNumber, tvb, offset + m_versionNumber.GetStartByte(), m_versionNumber.GetByteLength() , pversionNumber );
    delete[] pversionNumber;
  }

}
#endif  //USE_FOR_ETHEREAL

//
// UserInputIndication
//

H245_UserInputIndication::H245_UserInputIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "alphanumeric "
        "userInputSupportIndication "
        "signal "
        "signalUpdate "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UserInputIndication::operator H245_NonStandardParameter &() const
#else
H245_UserInputIndication::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_UserInputIndication::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UserInputIndication::operator H245_UserInputIndication_userInputSupportIndication &() const
#else
H245_UserInputIndication::operator H245_UserInputIndication_userInputSupportIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_UserInputIndication_userInputSupportIndication::Class()), PInvalidCast);
#endif
  return *(H245_UserInputIndication_userInputSupportIndication *)choice;
}


H245_UserInputIndication::operator const H245_UserInputIndication_userInputSupportIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_UserInputIndication_userInputSupportIndication::Class()), PInvalidCast);
#endif
  return *(H245_UserInputIndication_userInputSupportIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UserInputIndication::operator H245_UserInputIndication_signal &() const
#else
H245_UserInputIndication::operator H245_UserInputIndication_signal &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_UserInputIndication_signal::Class()), PInvalidCast);
#endif
  return *(H245_UserInputIndication_signal *)choice;
}


H245_UserInputIndication::operator const H245_UserInputIndication_signal &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_UserInputIndication_signal::Class()), PInvalidCast);
#endif
  return *(H245_UserInputIndication_signal *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UserInputIndication::operator H245_UserInputIndication_signalUpdate &() const
#else
H245_UserInputIndication::operator H245_UserInputIndication_signalUpdate &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_UserInputIndication_signalUpdate::Class()), PInvalidCast);
#endif
  return *(H245_UserInputIndication_signalUpdate *)choice;
}


H245_UserInputIndication::operator const H245_UserInputIndication_signalUpdate &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_UserInputIndication_signalUpdate::Class()), PInvalidCast);
#endif
  return *(H245_UserInputIndication_signalUpdate *)choice;
}


BOOL H245_UserInputIndication::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_alphanumeric :
      choice = new PASN_GeneralString();
      return TRUE;
    case e_userInputSupportIndication :
      choice = new H245_UserInputIndication_userInputSupportIndication();
      return TRUE;
    case e_signal :
      choice = new H245_UserInputIndication_signal();
      return TRUE;
    case e_signalUpdate :
      choice = new H245_UserInputIndication_signalUpdate();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_UserInputIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UserInputIndication::Class()), PInvalidCast);
#endif
  return new H245_UserInputIndication(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_UserInputIndication::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_alphanumeric :
        ( ( PASN_GeneralString * ) choice )->preShowEthereal();
        break;
      case e_userInputSupportIndication :
        ( ( H245_UserInputIndication_userInputSupportIndication * ) choice )->preShowEthereal();
        break;
      case e_signal :
        ( ( H245_UserInputIndication_signal * ) choice )->preShowEthereal();
        break;
      case e_signalUpdate :
        ( ( H245_UserInputIndication_signalUpdate * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_UserInputIndication::getSummary( void ) 
{
  return PString( "UserInputIndication" );
}

void H245_UserInputIndication::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "alphanumeric" ) == 0 ) {
      char* pstring = ( ( PASN_GeneralString* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_UserInputIndication_alphanumeric, tvb, offset + ( ( PASN_GeneralString* ) choice) ->GetStartByte(), ( ( PASN_GeneralString* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_UserInputIndication_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// NonStandardIdentifier_h221NonStandard
//

H245_NonStandardIdentifier_h221NonStandard::H245_NonStandardIdentifier_h221NonStandard(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
  m_t35CountryCode.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
  m_t35Extension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
  m_manufacturerCode.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_NonStandardIdentifier_h221NonStandard::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "t35CountryCode = " << setprecision(indent) << m_t35CountryCode << '\n';
  strm << setw(indent+15) << "t35Extension = " << setprecision(indent) << m_t35Extension << '\n';
  strm << setw(indent+19) << "manufacturerCode = " << setprecision(indent) << m_manufacturerCode << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_NonStandardIdentifier_h221NonStandard::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_NonStandardIdentifier_h221NonStandard::Class()), PInvalidCast);
#endif
  const H245_NonStandardIdentifier_h221NonStandard & other = (const H245_NonStandardIdentifier_h221NonStandard &)obj;

  Comparison result;

  if ((result = m_t35CountryCode.Compare(other.m_t35CountryCode)) != EqualTo)
    return result;
  if ((result = m_t35Extension.Compare(other.m_t35Extension)) != EqualTo)
    return result;
  if ((result = m_manufacturerCode.Compare(other.m_manufacturerCode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NonStandardIdentifier_h221NonStandard::GetDataLength() const
{
  return m_t35CountryCode.GetObjectLength() +
         m_t35Extension.GetObjectLength() +
         m_manufacturerCode.GetObjectLength();
}


BOOL H245_NonStandardIdentifier_h221NonStandard::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_t35CountryCode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_t35Extension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_manufacturerCode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_NonStandardIdentifier_h221NonStandard::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_t35CountryCode.Encode(strm);
  m_t35Extension.Encode(strm);
  m_manufacturerCode.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_t35CountryCode.Encode(strm);
  m_t35Extension.Encode(strm);
  m_manufacturerCode.Encode(strm);
}


PObject * H245_NonStandardIdentifier_h221NonStandard::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NonStandardIdentifier_h221NonStandard::Class()), PInvalidCast);
#endif
  return new H245_NonStandardIdentifier_h221NonStandard(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NonStandardIdentifier_h221NonStandard::preShowEthereal( void )
{
  m_t35CountryCode.preShowEthereal( );
  m_t35Extension.preShowEthereal( );
  m_manufacturerCode.preShowEthereal( );
}

PString H245_NonStandardIdentifier_h221NonStandard::getSummary( void ) 
{
  return PString( "NonStandardIdentifier_h221NonStandard" );
}

void H245_NonStandardIdentifier_h221NonStandard::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_NonStandardIdentifier_h221NonStandard_t35CountryCode, tvb, offset + m_t35CountryCode.GetStartByte(), m_t35CountryCode.GetByteLength() , m_t35CountryCode.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_NonStandardIdentifier_h221NonStandard_t35Extension, tvb, offset + m_t35Extension.GetStartByte(), m_t35Extension.GetByteLength() , m_t35Extension.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_NonStandardIdentifier_h221NonStandard_manufacturerCode, tvb, offset + m_manufacturerCode.GetStartByte(), m_manufacturerCode.GetByteLength() , m_manufacturerCode.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// MasterSlaveDeterminationAck_decision
//

H245_MasterSlaveDeterminationAck_decision::H245_MasterSlaveDeterminationAck_decision(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
      , "master "
        "slave "
#endif
    )
{
}


BOOL H245_MasterSlaveDeterminationAck_decision::CreateObject()
{
  switch (tag) {
    case e_master :
    case e_slave :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_MasterSlaveDeterminationAck_decision::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MasterSlaveDeterminationAck_decision::Class()), PInvalidCast);
#endif
  return new H245_MasterSlaveDeterminationAck_decision(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MasterSlaveDeterminationAck_decision::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_master :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_slave :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_MasterSlaveDeterminationAck_decision::getSummary( void ) 
{
  return PString( "MasterSlaveDeterminationAck_decision" );
}

void H245_MasterSlaveDeterminationAck_decision::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "master" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_MasterSlaveDeterminationAck_decision_master, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "slave" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_MasterSlaveDeterminationAck_decision_slave, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// MasterSlaveDeterminationReject_cause
//

H245_MasterSlaveDeterminationReject_cause::H245_MasterSlaveDeterminationReject_cause(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
      , "identicalNumbers "
#endif
    )
{
}


BOOL H245_MasterSlaveDeterminationReject_cause::CreateObject()
{
  switch (tag) {
    case e_identicalNumbers :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_MasterSlaveDeterminationReject_cause::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MasterSlaveDeterminationReject_cause::Class()), PInvalidCast);
#endif
  return new H245_MasterSlaveDeterminationReject_cause(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MasterSlaveDeterminationReject_cause::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_identicalNumbers :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_MasterSlaveDeterminationReject_cause::getSummary( void ) 
{
  return PString( "MasterSlaveDeterminationReject_cause" );
}

void H245_MasterSlaveDeterminationReject_cause::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "identicalNumbers" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_MasterSlaveDeterminationReject_cause_identicalNumbers, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_CapabilityTableEntry
//

H245_ArrayOf_CapabilityTableEntry::H245_ArrayOf_CapabilityTableEntry(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_CapabilityTableEntry::CreateObject() const
{
  return new H245_CapabilityTableEntry;
}


H245_CapabilityTableEntry & H245_ArrayOf_CapabilityTableEntry::operator[](PINDEX i) const
{
  return (H245_CapabilityTableEntry &)array[i];
}


PObject * H245_ArrayOf_CapabilityTableEntry::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_CapabilityTableEntry::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_CapabilityTableEntry(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_CapabilityTableEntry::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_CapabilityTableEntry& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_CapabilityTableEntry::getSummary( void ) 
{
  return PString( "ArrayOf_CapabilityTableEntry" );
}

void H245_ArrayOf_CapabilityTableEntry::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_CapabilityTableEntry_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_CapabilityTableEntry_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_CapabilityTableEntry_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (CapabilityTableEntry)", i );
    ArrayOf_CapabilityTableEntry_tree = proto_item_add_subtree( ArrayOf_CapabilityTableEntry_ti, hCont->h245_0.ett_h245_ArrayOf_CapabilityTableEntry );
    array[i].showEthereal( ArrayOf_CapabilityTableEntry_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_CapabilityDescriptor
//

H245_ArrayOf_CapabilityDescriptor::H245_ArrayOf_CapabilityDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_CapabilityDescriptor::CreateObject() const
{
  return new H245_CapabilityDescriptor;
}


H245_CapabilityDescriptor & H245_ArrayOf_CapabilityDescriptor::operator[](PINDEX i) const
{
  return (H245_CapabilityDescriptor &)array[i];
}


PObject * H245_ArrayOf_CapabilityDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_CapabilityDescriptor::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_CapabilityDescriptor(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_CapabilityDescriptor::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_CapabilityDescriptor& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_CapabilityDescriptor::getSummary( void ) 
{
  return PString( "ArrayOf_CapabilityDescriptor" );
}

void H245_ArrayOf_CapabilityDescriptor::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_CapabilityDescriptor_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_CapabilityDescriptor_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_CapabilityDescriptor_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (CapabilityDescriptor)", i );
    ArrayOf_CapabilityDescriptor_tree = proto_item_add_subtree( ArrayOf_CapabilityDescriptor_ti, hCont->h245_0.ett_h245_ArrayOf_CapabilityDescriptor );
    array[i].showEthereal( ArrayOf_CapabilityDescriptor_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_AlternativeCapabilitySet
//

H245_ArrayOf_AlternativeCapabilitySet::H245_ArrayOf_AlternativeCapabilitySet(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_AlternativeCapabilitySet::CreateObject() const
{
  return new H245_AlternativeCapabilitySet;
}


H245_AlternativeCapabilitySet & H245_ArrayOf_AlternativeCapabilitySet::operator[](PINDEX i) const
{
  return (H245_AlternativeCapabilitySet &)array[i];
}


PObject * H245_ArrayOf_AlternativeCapabilitySet::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_AlternativeCapabilitySet::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_AlternativeCapabilitySet(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_AlternativeCapabilitySet::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_AlternativeCapabilitySet& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_AlternativeCapabilitySet::getSummary( void ) 
{
  return PString( "ArrayOf_AlternativeCapabilitySet" );
}

void H245_ArrayOf_AlternativeCapabilitySet::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_AlternativeCapabilitySet_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_AlternativeCapabilitySet_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_AlternativeCapabilitySet_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (AlternativeCapabilitySet)", i );
    ArrayOf_AlternativeCapabilitySet_tree = proto_item_add_subtree( ArrayOf_AlternativeCapabilitySet_ti, hCont->h245_0.ett_h245_ArrayOf_AlternativeCapabilitySet );
    array[i].showEthereal( ArrayOf_AlternativeCapabilitySet_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// TerminalCapabilitySetReject_cause
//

H245_TerminalCapabilitySetReject_cause::H245_TerminalCapabilitySetReject_cause(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "unspecified "
        "undefinedTableEntryUsed "
        "descriptorCapacityExceeded "
        "tableEntryCapacityExceeded "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_TerminalCapabilitySetReject_cause::operator H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded &() const
#else
H245_TerminalCapabilitySetReject_cause::operator H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded::Class()), PInvalidCast);
#endif
  return *(H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *)choice;
}


H245_TerminalCapabilitySetReject_cause::operator const H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded::Class()), PInvalidCast);
#endif
  return *(H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *)choice;
}


BOOL H245_TerminalCapabilitySetReject_cause::CreateObject()
{
  switch (tag) {
    case e_unspecified :
    case e_undefinedTableEntryUsed :
    case e_descriptorCapacityExceeded :
      choice = new PASN_Null();
      return TRUE;
    case e_tableEntryCapacityExceeded :
      choice = new H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_TerminalCapabilitySetReject_cause::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TerminalCapabilitySetReject_cause::Class()), PInvalidCast);
#endif
  return new H245_TerminalCapabilitySetReject_cause(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_TerminalCapabilitySetReject_cause::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_unspecified :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_undefinedTableEntryUsed :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_descriptorCapacityExceeded :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_tableEntryCapacityExceeded :
        ( ( H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_TerminalCapabilitySetReject_cause::getSummary( void ) 
{
  return PString( "TerminalCapabilitySetReject_cause" );
}

void H245_TerminalCapabilitySetReject_cause::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "unspecified" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_TerminalCapabilitySetReject_cause_unspecified, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "undefinedTableEntryUsed" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_TerminalCapabilitySetReject_cause_undefinedTableEntryUsed, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "descriptorCapacityExceeded" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_TerminalCapabilitySetReject_cause_descriptorCapacityExceeded, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_TerminalCapabilitySetReject_cause_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// Capability_h233EncryptionReceiveCapability
//

H245_Capability_h233EncryptionReceiveCapability::H245_Capability_h233EncryptionReceiveCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_h233IVResponseTime.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H245_Capability_h233EncryptionReceiveCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "h233IVResponseTime = " << setprecision(indent) << m_h233IVResponseTime << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_Capability_h233EncryptionReceiveCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_Capability_h233EncryptionReceiveCapability::Class()), PInvalidCast);
#endif
  const H245_Capability_h233EncryptionReceiveCapability & other = (const H245_Capability_h233EncryptionReceiveCapability &)obj;

  Comparison result;

  if ((result = m_h233IVResponseTime.Compare(other.m_h233IVResponseTime)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_Capability_h233EncryptionReceiveCapability::GetDataLength() const
{
  return m_h233IVResponseTime.GetObjectLength();
}


BOOL H245_Capability_h233EncryptionReceiveCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_h233IVResponseTime.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_Capability_h233EncryptionReceiveCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_h233IVResponseTime.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_h233IVResponseTime.Encode(strm);
}


PObject * H245_Capability_h233EncryptionReceiveCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_Capability_h233EncryptionReceiveCapability::Class()), PInvalidCast);
#endif
  return new H245_Capability_h233EncryptionReceiveCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_Capability_h233EncryptionReceiveCapability::preShowEthereal( void )
{
  m_h233IVResponseTime.preShowEthereal( );
}

PString H245_Capability_h233EncryptionReceiveCapability::getSummary( void ) 
{
  return PString( "Capability_h233EncryptionReceiveCapability" );
}

void H245_Capability_h233EncryptionReceiveCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_Capability_h233EncryptionReceiveCapability_h233IVResponseTime, tvb, offset + m_h233IVResponseTime.GetStartByte(), m_h233IVResponseTime.GetByteLength() , m_h233IVResponseTime.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// ArrayOf_VCCapability
//

H245_ArrayOf_VCCapability::H245_ArrayOf_VCCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_VCCapability::CreateObject() const
{
  return new H245_VCCapability;
}


H245_VCCapability & H245_ArrayOf_VCCapability::operator[](PINDEX i) const
{
  return (H245_VCCapability &)array[i];
}


PObject * H245_ArrayOf_VCCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_VCCapability::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_VCCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_VCCapability::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_VCCapability& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_VCCapability::getSummary( void ) 
{
  return PString( "ArrayOf_VCCapability" );
}

void H245_ArrayOf_VCCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_VCCapability_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_VCCapability_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_VCCapability_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (VCCapability)", i );
    ArrayOf_VCCapability_tree = proto_item_add_subtree( ArrayOf_VCCapability_ti, hCont->h245_0.ett_h245_ArrayOf_VCCapability );
    array[i].showEthereal( ArrayOf_VCCapability_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// VCCapability_aal1
//

H245_VCCapability_aal1::H245_VCCapability_aal1(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_VCCapability_aal1::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+20) << "nullClockRecovery = " << setprecision(indent) << m_nullClockRecovery << '\n';
  strm << setw(indent+20) << "srtsClockRecovery = " << setprecision(indent) << m_srtsClockRecovery << '\n';
  strm << setw(indent+24) << "adaptiveClockRecovery = " << setprecision(indent) << m_adaptiveClockRecovery << '\n';
  strm << setw(indent+22) << "nullErrorCorrection = " << setprecision(indent) << m_nullErrorCorrection << '\n';
  strm << setw(indent+18) << "longInterleaver = " << setprecision(indent) << m_longInterleaver << '\n';
  strm << setw(indent+19) << "shortInterleaver = " << setprecision(indent) << m_shortInterleaver << '\n';
  strm << setw(indent+22) << "errorCorrectionOnly = " << setprecision(indent) << m_errorCorrectionOnly << '\n';
  strm << setw(indent+25) << "structuredDataTransfer = " << setprecision(indent) << m_structuredDataTransfer << '\n';
  strm << setw(indent+23) << "partiallyFilledCells = " << setprecision(indent) << m_partiallyFilledCells << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_VCCapability_aal1::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_VCCapability_aal1::Class()), PInvalidCast);
#endif
  const H245_VCCapability_aal1 & other = (const H245_VCCapability_aal1 &)obj;

  Comparison result;

  if ((result = m_nullClockRecovery.Compare(other.m_nullClockRecovery)) != EqualTo)
    return result;
  if ((result = m_srtsClockRecovery.Compare(other.m_srtsClockRecovery)) != EqualTo)
    return result;
  if ((result = m_adaptiveClockRecovery.Compare(other.m_adaptiveClockRecovery)) != EqualTo)
    return result;
  if ((result = m_nullErrorCorrection.Compare(other.m_nullErrorCorrection)) != EqualTo)
    return result;
  if ((result = m_longInterleaver.Compare(other.m_longInterleaver)) != EqualTo)
    return result;
  if ((result = m_shortInterleaver.Compare(other.m_shortInterleaver)) != EqualTo)
    return result;
  if ((result = m_errorCorrectionOnly.Compare(other.m_errorCorrectionOnly)) != EqualTo)
    return result;
  if ((result = m_structuredDataTransfer.Compare(other.m_structuredDataTransfer)) != EqualTo)
    return result;
  if ((result = m_partiallyFilledCells.Compare(other.m_partiallyFilledCells)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_VCCapability_aal1::GetDataLength() const
{
  return m_nullClockRecovery.GetObjectLength() +
         m_srtsClockRecovery.GetObjectLength() +
         m_adaptiveClockRecovery.GetObjectLength() +
         m_nullErrorCorrection.GetObjectLength() +
         m_longInterleaver.GetObjectLength() +
         m_shortInterleaver.GetObjectLength() +
         m_errorCorrectionOnly.GetObjectLength() +
         m_structuredDataTransfer.GetObjectLength() +
         m_partiallyFilledCells.GetObjectLength();
}


BOOL H245_VCCapability_aal1::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_nullClockRecovery.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_srtsClockRecovery.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_adaptiveClockRecovery.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_nullErrorCorrection.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_longInterleaver.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_shortInterleaver.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_errorCorrectionOnly.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_structuredDataTransfer.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_partiallyFilledCells.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_VCCapability_aal1::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nullClockRecovery.Encode(strm);
  m_srtsClockRecovery.Encode(strm);
  m_adaptiveClockRecovery.Encode(strm);
  m_nullErrorCorrection.Encode(strm);
  m_longInterleaver.Encode(strm);
  m_shortInterleaver.Encode(strm);
  m_errorCorrectionOnly.Encode(strm);
  m_structuredDataTransfer.Encode(strm);
  m_partiallyFilledCells.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_nullClockRecovery.Encode(strm);
  m_srtsClockRecovery.Encode(strm);
  m_adaptiveClockRecovery.Encode(strm);
  m_nullErrorCorrection.Encode(strm);
  m_longInterleaver.Encode(strm);
  m_shortInterleaver.Encode(strm);
  m_errorCorrectionOnly.Encode(strm);
  m_structuredDataTransfer.Encode(strm);
  m_partiallyFilledCells.Encode(strm);
}


PObject * H245_VCCapability_aal1::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_VCCapability_aal1::Class()), PInvalidCast);
#endif
  return new H245_VCCapability_aal1(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_VCCapability_aal1::preShowEthereal( void )
{
  m_nullClockRecovery.preShowEthereal( );
  m_srtsClockRecovery.preShowEthereal( );
  m_adaptiveClockRecovery.preShowEthereal( );
  m_nullErrorCorrection.preShowEthereal( );
  m_longInterleaver.preShowEthereal( );
  m_shortInterleaver.preShowEthereal( );
  m_errorCorrectionOnly.preShowEthereal( );
  m_structuredDataTransfer.preShowEthereal( );
  m_partiallyFilledCells.preShowEthereal( );
}

PString H245_VCCapability_aal1::getSummary( void ) 
{
  return PString( "VCCapability_aal1" );
}

void H245_VCCapability_aal1::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_VCCapability_aal1_nullClockRecovery, tvb, offset + m_nullClockRecovery.GetStartByte(), m_nullClockRecovery.GetByteLength() , m_nullClockRecovery.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_VCCapability_aal1_srtsClockRecovery, tvb, offset + m_srtsClockRecovery.GetStartByte(), m_srtsClockRecovery.GetByteLength() , m_srtsClockRecovery.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_VCCapability_aal1_adaptiveClockRecovery, tvb, offset + m_adaptiveClockRecovery.GetStartByte(), m_adaptiveClockRecovery.GetByteLength() , m_adaptiveClockRecovery.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_VCCapability_aal1_nullErrorCorrection, tvb, offset + m_nullErrorCorrection.GetStartByte(), m_nullErrorCorrection.GetByteLength() , m_nullErrorCorrection.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_VCCapability_aal1_longInterleaver, tvb, offset + m_longInterleaver.GetStartByte(), m_longInterleaver.GetByteLength() , m_longInterleaver.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_VCCapability_aal1_shortInterleaver, tvb, offset + m_shortInterleaver.GetStartByte(), m_shortInterleaver.GetByteLength() , m_shortInterleaver.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_VCCapability_aal1_errorCorrectionOnly, tvb, offset + m_errorCorrectionOnly.GetStartByte(), m_errorCorrectionOnly.GetByteLength() , m_errorCorrectionOnly.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_VCCapability_aal1_structuredDataTransfer, tvb, offset + m_structuredDataTransfer.GetStartByte(), m_structuredDataTransfer.GetByteLength() , m_structuredDataTransfer.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_VCCapability_aal1_partiallyFilledCells, tvb, offset + m_partiallyFilledCells.GetStartByte(), m_partiallyFilledCells.GetByteLength() , m_partiallyFilledCells.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// VCCapability_aal5
//

H245_VCCapability_aal5::H245_VCCapability_aal5(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_forwardMaximumSDUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_backwardMaximumSDUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_VCCapability_aal5::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "forwardMaximumSDUSize = " << setprecision(indent) << m_forwardMaximumSDUSize << '\n';
  strm << setw(indent+25) << "backwardMaximumSDUSize = " << setprecision(indent) << m_backwardMaximumSDUSize << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_VCCapability_aal5::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_VCCapability_aal5::Class()), PInvalidCast);
#endif
  const H245_VCCapability_aal5 & other = (const H245_VCCapability_aal5 &)obj;

  Comparison result;

  if ((result = m_forwardMaximumSDUSize.Compare(other.m_forwardMaximumSDUSize)) != EqualTo)
    return result;
  if ((result = m_backwardMaximumSDUSize.Compare(other.m_backwardMaximumSDUSize)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_VCCapability_aal5::GetDataLength() const
{
  return m_forwardMaximumSDUSize.GetObjectLength() +
         m_backwardMaximumSDUSize.GetObjectLength();
}


BOOL H245_VCCapability_aal5::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_forwardMaximumSDUSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_backwardMaximumSDUSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_VCCapability_aal5::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardMaximumSDUSize.Encode(strm);
  m_backwardMaximumSDUSize.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_forwardMaximumSDUSize.Encode(strm);
  m_backwardMaximumSDUSize.Encode(strm);
}


PObject * H245_VCCapability_aal5::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_VCCapability_aal5::Class()), PInvalidCast);
#endif
  return new H245_VCCapability_aal5(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_VCCapability_aal5::preShowEthereal( void )
{
  m_forwardMaximumSDUSize.preShowEthereal( );
  m_backwardMaximumSDUSize.preShowEthereal( );
}

PString H245_VCCapability_aal5::getSummary( void ) 
{
  return PString( "VCCapability_aal5" );
}

void H245_VCCapability_aal5::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_VCCapability_aal5_forwardMaximumSDUSize, tvb, offset + m_forwardMaximumSDUSize.GetStartByte(), m_forwardMaximumSDUSize.GetByteLength() , m_forwardMaximumSDUSize.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_VCCapability_aal5_backwardMaximumSDUSize, tvb, offset + m_backwardMaximumSDUSize.GetStartByte(), m_backwardMaximumSDUSize.GetByteLength() , m_backwardMaximumSDUSize.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// H223Capability_h223MultiplexTableCapability
//

H245_H223Capability_h223MultiplexTableCapability::H245_H223Capability_h223MultiplexTableCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
      , "basic "
        "enhanced "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223Capability_h223MultiplexTableCapability::operator H245_H223Capability_h223MultiplexTableCapability_enhanced &() const
#else
H245_H223Capability_h223MultiplexTableCapability::operator H245_H223Capability_h223MultiplexTableCapability_enhanced &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223Capability_h223MultiplexTableCapability_enhanced::Class()), PInvalidCast);
#endif
  return *(H245_H223Capability_h223MultiplexTableCapability_enhanced *)choice;
}


H245_H223Capability_h223MultiplexTableCapability::operator const H245_H223Capability_h223MultiplexTableCapability_enhanced &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223Capability_h223MultiplexTableCapability_enhanced::Class()), PInvalidCast);
#endif
  return *(H245_H223Capability_h223MultiplexTableCapability_enhanced *)choice;
}


BOOL H245_H223Capability_h223MultiplexTableCapability::CreateObject()
{
  switch (tag) {
    case e_basic :
      choice = new PASN_Null();
      return TRUE;
    case e_enhanced :
      choice = new H245_H223Capability_h223MultiplexTableCapability_enhanced();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_H223Capability_h223MultiplexTableCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223Capability_h223MultiplexTableCapability::Class()), PInvalidCast);
#endif
  return new H245_H223Capability_h223MultiplexTableCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223Capability_h223MultiplexTableCapability::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_basic :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_enhanced :
        ( ( H245_H223Capability_h223MultiplexTableCapability_enhanced * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_H223Capability_h223MultiplexTableCapability::getSummary( void ) 
{
  return PString( "H223Capability_h223MultiplexTableCapability" );
}

void H245_H223Capability_h223MultiplexTableCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "basic" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_H223Capability_h223MultiplexTableCapability_basic, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_H223Capability_h223MultiplexTableCapability_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H223Capability_mobileOperationTransmitCapability
//

H245_H223Capability_mobileOperationTransmitCapability::H245_H223Capability_mobileOperationTransmitCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_H223Capability_mobileOperationTransmitCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "modeChangeCapability = " << setprecision(indent) << m_modeChangeCapability << '\n';
  strm << setw(indent+13) << "h223AnnexA = " << setprecision(indent) << m_h223AnnexA << '\n';
  strm << setw(indent+23) << "h223AnnexADoubleFlag = " << setprecision(indent) << m_h223AnnexADoubleFlag << '\n';
  strm << setw(indent+13) << "h223AnnexB = " << setprecision(indent) << m_h223AnnexB << '\n';
  strm << setw(indent+23) << "h223AnnexBwithHeader = " << setprecision(indent) << m_h223AnnexBwithHeader << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H223Capability_mobileOperationTransmitCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H223Capability_mobileOperationTransmitCapability::Class()), PInvalidCast);
#endif
  const H245_H223Capability_mobileOperationTransmitCapability & other = (const H245_H223Capability_mobileOperationTransmitCapability &)obj;

  Comparison result;

  if ((result = m_modeChangeCapability.Compare(other.m_modeChangeCapability)) != EqualTo)
    return result;
  if ((result = m_h223AnnexA.Compare(other.m_h223AnnexA)) != EqualTo)
    return result;
  if ((result = m_h223AnnexADoubleFlag.Compare(other.m_h223AnnexADoubleFlag)) != EqualTo)
    return result;
  if ((result = m_h223AnnexB.Compare(other.m_h223AnnexB)) != EqualTo)
    return result;
  if ((result = m_h223AnnexBwithHeader.Compare(other.m_h223AnnexBwithHeader)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223Capability_mobileOperationTransmitCapability::GetDataLength() const
{
  return m_modeChangeCapability.GetObjectLength() +
         m_h223AnnexA.GetObjectLength() +
         m_h223AnnexADoubleFlag.GetObjectLength() +
         m_h223AnnexB.GetObjectLength() +
         m_h223AnnexBwithHeader.GetObjectLength();
}


BOOL H245_H223Capability_mobileOperationTransmitCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_modeChangeCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_h223AnnexA.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_h223AnnexADoubleFlag.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_h223AnnexB.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_h223AnnexBwithHeader.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H223Capability_mobileOperationTransmitCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_modeChangeCapability.Encode(strm);
  m_h223AnnexA.Encode(strm);
  m_h223AnnexADoubleFlag.Encode(strm);
  m_h223AnnexB.Encode(strm);
  m_h223AnnexBwithHeader.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_modeChangeCapability.Encode(strm);
  m_h223AnnexA.Encode(strm);
  m_h223AnnexADoubleFlag.Encode(strm);
  m_h223AnnexB.Encode(strm);
  m_h223AnnexBwithHeader.Encode(strm);
}


PObject * H245_H223Capability_mobileOperationTransmitCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223Capability_mobileOperationTransmitCapability::Class()), PInvalidCast);
#endif
  return new H245_H223Capability_mobileOperationTransmitCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223Capability_mobileOperationTransmitCapability::preShowEthereal( void )
{
  m_modeChangeCapability.preShowEthereal( );
  m_h223AnnexA.preShowEthereal( );
  m_h223AnnexADoubleFlag.preShowEthereal( );
  m_h223AnnexB.preShowEthereal( );
  m_h223AnnexBwithHeader.preShowEthereal( );
}

PString H245_H223Capability_mobileOperationTransmitCapability::getSummary( void ) 
{
  return PString( "H223Capability_mobileOperationTransmitCapability" );
}

void H245_H223Capability_mobileOperationTransmitCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H223Capability_mobileOperationTransmitCapability_modeChangeCapability, tvb, offset + m_modeChangeCapability.GetStartByte(), m_modeChangeCapability.GetByteLength() , m_modeChangeCapability.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H223Capability_mobileOperationTransmitCapability_h223AnnexA, tvb, offset + m_h223AnnexA.GetStartByte(), m_h223AnnexA.GetByteLength() , m_h223AnnexA.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H223Capability_mobileOperationTransmitCapability_h223AnnexADoubleFlag, tvb, offset + m_h223AnnexADoubleFlag.GetStartByte(), m_h223AnnexADoubleFlag.GetByteLength() , m_h223AnnexADoubleFlag.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H223Capability_mobileOperationTransmitCapability_h223AnnexB, tvb, offset + m_h223AnnexB.GetStartByte(), m_h223AnnexB.GetByteLength() , m_h223AnnexB.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H223Capability_mobileOperationTransmitCapability_h223AnnexBwithHeader, tvb, offset + m_h223AnnexBwithHeader.GetStartByte(), m_h223AnnexBwithHeader.GetByteLength() , m_h223AnnexBwithHeader.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// H2250Capability_mcCapability
//

H245_H2250Capability_mcCapability::H245_H2250Capability_mcCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_H2250Capability_mcCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+26) << "centralizedConferenceMC = " << setprecision(indent) << m_centralizedConferenceMC << '\n';
  strm << setw(indent+28) << "decentralizedConferenceMC = " << setprecision(indent) << m_decentralizedConferenceMC << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H2250Capability_mcCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H2250Capability_mcCapability::Class()), PInvalidCast);
#endif
  const H245_H2250Capability_mcCapability & other = (const H245_H2250Capability_mcCapability &)obj;

  Comparison result;

  if ((result = m_centralizedConferenceMC.Compare(other.m_centralizedConferenceMC)) != EqualTo)
    return result;
  if ((result = m_decentralizedConferenceMC.Compare(other.m_decentralizedConferenceMC)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H2250Capability_mcCapability::GetDataLength() const
{
  return m_centralizedConferenceMC.GetObjectLength() +
         m_decentralizedConferenceMC.GetObjectLength();
}


BOOL H245_H2250Capability_mcCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_centralizedConferenceMC.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_decentralizedConferenceMC.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H2250Capability_mcCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_centralizedConferenceMC.Encode(strm);
  m_decentralizedConferenceMC.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_centralizedConferenceMC.Encode(strm);
  m_decentralizedConferenceMC.Encode(strm);
}


PObject * H245_H2250Capability_mcCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H2250Capability_mcCapability::Class()), PInvalidCast);
#endif
  return new H245_H2250Capability_mcCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H2250Capability_mcCapability::preShowEthereal( void )
{
  m_centralizedConferenceMC.preShowEthereal( );
  m_decentralizedConferenceMC.preShowEthereal( );
}

PString H245_H2250Capability_mcCapability::getSummary( void ) 
{
  return PString( "H2250Capability_mcCapability" );
}

void H245_H2250Capability_mcCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H2250Capability_mcCapability_centralizedConferenceMC, tvb, offset + m_centralizedConferenceMC.GetStartByte(), m_centralizedConferenceMC.GetByteLength() , m_centralizedConferenceMC.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_H2250Capability_mcCapability_decentralizedConferenceMC, tvb, offset + m_decentralizedConferenceMC.GetStartByte(), m_decentralizedConferenceMC.GetByteLength() , m_decentralizedConferenceMC.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// ArrayOf_RedundancyEncodingCapability
//

H245_ArrayOf_RedundancyEncodingCapability::H245_ArrayOf_RedundancyEncodingCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_RedundancyEncodingCapability::CreateObject() const
{
  return new H245_RedundancyEncodingCapability;
}


H245_RedundancyEncodingCapability & H245_ArrayOf_RedundancyEncodingCapability::operator[](PINDEX i) const
{
  return (H245_RedundancyEncodingCapability &)array[i];
}


PObject * H245_ArrayOf_RedundancyEncodingCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_RedundancyEncodingCapability::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_RedundancyEncodingCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_RedundancyEncodingCapability::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_RedundancyEncodingCapability& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_RedundancyEncodingCapability::getSummary( void ) 
{
  return PString( "ArrayOf_RedundancyEncodingCapability" );
}

void H245_ArrayOf_RedundancyEncodingCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_RedundancyEncodingCapability_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_RedundancyEncodingCapability_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_RedundancyEncodingCapability_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (RedundancyEncodingCapability)", i );
    ArrayOf_RedundancyEncodingCapability_tree = proto_item_add_subtree( ArrayOf_RedundancyEncodingCapability_ti, hCont->h245_0.ett_h245_ArrayOf_RedundancyEncodingCapability );
    array[i].showEthereal( ArrayOf_RedundancyEncodingCapability_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_RTPPayloadType
//

H245_ArrayOf_RTPPayloadType::H245_ArrayOf_RTPPayloadType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_RTPPayloadType::CreateObject() const
{
  return new H245_RTPPayloadType;
}


H245_RTPPayloadType & H245_ArrayOf_RTPPayloadType::operator[](PINDEX i) const
{
  return (H245_RTPPayloadType &)array[i];
}


PObject * H245_ArrayOf_RTPPayloadType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_RTPPayloadType::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_RTPPayloadType(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_RTPPayloadType::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_RTPPayloadType& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_RTPPayloadType::getSummary( void ) 
{
  return PString( "ArrayOf_RTPPayloadType" );
}

void H245_ArrayOf_RTPPayloadType::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_RTPPayloadType_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_RTPPayloadType_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_RTPPayloadType_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (RTPPayloadType)", i );
    ArrayOf_RTPPayloadType_tree = proto_item_add_subtree( ArrayOf_RTPPayloadType_ti, hCont->h245_0.ett_h245_ArrayOf_RTPPayloadType );
    array[i].showEthereal( ArrayOf_RTPPayloadType_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_QOSCapability
//

H245_ArrayOf_QOSCapability::H245_ArrayOf_QOSCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_QOSCapability::CreateObject() const
{
  return new H245_QOSCapability;
}


H245_QOSCapability & H245_ArrayOf_QOSCapability::operator[](PINDEX i) const
{
  return (H245_QOSCapability &)array[i];
}


PObject * H245_ArrayOf_QOSCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_QOSCapability::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_QOSCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_QOSCapability::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_QOSCapability& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_QOSCapability::getSummary( void ) 
{
  return PString( "ArrayOf_QOSCapability" );
}

void H245_ArrayOf_QOSCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_QOSCapability_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_QOSCapability_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_QOSCapability_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (QOSCapability)", i );
    ArrayOf_QOSCapability_tree = proto_item_add_subtree( ArrayOf_QOSCapability_ti, hCont->h245_0.ett_h245_ArrayOf_QOSCapability );
    array[i].showEthereal( ArrayOf_QOSCapability_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_MediaChannelCapability
//

H245_ArrayOf_MediaChannelCapability::H245_ArrayOf_MediaChannelCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_MediaChannelCapability::CreateObject() const
{
  return new H245_MediaChannelCapability;
}


H245_MediaChannelCapability & H245_ArrayOf_MediaChannelCapability::operator[](PINDEX i) const
{
  return (H245_MediaChannelCapability &)array[i];
}


PObject * H245_ArrayOf_MediaChannelCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_MediaChannelCapability::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_MediaChannelCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_MediaChannelCapability::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_MediaChannelCapability& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_MediaChannelCapability::getSummary( void ) 
{
  return PString( "ArrayOf_MediaChannelCapability" );
}

void H245_ArrayOf_MediaChannelCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_MediaChannelCapability_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_MediaChannelCapability_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_MediaChannelCapability_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (MediaChannelCapability)", i );
    ArrayOf_MediaChannelCapability_tree = proto_item_add_subtree( ArrayOf_MediaChannelCapability_ti, hCont->h245_0.ett_h245_ArrayOf_MediaChannelCapability );
    array[i].showEthereal( ArrayOf_MediaChannelCapability_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_CapabilityTableEntryNumber
//

H245_ArrayOf_CapabilityTableEntryNumber::H245_ArrayOf_CapabilityTableEntryNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_CapabilityTableEntryNumber::CreateObject() const
{
  return new H245_CapabilityTableEntryNumber;
}


H245_CapabilityTableEntryNumber & H245_ArrayOf_CapabilityTableEntryNumber::operator[](PINDEX i) const
{
  return (H245_CapabilityTableEntryNumber &)array[i];
}


PObject * H245_ArrayOf_CapabilityTableEntryNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_CapabilityTableEntryNumber::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_CapabilityTableEntryNumber(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_CapabilityTableEntryNumber::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_CapabilityTableEntryNumber& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_CapabilityTableEntryNumber::getSummary( void ) 
{
  return PString( "ArrayOf_CapabilityTableEntryNumber" );
}

void H245_ArrayOf_CapabilityTableEntryNumber::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  for (int i=0; i < array.GetSize(); i++ ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_ArrayOf_CapabilityTableEntryNumber_array, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), ( (PASN_Integer& ) array[i] ).GetValue() );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// RTPH263VideoRedundancyEncoding_frameToThreadMapping
//

H245_RTPH263VideoRedundancyEncoding_frameToThreadMapping::H245_RTPH263VideoRedundancyEncoding_frameToThreadMapping(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "roundrobin "
        "custom "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RTPH263VideoRedundancyEncoding_frameToThreadMapping::operator H245_ArrayOf_RTPH263VideoRedundancyFrameMapping &() const
#else
H245_RTPH263VideoRedundancyEncoding_frameToThreadMapping::operator H245_ArrayOf_RTPH263VideoRedundancyFrameMapping &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ArrayOf_RTPH263VideoRedundancyFrameMapping::Class()), PInvalidCast);
#endif
  return *(H245_ArrayOf_RTPH263VideoRedundancyFrameMapping *)choice;
}


H245_RTPH263VideoRedundancyEncoding_frameToThreadMapping::operator const H245_ArrayOf_RTPH263VideoRedundancyFrameMapping &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ArrayOf_RTPH263VideoRedundancyFrameMapping::Class()), PInvalidCast);
#endif
  return *(H245_ArrayOf_RTPH263VideoRedundancyFrameMapping *)choice;
}


BOOL H245_RTPH263VideoRedundancyEncoding_frameToThreadMapping::CreateObject()
{
  switch (tag) {
    case e_roundrobin :
      choice = new PASN_Null();
      return TRUE;
    case e_custom :
      choice = new H245_ArrayOf_RTPH263VideoRedundancyFrameMapping();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_RTPH263VideoRedundancyEncoding_frameToThreadMapping::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RTPH263VideoRedundancyEncoding_frameToThreadMapping::Class()), PInvalidCast);
#endif
  return new H245_RTPH263VideoRedundancyEncoding_frameToThreadMapping(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RTPH263VideoRedundancyEncoding_frameToThreadMapping::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_roundrobin :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_custom :
        ( ( H245_ArrayOf_RTPH263VideoRedundancyFrameMapping * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_RTPH263VideoRedundancyEncoding_frameToThreadMapping::getSummary( void ) 
{
  return PString( "RTPH263VideoRedundancyEncoding_frameToThreadMapping" );
}

void H245_RTPH263VideoRedundancyEncoding_frameToThreadMapping::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "roundrobin" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_RTPH263VideoRedundancyEncoding_frameToThreadMapping_roundrobin, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_RTPH263VideoRedundancyEncoding_frameToThreadMapping_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// RTPH263VideoRedundancyEncoding_containedThreads
//

H245_RTPH263VideoRedundancyEncoding_containedThreads::H245_RTPH263VideoRedundancyEncoding_containedThreads(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


PASN_Object * H245_RTPH263VideoRedundancyEncoding_containedThreads::CreateObject() const
{
  PASN_Integer * obj = new PASN_Integer;
  obj->SetConstraints(PASN_Object::FixedConstraint, 0, 15);
  return obj;
}


PASN_Integer & H245_RTPH263VideoRedundancyEncoding_containedThreads::operator[](PINDEX i) const
{
  return (PASN_Integer &)array[i];
}


PObject * H245_RTPH263VideoRedundancyEncoding_containedThreads::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RTPH263VideoRedundancyEncoding_containedThreads::Class()), PInvalidCast);
#endif
  return new H245_RTPH263VideoRedundancyEncoding_containedThreads(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RTPH263VideoRedundancyEncoding_containedThreads::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (PASN_Integer& ) array[i] ).preShowEthereal();
  }
}

PString H245_RTPH263VideoRedundancyEncoding_containedThreads::getSummary( void ) 
{
  return PString( "RTPH263VideoRedundancyEncoding_containedThreads" );
}

void H245_RTPH263VideoRedundancyEncoding_containedThreads::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  for (int i=0; i < array.GetSize(); i++ ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_RTPH263VideoRedundancyEncoding_containedThreads_array, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), ( (PASN_Integer& ) array[i] ).GetValue() );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// RTPH263VideoRedundancyFrameMapping_frameSequence
//

H245_RTPH263VideoRedundancyFrameMapping_frameSequence::H245_RTPH263VideoRedundancyFrameMapping_frameSequence(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


PASN_Object * H245_RTPH263VideoRedundancyFrameMapping_frameSequence::CreateObject() const
{
  PASN_Integer * obj = new PASN_Integer;
  obj->SetConstraints(PASN_Object::FixedConstraint, 0, 255);
  return obj;
}


PASN_Integer & H245_RTPH263VideoRedundancyFrameMapping_frameSequence::operator[](PINDEX i) const
{
  return (PASN_Integer &)array[i];
}


PObject * H245_RTPH263VideoRedundancyFrameMapping_frameSequence::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RTPH263VideoRedundancyFrameMapping_frameSequence::Class()), PInvalidCast);
#endif
  return new H245_RTPH263VideoRedundancyFrameMapping_frameSequence(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RTPH263VideoRedundancyFrameMapping_frameSequence::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (PASN_Integer& ) array[i] ).preShowEthereal();
  }
}

PString H245_RTPH263VideoRedundancyFrameMapping_frameSequence::getSummary( void ) 
{
  return PString( "RTPH263VideoRedundancyFrameMapping_frameSequence" );
}

void H245_RTPH263VideoRedundancyFrameMapping_frameSequence::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  for (int i=0; i < array.GetSize(); i++ ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_RTPH263VideoRedundancyFrameMapping_frameSequence_array, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), ( (PASN_Integer& ) array[i] ).GetValue() );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_MediaDistributionCapability
//

H245_ArrayOf_MediaDistributionCapability::H245_ArrayOf_MediaDistributionCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_MediaDistributionCapability::CreateObject() const
{
  return new H245_MediaDistributionCapability;
}


H245_MediaDistributionCapability & H245_ArrayOf_MediaDistributionCapability::operator[](PINDEX i) const
{
  return (H245_MediaDistributionCapability &)array[i];
}


PObject * H245_ArrayOf_MediaDistributionCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_MediaDistributionCapability::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_MediaDistributionCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_MediaDistributionCapability::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_MediaDistributionCapability& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_MediaDistributionCapability::getSummary( void ) 
{
  return PString( "ArrayOf_MediaDistributionCapability" );
}

void H245_ArrayOf_MediaDistributionCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_MediaDistributionCapability_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_MediaDistributionCapability_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_MediaDistributionCapability_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (MediaDistributionCapability)", i );
    ArrayOf_MediaDistributionCapability_tree = proto_item_add_subtree( ArrayOf_MediaDistributionCapability_ti, hCont->h245_0.ett_h245_ArrayOf_MediaDistributionCapability );
    array[i].showEthereal( ArrayOf_MediaDistributionCapability_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_DataApplicationCapability
//

H245_ArrayOf_DataApplicationCapability::H245_ArrayOf_DataApplicationCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_DataApplicationCapability::CreateObject() const
{
  return new H245_DataApplicationCapability;
}


H245_DataApplicationCapability & H245_ArrayOf_DataApplicationCapability::operator[](PINDEX i) const
{
  return (H245_DataApplicationCapability &)array[i];
}


PObject * H245_ArrayOf_DataApplicationCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_DataApplicationCapability::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_DataApplicationCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_DataApplicationCapability::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_DataApplicationCapability& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_DataApplicationCapability::getSummary( void ) 
{
  return PString( "ArrayOf_DataApplicationCapability" );
}

void H245_ArrayOf_DataApplicationCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_DataApplicationCapability_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_DataApplicationCapability_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_DataApplicationCapability_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (DataApplicationCapability)", i );
    ArrayOf_DataApplicationCapability_tree = proto_item_add_subtree( ArrayOf_DataApplicationCapability_ti, hCont->h245_0.ett_h245_ArrayOf_DataApplicationCapability );
    array[i].showEthereal( ArrayOf_DataApplicationCapability_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_EnhancementOptions
//

H245_ArrayOf_EnhancementOptions::H245_ArrayOf_EnhancementOptions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_EnhancementOptions::CreateObject() const
{
  return new H245_EnhancementOptions;
}


H245_EnhancementOptions & H245_ArrayOf_EnhancementOptions::operator[](PINDEX i) const
{
  return (H245_EnhancementOptions &)array[i];
}


PObject * H245_ArrayOf_EnhancementOptions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_EnhancementOptions::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_EnhancementOptions(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_EnhancementOptions::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_EnhancementOptions& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_EnhancementOptions::getSummary( void ) 
{
  return PString( "ArrayOf_EnhancementOptions" );
}

void H245_ArrayOf_EnhancementOptions::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_EnhancementOptions_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_EnhancementOptions_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_EnhancementOptions_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (EnhancementOptions)", i );
    ArrayOf_EnhancementOptions_tree = proto_item_add_subtree( ArrayOf_EnhancementOptions_ti, hCont->h245_0.ett_h245_ArrayOf_EnhancementOptions );
    array[i].showEthereal( ArrayOf_EnhancementOptions_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_BEnhancementParameters
//

H245_ArrayOf_BEnhancementParameters::H245_ArrayOf_BEnhancementParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_BEnhancementParameters::CreateObject() const
{
  return new H245_BEnhancementParameters;
}


H245_BEnhancementParameters & H245_ArrayOf_BEnhancementParameters::operator[](PINDEX i) const
{
  return (H245_BEnhancementParameters &)array[i];
}


PObject * H245_ArrayOf_BEnhancementParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_BEnhancementParameters::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_BEnhancementParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_BEnhancementParameters::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_BEnhancementParameters& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_BEnhancementParameters::getSummary( void ) 
{
  return PString( "ArrayOf_BEnhancementParameters" );
}

void H245_ArrayOf_BEnhancementParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_BEnhancementParameters_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_BEnhancementParameters_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_BEnhancementParameters_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (BEnhancementParameters)", i );
    ArrayOf_BEnhancementParameters_tree = proto_item_add_subtree( ArrayOf_BEnhancementParameters_ti, hCont->h245_0.ett_h245_ArrayOf_BEnhancementParameters );
    array[i].showEthereal( ArrayOf_BEnhancementParameters_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_CustomPictureClockFrequency
//

H245_ArrayOf_CustomPictureClockFrequency::H245_ArrayOf_CustomPictureClockFrequency(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_CustomPictureClockFrequency::CreateObject() const
{
  return new H245_CustomPictureClockFrequency;
}


H245_CustomPictureClockFrequency & H245_ArrayOf_CustomPictureClockFrequency::operator[](PINDEX i) const
{
  return (H245_CustomPictureClockFrequency &)array[i];
}


PObject * H245_ArrayOf_CustomPictureClockFrequency::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_CustomPictureClockFrequency::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_CustomPictureClockFrequency(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_CustomPictureClockFrequency::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_CustomPictureClockFrequency& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_CustomPictureClockFrequency::getSummary( void ) 
{
  return PString( "ArrayOf_CustomPictureClockFrequency" );
}

void H245_ArrayOf_CustomPictureClockFrequency::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_CustomPictureClockFrequency_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_CustomPictureClockFrequency_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_CustomPictureClockFrequency_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (CustomPictureClockFrequency)", i );
    ArrayOf_CustomPictureClockFrequency_tree = proto_item_add_subtree( ArrayOf_CustomPictureClockFrequency_ti, hCont->h245_0.ett_h245_ArrayOf_CustomPictureClockFrequency );
    array[i].showEthereal( ArrayOf_CustomPictureClockFrequency_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_CustomPictureFormat
//

H245_ArrayOf_CustomPictureFormat::H245_ArrayOf_CustomPictureFormat(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_CustomPictureFormat::CreateObject() const
{
  return new H245_CustomPictureFormat;
}


H245_CustomPictureFormat & H245_ArrayOf_CustomPictureFormat::operator[](PINDEX i) const
{
  return (H245_CustomPictureFormat &)array[i];
}


PObject * H245_ArrayOf_CustomPictureFormat::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_CustomPictureFormat::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_CustomPictureFormat(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_CustomPictureFormat::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_CustomPictureFormat& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_CustomPictureFormat::getSummary( void ) 
{
  return PString( "ArrayOf_CustomPictureFormat" );
}

void H245_ArrayOf_CustomPictureFormat::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_CustomPictureFormat_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_CustomPictureFormat_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_CustomPictureFormat_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (CustomPictureFormat)", i );
    ArrayOf_CustomPictureFormat_tree = proto_item_add_subtree( ArrayOf_CustomPictureFormat_ti, hCont->h245_0.ett_h245_ArrayOf_CustomPictureFormat );
    array[i].showEthereal( ArrayOf_CustomPictureFormat_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_H263VideoModeCombos
//

H245_ArrayOf_H263VideoModeCombos::H245_ArrayOf_H263VideoModeCombos(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_H263VideoModeCombos::CreateObject() const
{
  return new H245_H263VideoModeCombos;
}


H245_H263VideoModeCombos & H245_ArrayOf_H263VideoModeCombos::operator[](PINDEX i) const
{
  return (H245_H263VideoModeCombos &)array[i];
}


PObject * H245_ArrayOf_H263VideoModeCombos::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_H263VideoModeCombos::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_H263VideoModeCombos(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_H263VideoModeCombos::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_H263VideoModeCombos& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_H263VideoModeCombos::getSummary( void ) 
{
  return PString( "ArrayOf_H263VideoModeCombos" );
}

void H245_ArrayOf_H263VideoModeCombos::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_H263VideoModeCombos_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_H263VideoModeCombos_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_H263VideoModeCombos_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (H263VideoModeCombos)", i );
    ArrayOf_H263VideoModeCombos_tree = proto_item_add_subtree( ArrayOf_H263VideoModeCombos_ti, hCont->h245_0.ett_h245_ArrayOf_H263VideoModeCombos );
    array[i].showEthereal( ArrayOf_H263VideoModeCombos_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// RefPictureSelection_additionalPictureMemory
//

H245_RefPictureSelection_additionalPictureMemory::H245_RefPictureSelection_additionalPictureMemory(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 6, TRUE, 0)
{
  m_sqcifAdditionalPictureMemory.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
  m_qcifAdditionalPictureMemory.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
  m_cifAdditionalPictureMemory.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
  m_cif4AdditionalPictureMemory.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
  m_cif16AdditionalPictureMemory.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
  m_bigCpfAdditionalPictureMemory.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_RefPictureSelection_additionalPictureMemory::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_sqcifAdditionalPictureMemory))
    strm << setw(indent+31) << "sqcifAdditionalPictureMemory = " << setprecision(indent) << m_sqcifAdditionalPictureMemory << '\n';
  if (HasOptionalField(e_qcifAdditionalPictureMemory))
    strm << setw(indent+30) << "qcifAdditionalPictureMemory = " << setprecision(indent) << m_qcifAdditionalPictureMemory << '\n';
  if (HasOptionalField(e_cifAdditionalPictureMemory))
    strm << setw(indent+29) << "cifAdditionalPictureMemory = " << setprecision(indent) << m_cifAdditionalPictureMemory << '\n';
  if (HasOptionalField(e_cif4AdditionalPictureMemory))
    strm << setw(indent+30) << "cif4AdditionalPictureMemory = " << setprecision(indent) << m_cif4AdditionalPictureMemory << '\n';
  if (HasOptionalField(e_cif16AdditionalPictureMemory))
    strm << setw(indent+31) << "cif16AdditionalPictureMemory = " << setprecision(indent) << m_cif16AdditionalPictureMemory << '\n';
  if (HasOptionalField(e_bigCpfAdditionalPictureMemory))
    strm << setw(indent+32) << "bigCpfAdditionalPictureMemory = " << setprecision(indent) << m_bigCpfAdditionalPictureMemory << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RefPictureSelection_additionalPictureMemory::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RefPictureSelection_additionalPictureMemory::Class()), PInvalidCast);
#endif
  const H245_RefPictureSelection_additionalPictureMemory & other = (const H245_RefPictureSelection_additionalPictureMemory &)obj;

  Comparison result;

  if ((result = m_sqcifAdditionalPictureMemory.Compare(other.m_sqcifAdditionalPictureMemory)) != EqualTo)
    return result;
  if ((result = m_qcifAdditionalPictureMemory.Compare(other.m_qcifAdditionalPictureMemory)) != EqualTo)
    return result;
  if ((result = m_cifAdditionalPictureMemory.Compare(other.m_cifAdditionalPictureMemory)) != EqualTo)
    return result;
  if ((result = m_cif4AdditionalPictureMemory.Compare(other.m_cif4AdditionalPictureMemory)) != EqualTo)
    return result;
  if ((result = m_cif16AdditionalPictureMemory.Compare(other.m_cif16AdditionalPictureMemory)) != EqualTo)
    return result;
  if ((result = m_bigCpfAdditionalPictureMemory.Compare(other.m_bigCpfAdditionalPictureMemory)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RefPictureSelection_additionalPictureMemory::GetDataLength() const
{
  return m_sqcifAdditionalPictureMemory.GetObjectLength() +
         m_qcifAdditionalPictureMemory.GetObjectLength() +
         m_cifAdditionalPictureMemory.GetObjectLength() +
         m_cif4AdditionalPictureMemory.GetObjectLength() +
         m_cif16AdditionalPictureMemory.GetObjectLength() +
         m_bigCpfAdditionalPictureMemory.GetObjectLength();
}


BOOL H245_RefPictureSelection_additionalPictureMemory::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_sqcifAdditionalPictureMemory ) && !m_sqcifAdditionalPictureMemory.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_qcifAdditionalPictureMemory ) && !m_qcifAdditionalPictureMemory.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_cifAdditionalPictureMemory ) && !m_cifAdditionalPictureMemory.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_cif4AdditionalPictureMemory ) && !m_cif4AdditionalPictureMemory.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_cif16AdditionalPictureMemory ) && !m_cif16AdditionalPictureMemory.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_bigCpfAdditionalPictureMemory ) && !m_bigCpfAdditionalPictureMemory.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RefPictureSelection_additionalPictureMemory::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_sqcifAdditionalPictureMemory))
    m_sqcifAdditionalPictureMemory.Encode(strm);
  if (HasOptionalField(e_qcifAdditionalPictureMemory))
    m_qcifAdditionalPictureMemory.Encode(strm);
  if (HasOptionalField(e_cifAdditionalPictureMemory))
    m_cifAdditionalPictureMemory.Encode(strm);
  if (HasOptionalField(e_cif4AdditionalPictureMemory))
    m_cif4AdditionalPictureMemory.Encode(strm);
  if (HasOptionalField(e_cif16AdditionalPictureMemory))
    m_cif16AdditionalPictureMemory.Encode(strm);
  if (HasOptionalField(e_bigCpfAdditionalPictureMemory))
    m_bigCpfAdditionalPictureMemory.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_sqcifAdditionalPictureMemory))
    m_sqcifAdditionalPictureMemory.Encode(strm);
  if (HasOptionalField(e_qcifAdditionalPictureMemory))
    m_qcifAdditionalPictureMemory.Encode(strm);
  if (HasOptionalField(e_cifAdditionalPictureMemory))
    m_cifAdditionalPictureMemory.Encode(strm);
  if (HasOptionalField(e_cif4AdditionalPictureMemory))
    m_cif4AdditionalPictureMemory.Encode(strm);
  if (HasOptionalField(e_cif16AdditionalPictureMemory))
    m_cif16AdditionalPictureMemory.Encode(strm);
  if (HasOptionalField(e_bigCpfAdditionalPictureMemory))
    m_bigCpfAdditionalPictureMemory.Encode(strm);
}


PObject * H245_RefPictureSelection_additionalPictureMemory::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RefPictureSelection_additionalPictureMemory::Class()), PInvalidCast);
#endif
  return new H245_RefPictureSelection_additionalPictureMemory(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RefPictureSelection_additionalPictureMemory::preShowEthereal( void )
{
  if ( HasOptionalField( e_sqcifAdditionalPictureMemory ) ) 
      m_sqcifAdditionalPictureMemory.preShowEthereal( );
  if ( HasOptionalField( e_qcifAdditionalPictureMemory ) ) 
      m_qcifAdditionalPictureMemory.preShowEthereal( );
  if ( HasOptionalField( e_cifAdditionalPictureMemory ) ) 
      m_cifAdditionalPictureMemory.preShowEthereal( );
  if ( HasOptionalField( e_cif4AdditionalPictureMemory ) ) 
      m_cif4AdditionalPictureMemory.preShowEthereal( );
  if ( HasOptionalField( e_cif16AdditionalPictureMemory ) ) 
      m_cif16AdditionalPictureMemory.preShowEthereal( );
  if ( HasOptionalField( e_bigCpfAdditionalPictureMemory ) ) 
      m_bigCpfAdditionalPictureMemory.preShowEthereal( );
}

PString H245_RefPictureSelection_additionalPictureMemory::getSummary( void ) 
{
  return PString( "RefPictureSelection_additionalPictureMemory" );
}

void H245_RefPictureSelection_additionalPictureMemory::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_sqcifAdditionalPictureMemory ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory, tvb, offset + m_sqcifAdditionalPictureMemory.GetStartByte(), m_sqcifAdditionalPictureMemory.GetByteLength() , m_sqcifAdditionalPictureMemory.GetValue() );
  }

  if ( HasOptionalField( e_qcifAdditionalPictureMemory ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory, tvb, offset + m_qcifAdditionalPictureMemory.GetStartByte(), m_qcifAdditionalPictureMemory.GetByteLength() , m_qcifAdditionalPictureMemory.GetValue() );
  }

  if ( HasOptionalField( e_cifAdditionalPictureMemory ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory, tvb, offset + m_cifAdditionalPictureMemory.GetStartByte(), m_cifAdditionalPictureMemory.GetByteLength() , m_cifAdditionalPictureMemory.GetValue() );
  }

  if ( HasOptionalField( e_cif4AdditionalPictureMemory ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory, tvb, offset + m_cif4AdditionalPictureMemory.GetStartByte(), m_cif4AdditionalPictureMemory.GetByteLength() , m_cif4AdditionalPictureMemory.GetValue() );
  }

  if ( HasOptionalField( e_cif16AdditionalPictureMemory ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory, tvb, offset + m_cif16AdditionalPictureMemory.GetStartByte(), m_cif16AdditionalPictureMemory.GetByteLength() , m_cif16AdditionalPictureMemory.GetValue() );
  }

  if ( HasOptionalField( e_bigCpfAdditionalPictureMemory ) ) {
    proto_tree_add_uint( tree, hCont->h245_0.hf_h245_RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory, tvb, offset + m_bigCpfAdditionalPictureMemory.GetStartByte(), m_bigCpfAdditionalPictureMemory.GetByteLength() , m_bigCpfAdditionalPictureMemory.GetValue() );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// RefPictureSelection_videoBackChannelSend
//

H245_RefPictureSelection_videoBackChannelSend::H245_RefPictureSelection_videoBackChannelSend(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
      , "none "
        "ackMessageOnly "
        "nackMessageOnly "
        "ackOrNackMessageOnly "
        "ackAndNackMessage "
#endif
    )
{
}


BOOL H245_RefPictureSelection_videoBackChannelSend::CreateObject()
{
  switch (tag) {
    case e_none :
    case e_ackMessageOnly :
    case e_nackMessageOnly :
    case e_ackOrNackMessageOnly :
    case e_ackAndNackMessage :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_RefPictureSelection_videoBackChannelSend::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RefPictureSelection_videoBackChannelSend::Class()), PInvalidCast);
#endif
  return new H245_RefPictureSelection_videoBackChannelSend(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RefPictureSelection_videoBackChannelSend::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_none :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_ackMessageOnly :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_nackMessageOnly :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_ackOrNackMessageOnly :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_ackAndNackMessage :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_RefPictureSelection_videoBackChannelSend::getSummary( void ) 
{
  return PString( "RefPictureSelection_videoBackChannelSend" );
}

void H245_RefPictureSelection_videoBackChannelSend::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "none" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_RefPictureSelection_videoBackChannelSend_none, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "ackMessageOnly" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_RefPictureSelection_videoBackChannelSend_ackMessageOnly, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "nackMessageOnly" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_RefPictureSelection_videoBackChannelSend_nackMessageOnly, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "ackOrNackMessageOnly" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_RefPictureSelection_videoBackChannelSend_ackOrNackMessageOnly, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "ackAndNackMessage" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_RefPictureSelection_videoBackChannelSend_ackAndNackMessage, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// CustomPictureFormat_pixelAspectInformation
//

H245_CustomPictureFormat_pixelAspectInformation::H245_CustomPictureFormat_pixelAspectInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "anyPixelAspectRatio "
        "pixelAspectCode "
        "extendedPAR "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CustomPictureFormat_pixelAspectInformation::operator H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode &() const
#else
H245_CustomPictureFormat_pixelAspectInformation::operator H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode::Class()), PInvalidCast);
#endif
  return *(H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode *)choice;
}


H245_CustomPictureFormat_pixelAspectInformation::operator const H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode::Class()), PInvalidCast);
#endif
  return *(H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CustomPictureFormat_pixelAspectInformation::operator H245_CustomPictureFormat_pixelAspectInformation_extendedPAR &() const
#else
H245_CustomPictureFormat_pixelAspectInformation::operator H245_CustomPictureFormat_pixelAspectInformation_extendedPAR &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_CustomPictureFormat_pixelAspectInformation_extendedPAR::Class()), PInvalidCast);
#endif
  return *(H245_CustomPictureFormat_pixelAspectInformation_extendedPAR *)choice;
}


H245_CustomPictureFormat_pixelAspectInformation::operator const H245_CustomPictureFormat_pixelAspectInformation_extendedPAR &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_CustomPictureFormat_pixelAspectInformation_extendedPAR::Class()), PInvalidCast);
#endif
  return *(H245_CustomPictureFormat_pixelAspectInformation_extendedPAR *)choice;
}


BOOL H245_CustomPictureFormat_pixelAspectInformation::CreateObject()
{
  switch (tag) {
    case e_anyPixelAspectRatio :
      choice = new PASN_Boolean();
      return TRUE;
    case e_pixelAspectCode :
      choice = new H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode();
      return TRUE;
    case e_extendedPAR :
      choice = new H245_CustomPictureFormat_pixelAspectInformation_extendedPAR();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_CustomPictureFormat_pixelAspectInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CustomPictureFormat_pixelAspectInformation::Class()), PInvalidCast);
#endif
  return new H245_CustomPictureFormat_pixelAspectInformation(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CustomPictureFormat_pixelAspectInformation::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_anyPixelAspectRatio :
        ( ( PASN_Boolean * ) choice )->preShowEthereal();
        break;
      case e_pixelAspectCode :
        ( ( H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode * ) choice )->preShowEthereal();
        break;
      case e_extendedPAR :
        ( ( H245_CustomPictureFormat_pixelAspectInformation_extendedPAR * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_CustomPictureFormat_pixelAspectInformation::getSummary( void ) 
{
  return PString( "CustomPictureFormat_pixelAspectInformation" );
}

void H245_CustomPictureFormat_pixelAspectInformation::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "anyPixelAspectRatio" ) == 0 ) {
    proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_CustomPictureFormat_pixelAspectInformation_anyPixelAspectRatio, tvb, offset + ( ( PASN_Boolean* ) choice) ->GetStartByte(), ( ( PASN_Boolean* ) choice) ->GetByteLength(),  ( ( PASN_Boolean* ) choice) ->GetValue() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_CustomPictureFormat_pixelAspectInformation_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_H263ModeComboFlags
//

H245_ArrayOf_H263ModeComboFlags::H245_ArrayOf_H263ModeComboFlags(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_H263ModeComboFlags::CreateObject() const
{
  return new H245_H263ModeComboFlags;
}


H245_H263ModeComboFlags & H245_ArrayOf_H263ModeComboFlags::operator[](PINDEX i) const
{
  return (H245_H263ModeComboFlags &)array[i];
}


PObject * H245_ArrayOf_H263ModeComboFlags::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_H263ModeComboFlags::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_H263ModeComboFlags(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_H263ModeComboFlags::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_H263ModeComboFlags& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_H263ModeComboFlags::getSummary( void ) 
{
  return PString( "ArrayOf_H263ModeComboFlags" );
}

void H245_ArrayOf_H263ModeComboFlags::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_H263ModeComboFlags_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_H263ModeComboFlags_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_H263ModeComboFlags_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (H263ModeComboFlags)", i );
    ArrayOf_H263ModeComboFlags_tree = proto_item_add_subtree( ArrayOf_H263ModeComboFlags_ti, hCont->h245_0.ett_h245_ArrayOf_H263ModeComboFlags );
    array[i].showEthereal( ArrayOf_H263ModeComboFlags_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// AudioCapability_g7231
//

H245_AudioCapability_g7231::H245_AudioCapability_g7231(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
  m_maxAl_sduAudioFrames.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_AudioCapability_g7231::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "maxAl_sduAudioFrames = " << setprecision(indent) << m_maxAl_sduAudioFrames << '\n';
  strm << setw(indent+21) << "silenceSuppression = " << setprecision(indent) << m_silenceSuppression << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_AudioCapability_g7231::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_AudioCapability_g7231::Class()), PInvalidCast);
#endif
  const H245_AudioCapability_g7231 & other = (const H245_AudioCapability_g7231 &)obj;

  Comparison result;

  if ((result = m_maxAl_sduAudioFrames.Compare(other.m_maxAl_sduAudioFrames)) != EqualTo)
    return result;
  if ((result = m_silenceSuppression.Compare(other.m_silenceSuppression)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_AudioCapability_g7231::GetDataLength() const
{
  return m_maxAl_sduAudioFrames.GetObjectLength() +
         m_silenceSuppression.GetObjectLength();
}


BOOL H245_AudioCapability_g7231::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maxAl_sduAudioFrames.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_silenceSuppression.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_AudioCapability_g7231::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_maxAl_sduAudioFrames.Encode(strm);
  m_silenceSuppression.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_maxAl_sduAudioFrames.Encode(strm);
  m_silenceSuppression.Encode(strm);
}


PObject * H245_AudioCapability_g7231::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_AudioCapability_g7231::Class()), PInvalidCast);
#endif
  return new H245_AudioCapability_g7231(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_AudioCapability_g7231::preShowEthereal( void )
{
  m_maxAl_sduAudioFrames.preShowEthereal( );
  m_silenceSuppression.preShowEthereal( );
}

PString H245_AudioCapability_g7231::getSummary( void ) 
{
  return PString( "AudioCapability_g7231" );
}

void H245_AudioCapability_g7231::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_AudioCapability_g7231_maxAl_sduAudioFrames, tvb, offset + m_maxAl_sduAudioFrames.GetStartByte(), m_maxAl_sduAudioFrames.GetByteLength() , m_maxAl_sduAudioFrames.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_AudioCapability_g7231_silenceSuppression, tvb, offset + m_silenceSuppression.GetStartByte(), m_silenceSuppression.GetByteLength() , m_silenceSuppression.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// G7231AnnexCCapability_g723AnnexCAudioMode
//

H245_G7231AnnexCCapability_g723AnnexCAudioMode::H245_G7231AnnexCCapability_g723AnnexCAudioMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_highRateMode0.SetConstraints(PASN_Object::FixedConstraint, 27, 78);
  m_highRateMode1.SetConstraints(PASN_Object::FixedConstraint, 27, 78);
  m_lowRateMode0.SetConstraints(PASN_Object::FixedConstraint, 23, 66);
  m_lowRateMode1.SetConstraints(PASN_Object::FixedConstraint, 23, 66);
  m_sidMode0.SetConstraints(PASN_Object::FixedConstraint, 6, 17);
  m_sidMode1.SetConstraints(PASN_Object::FixedConstraint, 6, 17);
}


#ifndef PASN_NOPRINTON
void H245_G7231AnnexCCapability_g723AnnexCAudioMode::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "highRateMode0 = " << setprecision(indent) << m_highRateMode0 << '\n';
  strm << setw(indent+16) << "highRateMode1 = " << setprecision(indent) << m_highRateMode1 << '\n';
  strm << setw(indent+15) << "lowRateMode0 = " << setprecision(indent) << m_lowRateMode0 << '\n';
  strm << setw(indent+15) << "lowRateMode1 = " << setprecision(indent) << m_lowRateMode1 << '\n';
  strm << setw(indent+11) << "sidMode0 = " << setprecision(indent) << m_sidMode0 << '\n';
  strm << setw(indent+11) << "sidMode1 = " << setprecision(indent) << m_sidMode1 << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_G7231AnnexCCapability_g723AnnexCAudioMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_G7231AnnexCCapability_g723AnnexCAudioMode::Class()), PInvalidCast);
#endif
  const H245_G7231AnnexCCapability_g723AnnexCAudioMode & other = (const H245_G7231AnnexCCapability_g723AnnexCAudioMode &)obj;

  Comparison result;

  if ((result = m_highRateMode0.Compare(other.m_highRateMode0)) != EqualTo)
    return result;
  if ((result = m_highRateMode1.Compare(other.m_highRateMode1)) != EqualTo)
    return result;
  if ((result = m_lowRateMode0.Compare(other.m_lowRateMode0)) != EqualTo)
    return result;
  if ((result = m_lowRateMode1.Compare(other.m_lowRateMode1)) != EqualTo)
    return result;
  if ((result = m_sidMode0.Compare(other.m_sidMode0)) != EqualTo)
    return result;
  if ((result = m_sidMode1.Compare(other.m_sidMode1)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_G7231AnnexCCapability_g723AnnexCAudioMode::GetDataLength() const
{
  return m_highRateMode0.GetObjectLength() +
         m_highRateMode1.GetObjectLength() +
         m_lowRateMode0.GetObjectLength() +
         m_lowRateMode1.GetObjectLength() +
         m_sidMode0.GetObjectLength() +
         m_sidMode1.GetObjectLength();
}


BOOL H245_G7231AnnexCCapability_g723AnnexCAudioMode::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_highRateMode0.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_highRateMode1.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_lowRateMode0.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_lowRateMode1.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sidMode0.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sidMode1.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_G7231AnnexCCapability_g723AnnexCAudioMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_highRateMode0.Encode(strm);
  m_highRateMode1.Encode(strm);
  m_lowRateMode0.Encode(strm);
  m_lowRateMode1.Encode(strm);
  m_sidMode0.Encode(strm);
  m_sidMode1.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_highRateMode0.Encode(strm);
  m_highRateMode1.Encode(strm);
  m_lowRateMode0.Encode(strm);
  m_lowRateMode1.Encode(strm);
  m_sidMode0.Encode(strm);
  m_sidMode1.Encode(strm);
}


PObject * H245_G7231AnnexCCapability_g723AnnexCAudioMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_G7231AnnexCCapability_g723AnnexCAudioMode::Class()), PInvalidCast);
#endif
  return new H245_G7231AnnexCCapability_g723AnnexCAudioMode(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_G7231AnnexCCapability_g723AnnexCAudioMode::preShowEthereal( void )
{
  m_highRateMode0.preShowEthereal( );
  m_highRateMode1.preShowEthereal( );
  m_lowRateMode0.preShowEthereal( );
  m_lowRateMode1.preShowEthereal( );
  m_sidMode0.preShowEthereal( );
  m_sidMode1.preShowEthereal( );
}

PString H245_G7231AnnexCCapability_g723AnnexCAudioMode::getSummary( void ) 
{
  return PString( "G7231AnnexCCapability_g723AnnexCAudioMode" );
}

void H245_G7231AnnexCCapability_g723AnnexCAudioMode::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode0, tvb, offset + m_highRateMode0.GetStartByte(), m_highRateMode0.GetByteLength() , m_highRateMode0.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode1, tvb, offset + m_highRateMode1.GetStartByte(), m_highRateMode1.GetByteLength() , m_highRateMode1.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode0, tvb, offset + m_lowRateMode0.GetStartByte(), m_lowRateMode0.GetByteLength() , m_lowRateMode0.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode1, tvb, offset + m_lowRateMode1.GetStartByte(), m_lowRateMode1.GetByteLength() , m_lowRateMode1.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_G7231AnnexCCapability_g723AnnexCAudioMode_sidMode0, tvb, offset + m_sidMode0.GetStartByte(), m_sidMode0.GetByteLength() , m_sidMode0.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_0.hf_h245_G7231AnnexCCapability_g723AnnexCAudioMode_sidMode1, tvb, offset + m_sidMode1.GetStartByte(), m_sidMode1.GetByteLength() , m_sidMode1.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// DataApplicationCapability_application
//

H245_DataApplicationCapability_application::H245_DataApplicationCapability_application(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 10, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "t120 "
        "dsm_cc "
        "userData "
        "t84 "
        "t434 "
        "h224 "
        "nlpid "
        "dsvdControl "
        "h222DataPartitioning "
        "t30fax "
        "t140 "
        "t38fax "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataApplicationCapability_application::operator H245_NonStandardParameter &() const
#else
H245_DataApplicationCapability_application::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_DataApplicationCapability_application::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataApplicationCapability_application::operator H245_DataProtocolCapability &() const
#else
H245_DataApplicationCapability_application::operator H245_DataProtocolCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataProtocolCapability::Class()), PInvalidCast);
#endif
  return *(H245_DataProtocolCapability *)choice;
}


H245_DataApplicationCapability_application::operator const H245_DataProtocolCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataProtocolCapability::Class()), PInvalidCast);
#endif
  return *(H245_DataProtocolCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataApplicationCapability_application::operator H245_DataApplicationCapability_application_t84 &() const
#else
H245_DataApplicationCapability_application::operator H245_DataApplicationCapability_application_t84 &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataApplicationCapability_application_t84::Class()), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability_application_t84 *)choice;
}


H245_DataApplicationCapability_application::operator const H245_DataApplicationCapability_application_t84 &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataApplicationCapability_application_t84::Class()), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability_application_t84 *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataApplicationCapability_application::operator H245_DataApplicationCapability_application_nlpid &() const
#else
H245_DataApplicationCapability_application::operator H245_DataApplicationCapability_application_nlpid &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataApplicationCapability_application_nlpid::Class()), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability_application_nlpid *)choice;
}


H245_DataApplicationCapability_application::operator const H245_DataApplicationCapability_application_nlpid &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataApplicationCapability_application_nlpid::Class()), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability_application_nlpid *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataApplicationCapability_application::operator H245_DataApplicationCapability_application_t38fax &() const
#else
H245_DataApplicationCapability_application::operator H245_DataApplicationCapability_application_t38fax &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataApplicationCapability_application_t38fax::Class()), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability_application_t38fax *)choice;
}


H245_DataApplicationCapability_application::operator const H245_DataApplicationCapability_application_t38fax &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataApplicationCapability_application_t38fax::Class()), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability_application_t38fax *)choice;
}


BOOL H245_DataApplicationCapability_application::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_t120 :
    case e_dsm_cc :
    case e_userData :
    case e_t434 :
    case e_h224 :
    case e_h222DataPartitioning :
    case e_t30fax :
    case e_t140 :
      choice = new H245_DataProtocolCapability();
      return TRUE;
    case e_t84 :
      choice = new H245_DataApplicationCapability_application_t84();
      return TRUE;
    case e_nlpid :
      choice = new H245_DataApplicationCapability_application_nlpid();
      return TRUE;
    case e_dsvdControl :
      choice = new PASN_Null();
      return TRUE;
    case e_t38fax :
      choice = new H245_DataApplicationCapability_application_t38fax();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_DataApplicationCapability_application::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataApplicationCapability_application::Class()), PInvalidCast);
#endif
  return new H245_DataApplicationCapability_application(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_DataApplicationCapability_application::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_t120 :
        ( ( H245_DataProtocolCapability * ) choice )->preShowEthereal();
        break;
      case e_dsm_cc :
        ( ( H245_DataProtocolCapability * ) choice )->preShowEthereal();
        break;
      case e_userData :
        ( ( H245_DataProtocolCapability * ) choice )->preShowEthereal();
        break;
      case e_t84 :
        ( ( H245_DataApplicationCapability_application_t84 * ) choice )->preShowEthereal();
        break;
      case e_t434 :
        ( ( H245_DataProtocolCapability * ) choice )->preShowEthereal();
        break;
      case e_h224 :
        ( ( H245_DataProtocolCapability * ) choice )->preShowEthereal();
        break;
      case e_nlpid :
        ( ( H245_DataApplicationCapability_application_nlpid * ) choice )->preShowEthereal();
        break;
      case e_dsvdControl :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_h222DataPartitioning :
        ( ( H245_DataProtocolCapability * ) choice )->preShowEthereal();
        break;
      case e_t30fax :
        ( ( H245_DataProtocolCapability * ) choice )->preShowEthereal();
        break;
      case e_t140 :
        ( ( H245_DataProtocolCapability * ) choice )->preShowEthereal();
        break;
      case e_t38fax :
        ( ( H245_DataApplicationCapability_application_t38fax * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_DataApplicationCapability_application::getSummary( void ) 
{
  return PString( "DataApplicationCapability_application" );
}

void H245_DataApplicationCapability_application::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "dsvdControl" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_0.hf_h245_DataApplicationCapability_application_dsvdControl, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_DataApplicationCapability_application_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// DataProtocolCapability_v76wCompression
//

H245_DataProtocolCapability_v76wCompression::H245_DataProtocolCapability_v76wCompression(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "transmitCompression "
        "receiveCompression "
        "transmitAndReceiveCompression "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataProtocolCapability_v76wCompression::operator H245_CompressionType &() const
#else
H245_DataProtocolCapability_v76wCompression::operator H245_CompressionType &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_CompressionType::Class()), PInvalidCast);
#endif
  return *(H245_CompressionType *)choice;
}


H245_DataProtocolCapability_v76wCompression::operator const H245_CompressionType &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_CompressionType::Class()), PInvalidCast);
#endif
  return *(H245_CompressionType *)choice;
}


BOOL H245_DataProtocolCapability_v76wCompression::CreateObject()
{
  switch (tag) {
    case e_transmitCompression :
    case e_receiveCompression :
    case e_transmitAndReceiveCompression :
      choice = new H245_CompressionType();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_DataProtocolCapability_v76wCompression::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataProtocolCapability_v76wCompression::Class()), PInvalidCast);
#endif
  return new H245_DataProtocolCapability_v76wCompression(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_DataProtocolCapability_v76wCompression::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_transmitCompression :
        ( ( H245_CompressionType * ) choice )->preShowEthereal();
        break;
      case e_receiveCompression :
        ( ( H245_CompressionType * ) choice )->preShowEthereal();
        break;
      case e_transmitAndReceiveCompression :
        ( ( H245_CompressionType * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_DataProtocolCapability_v76wCompression::getSummary( void ) 
{
  return PString( "DataProtocolCapability_v76wCompression" );
}

void H245_DataProtocolCapability_v76wCompression::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_0.ett_h245_DataProtocolCapability_v76wCompression_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// T84Profile_t84Restricted
//

H245_T84Profile_t84Restricted::H245_T84Profile_t84Restricted(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_T84Profile_t84Restricted::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "qcif = " << setprecision(indent) << m_qcif << '\n';
  strm << setw(indent+6) << "cif = " << setprecision(indent) << m_cif << '\n';
  strm << setw(indent+13) << "ccir601Seq = " << setprecision(indent) << m_ccir601Seq << '\n';
  strm << setw(indent+14) << "ccir601Prog = " << setprecision(indent) << m_ccir601Prog << '\n';
  strm << setw(indent+10) << "hdtvSeq = " << setprecision(indent) << m_hdtvSeq << '\n';
  strm << setw(indent+11) << "hdtvProg = " << setprecision(indent) << m_hdtvProg << '\n';
  strm << setw(indent+18) << "g3FacsMH200x100 = " << setprecision(indent) << m_g3FacsMH200x100 << '\n';
  strm << setw(indent+18) << "g3FacsMH200x200 = " << setprecision(indent) << m_g3FacsMH200x200 << '\n';
  strm << setw(indent+19) << "g4FacsMMR200x100 = " << setprecision(indent) << m_g4FacsMMR200x100 << '\n';
  strm << setw(indent+19) << "g4FacsMMR200x200 = " << setprecision(indent) << m_g4FacsMMR200x200 << '\n';
  strm << setw(indent+17) << "jbig200x200Seq = " << setprecision(indent) << m_jbig200x200Seq << '\n';
  strm << setw(indent+18) << "jbig200x200Prog = " << setprecision(indent) << m_jbig200x200Prog << '\n';
  strm << setw(indent+17) << "jbig300x300Seq = " << setprecision(indent) << m_jbig300x300Seq << '\n';
  strm << setw(indent+18) << "jbig300x300Prog = " << setprecision(indent) << m_jbig300x300Prog << '\n';
  strm << setw(indent+14) << "digPhotoLow = " << setprecision(indent) << m_digPhotoLow << '\n';
  strm << setw(indent+17) << "digPhotoMedSeq = " << setprecision(indent) << m_digPhotoMedSeq << '\n';
  strm << setw(indent+18) << "digPhotoMedProg = " << setprecision(indent) << m_digPhotoMedProg << '\n';
  strm << setw(indent+18) << "digPhotoHighSeq = " << setprecision(indent) << m_digPhotoHighSeq << '\n';
  strm << setw(indent+19) << "digPhotoHighProg = " << setprecision(indent) << m_digPhotoHighProg << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_T84Profile_t84Restricted::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_T84Profile_t84Restricted::Class()), PInvalidCast);
#endif
  const H245_T84Profile_t84Restricted & other = (const H245_T84Profile_t84Restricted &)obj;

  Comparison result;

  if ((result = m_qcif.Compare(other.m_qcif)) != EqualTo)
    return result;
  if ((result = m_cif.Compare(other.m_cif)) != EqualTo)
    return result;
  if ((result = m_ccir601Seq.Compare(other.m_ccir601Seq)) != EqualTo)
    return result;
  if ((result = m_ccir601Prog.Compare(other.m_ccir601Prog)) != EqualTo)
    return result;
  if ((result = m_hdtvSeq.Compare(other.m_hdtvSeq)) != EqualTo)
    return result;
  if ((result = m_hdtvProg.Compare(other.m_hdtvProg)) != EqualTo)
    return result;
  if ((result = m_g3FacsMH200x100.Compare(other.m_g3FacsMH200x100)) != EqualTo)
    return result;
  if ((result = m_g3FacsMH200x200.Compare(other.m_g3FacsMH200x200)) != EqualTo)
    return result;
  if ((result = m_g4FacsMMR200x100.Compare(other.m_g4FacsMMR200x100)) != EqualTo)
    return result;
  if ((result = m_g4FacsMMR200x200.Compare(other.m_g4FacsMMR200x200)) != EqualTo)
    return result;
  if ((result = m_jbig200x200Seq.Compare(other.m_jbig200x200Seq)) != EqualTo)
    return result;
  if ((result = m_jbig200x200Prog.Compare(other.m_jbig200x200Prog)) != EqualTo)
    return result;
  if ((result = m_jbig300x300Seq.Compare(other.m_jbig300x300Seq)) != EqualTo)
    return result;
  if ((result = m_jbig300x300Prog.Compare(other.m_jbig300x300Prog)) != EqualTo)
    return result;
  if ((result = m_digPhotoLow.Compare(other.m_digPhotoLow)) != EqualTo)
    return result;
  if ((result = m_digPhotoMedSeq.Compare(other.m_digPhotoMedSeq)) != EqualTo)
    return result;
  if ((result = m_digPhotoMedProg.Compare(other.m_digPhotoMedProg)) != EqualTo)
    return result;
  if ((result = m_digPhotoHighSeq.Compare(other.m_digPhotoHighSeq)) != EqualTo)
    return result;
  if ((result = m_digPhotoHighProg.Compare(other.m_digPhotoHighProg)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_T84Profile_t84Restricted::GetDataLength() const
{
  return m_qcif.GetObjectLength() +
         m_cif.GetObjectLength() +
         m_ccir601Seq.GetObjectLength() +
         m_ccir601Prog.GetObjectLength() +
         m_hdtvSeq.GetObjectLength() +
         m_hdtvProg.GetObjectLength() +
         m_g3FacsMH200x100.GetObjectLength() +
         m_g3FacsMH200x200.GetObjectLength() +
         m_g4FacsMMR200x100.GetObjectLength() +
         m_g4FacsMMR200x200.GetObjectLength() +
         m_jbig200x200Seq.GetObjectLength() +
         m_jbig200x200Prog.GetObjectLength() +
         m_jbig300x300Seq.GetObjectLength() +
         m_jbig300x300Prog.GetObjectLength() +
         m_digPhotoLow.GetObjectLength() +
         m_digPhotoMedSeq.GetObjectLength() +
         m_digPhotoMedProg.GetObjectLength() +
         m_digPhotoHighSeq.GetObjectLength() +
         m_digPhotoHighProg.GetObjectLength();
}


BOOL H245_T84Profile_t84Restricted::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_qcif.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_cif.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_ccir601Seq.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_ccir601Prog.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_hdtvSeq.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_hdtvProg.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_g3FacsMH200x100.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_g3FacsMH200x200.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_g4FacsMMR200x100.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_g4FacsMMR200x200.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_jbig200x200Seq.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_jbig200x200Prog.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_jbig300x300Seq.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_jbig300x300Prog.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_digPhotoLow.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_digPhotoMedSeq.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_digPhotoMedProg.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_digPhotoHighSeq.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_digPhotoHighProg.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_T84Profile_t84Restricted::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_qcif.Encode(strm);
  m_cif.Encode(strm);
  m_ccir601Seq.Encode(strm);
  m_ccir601Prog.Encode(strm);
  m_hdtvSeq.Encode(strm);
  m_hdtvProg.Encode(strm);
  m_g3FacsMH200x100.Encode(strm);
  m_g3FacsMH200x200.Encode(strm);
  m_g4FacsMMR200x100.Encode(strm);
  m_g4FacsMMR200x200.Encode(strm);
  m_jbig200x200Seq.Encode(strm);
  m_jbig200x200Prog.Encode(strm);
  m_jbig300x300Seq.Encode(strm);
  m_jbig300x300Prog.Encode(strm);
  m_digPhotoLow.Encode(strm);
  m_digPhotoMedSeq.Encode(strm);
  m_digPhotoMedProg.Encode(strm);
  m_digPhotoHighSeq.Encode(strm);
  m_digPhotoHighProg.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_qcif.Encode(strm);
  m_cif.Encode(strm);
  m_ccir601Seq.Encode(strm);
  m_ccir601Prog.Encode(strm);
  m_hdtvSeq.Encode(strm);
  m_hdtvProg.Encode(strm);
  m_g3FacsMH200x100.Encode(strm);
  m_g3FacsMH200x200.Encode(strm);
  m_g4FacsMMR200x100.Encode(strm);
  m_g4FacsMMR200x200.Encode(strm);
  m_jbig200x200Seq.Encode(strm);
  m_jbig200x200Prog.Encode(strm);
  m_jbig300x300Seq.Encode(strm);
  m_jbig300x300Prog.Encode(strm);
  m_digPhotoLow.Encode(strm);
  m_digPhotoMedSeq.Encode(strm);
  m_digPhotoMedProg.Encode(strm);
  m_digPhotoHighSeq.Encode(strm);
  m_digPhotoHighProg.Encode(strm);
}


PObject * H245_T84Profile_t84Restricted::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_T84Profile_t84Restricted::Class()), PInvalidCast);
#endif
  return new H245_T84Profile_t84Restricted(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_T84Profile_t84Restricted::preShowEthereal( void )
{
  m_qcif.preShowEthereal( );
  m_cif.preShowEthereal( );
  m_ccir601Seq.preShowEthereal( );
  m_ccir601Prog.preShowEthereal( );
  m_hdtvSeq.preShowEthereal( );
  m_hdtvProg.preShowEthereal( );
  m_g3FacsMH200x100.preShowEthereal( );
  m_g3FacsMH200x200.preShowEthereal( );
  m_g4FacsMMR200x100.preShowEthereal( );
  m_g4FacsMMR200x200.preShowEthereal( );
  m_jbig200x200Seq.preShowEthereal( );
  m_jbig200x200Prog.preShowEthereal( );
  m_jbig300x300Seq.preShowEthereal( );
  m_jbig300x300Prog.preShowEthereal( );
  m_digPhotoLow.preShowEthereal( );
  m_digPhotoMedSeq.preShowEthereal( );
  m_digPhotoMedProg.preShowEthereal( );
  m_digPhotoHighSeq.preShowEthereal( );
  m_digPhotoHighProg.preShowEthereal( );
}

PString H245_T84Profile_t84Restricted::getSummary( void ) 
{
  return PString( "T84Profile_t84Restricted" );
}

void H245_T84Profile_t84Restricted::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_T84Profile_t84Restricted_qcif, tvb, offset + m_qcif.GetStartByte(), m_qcif.GetByteLength() , m_qcif.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_T84Profile_t84Restricted_cif, tvb, offset + m_cif.GetStartByte(), m_cif.GetByteLength() , m_cif.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_T84Profile_t84Restricted_ccir601Seq, tvb, offset + m_ccir601Seq.GetStartByte(), m_ccir601Seq.GetByteLength() , m_ccir601Seq.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_T84Profile_t84Restricted_ccir601Prog, tvb, offset + m_ccir601Prog.GetStartByte(), m_ccir601Prog.GetByteLength() , m_ccir601Prog.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_T84Profile_t84Restricted_hdtvSeq, tvb, offset + m_hdtvSeq.GetStartByte(), m_hdtvSeq.GetByteLength() , m_hdtvSeq.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_T84Profile_t84Restricted_hdtvProg, tvb, offset + m_hdtvProg.GetStartByte(), m_hdtvProg.GetByteLength() , m_hdtvProg.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_T84Profile_t84Restricted_g3FacsMH200x100, tvb, offset + m_g3FacsMH200x100.GetStartByte(), m_g3FacsMH200x100.GetByteLength() , m_g3FacsMH200x100.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_T84Profile_t84Restricted_g3FacsMH200x200, tvb, offset + m_g3FacsMH200x200.GetStartByte(), m_g3FacsMH200x200.GetByteLength() , m_g3FacsMH200x200.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_T84Profile_t84Restricted_g4FacsMMR200x100, tvb, offset + m_g4FacsMMR200x100.GetStartByte(), m_g4FacsMMR200x100.GetByteLength() , m_g4FacsMMR200x100.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_T84Profile_t84Restricted_g4FacsMMR200x200, tvb, offset + m_g4FacsMMR200x200.GetStartByte(), m_g4FacsMMR200x200.GetByteLength() , m_g4FacsMMR200x200.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_T84Profile_t84Restricted_jbig200x200Seq, tvb, offset + m_jbig200x200Seq.GetStartByte(), m_jbig200x200Seq.GetByteLength() , m_jbig200x200Seq.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_T84Profile_t84Restricted_jbig200x200Prog, tvb, offset + m_jbig200x200Prog.GetStartByte(), m_jbig200x200Prog.GetByteLength() , m_jbig200x200Prog.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_T84Profile_t84Restricted_jbig300x300Seq, tvb, offset + m_jbig300x300Seq.GetStartByte(), m_jbig300x300Seq.GetByteLength() , m_jbig300x300Seq.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_T84Profile_t84Restricted_jbig300x300Prog, tvb, offset + m_jbig300x300Prog.GetStartByte(), m_jbig300x300Prog.GetByteLength() , m_jbig300x300Prog.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_0.hf_h245_T84Profile_t84Restricted_digPhotoLow, tvb, offset + m_digPhotoLow.GetStartByte(), m_digPhotoLow.GetByteLength() , m_digPhotoLow.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_1.hf_h245_T84Profile_t84Restricted_digPhotoMedSeq, tvb, offset + m_digPhotoMedSeq.GetStartByte(), m_digPhotoMedSeq.GetByteLength() , m_digPhotoMedSeq.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_1.hf_h245_T84Profile_t84Restricted_digPhotoMedProg, tvb, offset + m_digPhotoMedProg.GetStartByte(), m_digPhotoMedProg.GetByteLength() , m_digPhotoMedProg.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_1.hf_h245_T84Profile_t84Restricted_digPhotoHighSeq, tvb, offset + m_digPhotoHighSeq.GetStartByte(), m_digPhotoHighSeq.GetByteLength() , m_digPhotoHighSeq.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_1.hf_h245_T84Profile_t84Restricted_digPhotoHighProg, tvb, offset + m_digPhotoHighProg.GetStartByte(), m_digPhotoHighProg.GetByteLength() , m_digPhotoHighProg.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// ArrayOf_NonStandardParameter
//

H245_ArrayOf_NonStandardParameter::H245_ArrayOf_NonStandardParameter(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_NonStandardParameter::CreateObject() const
{
  return new H245_NonStandardParameter;
}


H245_NonStandardParameter & H245_ArrayOf_NonStandardParameter::operator[](PINDEX i) const
{
  return (H245_NonStandardParameter &)array[i];
}


PObject * H245_ArrayOf_NonStandardParameter::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_NonStandardParameter::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_NonStandardParameter(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_NonStandardParameter::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_NonStandardParameter& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_NonStandardParameter::getSummary( void ) 
{
  return PString( "ArrayOf_NonStandardParameter" );
}

void H245_ArrayOf_NonStandardParameter::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_NonStandardParameter_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_NonStandardParameter_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_NonStandardParameter_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (NonStandardParameter)", i );
    ArrayOf_NonStandardParameter_tree = proto_item_add_subtree( ArrayOf_NonStandardParameter_ti, hCont->h245_1.ett_h245_ArrayOf_NonStandardParameter );
    array[i].showEthereal( ArrayOf_NonStandardParameter_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// NetworkAccessParameters_distribution
//

H245_NetworkAccessParameters_distribution::H245_NetworkAccessParameters_distribution(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "unicast "
        "multicast "
#endif
    )
{
}


BOOL H245_NetworkAccessParameters_distribution::CreateObject()
{
  switch (tag) {
    case e_unicast :
    case e_multicast :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_NetworkAccessParameters_distribution::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NetworkAccessParameters_distribution::Class()), PInvalidCast);
#endif
  return new H245_NetworkAccessParameters_distribution(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NetworkAccessParameters_distribution::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_unicast :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_multicast :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_NetworkAccessParameters_distribution::getSummary( void ) 
{
  return PString( "NetworkAccessParameters_distribution" );
}

void H245_NetworkAccessParameters_distribution::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "unicast" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NetworkAccessParameters_distribution_unicast, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "multicast" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NetworkAccessParameters_distribution_multicast, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// NetworkAccessParameters_networkAddress
//

H245_NetworkAccessParameters_networkAddress::H245_NetworkAccessParameters_networkAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "q2931Address "
        "e164Address "
        "localAreaAddress "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_NetworkAccessParameters_networkAddress::operator H245_Q2931Address &() const
#else
H245_NetworkAccessParameters_networkAddress::operator H245_Q2931Address &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_Q2931Address::Class()), PInvalidCast);
#endif
  return *(H245_Q2931Address *)choice;
}


H245_NetworkAccessParameters_networkAddress::operator const H245_Q2931Address &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_Q2931Address::Class()), PInvalidCast);
#endif
  return *(H245_Q2931Address *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_NetworkAccessParameters_networkAddress::operator H245_TransportAddress &() const
#else
H245_NetworkAccessParameters_networkAddress::operator H245_TransportAddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_TransportAddress::Class()), PInvalidCast);
#endif
  return *(H245_TransportAddress *)choice;
}


H245_NetworkAccessParameters_networkAddress::operator const H245_TransportAddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_TransportAddress::Class()), PInvalidCast);
#endif
  return *(H245_TransportAddress *)choice;
}


BOOL H245_NetworkAccessParameters_networkAddress::CreateObject()
{
  switch (tag) {
    case e_q2931Address :
      choice = new H245_Q2931Address();
      return TRUE;
    case e_e164Address :
      choice = new PASN_IA5String();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 128);
      choice->SetCharacterSet(PASN_Object::FixedConstraint, "0123456789#*,");
      return TRUE;
    case e_localAreaAddress :
      choice = new H245_TransportAddress();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_NetworkAccessParameters_networkAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NetworkAccessParameters_networkAddress::Class()), PInvalidCast);
#endif
  return new H245_NetworkAccessParameters_networkAddress(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NetworkAccessParameters_networkAddress::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_q2931Address :
        ( ( H245_Q2931Address * ) choice )->preShowEthereal();
        break;
      case e_e164Address :
        ( ( PASN_IA5String * ) choice )->preShowEthereal();
        break;
      case e_localAreaAddress :
        ( ( H245_TransportAddress * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_NetworkAccessParameters_networkAddress::getSummary( void ) 
{
  return PString( "NetworkAccessParameters_networkAddress" );
}

void H245_NetworkAccessParameters_networkAddress::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "e164Address" ) == 0 ) {
      char* pstring = ( ( PASN_IA5String* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NetworkAccessParameters_networkAddress_e164Address, tvb, offset + ( ( PASN_IA5String* ) choice) ->GetStartByte(), ( ( PASN_IA5String* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_NetworkAccessParameters_networkAddress_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// NetworkAccessParameters_t120SetupProcedure
//

H245_NetworkAccessParameters_t120SetupProcedure::H245_NetworkAccessParameters_t120SetupProcedure(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "originateCall "
        "waitForCall "
        "issueQuery "
#endif
    )
{
}


BOOL H245_NetworkAccessParameters_t120SetupProcedure::CreateObject()
{
  switch (tag) {
    case e_originateCall :
    case e_waitForCall :
    case e_issueQuery :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_NetworkAccessParameters_t120SetupProcedure::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NetworkAccessParameters_t120SetupProcedure::Class()), PInvalidCast);
#endif
  return new H245_NetworkAccessParameters_t120SetupProcedure(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NetworkAccessParameters_t120SetupProcedure::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_originateCall :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_waitForCall :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_issueQuery :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_NetworkAccessParameters_t120SetupProcedure::getSummary( void ) 
{
  return PString( "NetworkAccessParameters_t120SetupProcedure" );
}

void H245_NetworkAccessParameters_t120SetupProcedure::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "originateCall" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NetworkAccessParameters_t120SetupProcedure_originateCall, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "waitForCall" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NetworkAccessParameters_t120SetupProcedure_waitForCall, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "issueQuery" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NetworkAccessParameters_t120SetupProcedure_issueQuery, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// Q2931Address_address
//

H245_Q2931Address_address::H245_Q2931Address_address(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "internationalNumber "
        "nsapAddress "
#endif
    )
{
}


BOOL H245_Q2931Address_address::CreateObject()
{
  switch (tag) {
    case e_internationalNumber :
      choice = new PASN_NumericString();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 16);
      return TRUE;
    case e_nsapAddress :
      choice = new PASN_OctetString();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 20);
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_Q2931Address_address::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_Q2931Address_address::Class()), PInvalidCast);
#endif
  return new H245_Q2931Address_address(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_Q2931Address_address::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_internationalNumber :
        ( ( PASN_NumericString * ) choice )->preShowEthereal();
        break;
      case e_nsapAddress :
        ( ( PASN_OctetString * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_Q2931Address_address::getSummary( void ) 
{
  return PString( "Q2931Address_address" );
}

void H245_Q2931Address_address::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "internationalNumber" ) == 0 ) {
      char* pstring = ( ( PASN_NumericString* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_Q2931Address_address_internationalNumber, tvb, offset + ( ( PASN_NumericString* ) choice) ->GetStartByte(), ( ( PASN_NumericString* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    if ( strcmp( GetTagName(), "nsapAddress" ) == 0 ) {
      char* pstring = ( ( PASN_OctetString* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_Q2931Address_address_nsapAddress, tvb, offset + ( ( PASN_OctetString* ) choice) ->GetStartByte(), ( ( PASN_OctetString* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H235Media_mediaType
//

H245_H235Media_mediaType::H245_H235Media_mediaType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "videoData "
        "audioData "
        "data "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H235Media_mediaType::operator H245_NonStandardParameter &() const
#else
H245_H235Media_mediaType::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_H235Media_mediaType::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H235Media_mediaType::operator H245_VideoCapability &() const
#else
H245_H235Media_mediaType::operator H245_VideoCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_VideoCapability::Class()), PInvalidCast);
#endif
  return *(H245_VideoCapability *)choice;
}


H245_H235Media_mediaType::operator const H245_VideoCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_VideoCapability::Class()), PInvalidCast);
#endif
  return *(H245_VideoCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H235Media_mediaType::operator H245_AudioCapability &() const
#else
H245_H235Media_mediaType::operator H245_AudioCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_AudioCapability::Class()), PInvalidCast);
#endif
  return *(H245_AudioCapability *)choice;
}


H245_H235Media_mediaType::operator const H245_AudioCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_AudioCapability::Class()), PInvalidCast);
#endif
  return *(H245_AudioCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H235Media_mediaType::operator H245_DataApplicationCapability &() const
#else
H245_H235Media_mediaType::operator H245_DataApplicationCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataApplicationCapability::Class()), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability *)choice;
}


H245_H235Media_mediaType::operator const H245_DataApplicationCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataApplicationCapability::Class()), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability *)choice;
}


BOOL H245_H235Media_mediaType::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_videoData :
      choice = new H245_VideoCapability();
      return TRUE;
    case e_audioData :
      choice = new H245_AudioCapability();
      return TRUE;
    case e_data :
      choice = new H245_DataApplicationCapability();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_H235Media_mediaType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H235Media_mediaType::Class()), PInvalidCast);
#endif
  return new H245_H235Media_mediaType(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H235Media_mediaType::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_videoData :
        ( ( H245_VideoCapability * ) choice )->preShowEthereal();
        break;
      case e_audioData :
        ( ( H245_AudioCapability * ) choice )->preShowEthereal();
        break;
      case e_data :
        ( ( H245_DataApplicationCapability * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_H235Media_mediaType::getSummary( void ) 
{
  return PString( "H235Media_mediaType" );
}

void H245_H235Media_mediaType::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_H235Media_mediaType_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H223LogicalChannelParameters_adaptationLayerType
//

H245_H223LogicalChannelParameters_adaptationLayerType::H245_H223LogicalChannelParameters_adaptationLayerType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 6, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "al1Framed "
        "al1NotFramed "
        "al2WithoutSequenceNumbers "
        "al2WithSequenceNumbers "
        "al3 "
        "al1M "
        "al2M "
        "al3M "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223LogicalChannelParameters_adaptationLayerType::operator H245_NonStandardParameter &() const
#else
H245_H223LogicalChannelParameters_adaptationLayerType::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_H223LogicalChannelParameters_adaptationLayerType::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223LogicalChannelParameters_adaptationLayerType::operator H245_H223LogicalChannelParameters_adaptationLayerType_al3 &() const
#else
H245_H223LogicalChannelParameters_adaptationLayerType::operator H245_H223LogicalChannelParameters_adaptationLayerType_al3 &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223LogicalChannelParameters_adaptationLayerType_al3::Class()), PInvalidCast);
#endif
  return *(H245_H223LogicalChannelParameters_adaptationLayerType_al3 *)choice;
}


H245_H223LogicalChannelParameters_adaptationLayerType::operator const H245_H223LogicalChannelParameters_adaptationLayerType_al3 &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223LogicalChannelParameters_adaptationLayerType_al3::Class()), PInvalidCast);
#endif
  return *(H245_H223LogicalChannelParameters_adaptationLayerType_al3 *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223LogicalChannelParameters_adaptationLayerType::operator H245_H223AL1MParameters &() const
#else
H245_H223LogicalChannelParameters_adaptationLayerType::operator H245_H223AL1MParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223AL1MParameters::Class()), PInvalidCast);
#endif
  return *(H245_H223AL1MParameters *)choice;
}


H245_H223LogicalChannelParameters_adaptationLayerType::operator const H245_H223AL1MParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223AL1MParameters::Class()), PInvalidCast);
#endif
  return *(H245_H223AL1MParameters *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223LogicalChannelParameters_adaptationLayerType::operator H245_H223AL2MParameters &() const
#else
H245_H223LogicalChannelParameters_adaptationLayerType::operator H245_H223AL2MParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223AL2MParameters::Class()), PInvalidCast);
#endif
  return *(H245_H223AL2MParameters *)choice;
}


H245_H223LogicalChannelParameters_adaptationLayerType::operator const H245_H223AL2MParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223AL2MParameters::Class()), PInvalidCast);
#endif
  return *(H245_H223AL2MParameters *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223LogicalChannelParameters_adaptationLayerType::operator H245_H223AL3MParameters &() const
#else
H245_H223LogicalChannelParameters_adaptationLayerType::operator H245_H223AL3MParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223AL3MParameters::Class()), PInvalidCast);
#endif
  return *(H245_H223AL3MParameters *)choice;
}


H245_H223LogicalChannelParameters_adaptationLayerType::operator const H245_H223AL3MParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223AL3MParameters::Class()), PInvalidCast);
#endif
  return *(H245_H223AL3MParameters *)choice;
}


BOOL H245_H223LogicalChannelParameters_adaptationLayerType::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_al1Framed :
    case e_al1NotFramed :
    case e_al2WithoutSequenceNumbers :
    case e_al2WithSequenceNumbers :
      choice = new PASN_Null();
      return TRUE;
    case e_al3 :
      choice = new H245_H223LogicalChannelParameters_adaptationLayerType_al3();
      return TRUE;
    case e_al1M :
      choice = new H245_H223AL1MParameters();
      return TRUE;
    case e_al2M :
      choice = new H245_H223AL2MParameters();
      return TRUE;
    case e_al3M :
      choice = new H245_H223AL3MParameters();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_H223LogicalChannelParameters_adaptationLayerType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223LogicalChannelParameters_adaptationLayerType::Class()), PInvalidCast);
#endif
  return new H245_H223LogicalChannelParameters_adaptationLayerType(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223LogicalChannelParameters_adaptationLayerType::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_al1Framed :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_al1NotFramed :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_al2WithoutSequenceNumbers :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_al2WithSequenceNumbers :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_al3 :
        ( ( H245_H223LogicalChannelParameters_adaptationLayerType_al3 * ) choice )->preShowEthereal();
        break;
      case e_al1M :
        ( ( H245_H223AL1MParameters * ) choice )->preShowEthereal();
        break;
      case e_al2M :
        ( ( H245_H223AL2MParameters * ) choice )->preShowEthereal();
        break;
      case e_al3M :
        ( ( H245_H223AL3MParameters * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_H223LogicalChannelParameters_adaptationLayerType::getSummary( void ) 
{
  return PString( "H223LogicalChannelParameters_adaptationLayerType" );
}

void H245_H223LogicalChannelParameters_adaptationLayerType::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "al1Framed" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223LogicalChannelParameters_adaptationLayerType_al1Framed, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "al1NotFramed" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223LogicalChannelParameters_adaptationLayerType_al1NotFramed, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "al2WithoutSequenceNumbers" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223LogicalChannelParameters_adaptationLayerType_al2WithoutSequenceNumbers, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "al2WithSequenceNumbers" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223LogicalChannelParameters_adaptationLayerType_al2WithSequenceNumbers, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_H223LogicalChannelParameters_adaptationLayerType_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H223AL1MParameters_transferMode
//

H245_H223AL1MParameters_transferMode::H245_H223AL1MParameters_transferMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "framed "
        "unframed "
#endif
    )
{
}


BOOL H245_H223AL1MParameters_transferMode::CreateObject()
{
  switch (tag) {
    case e_framed :
    case e_unframed :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_H223AL1MParameters_transferMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AL1MParameters_transferMode::Class()), PInvalidCast);
#endif
  return new H245_H223AL1MParameters_transferMode(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223AL1MParameters_transferMode::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_framed :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_unframed :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_H223AL1MParameters_transferMode::getSummary( void ) 
{
  return PString( "H223AL1MParameters_transferMode" );
}

void H245_H223AL1MParameters_transferMode::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "framed" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223AL1MParameters_transferMode_framed, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "unframed" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223AL1MParameters_transferMode_unframed, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H223AL1MParameters_headerFEC
//

H245_H223AL1MParameters_headerFEC::H245_H223AL1MParameters_headerFEC(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "sebch16_7 "
        "golay24_12 "
#endif
    )
{
}


BOOL H245_H223AL1MParameters_headerFEC::CreateObject()
{
  switch (tag) {
    case e_sebch16_7 :
    case e_golay24_12 :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_H223AL1MParameters_headerFEC::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AL1MParameters_headerFEC::Class()), PInvalidCast);
#endif
  return new H245_H223AL1MParameters_headerFEC(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223AL1MParameters_headerFEC::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_sebch16_7 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_golay24_12 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_H223AL1MParameters_headerFEC::getSummary( void ) 
{
  return PString( "H223AL1MParameters_headerFEC" );
}

void H245_H223AL1MParameters_headerFEC::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "sebch16_7" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223AL1MParameters_headerFEC_sebch16_7, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "golay24_12" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223AL1MParameters_headerFEC_golay24_12, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H223AL1MParameters_crcLength
//

H245_H223AL1MParameters_crcLength::H245_H223AL1MParameters_crcLength(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "crc4bit "
        "crc12bit "
        "crc20bit "
        "crc28bit "
#endif
    )
{
}


BOOL H245_H223AL1MParameters_crcLength::CreateObject()
{
  switch (tag) {
    case e_crc4bit :
    case e_crc12bit :
    case e_crc20bit :
    case e_crc28bit :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_H223AL1MParameters_crcLength::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AL1MParameters_crcLength::Class()), PInvalidCast);
#endif
  return new H245_H223AL1MParameters_crcLength(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223AL1MParameters_crcLength::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_crc4bit :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_crc12bit :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_crc20bit :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_crc28bit :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_H223AL1MParameters_crcLength::getSummary( void ) 
{
  return PString( "H223AL1MParameters_crcLength" );
}

void H245_H223AL1MParameters_crcLength::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "crc4bit" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223AL1MParameters_crcLength_crc4bit, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "crc12bit" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223AL1MParameters_crcLength_crc12bit, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "crc20bit" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223AL1MParameters_crcLength_crc20bit, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "crc28bit" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223AL1MParameters_crcLength_crc28bit, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H223AL1MParameters_arqType
//

H245_H223AL1MParameters_arqType::H245_H223AL1MParameters_arqType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "noArq "
        "typeIArq "
        "typeIIArq "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223AL1MParameters_arqType::operator H245_H223AnnexCArqParameters &() const
#else
H245_H223AL1MParameters_arqType::operator H245_H223AnnexCArqParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223AnnexCArqParameters::Class()), PInvalidCast);
#endif
  return *(H245_H223AnnexCArqParameters *)choice;
}


H245_H223AL1MParameters_arqType::operator const H245_H223AnnexCArqParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223AnnexCArqParameters::Class()), PInvalidCast);
#endif
  return *(H245_H223AnnexCArqParameters *)choice;
}


BOOL H245_H223AL1MParameters_arqType::CreateObject()
{
  switch (tag) {
    case e_noArq :
      choice = new PASN_Null();
      return TRUE;
    case e_typeIArq :
    case e_typeIIArq :
      choice = new H245_H223AnnexCArqParameters();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_H223AL1MParameters_arqType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AL1MParameters_arqType::Class()), PInvalidCast);
#endif
  return new H245_H223AL1MParameters_arqType(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223AL1MParameters_arqType::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_noArq :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_typeIArq :
        ( ( H245_H223AnnexCArqParameters * ) choice )->preShowEthereal();
        break;
      case e_typeIIArq :
        ( ( H245_H223AnnexCArqParameters * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_H223AL1MParameters_arqType::getSummary( void ) 
{
  return PString( "H223AL1MParameters_arqType" );
}

void H245_H223AL1MParameters_arqType::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "noArq" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223AL1MParameters_arqType_noArq, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_H223AL1MParameters_arqType_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H223AL2MParameters_headerFEC
//

H245_H223AL2MParameters_headerFEC::H245_H223AL2MParameters_headerFEC(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "sebch16_5 "
        "golay24_12 "
#endif
    )
{
}


BOOL H245_H223AL2MParameters_headerFEC::CreateObject()
{
  switch (tag) {
    case e_sebch16_5 :
    case e_golay24_12 :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_H223AL2MParameters_headerFEC::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AL2MParameters_headerFEC::Class()), PInvalidCast);
#endif
  return new H245_H223AL2MParameters_headerFEC(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223AL2MParameters_headerFEC::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_sebch16_5 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_golay24_12 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_H223AL2MParameters_headerFEC::getSummary( void ) 
{
  return PString( "H223AL2MParameters_headerFEC" );
}

void H245_H223AL2MParameters_headerFEC::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "sebch16_5" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223AL2MParameters_headerFEC_sebch16_5, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "golay24_12" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223AL2MParameters_headerFEC_golay24_12, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H223AL3MParameters_headerFormat
//

H245_H223AL3MParameters_headerFormat::H245_H223AL3MParameters_headerFormat(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "sebch16_7 "
        "golay24_12 "
#endif
    )
{
}


BOOL H245_H223AL3MParameters_headerFormat::CreateObject()
{
  switch (tag) {
    case e_sebch16_7 :
    case e_golay24_12 :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_H223AL3MParameters_headerFormat::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AL3MParameters_headerFormat::Class()), PInvalidCast);
#endif
  return new H245_H223AL3MParameters_headerFormat(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223AL3MParameters_headerFormat::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_sebch16_7 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_golay24_12 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_H223AL3MParameters_headerFormat::getSummary( void ) 
{
  return PString( "H223AL3MParameters_headerFormat" );
}

void H245_H223AL3MParameters_headerFormat::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "sebch16_7" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223AL3MParameters_headerFormat_sebch16_7, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "golay24_12" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223AL3MParameters_headerFormat_golay24_12, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H223AL3MParameters_crcLength
//

H245_H223AL3MParameters_crcLength::H245_H223AL3MParameters_crcLength(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "crc4bit "
        "crc12bit "
        "crc20bit "
        "crc28bit "
#endif
    )
{
}


BOOL H245_H223AL3MParameters_crcLength::CreateObject()
{
  switch (tag) {
    case e_crc4bit :
    case e_crc12bit :
    case e_crc20bit :
    case e_crc28bit :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_H223AL3MParameters_crcLength::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AL3MParameters_crcLength::Class()), PInvalidCast);
#endif
  return new H245_H223AL3MParameters_crcLength(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223AL3MParameters_crcLength::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_crc4bit :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_crc12bit :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_crc20bit :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_crc28bit :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_H223AL3MParameters_crcLength::getSummary( void ) 
{
  return PString( "H223AL3MParameters_crcLength" );
}

void H245_H223AL3MParameters_crcLength::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "crc4bit" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223AL3MParameters_crcLength_crc4bit, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "crc12bit" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223AL3MParameters_crcLength_crc12bit, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "crc20bit" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223AL3MParameters_crcLength_crc20bit, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "crc28bit" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223AL3MParameters_crcLength_crc28bit, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H223AL3MParameters_arqType
//

H245_H223AL3MParameters_arqType::H245_H223AL3MParameters_arqType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "noArq "
        "typeIArq "
        "typeIIArq "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223AL3MParameters_arqType::operator H245_H223AnnexCArqParameters &() const
#else
H245_H223AL3MParameters_arqType::operator H245_H223AnnexCArqParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223AnnexCArqParameters::Class()), PInvalidCast);
#endif
  return *(H245_H223AnnexCArqParameters *)choice;
}


H245_H223AL3MParameters_arqType::operator const H245_H223AnnexCArqParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223AnnexCArqParameters::Class()), PInvalidCast);
#endif
  return *(H245_H223AnnexCArqParameters *)choice;
}


BOOL H245_H223AL3MParameters_arqType::CreateObject()
{
  switch (tag) {
    case e_noArq :
      choice = new PASN_Null();
      return TRUE;
    case e_typeIArq :
    case e_typeIIArq :
      choice = new H245_H223AnnexCArqParameters();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_H223AL3MParameters_arqType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AL3MParameters_arqType::Class()), PInvalidCast);
#endif
  return new H245_H223AL3MParameters_arqType(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223AL3MParameters_arqType::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_noArq :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_typeIArq :
        ( ( H245_H223AnnexCArqParameters * ) choice )->preShowEthereal();
        break;
      case e_typeIIArq :
        ( ( H245_H223AnnexCArqParameters * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_H223AL3MParameters_arqType::getSummary( void ) 
{
  return PString( "H223AL3MParameters_arqType" );
}

void H245_H223AL3MParameters_arqType::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "noArq" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223AL3MParameters_arqType_noArq, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_H223AL3MParameters_arqType_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H223AnnexCArqParameters_numberOfRetransmissions
//

H245_H223AnnexCArqParameters_numberOfRetransmissions::H245_H223AnnexCArqParameters_numberOfRetransmissions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "finite "
        "infinite "
#endif
    )
{
}


BOOL H245_H223AnnexCArqParameters_numberOfRetransmissions::CreateObject()
{
  switch (tag) {
    case e_finite :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 16);
      return TRUE;
    case e_infinite :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_H223AnnexCArqParameters_numberOfRetransmissions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AnnexCArqParameters_numberOfRetransmissions::Class()), PInvalidCast);
#endif
  return new H245_H223AnnexCArqParameters_numberOfRetransmissions(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223AnnexCArqParameters_numberOfRetransmissions::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_finite :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_infinite :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_H223AnnexCArqParameters_numberOfRetransmissions::getSummary( void ) 
{
  return PString( "H223AnnexCArqParameters_numberOfRetransmissions" );
}

void H245_H223AnnexCArqParameters_numberOfRetransmissions::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "finite" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_H223AnnexCArqParameters_numberOfRetransmissions_finite, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "infinite" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223AnnexCArqParameters_numberOfRetransmissions_infinite, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// V76LogicalChannelParameters_suspendResume
//

H245_V76LogicalChannelParameters_suspendResume::H245_V76LogicalChannelParameters_suspendResume(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "noSuspendResume "
        "suspendResumewAddress "
        "suspendResumewoAddress "
#endif
    )
{
}


BOOL H245_V76LogicalChannelParameters_suspendResume::CreateObject()
{
  switch (tag) {
    case e_noSuspendResume :
    case e_suspendResumewAddress :
    case e_suspendResumewoAddress :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_V76LogicalChannelParameters_suspendResume::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_V76LogicalChannelParameters_suspendResume::Class()), PInvalidCast);
#endif
  return new H245_V76LogicalChannelParameters_suspendResume(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_V76LogicalChannelParameters_suspendResume::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_noSuspendResume :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_suspendResumewAddress :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_suspendResumewoAddress :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_V76LogicalChannelParameters_suspendResume::getSummary( void ) 
{
  return PString( "V76LogicalChannelParameters_suspendResume" );
}

void H245_V76LogicalChannelParameters_suspendResume::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "noSuspendResume" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_V76LogicalChannelParameters_suspendResume_noSuspendResume, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "suspendResumewAddress" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_V76LogicalChannelParameters_suspendResume_suspendResumewAddress, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "suspendResumewoAddress" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_V76LogicalChannelParameters_suspendResume_suspendResumewoAddress, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// V76LogicalChannelParameters_mode
//

H245_V76LogicalChannelParameters_mode::H245_V76LogicalChannelParameters_mode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "eRM "
        "uNERM "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_V76LogicalChannelParameters_mode::operator H245_V76LogicalChannelParameters_mode_eRM &() const
#else
H245_V76LogicalChannelParameters_mode::operator H245_V76LogicalChannelParameters_mode_eRM &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_V76LogicalChannelParameters_mode_eRM::Class()), PInvalidCast);
#endif
  return *(H245_V76LogicalChannelParameters_mode_eRM *)choice;
}


H245_V76LogicalChannelParameters_mode::operator const H245_V76LogicalChannelParameters_mode_eRM &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_V76LogicalChannelParameters_mode_eRM::Class()), PInvalidCast);
#endif
  return *(H245_V76LogicalChannelParameters_mode_eRM *)choice;
}


BOOL H245_V76LogicalChannelParameters_mode::CreateObject()
{
  switch (tag) {
    case e_eRM :
      choice = new H245_V76LogicalChannelParameters_mode_eRM();
      return TRUE;
    case e_uNERM :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_V76LogicalChannelParameters_mode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_V76LogicalChannelParameters_mode::Class()), PInvalidCast);
#endif
  return new H245_V76LogicalChannelParameters_mode(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_V76LogicalChannelParameters_mode::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_eRM :
        ( ( H245_V76LogicalChannelParameters_mode_eRM * ) choice )->preShowEthereal();
        break;
      case e_uNERM :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_V76LogicalChannelParameters_mode::getSummary( void ) 
{
  return PString( "V76LogicalChannelParameters_mode" );
}

void H245_V76LogicalChannelParameters_mode::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "uNERM" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_V76LogicalChannelParameters_mode_uNERM, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_V76LogicalChannelParameters_mode_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H2250LogicalChannelParameters_mediaPacketization
//

H245_H2250LogicalChannelParameters_mediaPacketization::H245_H2250LogicalChannelParameters_mediaPacketization(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
      , "h261aVideoPacketization "
        "rtpPayloadType "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H2250LogicalChannelParameters_mediaPacketization::operator H245_RTPPayloadType &() const
#else
H245_H2250LogicalChannelParameters_mediaPacketization::operator H245_RTPPayloadType &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RTPPayloadType::Class()), PInvalidCast);
#endif
  return *(H245_RTPPayloadType *)choice;
}


H245_H2250LogicalChannelParameters_mediaPacketization::operator const H245_RTPPayloadType &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_RTPPayloadType::Class()), PInvalidCast);
#endif
  return *(H245_RTPPayloadType *)choice;
}


BOOL H245_H2250LogicalChannelParameters_mediaPacketization::CreateObject()
{
  switch (tag) {
    case e_h261aVideoPacketization :
      choice = new PASN_Null();
      return TRUE;
    case e_rtpPayloadType :
      choice = new H245_RTPPayloadType();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_H2250LogicalChannelParameters_mediaPacketization::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H2250LogicalChannelParameters_mediaPacketization::Class()), PInvalidCast);
#endif
  return new H245_H2250LogicalChannelParameters_mediaPacketization(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H2250LogicalChannelParameters_mediaPacketization::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_h261aVideoPacketization :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_rtpPayloadType :
        ( ( H245_RTPPayloadType * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_H2250LogicalChannelParameters_mediaPacketization::getSummary( void ) 
{
  return PString( "H2250LogicalChannelParameters_mediaPacketization" );
}

void H245_H2250LogicalChannelParameters_mediaPacketization::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "h261aVideoPacketization" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H2250LogicalChannelParameters_mediaPacketization_h261aVideoPacketization, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_H2250LogicalChannelParameters_mediaPacketization_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// RTPPayloadType_payloadDescriptor
//

H245_RTPPayloadType_payloadDescriptor::H245_RTPPayloadType_payloadDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandardIdentifier "
        "rfc_number "
        "oid "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RTPPayloadType_payloadDescriptor::operator H245_NonStandardParameter &() const
#else
H245_RTPPayloadType_payloadDescriptor::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_RTPPayloadType_payloadDescriptor::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


BOOL H245_RTPPayloadType_payloadDescriptor::CreateObject()
{
  switch (tag) {
    case e_nonStandardIdentifier :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_rfc_number :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::ExtendableConstraint, 1, 32768);
      return TRUE;
    case e_oid :
      choice = new PASN_ObjectId();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_RTPPayloadType_payloadDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RTPPayloadType_payloadDescriptor::Class()), PInvalidCast);
#endif
  return new H245_RTPPayloadType_payloadDescriptor(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RTPPayloadType_payloadDescriptor::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandardIdentifier :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_rfc_number :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_oid :
        ( ( PASN_ObjectId * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_RTPPayloadType_payloadDescriptor::getSummary( void ) 
{
  return PString( "RTPPayloadType_payloadDescriptor" );
}

void H245_RTPPayloadType_payloadDescriptor::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "rfc_number" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_RTPPayloadType_payloadDescriptor_rfc_number, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "oid" ) == 0 ) {
      char* pstring = ( ( PASN_ObjectId* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_RTPPayloadType_payloadDescriptor_oid, tvb, offset + ( ( PASN_ObjectId* ) choice) ->GetStartByte(), ( ( PASN_ObjectId* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_RTPPayloadType_payloadDescriptor_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// UnicastAddress_iPAddress
//

H245_UnicastAddress_iPAddress::H245_UnicastAddress_iPAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_network.SetConstraints(PASN_Object::FixedConstraint, 4, 4);
  m_tsapIdentifier.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_UnicastAddress_iPAddress::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "network = " << setprecision(indent) << m_network << '\n';
  strm << setw(indent+17) << "tsapIdentifier = " << setprecision(indent) << m_tsapIdentifier << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_UnicastAddress_iPAddress::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_UnicastAddress_iPAddress::Class()), PInvalidCast);
#endif
  const H245_UnicastAddress_iPAddress & other = (const H245_UnicastAddress_iPAddress &)obj;

  Comparison result;

  if ((result = m_network.Compare(other.m_network)) != EqualTo)
    return result;
  if ((result = m_tsapIdentifier.Compare(other.m_tsapIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_UnicastAddress_iPAddress::GetDataLength() const
{
  return m_network.GetObjectLength() +
         m_tsapIdentifier.GetObjectLength();
}


BOOL H245_UnicastAddress_iPAddress::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_network.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_tsapIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_UnicastAddress_iPAddress::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_network.Encode(strm);
  m_tsapIdentifier.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_network.Encode(strm);
  m_tsapIdentifier.Encode(strm);
}


PObject * H245_UnicastAddress_iPAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UnicastAddress_iPAddress::Class()), PInvalidCast);
#endif
  return new H245_UnicastAddress_iPAddress(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_UnicastAddress_iPAddress::preShowEthereal( void )
{
  m_network.preShowEthereal( );
  m_tsapIdentifier.preShowEthereal( );
}

PString H245_UnicastAddress_iPAddress::getSummary( void ) 
{
  return PString( "UnicastAddress_iPAddress" );
}

void H245_UnicastAddress_iPAddress::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pnetwork = m_network.getValue();
  proto_tree_add_ipv4( tree, hCont->h245_1.hf_h245_UnicastAddress_iPAddress_network, tvb, offset + m_network.GetStartByte(), m_network.GetByteLength() , pletohl( pnetwork ) );
  delete[] pnetwork;

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_UnicastAddress_iPAddress_tsapIdentifier, tvb, offset + m_tsapIdentifier.GetStartByte(), m_tsapIdentifier.GetByteLength() , m_tsapIdentifier.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// UnicastAddress_iPXAddress
//

H245_UnicastAddress_iPXAddress::H245_UnicastAddress_iPXAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_node.SetConstraints(PASN_Object::FixedConstraint, 6, 6);
  m_netnum.SetConstraints(PASN_Object::FixedConstraint, 4, 4);
  m_tsapIdentifier.SetConstraints(PASN_Object::FixedConstraint, 2, 2);
}


#ifndef PASN_NOPRINTON
void H245_UnicastAddress_iPXAddress::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "node = " << setprecision(indent) << m_node << '\n';
  strm << setw(indent+9) << "netnum = " << setprecision(indent) << m_netnum << '\n';
  strm << setw(indent+17) << "tsapIdentifier = " << setprecision(indent) << m_tsapIdentifier << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_UnicastAddress_iPXAddress::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_UnicastAddress_iPXAddress::Class()), PInvalidCast);
#endif
  const H245_UnicastAddress_iPXAddress & other = (const H245_UnicastAddress_iPXAddress &)obj;

  Comparison result;

  if ((result = m_node.Compare(other.m_node)) != EqualTo)
    return result;
  if ((result = m_netnum.Compare(other.m_netnum)) != EqualTo)
    return result;
  if ((result = m_tsapIdentifier.Compare(other.m_tsapIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_UnicastAddress_iPXAddress::GetDataLength() const
{
  return m_node.GetObjectLength() +
         m_netnum.GetObjectLength() +
         m_tsapIdentifier.GetObjectLength();
}


BOOL H245_UnicastAddress_iPXAddress::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_node.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_netnum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_tsapIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_UnicastAddress_iPXAddress::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_node.Encode(strm);
  m_netnum.Encode(strm);
  m_tsapIdentifier.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_node.Encode(strm);
  m_netnum.Encode(strm);
  m_tsapIdentifier.Encode(strm);
}


PObject * H245_UnicastAddress_iPXAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UnicastAddress_iPXAddress::Class()), PInvalidCast);
#endif
  return new H245_UnicastAddress_iPXAddress(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_UnicastAddress_iPXAddress::preShowEthereal( void )
{
  m_node.preShowEthereal( );
  m_netnum.preShowEthereal( );
  m_tsapIdentifier.preShowEthereal( );
}

PString H245_UnicastAddress_iPXAddress::getSummary( void ) 
{
  return PString( "UnicastAddress_iPXAddress" );
}

void H245_UnicastAddress_iPXAddress::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pnode = m_node.getValue();
  proto_tree_add_string( tree, hCont->h245_1.hf_h245_UnicastAddress_iPXAddress_node, tvb, offset + m_node.GetStartByte(), m_node.GetByteLength() , pnode );
  delete[] pnode;

  char* pnetnum = m_netnum.getValue();
  proto_tree_add_string( tree, hCont->h245_1.hf_h245_UnicastAddress_iPXAddress_netnum, tvb, offset + m_netnum.GetStartByte(), m_netnum.GetByteLength() , pnetnum );
  delete[] pnetnum;

  char* ptsapIdentifier = m_tsapIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h245_1.hf_h245_UnicastAddress_iPXAddress_tsapIdentifier, tvb, offset + m_tsapIdentifier.GetStartByte(), m_tsapIdentifier.GetByteLength() , ptsapIdentifier );
  delete[] ptsapIdentifier;

}
#endif  //USE_FOR_ETHEREAL

//
// UnicastAddress_iP6Address
//

H245_UnicastAddress_iP6Address::H245_UnicastAddress_iP6Address(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_network.SetConstraints(PASN_Object::FixedConstraint, 16, 16);
  m_tsapIdentifier.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_UnicastAddress_iP6Address::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "network = " << setprecision(indent) << m_network << '\n';
  strm << setw(indent+17) << "tsapIdentifier = " << setprecision(indent) << m_tsapIdentifier << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_UnicastAddress_iP6Address::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_UnicastAddress_iP6Address::Class()), PInvalidCast);
#endif
  const H245_UnicastAddress_iP6Address & other = (const H245_UnicastAddress_iP6Address &)obj;

  Comparison result;

  if ((result = m_network.Compare(other.m_network)) != EqualTo)
    return result;
  if ((result = m_tsapIdentifier.Compare(other.m_tsapIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_UnicastAddress_iP6Address::GetDataLength() const
{
  return m_network.GetObjectLength() +
         m_tsapIdentifier.GetObjectLength();
}


BOOL H245_UnicastAddress_iP6Address::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_network.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_tsapIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_UnicastAddress_iP6Address::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_network.Encode(strm);
  m_tsapIdentifier.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_network.Encode(strm);
  m_tsapIdentifier.Encode(strm);
}


PObject * H245_UnicastAddress_iP6Address::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UnicastAddress_iP6Address::Class()), PInvalidCast);
#endif
  return new H245_UnicastAddress_iP6Address(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_UnicastAddress_iP6Address::preShowEthereal( void )
{
  m_network.preShowEthereal( );
  m_tsapIdentifier.preShowEthereal( );
}

PString H245_UnicastAddress_iP6Address::getSummary( void ) 
{
  return PString( "UnicastAddress_iP6Address" );
}

void H245_UnicastAddress_iP6Address::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pnetwork = m_network.getValue();
  proto_tree_add_ipv6( tree, hCont->h245_1.hf_h245_UnicastAddress_iP6Address_network, tvb, offset + m_network.GetStartByte(), m_network.GetByteLength() , ( unsigned char* ) pnetwork );
  delete[] pnetwork;

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_UnicastAddress_iP6Address_tsapIdentifier, tvb, offset + m_tsapIdentifier.GetStartByte(), m_tsapIdentifier.GetByteLength() , m_tsapIdentifier.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// MulticastAddress_iPAddress
//

H245_MulticastAddress_iPAddress::H245_MulticastAddress_iPAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_network.SetConstraints(PASN_Object::FixedConstraint, 4, 4);
  m_tsapIdentifier.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_MulticastAddress_iPAddress::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "network = " << setprecision(indent) << m_network << '\n';
  strm << setw(indent+17) << "tsapIdentifier = " << setprecision(indent) << m_tsapIdentifier << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MulticastAddress_iPAddress::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MulticastAddress_iPAddress::Class()), PInvalidCast);
#endif
  const H245_MulticastAddress_iPAddress & other = (const H245_MulticastAddress_iPAddress &)obj;

  Comparison result;

  if ((result = m_network.Compare(other.m_network)) != EqualTo)
    return result;
  if ((result = m_tsapIdentifier.Compare(other.m_tsapIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MulticastAddress_iPAddress::GetDataLength() const
{
  return m_network.GetObjectLength() +
         m_tsapIdentifier.GetObjectLength();
}


BOOL H245_MulticastAddress_iPAddress::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_network.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_tsapIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MulticastAddress_iPAddress::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_network.Encode(strm);
  m_tsapIdentifier.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_network.Encode(strm);
  m_tsapIdentifier.Encode(strm);
}


PObject * H245_MulticastAddress_iPAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MulticastAddress_iPAddress::Class()), PInvalidCast);
#endif
  return new H245_MulticastAddress_iPAddress(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MulticastAddress_iPAddress::preShowEthereal( void )
{
  m_network.preShowEthereal( );
  m_tsapIdentifier.preShowEthereal( );
}

PString H245_MulticastAddress_iPAddress::getSummary( void ) 
{
  return PString( "MulticastAddress_iPAddress" );
}

void H245_MulticastAddress_iPAddress::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pnetwork = m_network.getValue();
  proto_tree_add_ipv4( tree, hCont->h245_1.hf_h245_MulticastAddress_iPAddress_network, tvb, offset + m_network.GetStartByte(), m_network.GetByteLength() , pletohl( pnetwork ) );
  delete[] pnetwork;

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MulticastAddress_iPAddress_tsapIdentifier, tvb, offset + m_tsapIdentifier.GetStartByte(), m_tsapIdentifier.GetByteLength() , m_tsapIdentifier.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// MulticastAddress_iP6Address
//

H245_MulticastAddress_iP6Address::H245_MulticastAddress_iP6Address(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_network.SetConstraints(PASN_Object::FixedConstraint, 16, 16);
  m_tsapIdentifier.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_MulticastAddress_iP6Address::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "network = " << setprecision(indent) << m_network << '\n';
  strm << setw(indent+17) << "tsapIdentifier = " << setprecision(indent) << m_tsapIdentifier << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MulticastAddress_iP6Address::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MulticastAddress_iP6Address::Class()), PInvalidCast);
#endif
  const H245_MulticastAddress_iP6Address & other = (const H245_MulticastAddress_iP6Address &)obj;

  Comparison result;

  if ((result = m_network.Compare(other.m_network)) != EqualTo)
    return result;
  if ((result = m_tsapIdentifier.Compare(other.m_tsapIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MulticastAddress_iP6Address::GetDataLength() const
{
  return m_network.GetObjectLength() +
         m_tsapIdentifier.GetObjectLength();
}


BOOL H245_MulticastAddress_iP6Address::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_network.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_tsapIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MulticastAddress_iP6Address::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_network.Encode(strm);
  m_tsapIdentifier.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_network.Encode(strm);
  m_tsapIdentifier.Encode(strm);
}


PObject * H245_MulticastAddress_iP6Address::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MulticastAddress_iP6Address::Class()), PInvalidCast);
#endif
  return new H245_MulticastAddress_iP6Address(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MulticastAddress_iP6Address::preShowEthereal( void )
{
  m_network.preShowEthereal( );
  m_tsapIdentifier.preShowEthereal( );
}

PString H245_MulticastAddress_iP6Address::getSummary( void ) 
{
  return PString( "MulticastAddress_iP6Address" );
}

void H245_MulticastAddress_iP6Address::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pnetwork = m_network.getValue();
  proto_tree_add_ipv6( tree, hCont->h245_1.hf_h245_MulticastAddress_iP6Address_network, tvb, offset + m_network.GetStartByte(), m_network.GetByteLength() , ( const unsigned char* )pnetwork );
  delete[] pnetwork;

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MulticastAddress_iP6Address_tsapIdentifier, tvb, offset + m_tsapIdentifier.GetStartByte(), m_tsapIdentifier.GetByteLength() , m_tsapIdentifier.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// ArrayOf_EscrowData
//

H245_ArrayOf_EscrowData::H245_ArrayOf_EscrowData(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_EscrowData::CreateObject() const
{
  return new H245_EscrowData;
}


H245_EscrowData & H245_ArrayOf_EscrowData::operator[](PINDEX i) const
{
  return (H245_EscrowData &)array[i];
}


PObject * H245_ArrayOf_EscrowData::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_EscrowData::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_EscrowData(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_EscrowData::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_EscrowData& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_EscrowData::getSummary( void ) 
{
  return PString( "ArrayOf_EscrowData" );
}

void H245_ArrayOf_EscrowData::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_EscrowData_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_EscrowData_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_EscrowData_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (EscrowData)", i );
    ArrayOf_EscrowData_tree = proto_item_add_subtree( ArrayOf_EscrowData_ti, hCont->h245_1.ett_h245_ArrayOf_EscrowData );
    array[i].showEthereal( ArrayOf_EscrowData_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// OpenLogicalChannelAck_forwardMultiplexAckParameters
//

H245_OpenLogicalChannelAck_forwardMultiplexAckParameters::H245_OpenLogicalChannelAck_forwardMultiplexAckParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
      , "h2250LogicalChannelAckParameters "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_OpenLogicalChannelAck_forwardMultiplexAckParameters::operator H245_H2250LogicalChannelAckParameters &() const
#else
H245_OpenLogicalChannelAck_forwardMultiplexAckParameters::operator H245_H2250LogicalChannelAckParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H2250LogicalChannelAckParameters::Class()), PInvalidCast);
#endif
  return *(H245_H2250LogicalChannelAckParameters *)choice;
}


H245_OpenLogicalChannelAck_forwardMultiplexAckParameters::operator const H245_H2250LogicalChannelAckParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H2250LogicalChannelAckParameters::Class()), PInvalidCast);
#endif
  return *(H245_H2250LogicalChannelAckParameters *)choice;
}


BOOL H245_OpenLogicalChannelAck_forwardMultiplexAckParameters::CreateObject()
{
  switch (tag) {
    case e_h2250LogicalChannelAckParameters :
      choice = new H245_H2250LogicalChannelAckParameters();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_OpenLogicalChannelAck_forwardMultiplexAckParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannelAck_forwardMultiplexAckParameters::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannelAck_forwardMultiplexAckParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_OpenLogicalChannelAck_forwardMultiplexAckParameters::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_h2250LogicalChannelAckParameters :
        ( ( H245_H2250LogicalChannelAckParameters * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_OpenLogicalChannelAck_forwardMultiplexAckParameters::getSummary( void ) 
{
  return PString( "OpenLogicalChannelAck_forwardMultiplexAckParameters" );
}

void H245_OpenLogicalChannelAck_forwardMultiplexAckParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_OpenLogicalChannelAck_forwardMultiplexAckParameters_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// OpenLogicalChannelReject_cause
//

H245_OpenLogicalChannelReject_cause::H245_OpenLogicalChannelReject_cause(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 6, TRUE
#ifndef PASN_NOPRINTON
      , "unspecified "
        "unsuitableReverseParameters "
        "dataTypeNotSupported "
        "dataTypeNotAvailable "
        "unknownDataType "
        "dataTypeALCombinationNotSupported "
        "multicastChannelNotAllowed "
        "insufficientBandwidth "
        "separateStackEstablishmentFailed "
        "invalidSessionID "
        "masterSlaveConflict "
        "waitForCommunicationMode "
        "invalidDependentChannel "
        "replacementForRejected "
#endif
    )
{
}


BOOL H245_OpenLogicalChannelReject_cause::CreateObject()
{
  switch (tag) {
    case e_unspecified :
    case e_unsuitableReverseParameters :
    case e_dataTypeNotSupported :
    case e_dataTypeNotAvailable :
    case e_unknownDataType :
    case e_dataTypeALCombinationNotSupported :
    case e_multicastChannelNotAllowed :
    case e_insufficientBandwidth :
    case e_separateStackEstablishmentFailed :
    case e_invalidSessionID :
    case e_masterSlaveConflict :
    case e_waitForCommunicationMode :
    case e_invalidDependentChannel :
    case e_replacementForRejected :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_OpenLogicalChannelReject_cause::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannelReject_cause::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannelReject_cause(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_OpenLogicalChannelReject_cause::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_unspecified :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_unsuitableReverseParameters :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_dataTypeNotSupported :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_dataTypeNotAvailable :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_unknownDataType :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_dataTypeALCombinationNotSupported :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_multicastChannelNotAllowed :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_insufficientBandwidth :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_separateStackEstablishmentFailed :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_invalidSessionID :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_masterSlaveConflict :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_waitForCommunicationMode :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_invalidDependentChannel :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_replacementForRejected :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_OpenLogicalChannelReject_cause::getSummary( void ) 
{
  return PString( "OpenLogicalChannelReject_cause" );
}

void H245_OpenLogicalChannelReject_cause::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "unspecified" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_OpenLogicalChannelReject_cause_unspecified, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "unsuitableReverseParameters" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_OpenLogicalChannelReject_cause_unsuitableReverseParameters, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "dataTypeNotSupported" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_OpenLogicalChannelReject_cause_dataTypeNotSupported, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "dataTypeNotAvailable" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_OpenLogicalChannelReject_cause_dataTypeNotAvailable, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "unknownDataType" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_OpenLogicalChannelReject_cause_unknownDataType, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "dataTypeALCombinationNotSupported" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_OpenLogicalChannelReject_cause_dataTypeALCombinationNotSupported, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "multicastChannelNotAllowed" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_OpenLogicalChannelReject_cause_multicastChannelNotAllowed, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "insufficientBandwidth" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_OpenLogicalChannelReject_cause_insufficientBandwidth, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "separateStackEstablishmentFailed" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_OpenLogicalChannelReject_cause_separateStackEstablishmentFailed, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "invalidSessionID" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_OpenLogicalChannelReject_cause_invalidSessionID, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "masterSlaveConflict" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_OpenLogicalChannelReject_cause_masterSlaveConflict, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "waitForCommunicationMode" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_OpenLogicalChannelReject_cause_waitForCommunicationMode, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "invalidDependentChannel" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_OpenLogicalChannelReject_cause_invalidDependentChannel, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "replacementForRejected" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_OpenLogicalChannelReject_cause_replacementForRejected, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// CloseLogicalChannel_source
//

H245_CloseLogicalChannel_source::H245_CloseLogicalChannel_source(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
      , "user "
        "lcse "
#endif
    )
{
}


BOOL H245_CloseLogicalChannel_source::CreateObject()
{
  switch (tag) {
    case e_user :
    case e_lcse :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_CloseLogicalChannel_source::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CloseLogicalChannel_source::Class()), PInvalidCast);
#endif
  return new H245_CloseLogicalChannel_source(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CloseLogicalChannel_source::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_user :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_lcse :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_CloseLogicalChannel_source::getSummary( void ) 
{
  return PString( "CloseLogicalChannel_source" );
}

void H245_CloseLogicalChannel_source::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "user" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_CloseLogicalChannel_source_user, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "lcse" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_CloseLogicalChannel_source_lcse, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// CloseLogicalChannel_reason
//

H245_CloseLogicalChannel_reason::H245_CloseLogicalChannel_reason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "unknown "
        "reopen "
        "reservationFailure "
#endif
    )
{
}


BOOL H245_CloseLogicalChannel_reason::CreateObject()
{
  switch (tag) {
    case e_unknown :
    case e_reopen :
    case e_reservationFailure :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_CloseLogicalChannel_reason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CloseLogicalChannel_reason::Class()), PInvalidCast);
#endif
  return new H245_CloseLogicalChannel_reason(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CloseLogicalChannel_reason::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_unknown :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_reopen :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_reservationFailure :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_CloseLogicalChannel_reason::getSummary( void ) 
{
  return PString( "CloseLogicalChannel_reason" );
}

void H245_CloseLogicalChannel_reason::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "unknown" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_CloseLogicalChannel_reason_unknown, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "reopen" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_CloseLogicalChannel_reason_reopen, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "reservationFailure" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_CloseLogicalChannel_reason_reservationFailure, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// RequestChannelClose_reason
//

H245_RequestChannelClose_reason::H245_RequestChannelClose_reason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "unknown "
        "normal "
        "reopen "
        "reservationFailure "
#endif
    )
{
}


BOOL H245_RequestChannelClose_reason::CreateObject()
{
  switch (tag) {
    case e_unknown :
    case e_normal :
    case e_reopen :
    case e_reservationFailure :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_RequestChannelClose_reason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestChannelClose_reason::Class()), PInvalidCast);
#endif
  return new H245_RequestChannelClose_reason(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RequestChannelClose_reason::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_unknown :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_normal :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_reopen :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_reservationFailure :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_RequestChannelClose_reason::getSummary( void ) 
{
  return PString( "RequestChannelClose_reason" );
}

void H245_RequestChannelClose_reason::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "unknown" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_RequestChannelClose_reason_unknown, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "normal" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_RequestChannelClose_reason_normal, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "reopen" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_RequestChannelClose_reason_reopen, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "reservationFailure" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_RequestChannelClose_reason_reservationFailure, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// RequestChannelCloseReject_cause
//

H245_RequestChannelCloseReject_cause::H245_RequestChannelCloseReject_cause(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
      , "unspecified "
#endif
    )
{
}


BOOL H245_RequestChannelCloseReject_cause::CreateObject()
{
  switch (tag) {
    case e_unspecified :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_RequestChannelCloseReject_cause::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestChannelCloseReject_cause::Class()), PInvalidCast);
#endif
  return new H245_RequestChannelCloseReject_cause(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RequestChannelCloseReject_cause::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_unspecified :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_RequestChannelCloseReject_cause::getSummary( void ) 
{
  return PString( "RequestChannelCloseReject_cause" );
}

void H245_RequestChannelCloseReject_cause::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "unspecified" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_RequestChannelCloseReject_cause_unspecified, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_MultiplexEntryDescriptor
//

H245_ArrayOf_MultiplexEntryDescriptor::H245_ArrayOf_MultiplexEntryDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_MultiplexEntryDescriptor::CreateObject() const
{
  return new H245_MultiplexEntryDescriptor;
}


H245_MultiplexEntryDescriptor & H245_ArrayOf_MultiplexEntryDescriptor::operator[](PINDEX i) const
{
  return (H245_MultiplexEntryDescriptor &)array[i];
}


PObject * H245_ArrayOf_MultiplexEntryDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_MultiplexEntryDescriptor::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_MultiplexEntryDescriptor(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_MultiplexEntryDescriptor::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_MultiplexEntryDescriptor& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_MultiplexEntryDescriptor::getSummary( void ) 
{
  return PString( "ArrayOf_MultiplexEntryDescriptor" );
}

void H245_ArrayOf_MultiplexEntryDescriptor::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_MultiplexEntryDescriptor_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_MultiplexEntryDescriptor_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_MultiplexEntryDescriptor_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (MultiplexEntryDescriptor)", i );
    ArrayOf_MultiplexEntryDescriptor_tree = proto_item_add_subtree( ArrayOf_MultiplexEntryDescriptor_ti, hCont->h245_1.ett_h245_ArrayOf_MultiplexEntryDescriptor );
    array[i].showEthereal( ArrayOf_MultiplexEntryDescriptor_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_MultiplexElement
//

H245_ArrayOf_MultiplexElement::H245_ArrayOf_MultiplexElement(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_MultiplexElement::CreateObject() const
{
  return new H245_MultiplexElement;
}


H245_MultiplexElement & H245_ArrayOf_MultiplexElement::operator[](PINDEX i) const
{
  return (H245_MultiplexElement &)array[i];
}


PObject * H245_ArrayOf_MultiplexElement::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_MultiplexElement::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_MultiplexElement(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_MultiplexElement::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_MultiplexElement& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_MultiplexElement::getSummary( void ) 
{
  return PString( "ArrayOf_MultiplexElement" );
}

void H245_ArrayOf_MultiplexElement::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_MultiplexElement_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_MultiplexElement_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_MultiplexElement_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (MultiplexElement)", i );
    ArrayOf_MultiplexElement_tree = proto_item_add_subtree( ArrayOf_MultiplexElement_ti, hCont->h245_1.ett_h245_ArrayOf_MultiplexElement );
    array[i].showEthereal( ArrayOf_MultiplexElement_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// MultiplexElement_type
//

H245_MultiplexElement_type::H245_MultiplexElement_type(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
      , "logicalChannelNumber "
        "subElementList "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultiplexElement_type::operator H245_ArrayOf_MultiplexElement &() const
#else
H245_MultiplexElement_type::operator H245_ArrayOf_MultiplexElement &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ArrayOf_MultiplexElement::Class()), PInvalidCast);
#endif
  return *(H245_ArrayOf_MultiplexElement *)choice;
}


H245_MultiplexElement_type::operator const H245_ArrayOf_MultiplexElement &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_ArrayOf_MultiplexElement::Class()), PInvalidCast);
#endif
  return *(H245_ArrayOf_MultiplexElement *)choice;
}


BOOL H245_MultiplexElement_type::CreateObject()
{
  switch (tag) {
    case e_logicalChannelNumber :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
      return TRUE;
    case e_subElementList :
      choice = new H245_ArrayOf_MultiplexElement();
      choice->SetConstraints(PASN_Object::FixedConstraint, 2, 255);
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_MultiplexElement_type::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexElement_type::Class()), PInvalidCast);
#endif
  return new H245_MultiplexElement_type(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultiplexElement_type::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_logicalChannelNumber :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_subElementList :
        ( ( H245_ArrayOf_MultiplexElement * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_MultiplexElement_type::getSummary( void ) 
{
  return PString( "MultiplexElement_type" );
}

void H245_MultiplexElement_type::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "logicalChannelNumber" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MultiplexElement_type_logicalChannelNumber, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_MultiplexElement_type_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// MultiplexElement_repeatCount
//

H245_MultiplexElement_repeatCount::H245_MultiplexElement_repeatCount(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
      , "finite "
        "untilClosingFlag "
#endif
    )
{
}


BOOL H245_MultiplexElement_repeatCount::CreateObject()
{
  switch (tag) {
    case e_finite :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
      return TRUE;
    case e_untilClosingFlag :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_MultiplexElement_repeatCount::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexElement_repeatCount::Class()), PInvalidCast);
#endif
  return new H245_MultiplexElement_repeatCount(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultiplexElement_repeatCount::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_finite :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_untilClosingFlag :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_MultiplexElement_repeatCount::getSummary( void ) 
{
  return PString( "MultiplexElement_repeatCount" );
}

void H245_MultiplexElement_repeatCount::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "finite" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MultiplexElement_repeatCount_finite, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "untilClosingFlag" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MultiplexElement_repeatCount_untilClosingFlag, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_MultiplexTableEntryNumber
//

H245_ArrayOf_MultiplexTableEntryNumber::H245_ArrayOf_MultiplexTableEntryNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_MultiplexTableEntryNumber::CreateObject() const
{
  return new H245_MultiplexTableEntryNumber;
}


H245_MultiplexTableEntryNumber & H245_ArrayOf_MultiplexTableEntryNumber::operator[](PINDEX i) const
{
  return (H245_MultiplexTableEntryNumber &)array[i];
}


PObject * H245_ArrayOf_MultiplexTableEntryNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_MultiplexTableEntryNumber::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_MultiplexTableEntryNumber(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_MultiplexTableEntryNumber::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_MultiplexTableEntryNumber& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_MultiplexTableEntryNumber::getSummary( void ) 
{
  return PString( "ArrayOf_MultiplexTableEntryNumber" );
}

void H245_ArrayOf_MultiplexTableEntryNumber::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  for (int i=0; i < array.GetSize(); i++ ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_ArrayOf_MultiplexTableEntryNumber_array, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), ( (PASN_Integer& ) array[i] ).GetValue() );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_MultiplexEntryRejectionDescriptions
//

H245_ArrayOf_MultiplexEntryRejectionDescriptions::H245_ArrayOf_MultiplexEntryRejectionDescriptions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_MultiplexEntryRejectionDescriptions::CreateObject() const
{
  return new H245_MultiplexEntryRejectionDescriptions;
}


H245_MultiplexEntryRejectionDescriptions & H245_ArrayOf_MultiplexEntryRejectionDescriptions::operator[](PINDEX i) const
{
  return (H245_MultiplexEntryRejectionDescriptions &)array[i];
}


PObject * H245_ArrayOf_MultiplexEntryRejectionDescriptions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_MultiplexEntryRejectionDescriptions::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_MultiplexEntryRejectionDescriptions(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_MultiplexEntryRejectionDescriptions::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_MultiplexEntryRejectionDescriptions& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_MultiplexEntryRejectionDescriptions::getSummary( void ) 
{
  return PString( "ArrayOf_MultiplexEntryRejectionDescriptions" );
}

void H245_ArrayOf_MultiplexEntryRejectionDescriptions::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_MultiplexEntryRejectionDescriptions_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_MultiplexEntryRejectionDescriptions_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_MultiplexEntryRejectionDescriptions_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (MultiplexEntryRejectionDescriptions)", i );
    ArrayOf_MultiplexEntryRejectionDescriptions_tree = proto_item_add_subtree( ArrayOf_MultiplexEntryRejectionDescriptions_ti, hCont->h245_1.ett_h245_ArrayOf_MultiplexEntryRejectionDescriptions );
    array[i].showEthereal( ArrayOf_MultiplexEntryRejectionDescriptions_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// MultiplexEntryRejectionDescriptions_cause
//

H245_MultiplexEntryRejectionDescriptions_cause::H245_MultiplexEntryRejectionDescriptions_cause(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "unspecifiedCause "
        "descriptorTooComplex "
#endif
    )
{
}


BOOL H245_MultiplexEntryRejectionDescriptions_cause::CreateObject()
{
  switch (tag) {
    case e_unspecifiedCause :
    case e_descriptorTooComplex :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_MultiplexEntryRejectionDescriptions_cause::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexEntryRejectionDescriptions_cause::Class()), PInvalidCast);
#endif
  return new H245_MultiplexEntryRejectionDescriptions_cause(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultiplexEntryRejectionDescriptions_cause::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_unspecifiedCause :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_descriptorTooComplex :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_MultiplexEntryRejectionDescriptions_cause::getSummary( void ) 
{
  return PString( "MultiplexEntryRejectionDescriptions_cause" );
}

void H245_MultiplexEntryRejectionDescriptions_cause::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "unspecifiedCause" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MultiplexEntryRejectionDescriptions_cause_unspecifiedCause, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "descriptorTooComplex" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MultiplexEntryRejectionDescriptions_cause_descriptorTooComplex, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_RequestMultiplexEntryRejectionDescriptions
//

H245_ArrayOf_RequestMultiplexEntryRejectionDescriptions::H245_ArrayOf_RequestMultiplexEntryRejectionDescriptions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_RequestMultiplexEntryRejectionDescriptions::CreateObject() const
{
  return new H245_RequestMultiplexEntryRejectionDescriptions;
}


H245_RequestMultiplexEntryRejectionDescriptions & H245_ArrayOf_RequestMultiplexEntryRejectionDescriptions::operator[](PINDEX i) const
{
  return (H245_RequestMultiplexEntryRejectionDescriptions &)array[i];
}


PObject * H245_ArrayOf_RequestMultiplexEntryRejectionDescriptions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_RequestMultiplexEntryRejectionDescriptions::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_RequestMultiplexEntryRejectionDescriptions(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_RequestMultiplexEntryRejectionDescriptions::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_RequestMultiplexEntryRejectionDescriptions& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_RequestMultiplexEntryRejectionDescriptions::getSummary( void ) 
{
  return PString( "ArrayOf_RequestMultiplexEntryRejectionDescriptions" );
}

void H245_ArrayOf_RequestMultiplexEntryRejectionDescriptions::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_RequestMultiplexEntryRejectionDescriptions_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_RequestMultiplexEntryRejectionDescriptions_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_RequestMultiplexEntryRejectionDescriptions_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (RequestMultiplexEntryRejectionDescriptions)", i );
    ArrayOf_RequestMultiplexEntryRejectionDescriptions_tree = proto_item_add_subtree( ArrayOf_RequestMultiplexEntryRejectionDescriptions_ti, hCont->h245_1.ett_h245_ArrayOf_RequestMultiplexEntryRejectionDescriptions );
    array[i].showEthereal( ArrayOf_RequestMultiplexEntryRejectionDescriptions_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// RequestMultiplexEntryRejectionDescriptions_cause
//

H245_RequestMultiplexEntryRejectionDescriptions_cause::H245_RequestMultiplexEntryRejectionDescriptions_cause(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
      , "unspecifiedCause "
#endif
    )
{
}


BOOL H245_RequestMultiplexEntryRejectionDescriptions_cause::CreateObject()
{
  switch (tag) {
    case e_unspecifiedCause :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_RequestMultiplexEntryRejectionDescriptions_cause::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestMultiplexEntryRejectionDescriptions_cause::Class()), PInvalidCast);
#endif
  return new H245_RequestMultiplexEntryRejectionDescriptions_cause(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RequestMultiplexEntryRejectionDescriptions_cause::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_unspecifiedCause :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_RequestMultiplexEntryRejectionDescriptions_cause::getSummary( void ) 
{
  return PString( "RequestMultiplexEntryRejectionDescriptions_cause" );
}

void H245_RequestMultiplexEntryRejectionDescriptions_cause::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "unspecifiedCause" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_RequestMultiplexEntryRejectionDescriptions_cause_unspecifiedCause, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_ModeDescription
//

H245_ArrayOf_ModeDescription::H245_ArrayOf_ModeDescription(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_ModeDescription::CreateObject() const
{
  return new H245_ModeDescription;
}


H245_ModeDescription & H245_ArrayOf_ModeDescription::operator[](PINDEX i) const
{
  return (H245_ModeDescription &)array[i];
}


PObject * H245_ArrayOf_ModeDescription::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_ModeDescription::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_ModeDescription(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_ModeDescription::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_ModeDescription& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_ModeDescription::getSummary( void ) 
{
  return PString( "ArrayOf_ModeDescription" );
}

void H245_ArrayOf_ModeDescription::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_ModeDescription_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_ModeDescription_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_ModeDescription_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (ModeDescription)", i );
    ArrayOf_ModeDescription_tree = proto_item_add_subtree( ArrayOf_ModeDescription_ti, hCont->h245_1.ett_h245_ArrayOf_ModeDescription );
    array[i].showEthereal( ArrayOf_ModeDescription_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// RequestModeAck_response
//

H245_RequestModeAck_response::H245_RequestModeAck_response(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "willTransmitMostPreferredMode "
        "willTransmitLessPreferredMode "
#endif
    )
{
}


BOOL H245_RequestModeAck_response::CreateObject()
{
  switch (tag) {
    case e_willTransmitMostPreferredMode :
    case e_willTransmitLessPreferredMode :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_RequestModeAck_response::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestModeAck_response::Class()), PInvalidCast);
#endif
  return new H245_RequestModeAck_response(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RequestModeAck_response::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_willTransmitMostPreferredMode :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_willTransmitLessPreferredMode :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_RequestModeAck_response::getSummary( void ) 
{
  return PString( "RequestModeAck_response" );
}

void H245_RequestModeAck_response::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "willTransmitMostPreferredMode" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_RequestModeAck_response_willTransmitMostPreferredMode, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "willTransmitLessPreferredMode" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_RequestModeAck_response_willTransmitLessPreferredMode, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// RequestModeReject_cause
//

H245_RequestModeReject_cause::H245_RequestModeReject_cause(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "modeUnavailable "
        "multipointConstraint "
        "requestDenied "
#endif
    )
{
}


BOOL H245_RequestModeReject_cause::CreateObject()
{
  switch (tag) {
    case e_modeUnavailable :
    case e_multipointConstraint :
    case e_requestDenied :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_RequestModeReject_cause::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestModeReject_cause::Class()), PInvalidCast);
#endif
  return new H245_RequestModeReject_cause(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RequestModeReject_cause::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_modeUnavailable :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_multipointConstraint :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_requestDenied :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_RequestModeReject_cause::getSummary( void ) 
{
  return PString( "RequestModeReject_cause" );
}

void H245_RequestModeReject_cause::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "modeUnavailable" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_RequestModeReject_cause_modeUnavailable, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "multipointConstraint" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_RequestModeReject_cause_multipointConstraint, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "requestDenied" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_RequestModeReject_cause_requestDenied, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ModeElement_type
//

H245_ModeElement_type::H245_ModeElement_type(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "videoMode "
        "audioMode "
        "dataMode "
        "encryptionMode "
        "h235Mode "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ModeElement_type::operator H245_NonStandardParameter &() const
#else
H245_ModeElement_type::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_ModeElement_type::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ModeElement_type::operator H245_VideoMode &() const
#else
H245_ModeElement_type::operator H245_VideoMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_VideoMode::Class()), PInvalidCast);
#endif
  return *(H245_VideoMode *)choice;
}


H245_ModeElement_type::operator const H245_VideoMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_VideoMode::Class()), PInvalidCast);
#endif
  return *(H245_VideoMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ModeElement_type::operator H245_AudioMode &() const
#else
H245_ModeElement_type::operator H245_AudioMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_AudioMode::Class()), PInvalidCast);
#endif
  return *(H245_AudioMode *)choice;
}


H245_ModeElement_type::operator const H245_AudioMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_AudioMode::Class()), PInvalidCast);
#endif
  return *(H245_AudioMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ModeElement_type::operator H245_DataMode &() const
#else
H245_ModeElement_type::operator H245_DataMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataMode::Class()), PInvalidCast);
#endif
  return *(H245_DataMode *)choice;
}


H245_ModeElement_type::operator const H245_DataMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataMode::Class()), PInvalidCast);
#endif
  return *(H245_DataMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ModeElement_type::operator H245_EncryptionMode &() const
#else
H245_ModeElement_type::operator H245_EncryptionMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_EncryptionMode::Class()), PInvalidCast);
#endif
  return *(H245_EncryptionMode *)choice;
}


H245_ModeElement_type::operator const H245_EncryptionMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_EncryptionMode::Class()), PInvalidCast);
#endif
  return *(H245_EncryptionMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ModeElement_type::operator H245_H235Mode &() const
#else
H245_ModeElement_type::operator H245_H235Mode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H235Mode::Class()), PInvalidCast);
#endif
  return *(H245_H235Mode *)choice;
}


H245_ModeElement_type::operator const H245_H235Mode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H235Mode::Class()), PInvalidCast);
#endif
  return *(H245_H235Mode *)choice;
}


BOOL H245_ModeElement_type::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_videoMode :
      choice = new H245_VideoMode();
      return TRUE;
    case e_audioMode :
      choice = new H245_AudioMode();
      return TRUE;
    case e_dataMode :
      choice = new H245_DataMode();
      return TRUE;
    case e_encryptionMode :
      choice = new H245_EncryptionMode();
      return TRUE;
    case e_h235Mode :
      choice = new H245_H235Mode();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_ModeElement_type::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ModeElement_type::Class()), PInvalidCast);
#endif
  return new H245_ModeElement_type(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ModeElement_type::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_videoMode :
        ( ( H245_VideoMode * ) choice )->preShowEthereal();
        break;
      case e_audioMode :
        ( ( H245_AudioMode * ) choice )->preShowEthereal();
        break;
      case e_dataMode :
        ( ( H245_DataMode * ) choice )->preShowEthereal();
        break;
      case e_encryptionMode :
        ( ( H245_EncryptionMode * ) choice )->preShowEthereal();
        break;
      case e_h235Mode :
        ( ( H245_H235Mode * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_ModeElement_type::getSummary( void ) 
{
  return PString( "ModeElement_type" );
}

void H245_ModeElement_type::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_ModeElement_type_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H235Mode_mediaMode
//

H245_H235Mode_mediaMode::H245_H235Mode_mediaMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "videoMode "
        "audioMode "
        "dataMode "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H235Mode_mediaMode::operator H245_NonStandardParameter &() const
#else
H245_H235Mode_mediaMode::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_H235Mode_mediaMode::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H235Mode_mediaMode::operator H245_VideoMode &() const
#else
H245_H235Mode_mediaMode::operator H245_VideoMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_VideoMode::Class()), PInvalidCast);
#endif
  return *(H245_VideoMode *)choice;
}


H245_H235Mode_mediaMode::operator const H245_VideoMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_VideoMode::Class()), PInvalidCast);
#endif
  return *(H245_VideoMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H235Mode_mediaMode::operator H245_AudioMode &() const
#else
H245_H235Mode_mediaMode::operator H245_AudioMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_AudioMode::Class()), PInvalidCast);
#endif
  return *(H245_AudioMode *)choice;
}


H245_H235Mode_mediaMode::operator const H245_AudioMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_AudioMode::Class()), PInvalidCast);
#endif
  return *(H245_AudioMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H235Mode_mediaMode::operator H245_DataMode &() const
#else
H245_H235Mode_mediaMode::operator H245_DataMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataMode::Class()), PInvalidCast);
#endif
  return *(H245_DataMode *)choice;
}


H245_H235Mode_mediaMode::operator const H245_DataMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataMode::Class()), PInvalidCast);
#endif
  return *(H245_DataMode *)choice;
}


BOOL H245_H235Mode_mediaMode::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_videoMode :
      choice = new H245_VideoMode();
      return TRUE;
    case e_audioMode :
      choice = new H245_AudioMode();
      return TRUE;
    case e_dataMode :
      choice = new H245_DataMode();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_H235Mode_mediaMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H235Mode_mediaMode::Class()), PInvalidCast);
#endif
  return new H245_H235Mode_mediaMode(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H235Mode_mediaMode::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_videoMode :
        ( ( H245_VideoMode * ) choice )->preShowEthereal();
        break;
      case e_audioMode :
        ( ( H245_AudioMode * ) choice )->preShowEthereal();
        break;
      case e_dataMode :
        ( ( H245_DataMode * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_H235Mode_mediaMode::getSummary( void ) 
{
  return PString( "H235Mode_mediaMode" );
}

void H245_H235Mode_mediaMode::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_H235Mode_mediaMode_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H223ModeParameters_adaptationLayerType
//

H245_H223ModeParameters_adaptationLayerType::H245_H223ModeParameters_adaptationLayerType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 6, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "al1Framed "
        "al1NotFramed "
        "al2WithoutSequenceNumbers "
        "al2WithSequenceNumbers "
        "al3 "
        "al1M "
        "al2M "
        "al3M "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223ModeParameters_adaptationLayerType::operator H245_NonStandardParameter &() const
#else
H245_H223ModeParameters_adaptationLayerType::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_H223ModeParameters_adaptationLayerType::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223ModeParameters_adaptationLayerType::operator H245_H223ModeParameters_adaptationLayerType_al3 &() const
#else
H245_H223ModeParameters_adaptationLayerType::operator H245_H223ModeParameters_adaptationLayerType_al3 &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223ModeParameters_adaptationLayerType_al3::Class()), PInvalidCast);
#endif
  return *(H245_H223ModeParameters_adaptationLayerType_al3 *)choice;
}


H245_H223ModeParameters_adaptationLayerType::operator const H245_H223ModeParameters_adaptationLayerType_al3 &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223ModeParameters_adaptationLayerType_al3::Class()), PInvalidCast);
#endif
  return *(H245_H223ModeParameters_adaptationLayerType_al3 *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223ModeParameters_adaptationLayerType::operator H245_H223AL1MParameters &() const
#else
H245_H223ModeParameters_adaptationLayerType::operator H245_H223AL1MParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223AL1MParameters::Class()), PInvalidCast);
#endif
  return *(H245_H223AL1MParameters *)choice;
}


H245_H223ModeParameters_adaptationLayerType::operator const H245_H223AL1MParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223AL1MParameters::Class()), PInvalidCast);
#endif
  return *(H245_H223AL1MParameters *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223ModeParameters_adaptationLayerType::operator H245_H223AL2MParameters &() const
#else
H245_H223ModeParameters_adaptationLayerType::operator H245_H223AL2MParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223AL2MParameters::Class()), PInvalidCast);
#endif
  return *(H245_H223AL2MParameters *)choice;
}


H245_H223ModeParameters_adaptationLayerType::operator const H245_H223AL2MParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223AL2MParameters::Class()), PInvalidCast);
#endif
  return *(H245_H223AL2MParameters *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223ModeParameters_adaptationLayerType::operator H245_H223AL3MParameters &() const
#else
H245_H223ModeParameters_adaptationLayerType::operator H245_H223AL3MParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223AL3MParameters::Class()), PInvalidCast);
#endif
  return *(H245_H223AL3MParameters *)choice;
}


H245_H223ModeParameters_adaptationLayerType::operator const H245_H223AL3MParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223AL3MParameters::Class()), PInvalidCast);
#endif
  return *(H245_H223AL3MParameters *)choice;
}


BOOL H245_H223ModeParameters_adaptationLayerType::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_al1Framed :
    case e_al1NotFramed :
    case e_al2WithoutSequenceNumbers :
    case e_al2WithSequenceNumbers :
      choice = new PASN_Null();
      return TRUE;
    case e_al3 :
      choice = new H245_H223ModeParameters_adaptationLayerType_al3();
      return TRUE;
    case e_al1M :
      choice = new H245_H223AL1MParameters();
      return TRUE;
    case e_al2M :
      choice = new H245_H223AL2MParameters();
      return TRUE;
    case e_al3M :
      choice = new H245_H223AL3MParameters();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_H223ModeParameters_adaptationLayerType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223ModeParameters_adaptationLayerType::Class()), PInvalidCast);
#endif
  return new H245_H223ModeParameters_adaptationLayerType(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223ModeParameters_adaptationLayerType::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_al1Framed :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_al1NotFramed :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_al2WithoutSequenceNumbers :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_al2WithSequenceNumbers :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_al3 :
        ( ( H245_H223ModeParameters_adaptationLayerType_al3 * ) choice )->preShowEthereal();
        break;
      case e_al1M :
        ( ( H245_H223AL1MParameters * ) choice )->preShowEthereal();
        break;
      case e_al2M :
        ( ( H245_H223AL2MParameters * ) choice )->preShowEthereal();
        break;
      case e_al3M :
        ( ( H245_H223AL3MParameters * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_H223ModeParameters_adaptationLayerType::getSummary( void ) 
{
  return PString( "H223ModeParameters_adaptationLayerType" );
}

void H245_H223ModeParameters_adaptationLayerType::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "al1Framed" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223ModeParameters_adaptationLayerType_al1Framed, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "al1NotFramed" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223ModeParameters_adaptationLayerType_al1NotFramed, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "al2WithoutSequenceNumbers" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223ModeParameters_adaptationLayerType_al2WithoutSequenceNumbers, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "al2WithSequenceNumbers" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223ModeParameters_adaptationLayerType_al2WithSequenceNumbers, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_H223ModeParameters_adaptationLayerType_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// RedundancyEncodingMode_secondaryEncoding
//

H245_RedundancyEncodingMode_secondaryEncoding::H245_RedundancyEncodingMode_secondaryEncoding(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "audioData "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RedundancyEncodingMode_secondaryEncoding::operator H245_NonStandardParameter &() const
#else
H245_RedundancyEncodingMode_secondaryEncoding::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_RedundancyEncodingMode_secondaryEncoding::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RedundancyEncodingMode_secondaryEncoding::operator H245_AudioMode &() const
#else
H245_RedundancyEncodingMode_secondaryEncoding::operator H245_AudioMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_AudioMode::Class()), PInvalidCast);
#endif
  return *(H245_AudioMode *)choice;
}


H245_RedundancyEncodingMode_secondaryEncoding::operator const H245_AudioMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_AudioMode::Class()), PInvalidCast);
#endif
  return *(H245_AudioMode *)choice;
}


BOOL H245_RedundancyEncodingMode_secondaryEncoding::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_audioData :
      choice = new H245_AudioMode();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_RedundancyEncodingMode_secondaryEncoding::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RedundancyEncodingMode_secondaryEncoding::Class()), PInvalidCast);
#endif
  return new H245_RedundancyEncodingMode_secondaryEncoding(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RedundancyEncodingMode_secondaryEncoding::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_audioData :
        ( ( H245_AudioMode * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_RedundancyEncodingMode_secondaryEncoding::getSummary( void ) 
{
  return PString( "RedundancyEncodingMode_secondaryEncoding" );
}

void H245_RedundancyEncodingMode_secondaryEncoding::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_RedundancyEncodingMode_secondaryEncoding_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H261VideoMode_resolution
//

H245_H261VideoMode_resolution::H245_H261VideoMode_resolution(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
      , "qcif "
        "cif "
#endif
    )
{
}


BOOL H245_H261VideoMode_resolution::CreateObject()
{
  switch (tag) {
    case e_qcif :
    case e_cif :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_H261VideoMode_resolution::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H261VideoMode_resolution::Class()), PInvalidCast);
#endif
  return new H245_H261VideoMode_resolution(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H261VideoMode_resolution::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_qcif :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_cif :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_H261VideoMode_resolution::getSummary( void ) 
{
  return PString( "H261VideoMode_resolution" );
}

void H245_H261VideoMode_resolution::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "qcif" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H261VideoMode_resolution_qcif, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "cif" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H261VideoMode_resolution_cif, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H262VideoMode_profileAndLevel
//

H245_H262VideoMode_profileAndLevel::H245_H262VideoMode_profileAndLevel(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 11, TRUE
#ifndef PASN_NOPRINTON
      , "profileAndLevel_SPatML "
        "profileAndLevel_MPatLL "
        "profileAndLevel_MPatML "
        "profileAndLevel_MPatH_14 "
        "profileAndLevel_MPatHL "
        "profileAndLevel_SNRatLL "
        "profileAndLevel_SNRatML "
        "profileAndLevel_SpatialatH_14 "
        "profileAndLevel_HPatML "
        "profileAndLevel_HPatH_14 "
        "profileAndLevel_HPatHL "
#endif
    )
{
}


BOOL H245_H262VideoMode_profileAndLevel::CreateObject()
{
  switch (tag) {
    case e_profileAndLevel_SPatML :
    case e_profileAndLevel_MPatLL :
    case e_profileAndLevel_MPatML :
    case e_profileAndLevel_MPatH_14 :
    case e_profileAndLevel_MPatHL :
    case e_profileAndLevel_SNRatLL :
    case e_profileAndLevel_SNRatML :
    case e_profileAndLevel_SpatialatH_14 :
    case e_profileAndLevel_HPatML :
    case e_profileAndLevel_HPatH_14 :
    case e_profileAndLevel_HPatHL :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_H262VideoMode_profileAndLevel::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H262VideoMode_profileAndLevel::Class()), PInvalidCast);
#endif
  return new H245_H262VideoMode_profileAndLevel(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H262VideoMode_profileAndLevel::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_profileAndLevel_SPatML :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_profileAndLevel_MPatLL :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_profileAndLevel_MPatML :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_profileAndLevel_MPatH_14 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_profileAndLevel_MPatHL :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_profileAndLevel_SNRatLL :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_profileAndLevel_SNRatML :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_profileAndLevel_SpatialatH_14 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_profileAndLevel_HPatML :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_profileAndLevel_HPatH_14 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_profileAndLevel_HPatHL :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_H262VideoMode_profileAndLevel::getSummary( void ) 
{
  return PString( "H262VideoMode_profileAndLevel" );
}

void H245_H262VideoMode_profileAndLevel::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "profileAndLevel_SPatML" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H262VideoMode_profileAndLevel_profileAndLevel_SPatML, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "profileAndLevel_MPatLL" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H262VideoMode_profileAndLevel_profileAndLevel_MPatLL, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "profileAndLevel_MPatML" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H262VideoMode_profileAndLevel_profileAndLevel_MPatML, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "profileAndLevel_MPatH_14" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H262VideoMode_profileAndLevel_profileAndLevel_MPatH_14, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "profileAndLevel_MPatHL" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H262VideoMode_profileAndLevel_profileAndLevel_MPatHL, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "profileAndLevel_SNRatLL" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H262VideoMode_profileAndLevel_profileAndLevel_SNRatLL, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "profileAndLevel_SNRatML" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H262VideoMode_profileAndLevel_profileAndLevel_SNRatML, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "profileAndLevel_SpatialatH_14" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H262VideoMode_profileAndLevel_profileAndLevel_SpatialatH_14, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "profileAndLevel_HPatML" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H262VideoMode_profileAndLevel_profileAndLevel_HPatML, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "profileAndLevel_HPatH_14" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H262VideoMode_profileAndLevel_profileAndLevel_HPatH_14, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "profileAndLevel_HPatHL" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H262VideoMode_profileAndLevel_profileAndLevel_HPatHL, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H263VideoMode_resolution
//

H245_H263VideoMode_resolution::H245_H263VideoMode_resolution(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
      , "sqcif "
        "qcif "
        "cif "
        "cif4 "
        "cif16 "
#endif
    )
{
}


BOOL H245_H263VideoMode_resolution::CreateObject()
{
  switch (tag) {
    case e_sqcif :
    case e_qcif :
    case e_cif :
    case e_cif4 :
    case e_cif16 :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_H263VideoMode_resolution::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H263VideoMode_resolution::Class()), PInvalidCast);
#endif
  return new H245_H263VideoMode_resolution(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H263VideoMode_resolution::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_sqcif :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_qcif :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_cif :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_cif4 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_cif16 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_H263VideoMode_resolution::getSummary( void ) 
{
  return PString( "H263VideoMode_resolution" );
}

void H245_H263VideoMode_resolution::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "sqcif" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H263VideoMode_resolution_sqcif, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "qcif" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H263VideoMode_resolution_qcif, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "cif" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H263VideoMode_resolution_cif, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "cif4" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H263VideoMode_resolution_cif4, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "cif16" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H263VideoMode_resolution_cif16, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// AudioMode_g7231
//

H245_AudioMode_g7231::H245_AudioMode_g7231(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, FALSE
#ifndef PASN_NOPRINTON
      , "noSilenceSuppressionLowRate "
        "noSilenceSuppressionHighRate "
        "silenceSuppressionLowRate "
        "silenceSuppressionHighRate "
#endif
    )
{
}


BOOL H245_AudioMode_g7231::CreateObject()
{
  switch (tag) {
    case e_noSilenceSuppressionLowRate :
    case e_noSilenceSuppressionHighRate :
    case e_silenceSuppressionLowRate :
    case e_silenceSuppressionHighRate :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_AudioMode_g7231::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_AudioMode_g7231::Class()), PInvalidCast);
#endif
  return new H245_AudioMode_g7231(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_AudioMode_g7231::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_noSilenceSuppressionLowRate :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_noSilenceSuppressionHighRate :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_silenceSuppressionLowRate :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_silenceSuppressionHighRate :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_AudioMode_g7231::getSummary( void ) 
{
  return PString( "AudioMode_g7231" );
}

void H245_AudioMode_g7231::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "noSilenceSuppressionLowRate" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_AudioMode_g7231_noSilenceSuppressionLowRate, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "noSilenceSuppressionHighRate" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_AudioMode_g7231_noSilenceSuppressionHighRate, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "silenceSuppressionLowRate" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_AudioMode_g7231_silenceSuppressionLowRate, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "silenceSuppressionHighRate" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_AudioMode_g7231_silenceSuppressionHighRate, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// IS11172AudioMode_audioLayer
//

H245_IS11172AudioMode_audioLayer::H245_IS11172AudioMode_audioLayer(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
      , "audioLayer1 "
        "audioLayer2 "
        "audioLayer3 "
#endif
    )
{
}


BOOL H245_IS11172AudioMode_audioLayer::CreateObject()
{
  switch (tag) {
    case e_audioLayer1 :
    case e_audioLayer2 :
    case e_audioLayer3 :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_IS11172AudioMode_audioLayer::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS11172AudioMode_audioLayer::Class()), PInvalidCast);
#endif
  return new H245_IS11172AudioMode_audioLayer(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_IS11172AudioMode_audioLayer::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_audioLayer1 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_audioLayer2 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_audioLayer3 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_IS11172AudioMode_audioLayer::getSummary( void ) 
{
  return PString( "IS11172AudioMode_audioLayer" );
}

void H245_IS11172AudioMode_audioLayer::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "audioLayer1" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS11172AudioMode_audioLayer_audioLayer1, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "audioLayer2" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS11172AudioMode_audioLayer_audioLayer2, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "audioLayer3" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS11172AudioMode_audioLayer_audioLayer3, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// IS11172AudioMode_audioSampling
//

H245_IS11172AudioMode_audioSampling::H245_IS11172AudioMode_audioSampling(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
      , "audioSampling32k "
        "audioSampling44k1 "
        "audioSampling48k "
#endif
    )
{
}


BOOL H245_IS11172AudioMode_audioSampling::CreateObject()
{
  switch (tag) {
    case e_audioSampling32k :
    case e_audioSampling44k1 :
    case e_audioSampling48k :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_IS11172AudioMode_audioSampling::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS11172AudioMode_audioSampling::Class()), PInvalidCast);
#endif
  return new H245_IS11172AudioMode_audioSampling(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_IS11172AudioMode_audioSampling::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_audioSampling32k :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_audioSampling44k1 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_audioSampling48k :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_IS11172AudioMode_audioSampling::getSummary( void ) 
{
  return PString( "IS11172AudioMode_audioSampling" );
}

void H245_IS11172AudioMode_audioSampling::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "audioSampling32k" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS11172AudioMode_audioSampling_audioSampling32k, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "audioSampling44k1" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS11172AudioMode_audioSampling_audioSampling44k1, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "audioSampling48k" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS11172AudioMode_audioSampling_audioSampling48k, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// IS11172AudioMode_multichannelType
//

H245_IS11172AudioMode_multichannelType::H245_IS11172AudioMode_multichannelType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
      , "singleChannel "
        "twoChannelStereo "
        "twoChannelDual "
#endif
    )
{
}


BOOL H245_IS11172AudioMode_multichannelType::CreateObject()
{
  switch (tag) {
    case e_singleChannel :
    case e_twoChannelStereo :
    case e_twoChannelDual :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_IS11172AudioMode_multichannelType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS11172AudioMode_multichannelType::Class()), PInvalidCast);
#endif
  return new H245_IS11172AudioMode_multichannelType(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_IS11172AudioMode_multichannelType::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_singleChannel :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_twoChannelStereo :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_twoChannelDual :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_IS11172AudioMode_multichannelType::getSummary( void ) 
{
  return PString( "IS11172AudioMode_multichannelType" );
}

void H245_IS11172AudioMode_multichannelType::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "singleChannel" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS11172AudioMode_multichannelType_singleChannel, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "twoChannelStereo" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS11172AudioMode_multichannelType_twoChannelStereo, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "twoChannelDual" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS11172AudioMode_multichannelType_twoChannelDual, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// IS13818AudioMode_audioLayer
//

H245_IS13818AudioMode_audioLayer::H245_IS13818AudioMode_audioLayer(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
      , "audioLayer1 "
        "audioLayer2 "
        "audioLayer3 "
#endif
    )
{
}


BOOL H245_IS13818AudioMode_audioLayer::CreateObject()
{
  switch (tag) {
    case e_audioLayer1 :
    case e_audioLayer2 :
    case e_audioLayer3 :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_IS13818AudioMode_audioLayer::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS13818AudioMode_audioLayer::Class()), PInvalidCast);
#endif
  return new H245_IS13818AudioMode_audioLayer(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_IS13818AudioMode_audioLayer::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_audioLayer1 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_audioLayer2 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_audioLayer3 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_IS13818AudioMode_audioLayer::getSummary( void ) 
{
  return PString( "IS13818AudioMode_audioLayer" );
}

void H245_IS13818AudioMode_audioLayer::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "audioLayer1" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS13818AudioMode_audioLayer_audioLayer1, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "audioLayer2" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS13818AudioMode_audioLayer_audioLayer2, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "audioLayer3" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS13818AudioMode_audioLayer_audioLayer3, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// IS13818AudioMode_audioSampling
//

H245_IS13818AudioMode_audioSampling::H245_IS13818AudioMode_audioSampling(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 6, FALSE
#ifndef PASN_NOPRINTON
      , "audioSampling16k "
        "audioSampling22k05 "
        "audioSampling24k "
        "audioSampling32k "
        "audioSampling44k1 "
        "audioSampling48k "
#endif
    )
{
}


BOOL H245_IS13818AudioMode_audioSampling::CreateObject()
{
  switch (tag) {
    case e_audioSampling16k :
    case e_audioSampling22k05 :
    case e_audioSampling24k :
    case e_audioSampling32k :
    case e_audioSampling44k1 :
    case e_audioSampling48k :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_IS13818AudioMode_audioSampling::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS13818AudioMode_audioSampling::Class()), PInvalidCast);
#endif
  return new H245_IS13818AudioMode_audioSampling(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_IS13818AudioMode_audioSampling::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_audioSampling16k :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_audioSampling22k05 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_audioSampling24k :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_audioSampling32k :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_audioSampling44k1 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_audioSampling48k :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_IS13818AudioMode_audioSampling::getSummary( void ) 
{
  return PString( "IS13818AudioMode_audioSampling" );
}

void H245_IS13818AudioMode_audioSampling::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "audioSampling16k" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS13818AudioMode_audioSampling_audioSampling16k, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "audioSampling22k05" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS13818AudioMode_audioSampling_audioSampling22k05, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "audioSampling24k" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS13818AudioMode_audioSampling_audioSampling24k, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "audioSampling32k" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS13818AudioMode_audioSampling_audioSampling32k, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "audioSampling44k1" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS13818AudioMode_audioSampling_audioSampling44k1, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "audioSampling48k" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS13818AudioMode_audioSampling_audioSampling48k, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// IS13818AudioMode_multichannelType
//

H245_IS13818AudioMode_multichannelType::H245_IS13818AudioMode_multichannelType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 10, FALSE
#ifndef PASN_NOPRINTON
      , "singleChannel "
        "twoChannelStereo "
        "twoChannelDual "
        "threeChannels2_1 "
        "threeChannels3_0 "
        "fourChannels2_0_2_0 "
        "fourChannels2_2 "
        "fourChannels3_1 "
        "fiveChannels3_0_2_0 "
        "fiveChannels3_2 "
#endif
    )
{
}


BOOL H245_IS13818AudioMode_multichannelType::CreateObject()
{
  switch (tag) {
    case e_singleChannel :
    case e_twoChannelStereo :
    case e_twoChannelDual :
    case e_threeChannels2_1 :
    case e_threeChannels3_0 :
    case e_fourChannels2_0_2_0 :
    case e_fourChannels2_2 :
    case e_fourChannels3_1 :
    case e_fiveChannels3_0_2_0 :
    case e_fiveChannels3_2 :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_IS13818AudioMode_multichannelType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS13818AudioMode_multichannelType::Class()), PInvalidCast);
#endif
  return new H245_IS13818AudioMode_multichannelType(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_IS13818AudioMode_multichannelType::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_singleChannel :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_twoChannelStereo :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_twoChannelDual :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_threeChannels2_1 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_threeChannels3_0 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_fourChannels2_0_2_0 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_fourChannels2_2 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_fourChannels3_1 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_fiveChannels3_0_2_0 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_fiveChannels3_2 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_IS13818AudioMode_multichannelType::getSummary( void ) 
{
  return PString( "IS13818AudioMode_multichannelType" );
}

void H245_IS13818AudioMode_multichannelType::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "singleChannel" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS13818AudioMode_multichannelType_singleChannel, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "twoChannelStereo" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS13818AudioMode_multichannelType_twoChannelStereo, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "twoChannelDual" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS13818AudioMode_multichannelType_twoChannelDual, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "threeChannels2_1" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS13818AudioMode_multichannelType_threeChannels2_1, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "threeChannels3_0" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS13818AudioMode_multichannelType_threeChannels3_0, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "fourChannels2_0_2_0" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS13818AudioMode_multichannelType_fourChannels2_0_2_0, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "fourChannels2_2" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS13818AudioMode_multichannelType_fourChannels2_2, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "fourChannels3_1" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS13818AudioMode_multichannelType_fourChannels3_1, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "fiveChannels3_0_2_0" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS13818AudioMode_multichannelType_fiveChannels3_0_2_0, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "fiveChannels3_2" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_IS13818AudioMode_multichannelType_fiveChannels3_2, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// G7231AnnexCMode_g723AnnexCAudioMode
//

H245_G7231AnnexCMode_g723AnnexCAudioMode::H245_G7231AnnexCMode_g723AnnexCAudioMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_highRateMode0.SetConstraints(PASN_Object::FixedConstraint, 27, 78);
  m_highRateMode1.SetConstraints(PASN_Object::FixedConstraint, 27, 78);
  m_lowRateMode0.SetConstraints(PASN_Object::FixedConstraint, 23, 66);
  m_lowRateMode1.SetConstraints(PASN_Object::FixedConstraint, 23, 66);
  m_sidMode0.SetConstraints(PASN_Object::FixedConstraint, 6, 17);
  m_sidMode1.SetConstraints(PASN_Object::FixedConstraint, 6, 17);
}


#ifndef PASN_NOPRINTON
void H245_G7231AnnexCMode_g723AnnexCAudioMode::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "highRateMode0 = " << setprecision(indent) << m_highRateMode0 << '\n';
  strm << setw(indent+16) << "highRateMode1 = " << setprecision(indent) << m_highRateMode1 << '\n';
  strm << setw(indent+15) << "lowRateMode0 = " << setprecision(indent) << m_lowRateMode0 << '\n';
  strm << setw(indent+15) << "lowRateMode1 = " << setprecision(indent) << m_lowRateMode1 << '\n';
  strm << setw(indent+11) << "sidMode0 = " << setprecision(indent) << m_sidMode0 << '\n';
  strm << setw(indent+11) << "sidMode1 = " << setprecision(indent) << m_sidMode1 << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_G7231AnnexCMode_g723AnnexCAudioMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_G7231AnnexCMode_g723AnnexCAudioMode::Class()), PInvalidCast);
#endif
  const H245_G7231AnnexCMode_g723AnnexCAudioMode & other = (const H245_G7231AnnexCMode_g723AnnexCAudioMode &)obj;

  Comparison result;

  if ((result = m_highRateMode0.Compare(other.m_highRateMode0)) != EqualTo)
    return result;
  if ((result = m_highRateMode1.Compare(other.m_highRateMode1)) != EqualTo)
    return result;
  if ((result = m_lowRateMode0.Compare(other.m_lowRateMode0)) != EqualTo)
    return result;
  if ((result = m_lowRateMode1.Compare(other.m_lowRateMode1)) != EqualTo)
    return result;
  if ((result = m_sidMode0.Compare(other.m_sidMode0)) != EqualTo)
    return result;
  if ((result = m_sidMode1.Compare(other.m_sidMode1)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_G7231AnnexCMode_g723AnnexCAudioMode::GetDataLength() const
{
  return m_highRateMode0.GetObjectLength() +
         m_highRateMode1.GetObjectLength() +
         m_lowRateMode0.GetObjectLength() +
         m_lowRateMode1.GetObjectLength() +
         m_sidMode0.GetObjectLength() +
         m_sidMode1.GetObjectLength();
}


BOOL H245_G7231AnnexCMode_g723AnnexCAudioMode::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_highRateMode0.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_highRateMode1.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_lowRateMode0.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_lowRateMode1.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sidMode0.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sidMode1.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_G7231AnnexCMode_g723AnnexCAudioMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_highRateMode0.Encode(strm);
  m_highRateMode1.Encode(strm);
  m_lowRateMode0.Encode(strm);
  m_lowRateMode1.Encode(strm);
  m_sidMode0.Encode(strm);
  m_sidMode1.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_highRateMode0.Encode(strm);
  m_highRateMode1.Encode(strm);
  m_lowRateMode0.Encode(strm);
  m_lowRateMode1.Encode(strm);
  m_sidMode0.Encode(strm);
  m_sidMode1.Encode(strm);
}


PObject * H245_G7231AnnexCMode_g723AnnexCAudioMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_G7231AnnexCMode_g723AnnexCAudioMode::Class()), PInvalidCast);
#endif
  return new H245_G7231AnnexCMode_g723AnnexCAudioMode(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_G7231AnnexCMode_g723AnnexCAudioMode::preShowEthereal( void )
{
  m_highRateMode0.preShowEthereal( );
  m_highRateMode1.preShowEthereal( );
  m_lowRateMode0.preShowEthereal( );
  m_lowRateMode1.preShowEthereal( );
  m_sidMode0.preShowEthereal( );
  m_sidMode1.preShowEthereal( );
}

PString H245_G7231AnnexCMode_g723AnnexCAudioMode::getSummary( void ) 
{
  return PString( "G7231AnnexCMode_g723AnnexCAudioMode" );
}

void H245_G7231AnnexCMode_g723AnnexCAudioMode::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_G7231AnnexCMode_g723AnnexCAudioMode_highRateMode0, tvb, offset + m_highRateMode0.GetStartByte(), m_highRateMode0.GetByteLength() , m_highRateMode0.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_G7231AnnexCMode_g723AnnexCAudioMode_highRateMode1, tvb, offset + m_highRateMode1.GetStartByte(), m_highRateMode1.GetByteLength() , m_highRateMode1.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode0, tvb, offset + m_lowRateMode0.GetStartByte(), m_lowRateMode0.GetByteLength() , m_lowRateMode0.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode1, tvb, offset + m_lowRateMode1.GetStartByte(), m_lowRateMode1.GetByteLength() , m_lowRateMode1.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_G7231AnnexCMode_g723AnnexCAudioMode_sidMode0, tvb, offset + m_sidMode0.GetStartByte(), m_sidMode0.GetByteLength() , m_sidMode0.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_G7231AnnexCMode_g723AnnexCAudioMode_sidMode1, tvb, offset + m_sidMode1.GetStartByte(), m_sidMode1.GetByteLength() , m_sidMode1.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// DataMode_application
//

H245_DataMode_application::H245_DataMode_application(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 10, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "t120 "
        "dsm_cc "
        "userData "
        "t84 "
        "t434 "
        "h224 "
        "nlpid "
        "dsvdControl "
        "h222DataPartitioning "
        "t30fax "
        "t140 "
        "t38fax "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataMode_application::operator H245_NonStandardParameter &() const
#else
H245_DataMode_application::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_DataMode_application::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataMode_application::operator H245_DataProtocolCapability &() const
#else
H245_DataMode_application::operator H245_DataProtocolCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataProtocolCapability::Class()), PInvalidCast);
#endif
  return *(H245_DataProtocolCapability *)choice;
}


H245_DataMode_application::operator const H245_DataProtocolCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataProtocolCapability::Class()), PInvalidCast);
#endif
  return *(H245_DataProtocolCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataMode_application::operator H245_DataMode_application_nlpid &() const
#else
H245_DataMode_application::operator H245_DataMode_application_nlpid &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataMode_application_nlpid::Class()), PInvalidCast);
#endif
  return *(H245_DataMode_application_nlpid *)choice;
}


H245_DataMode_application::operator const H245_DataMode_application_nlpid &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataMode_application_nlpid::Class()), PInvalidCast);
#endif
  return *(H245_DataMode_application_nlpid *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataMode_application::operator H245_DataMode_application_t38fax &() const
#else
H245_DataMode_application::operator H245_DataMode_application_t38fax &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataMode_application_t38fax::Class()), PInvalidCast);
#endif
  return *(H245_DataMode_application_t38fax *)choice;
}


H245_DataMode_application::operator const H245_DataMode_application_t38fax &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataMode_application_t38fax::Class()), PInvalidCast);
#endif
  return *(H245_DataMode_application_t38fax *)choice;
}


BOOL H245_DataMode_application::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_t120 :
    case e_dsm_cc :
    case e_userData :
    case e_t84 :
    case e_t434 :
    case e_h224 :
    case e_h222DataPartitioning :
    case e_t30fax :
    case e_t140 :
      choice = new H245_DataProtocolCapability();
      return TRUE;
    case e_nlpid :
      choice = new H245_DataMode_application_nlpid();
      return TRUE;
    case e_dsvdControl :
      choice = new PASN_Null();
      return TRUE;
    case e_t38fax :
      choice = new H245_DataMode_application_t38fax();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_DataMode_application::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataMode_application::Class()), PInvalidCast);
#endif
  return new H245_DataMode_application(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_DataMode_application::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_t120 :
        ( ( H245_DataProtocolCapability * ) choice )->preShowEthereal();
        break;
      case e_dsm_cc :
        ( ( H245_DataProtocolCapability * ) choice )->preShowEthereal();
        break;
      case e_userData :
        ( ( H245_DataProtocolCapability * ) choice )->preShowEthereal();
        break;
      case e_t84 :
        ( ( H245_DataProtocolCapability * ) choice )->preShowEthereal();
        break;
      case e_t434 :
        ( ( H245_DataProtocolCapability * ) choice )->preShowEthereal();
        break;
      case e_h224 :
        ( ( H245_DataProtocolCapability * ) choice )->preShowEthereal();
        break;
      case e_nlpid :
        ( ( H245_DataMode_application_nlpid * ) choice )->preShowEthereal();
        break;
      case e_dsvdControl :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_h222DataPartitioning :
        ( ( H245_DataProtocolCapability * ) choice )->preShowEthereal();
        break;
      case e_t30fax :
        ( ( H245_DataProtocolCapability * ) choice )->preShowEthereal();
        break;
      case e_t140 :
        ( ( H245_DataProtocolCapability * ) choice )->preShowEthereal();
        break;
      case e_t38fax :
        ( ( H245_DataMode_application_t38fax * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_DataMode_application::getSummary( void ) 
{
  return PString( "DataMode_application" );
}

void H245_DataMode_application::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "dsvdControl" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_DataMode_application_dsvdControl, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_DataMode_application_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// MaintenanceLoopRequest_type
//

H245_MaintenanceLoopRequest_type::H245_MaintenanceLoopRequest_type(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "systemLoop "
        "mediaLoop "
        "logicalChannelLoop "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MaintenanceLoopRequest_type::operator H245_LogicalChannelNumber &() const
#else
H245_MaintenanceLoopRequest_type::operator H245_LogicalChannelNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_LogicalChannelNumber::Class()), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


H245_MaintenanceLoopRequest_type::operator const H245_LogicalChannelNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_LogicalChannelNumber::Class()), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


BOOL H245_MaintenanceLoopRequest_type::CreateObject()
{
  switch (tag) {
    case e_systemLoop :
      choice = new PASN_Null();
      return TRUE;
    case e_mediaLoop :
    case e_logicalChannelLoop :
      choice = new H245_LogicalChannelNumber();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_MaintenanceLoopRequest_type::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MaintenanceLoopRequest_type::Class()), PInvalidCast);
#endif
  return new H245_MaintenanceLoopRequest_type(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MaintenanceLoopRequest_type::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_systemLoop :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_mediaLoop :
        ( ( H245_LogicalChannelNumber * ) choice )->preShowEthereal();
        break;
      case e_logicalChannelLoop :
        ( ( H245_LogicalChannelNumber * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_MaintenanceLoopRequest_type::getSummary( void ) 
{
  return PString( "MaintenanceLoopRequest_type" );
}

void H245_MaintenanceLoopRequest_type::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "systemLoop" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MaintenanceLoopRequest_type_systemLoop, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "mediaLoop" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MaintenanceLoopRequest_type_mediaLoop, tvb, offset + ( ( H245_LogicalChannelNumber* ) choice) ->GetStartByte(), ( ( H245_LogicalChannelNumber* ) choice) ->GetByteLength(),  ( ( H245_LogicalChannelNumber* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "logicalChannelLoop" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MaintenanceLoopRequest_type_logicalChannelLoop, tvb, offset + ( ( H245_LogicalChannelNumber* ) choice) ->GetStartByte(), ( ( H245_LogicalChannelNumber* ) choice) ->GetByteLength(),  ( ( H245_LogicalChannelNumber* ) choice) ->GetValue() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// MaintenanceLoopAck_type
//

H245_MaintenanceLoopAck_type::H245_MaintenanceLoopAck_type(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "systemLoop "
        "mediaLoop "
        "logicalChannelLoop "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MaintenanceLoopAck_type::operator H245_LogicalChannelNumber &() const
#else
H245_MaintenanceLoopAck_type::operator H245_LogicalChannelNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_LogicalChannelNumber::Class()), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


H245_MaintenanceLoopAck_type::operator const H245_LogicalChannelNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_LogicalChannelNumber::Class()), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


BOOL H245_MaintenanceLoopAck_type::CreateObject()
{
  switch (tag) {
    case e_systemLoop :
      choice = new PASN_Null();
      return TRUE;
    case e_mediaLoop :
    case e_logicalChannelLoop :
      choice = new H245_LogicalChannelNumber();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_MaintenanceLoopAck_type::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MaintenanceLoopAck_type::Class()), PInvalidCast);
#endif
  return new H245_MaintenanceLoopAck_type(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MaintenanceLoopAck_type::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_systemLoop :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_mediaLoop :
        ( ( H245_LogicalChannelNumber * ) choice )->preShowEthereal();
        break;
      case e_logicalChannelLoop :
        ( ( H245_LogicalChannelNumber * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_MaintenanceLoopAck_type::getSummary( void ) 
{
  return PString( "MaintenanceLoopAck_type" );
}

void H245_MaintenanceLoopAck_type::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "systemLoop" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MaintenanceLoopAck_type_systemLoop, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "mediaLoop" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MaintenanceLoopAck_type_mediaLoop, tvb, offset + ( ( H245_LogicalChannelNumber* ) choice) ->GetStartByte(), ( ( H245_LogicalChannelNumber* ) choice) ->GetByteLength(),  ( ( H245_LogicalChannelNumber* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "logicalChannelLoop" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MaintenanceLoopAck_type_logicalChannelLoop, tvb, offset + ( ( H245_LogicalChannelNumber* ) choice) ->GetStartByte(), ( ( H245_LogicalChannelNumber* ) choice) ->GetByteLength(),  ( ( H245_LogicalChannelNumber* ) choice) ->GetValue() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// MaintenanceLoopReject_type
//

H245_MaintenanceLoopReject_type::H245_MaintenanceLoopReject_type(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "systemLoop "
        "mediaLoop "
        "logicalChannelLoop "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MaintenanceLoopReject_type::operator H245_LogicalChannelNumber &() const
#else
H245_MaintenanceLoopReject_type::operator H245_LogicalChannelNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_LogicalChannelNumber::Class()), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


H245_MaintenanceLoopReject_type::operator const H245_LogicalChannelNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_LogicalChannelNumber::Class()), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


BOOL H245_MaintenanceLoopReject_type::CreateObject()
{
  switch (tag) {
    case e_systemLoop :
      choice = new PASN_Null();
      return TRUE;
    case e_mediaLoop :
    case e_logicalChannelLoop :
      choice = new H245_LogicalChannelNumber();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_MaintenanceLoopReject_type::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MaintenanceLoopReject_type::Class()), PInvalidCast);
#endif
  return new H245_MaintenanceLoopReject_type(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MaintenanceLoopReject_type::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_systemLoop :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_mediaLoop :
        ( ( H245_LogicalChannelNumber * ) choice )->preShowEthereal();
        break;
      case e_logicalChannelLoop :
        ( ( H245_LogicalChannelNumber * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_MaintenanceLoopReject_type::getSummary( void ) 
{
  return PString( "MaintenanceLoopReject_type" );
}

void H245_MaintenanceLoopReject_type::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "systemLoop" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MaintenanceLoopReject_type_systemLoop, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "mediaLoop" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MaintenanceLoopReject_type_mediaLoop, tvb, offset + ( ( H245_LogicalChannelNumber* ) choice) ->GetStartByte(), ( ( H245_LogicalChannelNumber* ) choice) ->GetByteLength(),  ( ( H245_LogicalChannelNumber* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "logicalChannelLoop" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MaintenanceLoopReject_type_logicalChannelLoop, tvb, offset + ( ( H245_LogicalChannelNumber* ) choice) ->GetStartByte(), ( ( H245_LogicalChannelNumber* ) choice) ->GetByteLength(),  ( ( H245_LogicalChannelNumber* ) choice) ->GetValue() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// MaintenanceLoopReject_cause
//

H245_MaintenanceLoopReject_cause::H245_MaintenanceLoopReject_cause(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
      , "canNotPerformLoop "
#endif
    )
{
}


BOOL H245_MaintenanceLoopReject_cause::CreateObject()
{
  switch (tag) {
    case e_canNotPerformLoop :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_MaintenanceLoopReject_cause::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MaintenanceLoopReject_cause::Class()), PInvalidCast);
#endif
  return new H245_MaintenanceLoopReject_cause(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MaintenanceLoopReject_cause::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_canNotPerformLoop :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_MaintenanceLoopReject_cause::getSummary( void ) 
{
  return PString( "MaintenanceLoopReject_cause" );
}

void H245_MaintenanceLoopReject_cause::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "canNotPerformLoop" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MaintenanceLoopReject_cause_canNotPerformLoop, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_CommunicationModeTableEntry
//

H245_ArrayOf_CommunicationModeTableEntry::H245_ArrayOf_CommunicationModeTableEntry(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_CommunicationModeTableEntry::CreateObject() const
{
  return new H245_CommunicationModeTableEntry;
}


H245_CommunicationModeTableEntry & H245_ArrayOf_CommunicationModeTableEntry::operator[](PINDEX i) const
{
  return (H245_CommunicationModeTableEntry &)array[i];
}


PObject * H245_ArrayOf_CommunicationModeTableEntry::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_CommunicationModeTableEntry::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_CommunicationModeTableEntry(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_CommunicationModeTableEntry::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_CommunicationModeTableEntry& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_CommunicationModeTableEntry::getSummary( void ) 
{
  return PString( "ArrayOf_CommunicationModeTableEntry" );
}

void H245_ArrayOf_CommunicationModeTableEntry::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_CommunicationModeTableEntry_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_CommunicationModeTableEntry_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_CommunicationModeTableEntry_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (CommunicationModeTableEntry)", i );
    ArrayOf_CommunicationModeTableEntry_tree = proto_item_add_subtree( ArrayOf_CommunicationModeTableEntry_ti, hCont->h245_1.ett_h245_ArrayOf_CommunicationModeTableEntry );
    array[i].showEthereal( ArrayOf_CommunicationModeTableEntry_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// CommunicationModeTableEntry_dataType
//

H245_CommunicationModeTableEntry_dataType::H245_CommunicationModeTableEntry_dataType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "videoData "
        "audioData "
        "data "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommunicationModeTableEntry_dataType::operator H245_VideoCapability &() const
#else
H245_CommunicationModeTableEntry_dataType::operator H245_VideoCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_VideoCapability::Class()), PInvalidCast);
#endif
  return *(H245_VideoCapability *)choice;
}


H245_CommunicationModeTableEntry_dataType::operator const H245_VideoCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_VideoCapability::Class()), PInvalidCast);
#endif
  return *(H245_VideoCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommunicationModeTableEntry_dataType::operator H245_AudioCapability &() const
#else
H245_CommunicationModeTableEntry_dataType::operator H245_AudioCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_AudioCapability::Class()), PInvalidCast);
#endif
  return *(H245_AudioCapability *)choice;
}


H245_CommunicationModeTableEntry_dataType::operator const H245_AudioCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_AudioCapability::Class()), PInvalidCast);
#endif
  return *(H245_AudioCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommunicationModeTableEntry_dataType::operator H245_DataApplicationCapability &() const
#else
H245_CommunicationModeTableEntry_dataType::operator H245_DataApplicationCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataApplicationCapability::Class()), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability *)choice;
}


H245_CommunicationModeTableEntry_dataType::operator const H245_DataApplicationCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_DataApplicationCapability::Class()), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability *)choice;
}


BOOL H245_CommunicationModeTableEntry_dataType::CreateObject()
{
  switch (tag) {
    case e_videoData :
      choice = new H245_VideoCapability();
      return TRUE;
    case e_audioData :
      choice = new H245_AudioCapability();
      return TRUE;
    case e_data :
      choice = new H245_DataApplicationCapability();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_CommunicationModeTableEntry_dataType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CommunicationModeTableEntry_dataType::Class()), PInvalidCast);
#endif
  return new H245_CommunicationModeTableEntry_dataType(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CommunicationModeTableEntry_dataType::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_videoData :
        ( ( H245_VideoCapability * ) choice )->preShowEthereal();
        break;
      case e_audioData :
        ( ( H245_AudioCapability * ) choice )->preShowEthereal();
        break;
      case e_data :
        ( ( H245_DataApplicationCapability * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_CommunicationModeTableEntry_dataType::getSummary( void ) 
{
  return PString( "CommunicationModeTableEntry_dataType" );
}

void H245_CommunicationModeTableEntry_dataType::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_CommunicationModeTableEntry_dataType_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_TerminalLabel
//

H245_ArrayOf_TerminalLabel::H245_ArrayOf_TerminalLabel(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_TerminalLabel::CreateObject() const
{
  return new H245_TerminalLabel;
}


H245_TerminalLabel & H245_ArrayOf_TerminalLabel::operator[](PINDEX i) const
{
  return (H245_TerminalLabel &)array[i];
}


PObject * H245_ArrayOf_TerminalLabel::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_TerminalLabel::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_TerminalLabel(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_TerminalLabel::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_TerminalLabel& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_TerminalLabel::getSummary( void ) 
{
  return PString( "ArrayOf_TerminalLabel" );
}

void H245_ArrayOf_TerminalLabel::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_TerminalLabel_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_TerminalLabel_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_TerminalLabel_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (TerminalLabel)", i );
    ArrayOf_TerminalLabel_tree = proto_item_add_subtree( ArrayOf_TerminalLabel_ti, hCont->h245_1.ett_h245_ArrayOf_TerminalLabel );
    array[i].showEthereal( ArrayOf_TerminalLabel_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ConferenceResponse_makeMeChairResponse
//

H245_ConferenceResponse_makeMeChairResponse::H245_ConferenceResponse_makeMeChairResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "grantedChairToken "
        "deniedChairToken "
#endif
    )
{
}


BOOL H245_ConferenceResponse_makeMeChairResponse::CreateObject()
{
  switch (tag) {
    case e_grantedChairToken :
    case e_deniedChairToken :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_ConferenceResponse_makeMeChairResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse_makeMeChairResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse_makeMeChairResponse(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ConferenceResponse_makeMeChairResponse::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_grantedChairToken :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_deniedChairToken :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_ConferenceResponse_makeMeChairResponse::getSummary( void ) 
{
  return PString( "ConferenceResponse_makeMeChairResponse" );
}

void H245_ConferenceResponse_makeMeChairResponse::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "grantedChairToken" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_ConferenceResponse_makeMeChairResponse_grantedChairToken, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "deniedChairToken" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_ConferenceResponse_makeMeChairResponse_deniedChairToken, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ConferenceResponse_extensionAddressResponse
//

H245_ConferenceResponse_extensionAddressResponse::H245_ConferenceResponse_extensionAddressResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_ConferenceResponse_extensionAddressResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+19) << "extensionAddress = " << setprecision(indent) << m_extensionAddress << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_ConferenceResponse_extensionAddressResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_ConferenceResponse_extensionAddressResponse::Class()), PInvalidCast);
#endif
  const H245_ConferenceResponse_extensionAddressResponse & other = (const H245_ConferenceResponse_extensionAddressResponse &)obj;

  Comparison result;

  if ((result = m_extensionAddress.Compare(other.m_extensionAddress)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ConferenceResponse_extensionAddressResponse::GetDataLength() const
{
  return m_extensionAddress.GetObjectLength();
}


BOOL H245_ConferenceResponse_extensionAddressResponse::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_extensionAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_ConferenceResponse_extensionAddressResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_extensionAddress.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_extensionAddress.Encode(strm);
}


PObject * H245_ConferenceResponse_extensionAddressResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse_extensionAddressResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse_extensionAddressResponse(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ConferenceResponse_extensionAddressResponse::preShowEthereal( void )
{
  m_extensionAddress.preShowEthereal( );
}

PString H245_ConferenceResponse_extensionAddressResponse::getSummary( void ) 
{
  return PString( "ConferenceResponse_extensionAddressResponse" );
}

void H245_ConferenceResponse_extensionAddressResponse::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pextensionAddress = m_extensionAddress.getValue();
  proto_tree_add_string( tree, hCont->h245_1.hf_h245_ConferenceResponse_extensionAddressResponse_extensionAddress, tvb, offset + m_extensionAddress.GetStartByte(), m_extensionAddress.GetByteLength() , pextensionAddress );
  delete[] pextensionAddress;

}
#endif  //USE_FOR_ETHEREAL

//
// ConferenceResponse_broadcastMyLogicalChannelResponse
//

H245_ConferenceResponse_broadcastMyLogicalChannelResponse::H245_ConferenceResponse_broadcastMyLogicalChannelResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "grantedBroadcastMyLogicalChannel "
        "deniedBroadcastMyLogicalChannel "
#endif
    )
{
}


BOOL H245_ConferenceResponse_broadcastMyLogicalChannelResponse::CreateObject()
{
  switch (tag) {
    case e_grantedBroadcastMyLogicalChannel :
    case e_deniedBroadcastMyLogicalChannel :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_ConferenceResponse_broadcastMyLogicalChannelResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse_broadcastMyLogicalChannelResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse_broadcastMyLogicalChannelResponse(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ConferenceResponse_broadcastMyLogicalChannelResponse::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_grantedBroadcastMyLogicalChannel :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_deniedBroadcastMyLogicalChannel :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_ConferenceResponse_broadcastMyLogicalChannelResponse::getSummary( void ) 
{
  return PString( "ConferenceResponse_broadcastMyLogicalChannelResponse" );
}

void H245_ConferenceResponse_broadcastMyLogicalChannelResponse::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "grantedBroadcastMyLogicalChannel" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_ConferenceResponse_broadcastMyLogicalChannelResponse_grantedBroadcastMyLogicalChannel, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "deniedBroadcastMyLogicalChannel" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_ConferenceResponse_broadcastMyLogicalChannelResponse_deniedBroadcastMyLogicalChannel, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ConferenceResponse_makeTerminalBroadcasterResponse
//

H245_ConferenceResponse_makeTerminalBroadcasterResponse::H245_ConferenceResponse_makeTerminalBroadcasterResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "grantedMakeTerminalBroadcaster "
        "deniedMakeTerminalBroadcaster "
#endif
    )
{
}


BOOL H245_ConferenceResponse_makeTerminalBroadcasterResponse::CreateObject()
{
  switch (tag) {
    case e_grantedMakeTerminalBroadcaster :
    case e_deniedMakeTerminalBroadcaster :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_ConferenceResponse_makeTerminalBroadcasterResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse_makeTerminalBroadcasterResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse_makeTerminalBroadcasterResponse(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ConferenceResponse_makeTerminalBroadcasterResponse::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_grantedMakeTerminalBroadcaster :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_deniedMakeTerminalBroadcaster :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_ConferenceResponse_makeTerminalBroadcasterResponse::getSummary( void ) 
{
  return PString( "ConferenceResponse_makeTerminalBroadcasterResponse" );
}

void H245_ConferenceResponse_makeTerminalBroadcasterResponse::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "grantedMakeTerminalBroadcaster" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_ConferenceResponse_makeTerminalBroadcasterResponse_grantedMakeTerminalBroadcaster, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "deniedMakeTerminalBroadcaster" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_ConferenceResponse_makeTerminalBroadcasterResponse_deniedMakeTerminalBroadcaster, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ConferenceResponse_sendThisSourceResponse
//

H245_ConferenceResponse_sendThisSourceResponse::H245_ConferenceResponse_sendThisSourceResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "grantedSendThisSource "
        "deniedSendThisSource "
#endif
    )
{
}


BOOL H245_ConferenceResponse_sendThisSourceResponse::CreateObject()
{
  switch (tag) {
    case e_grantedSendThisSource :
    case e_deniedSendThisSource :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_ConferenceResponse_sendThisSourceResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse_sendThisSourceResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse_sendThisSourceResponse(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ConferenceResponse_sendThisSourceResponse::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_grantedSendThisSource :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_deniedSendThisSource :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_ConferenceResponse_sendThisSourceResponse::getSummary( void ) 
{
  return PString( "ConferenceResponse_sendThisSourceResponse" );
}

void H245_ConferenceResponse_sendThisSourceResponse::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "grantedSendThisSource" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_ConferenceResponse_sendThisSourceResponse_grantedSendThisSource, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "deniedSendThisSource" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_ConferenceResponse_sendThisSourceResponse_deniedSendThisSource, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_TerminalInformation
//

H245_ArrayOf_TerminalInformation::H245_ArrayOf_TerminalInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_TerminalInformation::CreateObject() const
{
  return new H245_TerminalInformation;
}


H245_TerminalInformation & H245_ArrayOf_TerminalInformation::operator[](PINDEX i) const
{
  return (H245_TerminalInformation &)array[i];
}


PObject * H245_ArrayOf_TerminalInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_TerminalInformation::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_TerminalInformation(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_TerminalInformation::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_TerminalInformation& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_TerminalInformation::getSummary( void ) 
{
  return PString( "ArrayOf_TerminalInformation" );
}

void H245_ArrayOf_TerminalInformation::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_TerminalInformation_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_TerminalInformation_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_TerminalInformation_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (TerminalInformation)", i );
    ArrayOf_TerminalInformation_tree = proto_item_add_subtree( ArrayOf_TerminalInformation_ti, hCont->h245_1.ett_h245_ArrayOf_TerminalInformation );
    array[i].showEthereal( ArrayOf_TerminalInformation_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// RemoteMCResponse_reject
//

H245_RemoteMCResponse_reject::H245_RemoteMCResponse_reject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "unspecified "
        "functionNotSupported "
#endif
    )
{
}


BOOL H245_RemoteMCResponse_reject::CreateObject()
{
  switch (tag) {
    case e_unspecified :
    case e_functionNotSupported :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_RemoteMCResponse_reject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RemoteMCResponse_reject::Class()), PInvalidCast);
#endif
  return new H245_RemoteMCResponse_reject(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RemoteMCResponse_reject::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_unspecified :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_functionNotSupported :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_RemoteMCResponse_reject::getSummary( void ) 
{
  return PString( "RemoteMCResponse_reject" );
}

void H245_RemoteMCResponse_reject::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "unspecified" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_RemoteMCResponse_reject_unspecified, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "functionNotSupported" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_RemoteMCResponse_reject_functionNotSupported, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// MultilinkRequest_callInformation
//

H245_MultilinkRequest_callInformation::H245_MultilinkRequest_callInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_maxNumberOfAdditionalConnections.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H245_MultilinkRequest_callInformation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+35) << "maxNumberOfAdditionalConnections = " << setprecision(indent) << m_maxNumberOfAdditionalConnections << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MultilinkRequest_callInformation::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MultilinkRequest_callInformation::Class()), PInvalidCast);
#endif
  const H245_MultilinkRequest_callInformation & other = (const H245_MultilinkRequest_callInformation &)obj;

  Comparison result;

  if ((result = m_maxNumberOfAdditionalConnections.Compare(other.m_maxNumberOfAdditionalConnections)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultilinkRequest_callInformation::GetDataLength() const
{
  return m_maxNumberOfAdditionalConnections.GetObjectLength();
}


BOOL H245_MultilinkRequest_callInformation::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maxNumberOfAdditionalConnections.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MultilinkRequest_callInformation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_maxNumberOfAdditionalConnections.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_maxNumberOfAdditionalConnections.Encode(strm);
}


PObject * H245_MultilinkRequest_callInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkRequest_callInformation::Class()), PInvalidCast);
#endif
  return new H245_MultilinkRequest_callInformation(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultilinkRequest_callInformation::preShowEthereal( void )
{
  m_maxNumberOfAdditionalConnections.preShowEthereal( );
}

PString H245_MultilinkRequest_callInformation::getSummary( void ) 
{
  return PString( "MultilinkRequest_callInformation" );
}

void H245_MultilinkRequest_callInformation::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MultilinkRequest_callInformation_maxNumberOfAdditionalConnections, tvb, offset + m_maxNumberOfAdditionalConnections.GetStartByte(), m_maxNumberOfAdditionalConnections.GetByteLength() , m_maxNumberOfAdditionalConnections.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// MultilinkRequest_addConnection
//

H245_MultilinkRequest_addConnection::H245_MultilinkRequest_addConnection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultilinkRequest_addConnection::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+22) << "diallingInformation = " << setprecision(indent) << m_diallingInformation << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MultilinkRequest_addConnection::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MultilinkRequest_addConnection::Class()), PInvalidCast);
#endif
  const H245_MultilinkRequest_addConnection & other = (const H245_MultilinkRequest_addConnection &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_diallingInformation.Compare(other.m_diallingInformation)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultilinkRequest_addConnection::GetDataLength() const
{
  return m_sequenceNumber.GetObjectLength() +
         m_diallingInformation.GetObjectLength();
}


BOOL H245_MultilinkRequest_addConnection::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sequenceNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_diallingInformation.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MultilinkRequest_addConnection::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_diallingInformation.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_sequenceNumber.Encode(strm);
  m_diallingInformation.Encode(strm);
}


PObject * H245_MultilinkRequest_addConnection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkRequest_addConnection::Class()), PInvalidCast);
#endif
  return new H245_MultilinkRequest_addConnection(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultilinkRequest_addConnection::preShowEthereal( void )
{
  m_sequenceNumber.preShowEthereal( );
  m_diallingInformation.preShowEthereal( );
}

PString H245_MultilinkRequest_addConnection::getSummary( void ) 
{
  return PString( "MultilinkRequest_addConnection" );
}

void H245_MultilinkRequest_addConnection::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MultilinkRequest_addConnection_sequenceNumber, tvb, offset + m_sequenceNumber.GetStartByte(), m_sequenceNumber.GetByteLength() , m_sequenceNumber.GetValue() );

  proto_tree *diallingInformation_tree = (proto_tree*) NULL;
  proto_item *diallingInformation_ti = (proto_item*) NULL;
  diallingInformation_ti = proto_tree_add_text( tree, tvb, offset + m_diallingInformation.GetStartByte(), m_diallingInformation.GetByteLength(), "diallingInformation (%s)", ( const char* ) m_diallingInformation.GetTagName() );
  diallingInformation_tree = proto_item_add_subtree( diallingInformation_ti, hCont->h245_1.ett_h245_MultilinkRequest_addConnection_diallingInformation );

  m_diallingInformation.showEthereal( diallingInformation_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// MultilinkRequest_removeConnection
//

H245_MultilinkRequest_removeConnection::H245_MultilinkRequest_removeConnection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultilinkRequest_removeConnection::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "connectionIdentifier = " << setprecision(indent) << m_connectionIdentifier << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MultilinkRequest_removeConnection::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MultilinkRequest_removeConnection::Class()), PInvalidCast);
#endif
  const H245_MultilinkRequest_removeConnection & other = (const H245_MultilinkRequest_removeConnection &)obj;

  Comparison result;

  if ((result = m_connectionIdentifier.Compare(other.m_connectionIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultilinkRequest_removeConnection::GetDataLength() const
{
  return m_connectionIdentifier.GetObjectLength();
}


BOOL H245_MultilinkRequest_removeConnection::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_connectionIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MultilinkRequest_removeConnection::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_connectionIdentifier.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_connectionIdentifier.Encode(strm);
}


PObject * H245_MultilinkRequest_removeConnection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkRequest_removeConnection::Class()), PInvalidCast);
#endif
  return new H245_MultilinkRequest_removeConnection(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultilinkRequest_removeConnection::preShowEthereal( void )
{
  m_connectionIdentifier.preShowEthereal( );
}

PString H245_MultilinkRequest_removeConnection::getSummary( void ) 
{
  return PString( "MultilinkRequest_removeConnection" );
}

void H245_MultilinkRequest_removeConnection::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *connectionIdentifier_tree = (proto_tree*) NULL;
  proto_item *connectionIdentifier_ti = (proto_item*) NULL;
  connectionIdentifier_ti = proto_tree_add_text( tree, tvb, offset + m_connectionIdentifier.GetStartByte(), m_connectionIdentifier.GetByteLength(), "connectionIdentifier (ConnectionIdentifier)" );
  connectionIdentifier_tree = proto_item_add_subtree( connectionIdentifier_ti, hCont->h245_1.ett_h245_MultilinkRequest_removeConnection_connectionIdentifier );

  m_connectionIdentifier.showEthereal( connectionIdentifier_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// MultilinkResponse_callInformation
//

H245_MultilinkResponse_callInformation::H245_MultilinkResponse_callInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_callAssociationNumber.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H245_MultilinkResponse_callInformation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "diallingInformation = " << setprecision(indent) << m_diallingInformation << '\n';
  strm << setw(indent+24) << "callAssociationNumber = " << setprecision(indent) << m_callAssociationNumber << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MultilinkResponse_callInformation::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MultilinkResponse_callInformation::Class()), PInvalidCast);
#endif
  const H245_MultilinkResponse_callInformation & other = (const H245_MultilinkResponse_callInformation &)obj;

  Comparison result;

  if ((result = m_diallingInformation.Compare(other.m_diallingInformation)) != EqualTo)
    return result;
  if ((result = m_callAssociationNumber.Compare(other.m_callAssociationNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultilinkResponse_callInformation::GetDataLength() const
{
  return m_diallingInformation.GetObjectLength() +
         m_callAssociationNumber.GetObjectLength();
}


BOOL H245_MultilinkResponse_callInformation::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_diallingInformation.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callAssociationNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MultilinkResponse_callInformation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_diallingInformation.Encode(strm);
  m_callAssociationNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_diallingInformation.Encode(strm);
  m_callAssociationNumber.Encode(strm);
}


PObject * H245_MultilinkResponse_callInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkResponse_callInformation::Class()), PInvalidCast);
#endif
  return new H245_MultilinkResponse_callInformation(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultilinkResponse_callInformation::preShowEthereal( void )
{
  m_diallingInformation.preShowEthereal( );
  m_callAssociationNumber.preShowEthereal( );
}

PString H245_MultilinkResponse_callInformation::getSummary( void ) 
{
  return PString( "MultilinkResponse_callInformation" );
}

void H245_MultilinkResponse_callInformation::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *diallingInformation_tree = (proto_tree*) NULL;
  proto_item *diallingInformation_ti = (proto_item*) NULL;
  diallingInformation_ti = proto_tree_add_text( tree, tvb, offset + m_diallingInformation.GetStartByte(), m_diallingInformation.GetByteLength(), "diallingInformation (%s)", ( const char* ) m_diallingInformation.GetTagName() );
  diallingInformation_tree = proto_item_add_subtree( diallingInformation_ti, hCont->h245_1.ett_h245_MultilinkResponse_callInformation_diallingInformation );

  m_diallingInformation.showEthereal( diallingInformation_tree, tvb, offset );

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MultilinkResponse_callInformation_callAssociationNumber, tvb, offset + m_callAssociationNumber.GetStartByte(), m_callAssociationNumber.GetByteLength() , m_callAssociationNumber.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// MultilinkResponse_removeConnection
//

H245_MultilinkResponse_removeConnection::H245_MultilinkResponse_removeConnection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultilinkResponse_removeConnection::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "connectionIdentifier = " << setprecision(indent) << m_connectionIdentifier << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MultilinkResponse_removeConnection::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MultilinkResponse_removeConnection::Class()), PInvalidCast);
#endif
  const H245_MultilinkResponse_removeConnection & other = (const H245_MultilinkResponse_removeConnection &)obj;

  Comparison result;

  if ((result = m_connectionIdentifier.Compare(other.m_connectionIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultilinkResponse_removeConnection::GetDataLength() const
{
  return m_connectionIdentifier.GetObjectLength();
}


BOOL H245_MultilinkResponse_removeConnection::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_connectionIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MultilinkResponse_removeConnection::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_connectionIdentifier.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_connectionIdentifier.Encode(strm);
}


PObject * H245_MultilinkResponse_removeConnection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkResponse_removeConnection::Class()), PInvalidCast);
#endif
  return new H245_MultilinkResponse_removeConnection(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultilinkResponse_removeConnection::preShowEthereal( void )
{
  m_connectionIdentifier.preShowEthereal( );
}

PString H245_MultilinkResponse_removeConnection::getSummary( void ) 
{
  return PString( "MultilinkResponse_removeConnection" );
}

void H245_MultilinkResponse_removeConnection::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *connectionIdentifier_tree = (proto_tree*) NULL;
  proto_item *connectionIdentifier_ti = (proto_item*) NULL;
  connectionIdentifier_ti = proto_tree_add_text( tree, tvb, offset + m_connectionIdentifier.GetStartByte(), m_connectionIdentifier.GetByteLength(), "connectionIdentifier (ConnectionIdentifier)" );
  connectionIdentifier_tree = proto_item_add_subtree( connectionIdentifier_ti, hCont->h245_1.ett_h245_MultilinkResponse_removeConnection_connectionIdentifier );

  m_connectionIdentifier.showEthereal( connectionIdentifier_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// MultilinkResponse_maximumHeaderInterval
//

H245_MultilinkResponse_maximumHeaderInterval::H245_MultilinkResponse_maximumHeaderInterval(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_currentInterval.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_MultilinkResponse_maximumHeaderInterval::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+18) << "currentInterval = " << setprecision(indent) << m_currentInterval << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MultilinkResponse_maximumHeaderInterval::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MultilinkResponse_maximumHeaderInterval::Class()), PInvalidCast);
#endif
  const H245_MultilinkResponse_maximumHeaderInterval & other = (const H245_MultilinkResponse_maximumHeaderInterval &)obj;

  Comparison result;

  if ((result = m_currentInterval.Compare(other.m_currentInterval)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultilinkResponse_maximumHeaderInterval::GetDataLength() const
{
  return m_currentInterval.GetObjectLength();
}


BOOL H245_MultilinkResponse_maximumHeaderInterval::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_currentInterval.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MultilinkResponse_maximumHeaderInterval::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_currentInterval.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_currentInterval.Encode(strm);
}


PObject * H245_MultilinkResponse_maximumHeaderInterval::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkResponse_maximumHeaderInterval::Class()), PInvalidCast);
#endif
  return new H245_MultilinkResponse_maximumHeaderInterval(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultilinkResponse_maximumHeaderInterval::preShowEthereal( void )
{
  m_currentInterval.preShowEthereal( );
}

PString H245_MultilinkResponse_maximumHeaderInterval::getSummary( void ) 
{
  return PString( "MultilinkResponse_maximumHeaderInterval" );
}

void H245_MultilinkResponse_maximumHeaderInterval::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MultilinkResponse_maximumHeaderInterval_currentInterval, tvb, offset + m_currentInterval.GetStartByte(), m_currentInterval.GetByteLength() , m_currentInterval.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// MultilinkIndication_crcDesired
//

H245_MultilinkIndication_crcDesired::H245_MultilinkIndication_crcDesired(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultilinkIndication_crcDesired::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << "}";
}
#endif


PINDEX H245_MultilinkIndication_crcDesired::GetDataLength() const
{
  return 0;
}


BOOL H245_MultilinkIndication_crcDesired::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MultilinkIndication_crcDesired::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * H245_MultilinkIndication_crcDesired::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkIndication_crcDesired::Class()), PInvalidCast);
#endif
  return new H245_MultilinkIndication_crcDesired(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultilinkIndication_crcDesired::preShowEthereal( void )
{
}

PString H245_MultilinkIndication_crcDesired::getSummary( void ) 
{
  return PString( "MultilinkIndication_crcDesired" );
}

void H245_MultilinkIndication_crcDesired::showEthereal( proto_tree *, tvbuff_t *, unsigned int ) const
{
}
#endif  //USE_FOR_ETHEREAL

//
// MultilinkIndication_excessiveError
//

H245_MultilinkIndication_excessiveError::H245_MultilinkIndication_excessiveError(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultilinkIndication_excessiveError::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "connectionIdentifier = " << setprecision(indent) << m_connectionIdentifier << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MultilinkIndication_excessiveError::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MultilinkIndication_excessiveError::Class()), PInvalidCast);
#endif
  const H245_MultilinkIndication_excessiveError & other = (const H245_MultilinkIndication_excessiveError &)obj;

  Comparison result;

  if ((result = m_connectionIdentifier.Compare(other.m_connectionIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultilinkIndication_excessiveError::GetDataLength() const
{
  return m_connectionIdentifier.GetObjectLength();
}


BOOL H245_MultilinkIndication_excessiveError::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_connectionIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MultilinkIndication_excessiveError::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_connectionIdentifier.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_connectionIdentifier.Encode(strm);
}


PObject * H245_MultilinkIndication_excessiveError::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkIndication_excessiveError::Class()), PInvalidCast);
#endif
  return new H245_MultilinkIndication_excessiveError(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultilinkIndication_excessiveError::preShowEthereal( void )
{
  m_connectionIdentifier.preShowEthereal( );
}

PString H245_MultilinkIndication_excessiveError::getSummary( void ) 
{
  return PString( "MultilinkIndication_excessiveError" );
}

void H245_MultilinkIndication_excessiveError::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *connectionIdentifier_tree = (proto_tree*) NULL;
  proto_item *connectionIdentifier_ti = (proto_item*) NULL;
  connectionIdentifier_ti = proto_tree_add_text( tree, tvb, offset + m_connectionIdentifier.GetStartByte(), m_connectionIdentifier.GetByteLength(), "connectionIdentifier (ConnectionIdentifier)" );
  connectionIdentifier_tree = proto_item_add_subtree( connectionIdentifier_ti, hCont->h245_1.ett_h245_MultilinkIndication_excessiveError_connectionIdentifier );

  m_connectionIdentifier.showEthereal( connectionIdentifier_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// ArrayOf_DiallingInformationNumber
//

H245_ArrayOf_DiallingInformationNumber::H245_ArrayOf_DiallingInformationNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_DiallingInformationNumber::CreateObject() const
{
  return new H245_DiallingInformationNumber;
}


H245_DiallingInformationNumber & H245_ArrayOf_DiallingInformationNumber::operator[](PINDEX i) const
{
  return (H245_DiallingInformationNumber &)array[i];
}


PObject * H245_ArrayOf_DiallingInformationNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_DiallingInformationNumber::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_DiallingInformationNumber(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_DiallingInformationNumber::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_DiallingInformationNumber& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_DiallingInformationNumber::getSummary( void ) 
{
  return PString( "ArrayOf_DiallingInformationNumber" );
}

void H245_ArrayOf_DiallingInformationNumber::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_DiallingInformationNumber_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_DiallingInformationNumber_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_DiallingInformationNumber_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (DiallingInformationNumber)", i );
    ArrayOf_DiallingInformationNumber_tree = proto_item_add_subtree( ArrayOf_DiallingInformationNumber_ti, hCont->h245_1.ett_h245_ArrayOf_DiallingInformationNumber );
    array[i].showEthereal( ArrayOf_DiallingInformationNumber_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_DiallingInformationNetworkType
//

H245_ArrayOf_DiallingInformationNetworkType::H245_ArrayOf_DiallingInformationNetworkType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_DiallingInformationNetworkType::CreateObject() const
{
  return new H245_DiallingInformationNetworkType;
}


H245_DiallingInformationNetworkType & H245_ArrayOf_DiallingInformationNetworkType::operator[](PINDEX i) const
{
  return (H245_DiallingInformationNetworkType &)array[i];
}


PObject * H245_ArrayOf_DiallingInformationNetworkType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_DiallingInformationNetworkType::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_DiallingInformationNetworkType(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_DiallingInformationNetworkType::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_DiallingInformationNetworkType& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_DiallingInformationNetworkType::getSummary( void ) 
{
  return PString( "ArrayOf_DiallingInformationNetworkType" );
}

void H245_ArrayOf_DiallingInformationNetworkType::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_DiallingInformationNetworkType_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_DiallingInformationNetworkType_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_DiallingInformationNetworkType_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (%s)", i, (const char*) ( ( PASN_Choice* ) &( array[i] ) )->GetTagName() );
    ArrayOf_DiallingInformationNetworkType_tree = proto_item_add_subtree( ArrayOf_DiallingInformationNetworkType_ti, hCont->h245_1.ett_h245_ArrayOf_DiallingInformationNetworkType );
    array[i].showEthereal( ArrayOf_DiallingInformationNetworkType_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// FlowControlCommand_scope
//

H245_FlowControlCommand_scope::H245_FlowControlCommand_scope(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
      , "logicalChannelNumber "
        "resourceID "
        "wholeMultiplex "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_FlowControlCommand_scope::operator H245_LogicalChannelNumber &() const
#else
H245_FlowControlCommand_scope::operator H245_LogicalChannelNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_LogicalChannelNumber::Class()), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


H245_FlowControlCommand_scope::operator const H245_LogicalChannelNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_LogicalChannelNumber::Class()), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


BOOL H245_FlowControlCommand_scope::CreateObject()
{
  switch (tag) {
    case e_logicalChannelNumber :
      choice = new H245_LogicalChannelNumber();
      return TRUE;
    case e_resourceID :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
      return TRUE;
    case e_wholeMultiplex :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_FlowControlCommand_scope::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FlowControlCommand_scope::Class()), PInvalidCast);
#endif
  return new H245_FlowControlCommand_scope(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_FlowControlCommand_scope::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_logicalChannelNumber :
        ( ( H245_LogicalChannelNumber * ) choice )->preShowEthereal();
        break;
      case e_resourceID :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_wholeMultiplex :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_FlowControlCommand_scope::getSummary( void ) 
{
  return PString( "FlowControlCommand_scope" );
}

void H245_FlowControlCommand_scope::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "logicalChannelNumber" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_FlowControlCommand_scope_logicalChannelNumber, tvb, offset + ( ( H245_LogicalChannelNumber* ) choice) ->GetStartByte(), ( ( H245_LogicalChannelNumber* ) choice) ->GetByteLength(),  ( ( H245_LogicalChannelNumber* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "resourceID" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_FlowControlCommand_scope_resourceID, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "wholeMultiplex" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_FlowControlCommand_scope_wholeMultiplex, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// FlowControlCommand_restriction
//

H245_FlowControlCommand_restriction::H245_FlowControlCommand_restriction(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
      , "maximumBitRate "
        "noRestriction "
#endif
    )
{
}


BOOL H245_FlowControlCommand_restriction::CreateObject()
{
  switch (tag) {
    case e_maximumBitRate :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 16777215);
      return TRUE;
    case e_noRestriction :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_FlowControlCommand_restriction::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FlowControlCommand_restriction::Class()), PInvalidCast);
#endif
  return new H245_FlowControlCommand_restriction(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_FlowControlCommand_restriction::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_maximumBitRate :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_noRestriction :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_FlowControlCommand_restriction::getSummary( void ) 
{
  return PString( "FlowControlCommand_restriction" );
}

void H245_FlowControlCommand_restriction::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "maximumBitRate" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_FlowControlCommand_restriction_maximumBitRate, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "noRestriction" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_FlowControlCommand_restriction_noRestriction, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// EndSessionCommand_gstnOptions
//

H245_EndSessionCommand_gstnOptions::H245_EndSessionCommand_gstnOptions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
      , "telephonyMode "
        "v8bis "
        "v34DSVD "
        "v34DuplexFAX "
        "v34H324 "
#endif
    )
{
}


BOOL H245_EndSessionCommand_gstnOptions::CreateObject()
{
  switch (tag) {
    case e_telephonyMode :
    case e_v8bis :
    case e_v34DSVD :
    case e_v34DuplexFAX :
    case e_v34H324 :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_EndSessionCommand_gstnOptions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EndSessionCommand_gstnOptions::Class()), PInvalidCast);
#endif
  return new H245_EndSessionCommand_gstnOptions(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_EndSessionCommand_gstnOptions::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_telephonyMode :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_v8bis :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_v34DSVD :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_v34DuplexFAX :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_v34H324 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_EndSessionCommand_gstnOptions::getSummary( void ) 
{
  return PString( "EndSessionCommand_gstnOptions" );
}

void H245_EndSessionCommand_gstnOptions::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "telephonyMode" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_EndSessionCommand_gstnOptions_telephonyMode, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "v8bis" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_EndSessionCommand_gstnOptions_v8bis, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "v34DSVD" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_EndSessionCommand_gstnOptions_v34DSVD, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "v34DuplexFAX" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_EndSessionCommand_gstnOptions_v34DuplexFAX, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "v34H324" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_EndSessionCommand_gstnOptions_v34H324, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// EndSessionCommand_isdnOptions
//

H245_EndSessionCommand_isdnOptions::H245_EndSessionCommand_isdnOptions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "telephonyMode "
        "v140 "
        "terminalOnHold "
#endif
    )
{
}


BOOL H245_EndSessionCommand_isdnOptions::CreateObject()
{
  switch (tag) {
    case e_telephonyMode :
    case e_v140 :
    case e_terminalOnHold :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_EndSessionCommand_isdnOptions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EndSessionCommand_isdnOptions::Class()), PInvalidCast);
#endif
  return new H245_EndSessionCommand_isdnOptions(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_EndSessionCommand_isdnOptions::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_telephonyMode :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_v140 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_terminalOnHold :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_EndSessionCommand_isdnOptions::getSummary( void ) 
{
  return PString( "EndSessionCommand_isdnOptions" );
}

void H245_EndSessionCommand_isdnOptions::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "telephonyMode" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_EndSessionCommand_isdnOptions_telephonyMode, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "v140" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_EndSessionCommand_isdnOptions_v140, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "terminalOnHold" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_EndSessionCommand_isdnOptions_terminalOnHold, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// MiscellaneousCommand_type
//

H245_MiscellaneousCommand_type::H245_MiscellaneousCommand_type(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 10, TRUE
#ifndef PASN_NOPRINTON
      , "equalizeDelay "
        "zeroDelay "
        "multipointModeCommand "
        "cancelMultipointModeCommand "
        "videoFreezePicture "
        "videoFastUpdatePicture "
        "videoFastUpdateGOB "
        "videoTemporalSpatialTradeOff "
        "videoSendSyncEveryGOB "
        "videoSendSyncEveryGOBCancel "
        "videoFastUpdateMB "
        "maxH223MUXPDUsize "
        "encryptionUpdate "
        "encryptionUpdateRequest "
        "switchReceiveMediaOff "
        "switchReceiveMediaOn "
        "progressiveRefinementStart "
        "progressiveRefinementAbortOne "
        "progressiveRefinementAbortContinuous "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MiscellaneousCommand_type::operator H245_MiscellaneousCommand_type_videoFastUpdateGOB &() const
#else
H245_MiscellaneousCommand_type::operator H245_MiscellaneousCommand_type_videoFastUpdateGOB &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MiscellaneousCommand_type_videoFastUpdateGOB::Class()), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand_type_videoFastUpdateGOB *)choice;
}


H245_MiscellaneousCommand_type::operator const H245_MiscellaneousCommand_type_videoFastUpdateGOB &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MiscellaneousCommand_type_videoFastUpdateGOB::Class()), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand_type_videoFastUpdateGOB *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MiscellaneousCommand_type::operator H245_MiscellaneousCommand_type_videoFastUpdateMB &() const
#else
H245_MiscellaneousCommand_type::operator H245_MiscellaneousCommand_type_videoFastUpdateMB &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MiscellaneousCommand_type_videoFastUpdateMB::Class()), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand_type_videoFastUpdateMB *)choice;
}


H245_MiscellaneousCommand_type::operator const H245_MiscellaneousCommand_type_videoFastUpdateMB &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MiscellaneousCommand_type_videoFastUpdateMB::Class()), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand_type_videoFastUpdateMB *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MiscellaneousCommand_type::operator H245_EncryptionSync &() const
#else
H245_MiscellaneousCommand_type::operator H245_EncryptionSync &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_EncryptionSync::Class()), PInvalidCast);
#endif
  return *(H245_EncryptionSync *)choice;
}


H245_MiscellaneousCommand_type::operator const H245_EncryptionSync &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_EncryptionSync::Class()), PInvalidCast);
#endif
  return *(H245_EncryptionSync *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MiscellaneousCommand_type::operator H245_EncryptionUpdateRequest &() const
#else
H245_MiscellaneousCommand_type::operator H245_EncryptionUpdateRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_EncryptionUpdateRequest::Class()), PInvalidCast);
#endif
  return *(H245_EncryptionUpdateRequest *)choice;
}


H245_MiscellaneousCommand_type::operator const H245_EncryptionUpdateRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_EncryptionUpdateRequest::Class()), PInvalidCast);
#endif
  return *(H245_EncryptionUpdateRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MiscellaneousCommand_type::operator H245_MiscellaneousCommand_type_progressiveRefinementStart &() const
#else
H245_MiscellaneousCommand_type::operator H245_MiscellaneousCommand_type_progressiveRefinementStart &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MiscellaneousCommand_type_progressiveRefinementStart::Class()), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand_type_progressiveRefinementStart *)choice;
}


H245_MiscellaneousCommand_type::operator const H245_MiscellaneousCommand_type_progressiveRefinementStart &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MiscellaneousCommand_type_progressiveRefinementStart::Class()), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand_type_progressiveRefinementStart *)choice;
}


BOOL H245_MiscellaneousCommand_type::CreateObject()
{
  switch (tag) {
    case e_equalizeDelay :
    case e_zeroDelay :
    case e_multipointModeCommand :
    case e_cancelMultipointModeCommand :
    case e_videoFreezePicture :
    case e_videoFastUpdatePicture :
    case e_videoSendSyncEveryGOB :
    case e_videoSendSyncEveryGOBCancel :
    case e_switchReceiveMediaOff :
    case e_switchReceiveMediaOn :
    case e_progressiveRefinementAbortOne :
    case e_progressiveRefinementAbortContinuous :
      choice = new PASN_Null();
      return TRUE;
    case e_videoFastUpdateGOB :
      choice = new H245_MiscellaneousCommand_type_videoFastUpdateGOB();
      return TRUE;
    case e_videoTemporalSpatialTradeOff :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 31);
      return TRUE;
    case e_videoFastUpdateMB :
      choice = new H245_MiscellaneousCommand_type_videoFastUpdateMB();
      return TRUE;
    case e_maxH223MUXPDUsize :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
      return TRUE;
    case e_encryptionUpdate :
      choice = new H245_EncryptionSync();
      return TRUE;
    case e_encryptionUpdateRequest :
      choice = new H245_EncryptionUpdateRequest();
      return TRUE;
    case e_progressiveRefinementStart :
      choice = new H245_MiscellaneousCommand_type_progressiveRefinementStart();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_MiscellaneousCommand_type::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MiscellaneousCommand_type::Class()), PInvalidCast);
#endif
  return new H245_MiscellaneousCommand_type(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MiscellaneousCommand_type::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_equalizeDelay :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_zeroDelay :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_multipointModeCommand :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_cancelMultipointModeCommand :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_videoFreezePicture :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_videoFastUpdatePicture :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_videoFastUpdateGOB :
        ( ( H245_MiscellaneousCommand_type_videoFastUpdateGOB * ) choice )->preShowEthereal();
        break;
      case e_videoTemporalSpatialTradeOff :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_videoSendSyncEveryGOB :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_videoSendSyncEveryGOBCancel :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_videoFastUpdateMB :
        ( ( H245_MiscellaneousCommand_type_videoFastUpdateMB * ) choice )->preShowEthereal();
        break;
      case e_maxH223MUXPDUsize :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_encryptionUpdate :
        ( ( H245_EncryptionSync * ) choice )->preShowEthereal();
        break;
      case e_encryptionUpdateRequest :
        ( ( H245_EncryptionUpdateRequest * ) choice )->preShowEthereal();
        break;
      case e_switchReceiveMediaOff :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_switchReceiveMediaOn :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_progressiveRefinementStart :
        ( ( H245_MiscellaneousCommand_type_progressiveRefinementStart * ) choice )->preShowEthereal();
        break;
      case e_progressiveRefinementAbortOne :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_progressiveRefinementAbortContinuous :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_MiscellaneousCommand_type::getSummary( void ) 
{
  return PString( "MiscellaneousCommand_type" );
}

void H245_MiscellaneousCommand_type::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "equalizeDelay" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousCommand_type_equalizeDelay, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "zeroDelay" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousCommand_type_zeroDelay, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "multipointModeCommand" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousCommand_type_multipointModeCommand, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "cancelMultipointModeCommand" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousCommand_type_cancelMultipointModeCommand, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "videoFreezePicture" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousCommand_type_videoFreezePicture, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "videoFastUpdatePicture" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousCommand_type_videoFastUpdatePicture, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "videoTemporalSpatialTradeOff" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MiscellaneousCommand_type_videoTemporalSpatialTradeOff, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "videoSendSyncEveryGOB" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousCommand_type_videoSendSyncEveryGOB, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "videoSendSyncEveryGOBCancel" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousCommand_type_videoSendSyncEveryGOBCancel, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "maxH223MUXPDUsize" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MiscellaneousCommand_type_maxH223MUXPDUsize, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "switchReceiveMediaOff" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousCommand_type_switchReceiveMediaOff, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "switchReceiveMediaOn" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousCommand_type_switchReceiveMediaOn, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "progressiveRefinementAbortOne" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousCommand_type_progressiveRefinementAbortOne, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "progressiveRefinementAbortContinuous" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousCommand_type_progressiveRefinementAbortContinuous, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_MiscellaneousCommand_type_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H223MultiplexReconfiguration_h223ModeChange
//

H245_H223MultiplexReconfiguration_h223ModeChange::H245_H223MultiplexReconfiguration_h223ModeChange(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "toLevel0 "
        "toLevel1 "
        "toLevel2 "
        "toLevel2withOptionalHeader "
#endif
    )
{
}


BOOL H245_H223MultiplexReconfiguration_h223ModeChange::CreateObject()
{
  switch (tag) {
    case e_toLevel0 :
    case e_toLevel1 :
    case e_toLevel2 :
    case e_toLevel2withOptionalHeader :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_H223MultiplexReconfiguration_h223ModeChange::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223MultiplexReconfiguration_h223ModeChange::Class()), PInvalidCast);
#endif
  return new H245_H223MultiplexReconfiguration_h223ModeChange(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223MultiplexReconfiguration_h223ModeChange::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_toLevel0 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_toLevel1 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_toLevel2 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_toLevel2withOptionalHeader :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_H223MultiplexReconfiguration_h223ModeChange::getSummary( void ) 
{
  return PString( "H223MultiplexReconfiguration_h223ModeChange" );
}

void H245_H223MultiplexReconfiguration_h223ModeChange::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "toLevel0" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223MultiplexReconfiguration_h223ModeChange_toLevel0, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "toLevel1" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223MultiplexReconfiguration_h223ModeChange_toLevel1, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "toLevel2" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223MultiplexReconfiguration_h223ModeChange_toLevel2, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "toLevel2withOptionalHeader" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223MultiplexReconfiguration_h223ModeChange_toLevel2withOptionalHeader, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H223MultiplexReconfiguration_h223AnnexADoubleFlag
//

H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag::H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "start "
        "stop "
#endif
    )
{
}


BOOL H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag::CreateObject()
{
  switch (tag) {
    case e_start :
    case e_stop :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag::Class()), PInvalidCast);
#endif
  return new H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_start :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_stop :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag::getSummary( void ) 
{
  return PString( "H223MultiplexReconfiguration_h223AnnexADoubleFlag" );
}

void H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "start" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223MultiplexReconfiguration_h223AnnexADoubleFlag_start, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "stop" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_H223MultiplexReconfiguration_h223AnnexADoubleFlag_stop, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// NewATMVCCommand_aal
//

H245_NewATMVCCommand_aal::H245_NewATMVCCommand_aal(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "aal1 "
        "aal5 "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_NewATMVCCommand_aal::operator H245_NewATMVCCommand_aal_aal1 &() const
#else
H245_NewATMVCCommand_aal::operator H245_NewATMVCCommand_aal_aal1 &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NewATMVCCommand_aal_aal1::Class()), PInvalidCast);
#endif
  return *(H245_NewATMVCCommand_aal_aal1 *)choice;
}


H245_NewATMVCCommand_aal::operator const H245_NewATMVCCommand_aal_aal1 &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NewATMVCCommand_aal_aal1::Class()), PInvalidCast);
#endif
  return *(H245_NewATMVCCommand_aal_aal1 *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_NewATMVCCommand_aal::operator H245_NewATMVCCommand_aal_aal5 &() const
#else
H245_NewATMVCCommand_aal::operator H245_NewATMVCCommand_aal_aal5 &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NewATMVCCommand_aal_aal5::Class()), PInvalidCast);
#endif
  return *(H245_NewATMVCCommand_aal_aal5 *)choice;
}


H245_NewATMVCCommand_aal::operator const H245_NewATMVCCommand_aal_aal5 &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NewATMVCCommand_aal_aal5::Class()), PInvalidCast);
#endif
  return *(H245_NewATMVCCommand_aal_aal5 *)choice;
}


BOOL H245_NewATMVCCommand_aal::CreateObject()
{
  switch (tag) {
    case e_aal1 :
      choice = new H245_NewATMVCCommand_aal_aal1();
      return TRUE;
    case e_aal5 :
      choice = new H245_NewATMVCCommand_aal_aal5();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_NewATMVCCommand_aal::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCCommand_aal::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCCommand_aal(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NewATMVCCommand_aal::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_aal1 :
        ( ( H245_NewATMVCCommand_aal_aal1 * ) choice )->preShowEthereal();
        break;
      case e_aal5 :
        ( ( H245_NewATMVCCommand_aal_aal5 * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_NewATMVCCommand_aal::getSummary( void ) 
{
  return PString( "NewATMVCCommand_aal" );
}

void H245_NewATMVCCommand_aal::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_NewATMVCCommand_aal_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// NewATMVCCommand_multiplex
//

H245_NewATMVCCommand_multiplex::H245_NewATMVCCommand_multiplex(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "noMultiplex "
        "transportStream "
        "programStream "
#endif
    )
{
}


BOOL H245_NewATMVCCommand_multiplex::CreateObject()
{
  switch (tag) {
    case e_noMultiplex :
    case e_transportStream :
    case e_programStream :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_NewATMVCCommand_multiplex::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCCommand_multiplex::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCCommand_multiplex(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NewATMVCCommand_multiplex::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_noMultiplex :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_transportStream :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_programStream :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_NewATMVCCommand_multiplex::getSummary( void ) 
{
  return PString( "NewATMVCCommand_multiplex" );
}

void H245_NewATMVCCommand_multiplex::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "noMultiplex" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCCommand_multiplex_noMultiplex, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "transportStream" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCCommand_multiplex_transportStream, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "programStream" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCCommand_multiplex_programStream, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// FunctionNotSupported_cause
//

H245_FunctionNotSupported_cause::H245_FunctionNotSupported_cause(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "syntaxError "
        "semanticError "
        "unknownFunction "
#endif
    )
{
}


BOOL H245_FunctionNotSupported_cause::CreateObject()
{
  switch (tag) {
    case e_syntaxError :
    case e_semanticError :
    case e_unknownFunction :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_FunctionNotSupported_cause::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FunctionNotSupported_cause::Class()), PInvalidCast);
#endif
  return new H245_FunctionNotSupported_cause(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_FunctionNotSupported_cause::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_syntaxError :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_semanticError :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_unknownFunction :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_FunctionNotSupported_cause::getSummary( void ) 
{
  return PString( "FunctionNotSupported_cause" );
}

void H245_FunctionNotSupported_cause::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "syntaxError" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_FunctionNotSupported_cause_syntaxError, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "semanticError" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_FunctionNotSupported_cause_semanticError, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "unknownFunction" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_FunctionNotSupported_cause_unknownFunction, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// MiscellaneousIndication_type
//

H245_MiscellaneousIndication_type::H245_MiscellaneousIndication_type(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 10, TRUE
#ifndef PASN_NOPRINTON
      , "logicalChannelActive "
        "logicalChannelInactive "
        "multipointConference "
        "cancelMultipointConference "
        "multipointZeroComm "
        "cancelMultipointZeroComm "
        "multipointSecondaryStatus "
        "cancelMultipointSecondaryStatus "
        "videoIndicateReadyToActivate "
        "videoTemporalSpatialTradeOff "
        "videoNotDecodedMBs "
        "transportCapability "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MiscellaneousIndication_type::operator H245_MiscellaneousIndication_type_videoNotDecodedMBs &() const
#else
H245_MiscellaneousIndication_type::operator H245_MiscellaneousIndication_type_videoNotDecodedMBs &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MiscellaneousIndication_type_videoNotDecodedMBs::Class()), PInvalidCast);
#endif
  return *(H245_MiscellaneousIndication_type_videoNotDecodedMBs *)choice;
}


H245_MiscellaneousIndication_type::operator const H245_MiscellaneousIndication_type_videoNotDecodedMBs &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MiscellaneousIndication_type_videoNotDecodedMBs::Class()), PInvalidCast);
#endif
  return *(H245_MiscellaneousIndication_type_videoNotDecodedMBs *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MiscellaneousIndication_type::operator H245_TransportCapability &() const
#else
H245_MiscellaneousIndication_type::operator H245_TransportCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_TransportCapability::Class()), PInvalidCast);
#endif
  return *(H245_TransportCapability *)choice;
}


H245_MiscellaneousIndication_type::operator const H245_TransportCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_TransportCapability::Class()), PInvalidCast);
#endif
  return *(H245_TransportCapability *)choice;
}


BOOL H245_MiscellaneousIndication_type::CreateObject()
{
  switch (tag) {
    case e_logicalChannelActive :
    case e_logicalChannelInactive :
    case e_multipointConference :
    case e_cancelMultipointConference :
    case e_multipointZeroComm :
    case e_cancelMultipointZeroComm :
    case e_multipointSecondaryStatus :
    case e_cancelMultipointSecondaryStatus :
    case e_videoIndicateReadyToActivate :
      choice = new PASN_Null();
      return TRUE;
    case e_videoTemporalSpatialTradeOff :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 31);
      return TRUE;
    case e_videoNotDecodedMBs :
      choice = new H245_MiscellaneousIndication_type_videoNotDecodedMBs();
      return TRUE;
    case e_transportCapability :
      choice = new H245_TransportCapability();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_MiscellaneousIndication_type::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MiscellaneousIndication_type::Class()), PInvalidCast);
#endif
  return new H245_MiscellaneousIndication_type(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MiscellaneousIndication_type::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_logicalChannelActive :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_logicalChannelInactive :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_multipointConference :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_cancelMultipointConference :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_multipointZeroComm :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_cancelMultipointZeroComm :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_multipointSecondaryStatus :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_cancelMultipointSecondaryStatus :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_videoIndicateReadyToActivate :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_videoTemporalSpatialTradeOff :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_videoNotDecodedMBs :
        ( ( H245_MiscellaneousIndication_type_videoNotDecodedMBs * ) choice )->preShowEthereal();
        break;
      case e_transportCapability :
        ( ( H245_TransportCapability * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_MiscellaneousIndication_type::getSummary( void ) 
{
  return PString( "MiscellaneousIndication_type" );
}

void H245_MiscellaneousIndication_type::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "logicalChannelActive" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousIndication_type_logicalChannelActive, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "logicalChannelInactive" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousIndication_type_logicalChannelInactive, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "multipointConference" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousIndication_type_multipointConference, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "cancelMultipointConference" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousIndication_type_cancelMultipointConference, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "multipointZeroComm" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousIndication_type_multipointZeroComm, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "cancelMultipointZeroComm" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousIndication_type_cancelMultipointZeroComm, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "multipointSecondaryStatus" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousIndication_type_multipointSecondaryStatus, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "cancelMultipointSecondaryStatus" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousIndication_type_cancelMultipointSecondaryStatus, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "videoIndicateReadyToActivate" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousIndication_type_videoIndicateReadyToActivate, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "videoTemporalSpatialTradeOff" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MiscellaneousIndication_type_videoTemporalSpatialTradeOff, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_MiscellaneousIndication_type_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// JitterIndication_scope
//

H245_JitterIndication_scope::H245_JitterIndication_scope(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
      , "logicalChannelNumber "
        "resourceID "
        "wholeMultiplex "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_JitterIndication_scope::operator H245_LogicalChannelNumber &() const
#else
H245_JitterIndication_scope::operator H245_LogicalChannelNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_LogicalChannelNumber::Class()), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


H245_JitterIndication_scope::operator const H245_LogicalChannelNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_LogicalChannelNumber::Class()), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


BOOL H245_JitterIndication_scope::CreateObject()
{
  switch (tag) {
    case e_logicalChannelNumber :
      choice = new H245_LogicalChannelNumber();
      return TRUE;
    case e_resourceID :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
      return TRUE;
    case e_wholeMultiplex :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_JitterIndication_scope::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_JitterIndication_scope::Class()), PInvalidCast);
#endif
  return new H245_JitterIndication_scope(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_JitterIndication_scope::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_logicalChannelNumber :
        ( ( H245_LogicalChannelNumber * ) choice )->preShowEthereal();
        break;
      case e_resourceID :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_wholeMultiplex :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_JitterIndication_scope::getSummary( void ) 
{
  return PString( "JitterIndication_scope" );
}

void H245_JitterIndication_scope::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "logicalChannelNumber" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_JitterIndication_scope_logicalChannelNumber, tvb, offset + ( ( H245_LogicalChannelNumber* ) choice) ->GetStartByte(), ( ( H245_LogicalChannelNumber* ) choice) ->GetByteLength(),  ( ( H245_LogicalChannelNumber* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "resourceID" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_JitterIndication_scope_resourceID, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "wholeMultiplex" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_JitterIndication_scope_wholeMultiplex, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// NewATMVCIndication_aal
//

H245_NewATMVCIndication_aal::H245_NewATMVCIndication_aal(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "aal1 "
        "aal5 "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_NewATMVCIndication_aal::operator H245_NewATMVCIndication_aal_aal1 &() const
#else
H245_NewATMVCIndication_aal::operator H245_NewATMVCIndication_aal_aal1 &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NewATMVCIndication_aal_aal1::Class()), PInvalidCast);
#endif
  return *(H245_NewATMVCIndication_aal_aal1 *)choice;
}


H245_NewATMVCIndication_aal::operator const H245_NewATMVCIndication_aal_aal1 &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NewATMVCIndication_aal_aal1::Class()), PInvalidCast);
#endif
  return *(H245_NewATMVCIndication_aal_aal1 *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_NewATMVCIndication_aal::operator H245_NewATMVCIndication_aal_aal5 &() const
#else
H245_NewATMVCIndication_aal::operator H245_NewATMVCIndication_aal_aal5 &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NewATMVCIndication_aal_aal5::Class()), PInvalidCast);
#endif
  return *(H245_NewATMVCIndication_aal_aal5 *)choice;
}


H245_NewATMVCIndication_aal::operator const H245_NewATMVCIndication_aal_aal5 &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NewATMVCIndication_aal_aal5::Class()), PInvalidCast);
#endif
  return *(H245_NewATMVCIndication_aal_aal5 *)choice;
}


BOOL H245_NewATMVCIndication_aal::CreateObject()
{
  switch (tag) {
    case e_aal1 :
      choice = new H245_NewATMVCIndication_aal_aal1();
      return TRUE;
    case e_aal5 :
      choice = new H245_NewATMVCIndication_aal_aal5();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_NewATMVCIndication_aal::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCIndication_aal::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCIndication_aal(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NewATMVCIndication_aal::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_aal1 :
        ( ( H245_NewATMVCIndication_aal_aal1 * ) choice )->preShowEthereal();
        break;
      case e_aal5 :
        ( ( H245_NewATMVCIndication_aal_aal5 * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_NewATMVCIndication_aal::getSummary( void ) 
{
  return PString( "NewATMVCIndication_aal" );
}

void H245_NewATMVCIndication_aal::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_NewATMVCIndication_aal_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// NewATMVCIndication_multiplex
//

H245_NewATMVCIndication_multiplex::H245_NewATMVCIndication_multiplex(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "noMultiplex "
        "transportStream "
        "programStream "
#endif
    )
{
}


BOOL H245_NewATMVCIndication_multiplex::CreateObject()
{
  switch (tag) {
    case e_noMultiplex :
    case e_transportStream :
    case e_programStream :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_NewATMVCIndication_multiplex::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCIndication_multiplex::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCIndication_multiplex(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NewATMVCIndication_multiplex::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_noMultiplex :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_transportStream :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_programStream :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_NewATMVCIndication_multiplex::getSummary( void ) 
{
  return PString( "NewATMVCIndication_multiplex" );
}

void H245_NewATMVCIndication_multiplex::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "noMultiplex" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCIndication_multiplex_noMultiplex, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "transportStream" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCIndication_multiplex_transportStream, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "programStream" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCIndication_multiplex_programStream, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// UserInputIndication_userInputSupportIndication
//

H245_UserInputIndication_userInputSupportIndication::H245_UserInputIndication_userInputSupportIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "basicString "
        "iA5String "
        "generalString "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UserInputIndication_userInputSupportIndication::operator H245_NonStandardParameter &() const
#else
H245_UserInputIndication_userInputSupportIndication::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_UserInputIndication_userInputSupportIndication::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


BOOL H245_UserInputIndication_userInputSupportIndication::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_basicString :
    case e_iA5String :
    case e_generalString :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_UserInputIndication_userInputSupportIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UserInputIndication_userInputSupportIndication::Class()), PInvalidCast);
#endif
  return new H245_UserInputIndication_userInputSupportIndication(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_UserInputIndication_userInputSupportIndication::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H245_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_basicString :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_iA5String :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_generalString :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_UserInputIndication_userInputSupportIndication::getSummary( void ) 
{
  return PString( "UserInputIndication_userInputSupportIndication" );
}

void H245_UserInputIndication_userInputSupportIndication::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "basicString" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_UserInputIndication_userInputSupportIndication_basicString, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "iA5String" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_UserInputIndication_userInputSupportIndication_iA5String, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "generalString" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_UserInputIndication_userInputSupportIndication_generalString, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_UserInputIndication_userInputSupportIndication_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded
//

H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded::H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
      , "highestEntryNumberProcessed "
        "noneProcessed "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded::operator H245_CapabilityTableEntryNumber &() const
#else
H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded::operator H245_CapabilityTableEntryNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_CapabilityTableEntryNumber::Class()), PInvalidCast);
#endif
  return *(H245_CapabilityTableEntryNumber *)choice;
}


H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded::operator const H245_CapabilityTableEntryNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_CapabilityTableEntryNumber::Class()), PInvalidCast);
#endif
  return *(H245_CapabilityTableEntryNumber *)choice;
}


BOOL H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded::CreateObject()
{
  switch (tag) {
    case e_highestEntryNumberProcessed :
      choice = new H245_CapabilityTableEntryNumber();
      return TRUE;
    case e_noneProcessed :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded::Class()), PInvalidCast);
#endif
  return new H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_highestEntryNumberProcessed :
        ( ( H245_CapabilityTableEntryNumber * ) choice )->preShowEthereal();
        break;
      case e_noneProcessed :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded::getSummary( void ) 
{
  return PString( "TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded" );
}

void H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "highestEntryNumberProcessed" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded_highestEntryNumberProcessed, tvb, offset + ( ( H245_CapabilityTableEntryNumber* ) choice) ->GetStartByte(), ( ( H245_CapabilityTableEntryNumber* ) choice) ->GetByteLength(),  ( ( H245_CapabilityTableEntryNumber* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "noneProcessed" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded_noneProcessed, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// VCCapability_availableBitRates_type
//

H245_VCCapability_availableBitRates_type::H245_VCCapability_availableBitRates_type(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
      , "singleBitRate "
        "rangeOfBitRates "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VCCapability_availableBitRates_type::operator H245_VCCapability_availableBitRates_type_rangeOfBitRates &() const
#else
H245_VCCapability_availableBitRates_type::operator H245_VCCapability_availableBitRates_type_rangeOfBitRates &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_VCCapability_availableBitRates_type_rangeOfBitRates::Class()), PInvalidCast);
#endif
  return *(H245_VCCapability_availableBitRates_type_rangeOfBitRates *)choice;
}


H245_VCCapability_availableBitRates_type::operator const H245_VCCapability_availableBitRates_type_rangeOfBitRates &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_VCCapability_availableBitRates_type_rangeOfBitRates::Class()), PInvalidCast);
#endif
  return *(H245_VCCapability_availableBitRates_type_rangeOfBitRates *)choice;
}


BOOL H245_VCCapability_availableBitRates_type::CreateObject()
{
  switch (tag) {
    case e_singleBitRate :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
      return TRUE;
    case e_rangeOfBitRates :
      choice = new H245_VCCapability_availableBitRates_type_rangeOfBitRates();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_VCCapability_availableBitRates_type::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_VCCapability_availableBitRates_type::Class()), PInvalidCast);
#endif
  return new H245_VCCapability_availableBitRates_type(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_VCCapability_availableBitRates_type::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_singleBitRate :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_rangeOfBitRates :
        ( ( H245_VCCapability_availableBitRates_type_rangeOfBitRates * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_VCCapability_availableBitRates_type::getSummary( void ) 
{
  return PString( "VCCapability_availableBitRates_type" );
}

void H245_VCCapability_availableBitRates_type::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "singleBitRate" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_VCCapability_availableBitRates_type_singleBitRate, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_VCCapability_availableBitRates_type_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_Q2931Address
//

H245_ArrayOf_Q2931Address::H245_ArrayOf_Q2931Address(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_Q2931Address::CreateObject() const
{
  return new H245_Q2931Address;
}


H245_Q2931Address & H245_ArrayOf_Q2931Address::operator[](PINDEX i) const
{
  return (H245_Q2931Address &)array[i];
}


PObject * H245_ArrayOf_Q2931Address::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_Q2931Address::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_Q2931Address(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_Q2931Address::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_Q2931Address& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_Q2931Address::getSummary( void ) 
{
  return PString( "ArrayOf_Q2931Address" );
}

void H245_ArrayOf_Q2931Address::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_Q2931Address_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_Q2931Address_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_Q2931Address_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (Q2931Address)", i );
    ArrayOf_Q2931Address_tree = proto_item_add_subtree( ArrayOf_Q2931Address_ti, hCont->h245_1.ett_h245_ArrayOf_Q2931Address );
    array[i].showEthereal( ArrayOf_Q2931Address_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// H223Capability_h223MultiplexTableCapability_enhanced
//

H245_H223Capability_h223MultiplexTableCapability_enhanced::H245_H223Capability_h223MultiplexTableCapability_enhanced(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_maximumNestingDepth.SetConstraints(PASN_Object::FixedConstraint, 1, 15);
  m_maximumElementListSize.SetConstraints(PASN_Object::FixedConstraint, 2, 255);
  m_maximumSubElementListSize.SetConstraints(PASN_Object::FixedConstraint, 2, 255);
}


#ifndef PASN_NOPRINTON
void H245_H223Capability_h223MultiplexTableCapability_enhanced::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "maximumNestingDepth = " << setprecision(indent) << m_maximumNestingDepth << '\n';
  strm << setw(indent+25) << "maximumElementListSize = " << setprecision(indent) << m_maximumElementListSize << '\n';
  strm << setw(indent+28) << "maximumSubElementListSize = " << setprecision(indent) << m_maximumSubElementListSize << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H223Capability_h223MultiplexTableCapability_enhanced::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H223Capability_h223MultiplexTableCapability_enhanced::Class()), PInvalidCast);
#endif
  const H245_H223Capability_h223MultiplexTableCapability_enhanced & other = (const H245_H223Capability_h223MultiplexTableCapability_enhanced &)obj;

  Comparison result;

  if ((result = m_maximumNestingDepth.Compare(other.m_maximumNestingDepth)) != EqualTo)
    return result;
  if ((result = m_maximumElementListSize.Compare(other.m_maximumElementListSize)) != EqualTo)
    return result;
  if ((result = m_maximumSubElementListSize.Compare(other.m_maximumSubElementListSize)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223Capability_h223MultiplexTableCapability_enhanced::GetDataLength() const
{
  return m_maximumNestingDepth.GetObjectLength() +
         m_maximumElementListSize.GetObjectLength() +
         m_maximumSubElementListSize.GetObjectLength();
}


BOOL H245_H223Capability_h223MultiplexTableCapability_enhanced::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maximumNestingDepth.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maximumElementListSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maximumSubElementListSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H223Capability_h223MultiplexTableCapability_enhanced::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_maximumNestingDepth.Encode(strm);
  m_maximumElementListSize.Encode(strm);
  m_maximumSubElementListSize.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_maximumNestingDepth.Encode(strm);
  m_maximumElementListSize.Encode(strm);
  m_maximumSubElementListSize.Encode(strm);
}


PObject * H245_H223Capability_h223MultiplexTableCapability_enhanced::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223Capability_h223MultiplexTableCapability_enhanced::Class()), PInvalidCast);
#endif
  return new H245_H223Capability_h223MultiplexTableCapability_enhanced(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223Capability_h223MultiplexTableCapability_enhanced::preShowEthereal( void )
{
  m_maximumNestingDepth.preShowEthereal( );
  m_maximumElementListSize.preShowEthereal( );
  m_maximumSubElementListSize.preShowEthereal( );
}

PString H245_H223Capability_h223MultiplexTableCapability_enhanced::getSummary( void ) 
{
  return PString( "H223Capability_h223MultiplexTableCapability_enhanced" );
}

void H245_H223Capability_h223MultiplexTableCapability_enhanced::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_H223Capability_h223MultiplexTableCapability_enhanced_maximumNestingDepth, tvb, offset + m_maximumNestingDepth.GetStartByte(), m_maximumNestingDepth.GetByteLength() , m_maximumNestingDepth.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_H223Capability_h223MultiplexTableCapability_enhanced_maximumElementListSize, tvb, offset + m_maximumElementListSize.GetStartByte(), m_maximumElementListSize.GetByteLength() , m_maximumElementListSize.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_H223Capability_h223MultiplexTableCapability_enhanced_maximumSubElementListSize, tvb, offset + m_maximumSubElementListSize.GetStartByte(), m_maximumSubElementListSize.GetByteLength() , m_maximumSubElementListSize.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// ArrayOf_RTPH263VideoRedundancyFrameMapping
//

H245_ArrayOf_RTPH263VideoRedundancyFrameMapping::H245_ArrayOf_RTPH263VideoRedundancyFrameMapping(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_RTPH263VideoRedundancyFrameMapping::CreateObject() const
{
  return new H245_RTPH263VideoRedundancyFrameMapping;
}


H245_RTPH263VideoRedundancyFrameMapping & H245_ArrayOf_RTPH263VideoRedundancyFrameMapping::operator[](PINDEX i) const
{
  return (H245_RTPH263VideoRedundancyFrameMapping &)array[i];
}


PObject * H245_ArrayOf_RTPH263VideoRedundancyFrameMapping::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_RTPH263VideoRedundancyFrameMapping::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_RTPH263VideoRedundancyFrameMapping(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_RTPH263VideoRedundancyFrameMapping::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_RTPH263VideoRedundancyFrameMapping& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_RTPH263VideoRedundancyFrameMapping::getSummary( void ) 
{
  return PString( "ArrayOf_RTPH263VideoRedundancyFrameMapping" );
}

void H245_ArrayOf_RTPH263VideoRedundancyFrameMapping::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_RTPH263VideoRedundancyFrameMapping_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_RTPH263VideoRedundancyFrameMapping_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_RTPH263VideoRedundancyFrameMapping_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (RTPH263VideoRedundancyFrameMapping)", i );
    ArrayOf_RTPH263VideoRedundancyFrameMapping_tree = proto_item_add_subtree( ArrayOf_RTPH263VideoRedundancyFrameMapping_ti, hCont->h245_1.ett_h245_ArrayOf_RTPH263VideoRedundancyFrameMapping );
    array[i].showEthereal( ArrayOf_RTPH263VideoRedundancyFrameMapping_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// CustomPictureFormat_mPI_customPCF
//

H245_CustomPictureFormat_mPI_customPCF::H245_CustomPictureFormat_mPI_customPCF(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 16);
}


PASN_Object * H245_CustomPictureFormat_mPI_customPCF::CreateObject() const
{
  return new H245_CustomPictureFormat_mPI_customPCF_subtype;
}


H245_CustomPictureFormat_mPI_customPCF_subtype & H245_CustomPictureFormat_mPI_customPCF::operator[](PINDEX i) const
{
  return (H245_CustomPictureFormat_mPI_customPCF_subtype &)array[i];
}


PObject * H245_CustomPictureFormat_mPI_customPCF::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CustomPictureFormat_mPI_customPCF::Class()), PInvalidCast);
#endif
  return new H245_CustomPictureFormat_mPI_customPCF(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CustomPictureFormat_mPI_customPCF::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_CustomPictureFormat_mPI_customPCF_subtype& ) array[i] ).preShowEthereal();
  }
}

PString H245_CustomPictureFormat_mPI_customPCF::getSummary( void ) 
{
  return PString( "CustomPictureFormat_mPI_customPCF" );
}

void H245_CustomPictureFormat_mPI_customPCF::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *CustomPictureFormat_mPI_customPCF_tree = (proto_tree*) NULL;
  proto_item *CustomPictureFormat_mPI_customPCF_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    CustomPictureFormat_mPI_customPCF_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (CustomPictureFormat-mPI-customPCF-subtype)", i );
    CustomPictureFormat_mPI_customPCF_tree = proto_item_add_subtree( CustomPictureFormat_mPI_customPCF_ti, hCont->h245_1.ett_h245_CustomPictureFormat_mPI_customPCF );
    array[i].showEthereal( CustomPictureFormat_mPI_customPCF_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// CustomPictureFormat_pixelAspectInformation_pixelAspectCode
//

H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode::H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 14);
}


PASN_Object * H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode::CreateObject() const
{
  PASN_Integer * obj = new PASN_Integer;
  obj->SetConstraints(PASN_Object::FixedConstraint, 1, 14);
  return obj;
}


PASN_Integer & H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode::operator[](PINDEX i) const
{
  return (PASN_Integer &)array[i];
}


PObject * H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode::Class()), PInvalidCast);
#endif
  return new H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (PASN_Integer& ) array[i] ).preShowEthereal();
  }
}

PString H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode::getSummary( void ) 
{
  return PString( "CustomPictureFormat_pixelAspectInformation_pixelAspectCode" );
}

void H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  for (int i=0; i < array.GetSize(); i++ ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode_array, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), ( (PASN_Integer& ) array[i] ).GetValue() );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// CustomPictureFormat_pixelAspectInformation_extendedPAR
//

H245_CustomPictureFormat_pixelAspectInformation_extendedPAR::H245_CustomPictureFormat_pixelAspectInformation_extendedPAR(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


PASN_Object * H245_CustomPictureFormat_pixelAspectInformation_extendedPAR::CreateObject() const
{
  return new H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype;
}


H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype & H245_CustomPictureFormat_pixelAspectInformation_extendedPAR::operator[](PINDEX i) const
{
  return (H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype &)array[i];
}


PObject * H245_CustomPictureFormat_pixelAspectInformation_extendedPAR::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CustomPictureFormat_pixelAspectInformation_extendedPAR::Class()), PInvalidCast);
#endif
  return new H245_CustomPictureFormat_pixelAspectInformation_extendedPAR(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CustomPictureFormat_pixelAspectInformation_extendedPAR::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype& ) array[i] ).preShowEthereal();
  }
}

PString H245_CustomPictureFormat_pixelAspectInformation_extendedPAR::getSummary( void ) 
{
  return PString( "CustomPictureFormat_pixelAspectInformation_extendedPAR" );
}

void H245_CustomPictureFormat_pixelAspectInformation_extendedPAR::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *CustomPictureFormat_pixelAspectInformation_extendedPAR_tree = (proto_tree*) NULL;
  proto_item *CustomPictureFormat_pixelAspectInformation_extendedPAR_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    CustomPictureFormat_pixelAspectInformation_extendedPAR_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (CustomPictureFormat-pixelAspectInformation-extendedPAR-subtype)", i );
    CustomPictureFormat_pixelAspectInformation_extendedPAR_tree = proto_item_add_subtree( CustomPictureFormat_pixelAspectInformation_extendedPAR_ti, hCont->h245_1.ett_h245_CustomPictureFormat_pixelAspectInformation_extendedPAR );
    array[i].showEthereal( CustomPictureFormat_pixelAspectInformation_extendedPAR_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// DataApplicationCapability_application_t84
//

H245_DataApplicationCapability_application_t84::H245_DataApplicationCapability_application_t84(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_DataApplicationCapability_application_t84::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "t84Protocol = " << setprecision(indent) << m_t84Protocol << '\n';
  strm << setw(indent+13) << "t84Profile = " << setprecision(indent) << m_t84Profile << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_DataApplicationCapability_application_t84::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_DataApplicationCapability_application_t84::Class()), PInvalidCast);
#endif
  const H245_DataApplicationCapability_application_t84 & other = (const H245_DataApplicationCapability_application_t84 &)obj;

  Comparison result;

  if ((result = m_t84Protocol.Compare(other.m_t84Protocol)) != EqualTo)
    return result;
  if ((result = m_t84Profile.Compare(other.m_t84Profile)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DataApplicationCapability_application_t84::GetDataLength() const
{
  return m_t84Protocol.GetObjectLength() +
         m_t84Profile.GetObjectLength();
}


BOOL H245_DataApplicationCapability_application_t84::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_t84Protocol.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_t84Profile.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_DataApplicationCapability_application_t84::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_t84Protocol.Encode(strm);
  m_t84Profile.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_t84Protocol.Encode(strm);
  m_t84Profile.Encode(strm);
}


PObject * H245_DataApplicationCapability_application_t84::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataApplicationCapability_application_t84::Class()), PInvalidCast);
#endif
  return new H245_DataApplicationCapability_application_t84(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_DataApplicationCapability_application_t84::preShowEthereal( void )
{
  m_t84Protocol.preShowEthereal( );
  m_t84Profile.preShowEthereal( );
}

PString H245_DataApplicationCapability_application_t84::getSummary( void ) 
{
  return PString( "DataApplicationCapability_application_t84" );
}

void H245_DataApplicationCapability_application_t84::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *t84Protocol_tree = (proto_tree*) NULL;
  proto_item *t84Protocol_ti = (proto_item*) NULL;
  t84Protocol_ti = proto_tree_add_text( tree, tvb, offset + m_t84Protocol.GetStartByte(), m_t84Protocol.GetByteLength(), "t84Protocol (%s)", ( const char* ) m_t84Protocol.GetTagName() );
  t84Protocol_tree = proto_item_add_subtree( t84Protocol_ti, hCont->h245_1.ett_h245_DataApplicationCapability_application_t84_t84Protocol );

  m_t84Protocol.showEthereal( t84Protocol_tree, tvb, offset );

  proto_tree *t84Profile_tree = (proto_tree*) NULL;
  proto_item *t84Profile_ti = (proto_item*) NULL;
  t84Profile_ti = proto_tree_add_text( tree, tvb, offset + m_t84Profile.GetStartByte(), m_t84Profile.GetByteLength(), "t84Profile (%s)", ( const char* ) m_t84Profile.GetTagName() );
  t84Profile_tree = proto_item_add_subtree( t84Profile_ti, hCont->h245_1.ett_h245_DataApplicationCapability_application_t84_t84Profile );

  m_t84Profile.showEthereal( t84Profile_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// DataApplicationCapability_application_nlpid
//

H245_DataApplicationCapability_application_nlpid::H245_DataApplicationCapability_application_nlpid(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_DataApplicationCapability_application_nlpid::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "nlpidProtocol = " << setprecision(indent) << m_nlpidProtocol << '\n';
  strm << setw(indent+12) << "nlpidData = " << setprecision(indent) << m_nlpidData << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_DataApplicationCapability_application_nlpid::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_DataApplicationCapability_application_nlpid::Class()), PInvalidCast);
#endif
  const H245_DataApplicationCapability_application_nlpid & other = (const H245_DataApplicationCapability_application_nlpid &)obj;

  Comparison result;

  if ((result = m_nlpidProtocol.Compare(other.m_nlpidProtocol)) != EqualTo)
    return result;
  if ((result = m_nlpidData.Compare(other.m_nlpidData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DataApplicationCapability_application_nlpid::GetDataLength() const
{
  return m_nlpidProtocol.GetObjectLength() +
         m_nlpidData.GetObjectLength();
}


BOOL H245_DataApplicationCapability_application_nlpid::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_nlpidProtocol.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_nlpidData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_DataApplicationCapability_application_nlpid::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nlpidProtocol.Encode(strm);
  m_nlpidData.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_nlpidProtocol.Encode(strm);
  m_nlpidData.Encode(strm);
}


PObject * H245_DataApplicationCapability_application_nlpid::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataApplicationCapability_application_nlpid::Class()), PInvalidCast);
#endif
  return new H245_DataApplicationCapability_application_nlpid(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_DataApplicationCapability_application_nlpid::preShowEthereal( void )
{
  m_nlpidProtocol.preShowEthereal( );
  m_nlpidData.preShowEthereal( );
}

PString H245_DataApplicationCapability_application_nlpid::getSummary( void ) 
{
  return PString( "DataApplicationCapability_application_nlpid" );
}

void H245_DataApplicationCapability_application_nlpid::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *nlpidProtocol_tree = (proto_tree*) NULL;
  proto_item *nlpidProtocol_ti = (proto_item*) NULL;
  nlpidProtocol_ti = proto_tree_add_text( tree, tvb, offset + m_nlpidProtocol.GetStartByte(), m_nlpidProtocol.GetByteLength(), "nlpidProtocol (%s)", ( const char* ) m_nlpidProtocol.GetTagName() );
  nlpidProtocol_tree = proto_item_add_subtree( nlpidProtocol_ti, hCont->h245_1.ett_h245_DataApplicationCapability_application_nlpid_nlpidProtocol );

  m_nlpidProtocol.showEthereal( nlpidProtocol_tree, tvb, offset );

  char* pnlpidData = m_nlpidData.getValue();
  proto_tree_add_string( tree, hCont->h245_1.hf_h245_DataApplicationCapability_application_nlpid_nlpidData, tvb, offset + m_nlpidData.GetStartByte(), m_nlpidData.GetByteLength() , pnlpidData );
  delete[] pnlpidData;

}
#endif  //USE_FOR_ETHEREAL

//
// DataApplicationCapability_application_t38fax
//

H245_DataApplicationCapability_application_t38fax::H245_DataApplicationCapability_application_t38fax(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_DataApplicationCapability_application_t38fax::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "t38FaxProtocol = " << setprecision(indent) << m_t38FaxProtocol << '\n';
  strm << setw(indent+16) << "t38FaxProfile = " << setprecision(indent) << m_t38FaxProfile << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_DataApplicationCapability_application_t38fax::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_DataApplicationCapability_application_t38fax::Class()), PInvalidCast);
#endif
  const H245_DataApplicationCapability_application_t38fax & other = (const H245_DataApplicationCapability_application_t38fax &)obj;

  Comparison result;

  if ((result = m_t38FaxProtocol.Compare(other.m_t38FaxProtocol)) != EqualTo)
    return result;
  if ((result = m_t38FaxProfile.Compare(other.m_t38FaxProfile)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DataApplicationCapability_application_t38fax::GetDataLength() const
{
  return m_t38FaxProtocol.GetObjectLength() +
         m_t38FaxProfile.GetObjectLength();
}


BOOL H245_DataApplicationCapability_application_t38fax::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_t38FaxProtocol.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_t38FaxProfile.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_DataApplicationCapability_application_t38fax::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_t38FaxProtocol.Encode(strm);
  m_t38FaxProfile.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_t38FaxProtocol.Encode(strm);
  m_t38FaxProfile.Encode(strm);
}


PObject * H245_DataApplicationCapability_application_t38fax::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataApplicationCapability_application_t38fax::Class()), PInvalidCast);
#endif
  return new H245_DataApplicationCapability_application_t38fax(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_DataApplicationCapability_application_t38fax::preShowEthereal( void )
{
  m_t38FaxProtocol.preShowEthereal( );
  m_t38FaxProfile.preShowEthereal( );
}

PString H245_DataApplicationCapability_application_t38fax::getSummary( void ) 
{
  return PString( "DataApplicationCapability_application_t38fax" );
}

void H245_DataApplicationCapability_application_t38fax::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *t38FaxProtocol_tree = (proto_tree*) NULL;
  proto_item *t38FaxProtocol_ti = (proto_item*) NULL;
  t38FaxProtocol_ti = proto_tree_add_text( tree, tvb, offset + m_t38FaxProtocol.GetStartByte(), m_t38FaxProtocol.GetByteLength(), "t38FaxProtocol (%s)", ( const char* ) m_t38FaxProtocol.GetTagName() );
  t38FaxProtocol_tree = proto_item_add_subtree( t38FaxProtocol_ti, hCont->h245_1.ett_h245_DataApplicationCapability_application_t38fax_t38FaxProtocol );

  m_t38FaxProtocol.showEthereal( t38FaxProtocol_tree, tvb, offset );

  proto_tree *t38FaxProfile_tree = (proto_tree*) NULL;
  proto_item *t38FaxProfile_ti = (proto_item*) NULL;
  t38FaxProfile_ti = proto_tree_add_text( tree, tvb, offset + m_t38FaxProfile.GetStartByte(), m_t38FaxProfile.GetByteLength(), "t38FaxProfile (T38FaxProfile)" );
  t38FaxProfile_tree = proto_item_add_subtree( t38FaxProfile_ti, hCont->h245_1.ett_h245_DataApplicationCapability_application_t38fax_t38FaxProfile );

  m_t38FaxProfile.showEthereal( t38FaxProfile_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters
//

H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "h222LogicalChannelParameters "
        "h223LogicalChannelParameters "
        "v76LogicalChannelParameters "
        "h2250LogicalChannelParameters "
        "none "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator H245_H222LogicalChannelParameters &() const
#else
H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator H245_H222LogicalChannelParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H222LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return *(H245_H222LogicalChannelParameters *)choice;
}


H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator const H245_H222LogicalChannelParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H222LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return *(H245_H222LogicalChannelParameters *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator H245_H223LogicalChannelParameters &() const
#else
H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator H245_H223LogicalChannelParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return *(H245_H223LogicalChannelParameters *)choice;
}


H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator const H245_H223LogicalChannelParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return *(H245_H223LogicalChannelParameters *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator H245_V76LogicalChannelParameters &() const
#else
H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator H245_V76LogicalChannelParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_V76LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return *(H245_V76LogicalChannelParameters *)choice;
}


H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator const H245_V76LogicalChannelParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_V76LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return *(H245_V76LogicalChannelParameters *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator H245_H2250LogicalChannelParameters &() const
#else
H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator H245_H2250LogicalChannelParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H2250LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return *(H245_H2250LogicalChannelParameters *)choice;
}


H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator const H245_H2250LogicalChannelParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H2250LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return *(H245_H2250LogicalChannelParameters *)choice;
}


BOOL H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::CreateObject()
{
  switch (tag) {
    case e_h222LogicalChannelParameters :
      choice = new H245_H222LogicalChannelParameters();
      return TRUE;
    case e_h223LogicalChannelParameters :
      choice = new H245_H223LogicalChannelParameters();
      return TRUE;
    case e_v76LogicalChannelParameters :
      choice = new H245_V76LogicalChannelParameters();
      return TRUE;
    case e_h2250LogicalChannelParameters :
      choice = new H245_H2250LogicalChannelParameters();
      return TRUE;
    case e_none :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_h222LogicalChannelParameters :
        ( ( H245_H222LogicalChannelParameters * ) choice )->preShowEthereal();
        break;
      case e_h223LogicalChannelParameters :
        ( ( H245_H223LogicalChannelParameters * ) choice )->preShowEthereal();
        break;
      case e_v76LogicalChannelParameters :
        ( ( H245_V76LogicalChannelParameters * ) choice )->preShowEthereal();
        break;
      case e_h2250LogicalChannelParameters :
        ( ( H245_H2250LogicalChannelParameters * ) choice )->preShowEthereal();
        break;
      case e_none :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::getSummary( void ) 
{
  return PString( "OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters" );
}

void H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "none" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_none, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters
//

H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "h223LogicalChannelParameters "
        "v76LogicalChannelParameters "
        "h2250LogicalChannelParameters "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::operator H245_H223LogicalChannelParameters &() const
#else
H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::operator H245_H223LogicalChannelParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return *(H245_H223LogicalChannelParameters *)choice;
}


H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::operator const H245_H223LogicalChannelParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H223LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return *(H245_H223LogicalChannelParameters *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::operator H245_V76LogicalChannelParameters &() const
#else
H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::operator H245_V76LogicalChannelParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_V76LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return *(H245_V76LogicalChannelParameters *)choice;
}


H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::operator const H245_V76LogicalChannelParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_V76LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return *(H245_V76LogicalChannelParameters *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::operator H245_H2250LogicalChannelParameters &() const
#else
H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::operator H245_H2250LogicalChannelParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H2250LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return *(H245_H2250LogicalChannelParameters *)choice;
}


H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::operator const H245_H2250LogicalChannelParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H2250LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return *(H245_H2250LogicalChannelParameters *)choice;
}


BOOL H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::CreateObject()
{
  switch (tag) {
    case e_h223LogicalChannelParameters :
      choice = new H245_H223LogicalChannelParameters();
      return TRUE;
    case e_v76LogicalChannelParameters :
      choice = new H245_V76LogicalChannelParameters();
      return TRUE;
    case e_h2250LogicalChannelParameters :
      choice = new H245_H2250LogicalChannelParameters();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_h223LogicalChannelParameters :
        ( ( H245_H223LogicalChannelParameters * ) choice )->preShowEthereal();
        break;
      case e_v76LogicalChannelParameters :
        ( ( H245_V76LogicalChannelParameters * ) choice )->preShowEthereal();
        break;
      case e_h2250LogicalChannelParameters :
        ( ( H245_H2250LogicalChannelParameters * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::getSummary( void ) 
{
  return PString( "OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters" );
}

void H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H223LogicalChannelParameters_adaptationLayerType_al3
//

H245_H223LogicalChannelParameters_adaptationLayerType_al3::H245_H223LogicalChannelParameters_adaptationLayerType_al3(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
  m_controlFieldOctets.SetConstraints(PASN_Object::FixedConstraint, 0, 2);
  m_sendBufferSize.SetConstraints(PASN_Object::FixedConstraint, 0, 16777215);
}


#ifndef PASN_NOPRINTON
void H245_H223LogicalChannelParameters_adaptationLayerType_al3::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "controlFieldOctets = " << setprecision(indent) << m_controlFieldOctets << '\n';
  strm << setw(indent+17) << "sendBufferSize = " << setprecision(indent) << m_sendBufferSize << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H223LogicalChannelParameters_adaptationLayerType_al3::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H223LogicalChannelParameters_adaptationLayerType_al3::Class()), PInvalidCast);
#endif
  const H245_H223LogicalChannelParameters_adaptationLayerType_al3 & other = (const H245_H223LogicalChannelParameters_adaptationLayerType_al3 &)obj;

  Comparison result;

  if ((result = m_controlFieldOctets.Compare(other.m_controlFieldOctets)) != EqualTo)
    return result;
  if ((result = m_sendBufferSize.Compare(other.m_sendBufferSize)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223LogicalChannelParameters_adaptationLayerType_al3::GetDataLength() const
{
  return m_controlFieldOctets.GetObjectLength() +
         m_sendBufferSize.GetObjectLength();
}


BOOL H245_H223LogicalChannelParameters_adaptationLayerType_al3::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_controlFieldOctets.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sendBufferSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H223LogicalChannelParameters_adaptationLayerType_al3::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_controlFieldOctets.Encode(strm);
  m_sendBufferSize.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_controlFieldOctets.Encode(strm);
  m_sendBufferSize.Encode(strm);
}


PObject * H245_H223LogicalChannelParameters_adaptationLayerType_al3::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223LogicalChannelParameters_adaptationLayerType_al3::Class()), PInvalidCast);
#endif
  return new H245_H223LogicalChannelParameters_adaptationLayerType_al3(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223LogicalChannelParameters_adaptationLayerType_al3::preShowEthereal( void )
{
  m_controlFieldOctets.preShowEthereal( );
  m_sendBufferSize.preShowEthereal( );
}

PString H245_H223LogicalChannelParameters_adaptationLayerType_al3::getSummary( void ) 
{
  return PString( "H223LogicalChannelParameters_adaptationLayerType_al3" );
}

void H245_H223LogicalChannelParameters_adaptationLayerType_al3::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_H223LogicalChannelParameters_adaptationLayerType_al3_controlFieldOctets, tvb, offset + m_controlFieldOctets.GetStartByte(), m_controlFieldOctets.GetByteLength() , m_controlFieldOctets.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_H223LogicalChannelParameters_adaptationLayerType_al3_sendBufferSize, tvb, offset + m_sendBufferSize.GetStartByte(), m_sendBufferSize.GetByteLength() , m_sendBufferSize.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// UnicastAddress_iPSourceRouteAddress_routing
//

H245_UnicastAddress_iPSourceRouteAddress_routing::H245_UnicastAddress_iPSourceRouteAddress_routing(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
      , "strict "
        "loose "
#endif
    )
{
}


BOOL H245_UnicastAddress_iPSourceRouteAddress_routing::CreateObject()
{
  switch (tag) {
    case e_strict :
    case e_loose :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_UnicastAddress_iPSourceRouteAddress_routing::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UnicastAddress_iPSourceRouteAddress_routing::Class()), PInvalidCast);
#endif
  return new H245_UnicastAddress_iPSourceRouteAddress_routing(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_UnicastAddress_iPSourceRouteAddress_routing::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_strict :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_loose :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_UnicastAddress_iPSourceRouteAddress_routing::getSummary( void ) 
{
  return PString( "UnicastAddress_iPSourceRouteAddress_routing" );
}

void H245_UnicastAddress_iPSourceRouteAddress_routing::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "strict" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_UnicastAddress_iPSourceRouteAddress_routing_strict, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "loose" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_UnicastAddress_iPSourceRouteAddress_routing_loose, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// UnicastAddress_iPSourceRouteAddress_route
//

H245_UnicastAddress_iPSourceRouteAddress_route::H245_UnicastAddress_iPSourceRouteAddress_route(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_UnicastAddress_iPSourceRouteAddress_route::CreateObject() const
{
  PASN_OctetString * obj = new PASN_OctetString;
  obj->SetConstraints(PASN_Object::FixedConstraint, 4, 4);
  return obj;
}


PASN_OctetString & H245_UnicastAddress_iPSourceRouteAddress_route::operator[](PINDEX i) const
{
  return (PASN_OctetString &)array[i];
}


PObject * H245_UnicastAddress_iPSourceRouteAddress_route::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UnicastAddress_iPSourceRouteAddress_route::Class()), PInvalidCast);
#endif
  return new H245_UnicastAddress_iPSourceRouteAddress_route(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_UnicastAddress_iPSourceRouteAddress_route::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (PASN_OctetString& ) array[i] ).preShowEthereal();
  }
}

PString H245_UnicastAddress_iPSourceRouteAddress_route::getSummary( void ) 
{
  return PString( "UnicastAddress_iPSourceRouteAddress_route" );
}

void H245_UnicastAddress_iPSourceRouteAddress_route::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  for (int i=0; i < array.GetSize(); i++ ) {
    char* pstring = ( ( PASN_OctetString & ) array[i] ).getValue();
    proto_tree_add_string( tree, hCont->h245_1.hf_h245_UnicastAddress_iPSourceRouteAddress_route_array, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), pstring );
    delete[] pstring;
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters
//

H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters::H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
      , "h222LogicalChannelParameters "
        "h2250LogicalChannelParameters "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters::operator H245_H222LogicalChannelParameters &() const
#else
H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters::operator H245_H222LogicalChannelParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H222LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return *(H245_H222LogicalChannelParameters *)choice;
}


H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters::operator const H245_H222LogicalChannelParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H222LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return *(H245_H222LogicalChannelParameters *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters::operator H245_H2250LogicalChannelParameters &() const
#else
H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters::operator H245_H2250LogicalChannelParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H2250LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return *(H245_H2250LogicalChannelParameters *)choice;
}


H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters::operator const H245_H2250LogicalChannelParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_H2250LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return *(H245_H2250LogicalChannelParameters *)choice;
}


BOOL H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters::CreateObject()
{
  switch (tag) {
    case e_h222LogicalChannelParameters :
      choice = new H245_H222LogicalChannelParameters();
      return TRUE;
    case e_h2250LogicalChannelParameters :
      choice = new H245_H2250LogicalChannelParameters();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_h222LogicalChannelParameters :
        ( ( H245_H222LogicalChannelParameters * ) choice )->preShowEthereal();
        break;
      case e_h2250LogicalChannelParameters :
        ( ( H245_H2250LogicalChannelParameters * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters::getSummary( void ) 
{
  return PString( "OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters" );
}

void H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H223ModeParameters_adaptationLayerType_al3
//

H245_H223ModeParameters_adaptationLayerType_al3::H245_H223ModeParameters_adaptationLayerType_al3(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
  m_controlFieldOctets.SetConstraints(PASN_Object::FixedConstraint, 0, 2);
  m_sendBufferSize.SetConstraints(PASN_Object::FixedConstraint, 0, 16777215);
}


#ifndef PASN_NOPRINTON
void H245_H223ModeParameters_adaptationLayerType_al3::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "controlFieldOctets = " << setprecision(indent) << m_controlFieldOctets << '\n';
  strm << setw(indent+17) << "sendBufferSize = " << setprecision(indent) << m_sendBufferSize << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H223ModeParameters_adaptationLayerType_al3::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H223ModeParameters_adaptationLayerType_al3::Class()), PInvalidCast);
#endif
  const H245_H223ModeParameters_adaptationLayerType_al3 & other = (const H245_H223ModeParameters_adaptationLayerType_al3 &)obj;

  Comparison result;

  if ((result = m_controlFieldOctets.Compare(other.m_controlFieldOctets)) != EqualTo)
    return result;
  if ((result = m_sendBufferSize.Compare(other.m_sendBufferSize)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223ModeParameters_adaptationLayerType_al3::GetDataLength() const
{
  return m_controlFieldOctets.GetObjectLength() +
         m_sendBufferSize.GetObjectLength();
}


BOOL H245_H223ModeParameters_adaptationLayerType_al3::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_controlFieldOctets.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sendBufferSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H223ModeParameters_adaptationLayerType_al3::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_controlFieldOctets.Encode(strm);
  m_sendBufferSize.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_controlFieldOctets.Encode(strm);
  m_sendBufferSize.Encode(strm);
}


PObject * H245_H223ModeParameters_adaptationLayerType_al3::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223ModeParameters_adaptationLayerType_al3::Class()), PInvalidCast);
#endif
  return new H245_H223ModeParameters_adaptationLayerType_al3(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223ModeParameters_adaptationLayerType_al3::preShowEthereal( void )
{
  m_controlFieldOctets.preShowEthereal( );
  m_sendBufferSize.preShowEthereal( );
}

PString H245_H223ModeParameters_adaptationLayerType_al3::getSummary( void ) 
{
  return PString( "H223ModeParameters_adaptationLayerType_al3" );
}

void H245_H223ModeParameters_adaptationLayerType_al3::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_H223ModeParameters_adaptationLayerType_al3_controlFieldOctets, tvb, offset + m_controlFieldOctets.GetStartByte(), m_controlFieldOctets.GetByteLength() , m_controlFieldOctets.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_H223ModeParameters_adaptationLayerType_al3_sendBufferSize, tvb, offset + m_sendBufferSize.GetStartByte(), m_sendBufferSize.GetByteLength() , m_sendBufferSize.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// DataMode_application_nlpid
//

H245_DataMode_application_nlpid::H245_DataMode_application_nlpid(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_DataMode_application_nlpid::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "nlpidProtocol = " << setprecision(indent) << m_nlpidProtocol << '\n';
  strm << setw(indent+12) << "nlpidData = " << setprecision(indent) << m_nlpidData << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_DataMode_application_nlpid::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_DataMode_application_nlpid::Class()), PInvalidCast);
#endif
  const H245_DataMode_application_nlpid & other = (const H245_DataMode_application_nlpid &)obj;

  Comparison result;

  if ((result = m_nlpidProtocol.Compare(other.m_nlpidProtocol)) != EqualTo)
    return result;
  if ((result = m_nlpidData.Compare(other.m_nlpidData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DataMode_application_nlpid::GetDataLength() const
{
  return m_nlpidProtocol.GetObjectLength() +
         m_nlpidData.GetObjectLength();
}


BOOL H245_DataMode_application_nlpid::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_nlpidProtocol.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_nlpidData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_DataMode_application_nlpid::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nlpidProtocol.Encode(strm);
  m_nlpidData.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_nlpidProtocol.Encode(strm);
  m_nlpidData.Encode(strm);
}


PObject * H245_DataMode_application_nlpid::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataMode_application_nlpid::Class()), PInvalidCast);
#endif
  return new H245_DataMode_application_nlpid(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_DataMode_application_nlpid::preShowEthereal( void )
{
  m_nlpidProtocol.preShowEthereal( );
  m_nlpidData.preShowEthereal( );
}

PString H245_DataMode_application_nlpid::getSummary( void ) 
{
  return PString( "DataMode_application_nlpid" );
}

void H245_DataMode_application_nlpid::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *nlpidProtocol_tree = (proto_tree*) NULL;
  proto_item *nlpidProtocol_ti = (proto_item*) NULL;
  nlpidProtocol_ti = proto_tree_add_text( tree, tvb, offset + m_nlpidProtocol.GetStartByte(), m_nlpidProtocol.GetByteLength(), "nlpidProtocol (%s)", ( const char* ) m_nlpidProtocol.GetTagName() );
  nlpidProtocol_tree = proto_item_add_subtree( nlpidProtocol_ti, hCont->h245_1.ett_h245_DataMode_application_nlpid_nlpidProtocol );

  m_nlpidProtocol.showEthereal( nlpidProtocol_tree, tvb, offset );

  char* pnlpidData = m_nlpidData.getValue();
  proto_tree_add_string( tree, hCont->h245_1.hf_h245_DataMode_application_nlpid_nlpidData, tvb, offset + m_nlpidData.GetStartByte(), m_nlpidData.GetByteLength() , pnlpidData );
  delete[] pnlpidData;

}
#endif  //USE_FOR_ETHEREAL

//
// DataMode_application_t38fax
//

H245_DataMode_application_t38fax::H245_DataMode_application_t38fax(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_DataMode_application_t38fax::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "t38FaxProtocol = " << setprecision(indent) << m_t38FaxProtocol << '\n';
  strm << setw(indent+16) << "t38FaxProfile = " << setprecision(indent) << m_t38FaxProfile << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_DataMode_application_t38fax::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_DataMode_application_t38fax::Class()), PInvalidCast);
#endif
  const H245_DataMode_application_t38fax & other = (const H245_DataMode_application_t38fax &)obj;

  Comparison result;

  if ((result = m_t38FaxProtocol.Compare(other.m_t38FaxProtocol)) != EqualTo)
    return result;
  if ((result = m_t38FaxProfile.Compare(other.m_t38FaxProfile)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DataMode_application_t38fax::GetDataLength() const
{
  return m_t38FaxProtocol.GetObjectLength() +
         m_t38FaxProfile.GetObjectLength();
}


BOOL H245_DataMode_application_t38fax::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_t38FaxProtocol.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_t38FaxProfile.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_DataMode_application_t38fax::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_t38FaxProtocol.Encode(strm);
  m_t38FaxProfile.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_t38FaxProtocol.Encode(strm);
  m_t38FaxProfile.Encode(strm);
}


PObject * H245_DataMode_application_t38fax::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataMode_application_t38fax::Class()), PInvalidCast);
#endif
  return new H245_DataMode_application_t38fax(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_DataMode_application_t38fax::preShowEthereal( void )
{
  m_t38FaxProtocol.preShowEthereal( );
  m_t38FaxProfile.preShowEthereal( );
}

PString H245_DataMode_application_t38fax::getSummary( void ) 
{
  return PString( "DataMode_application_t38fax" );
}

void H245_DataMode_application_t38fax::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *t38FaxProtocol_tree = (proto_tree*) NULL;
  proto_item *t38FaxProtocol_ti = (proto_item*) NULL;
  t38FaxProtocol_ti = proto_tree_add_text( tree, tvb, offset + m_t38FaxProtocol.GetStartByte(), m_t38FaxProtocol.GetByteLength(), "t38FaxProtocol (%s)", ( const char* ) m_t38FaxProtocol.GetTagName() );
  t38FaxProtocol_tree = proto_item_add_subtree( t38FaxProtocol_ti, hCont->h245_1.ett_h245_DataMode_application_t38fax_t38FaxProtocol );

  m_t38FaxProtocol.showEthereal( t38FaxProtocol_tree, tvb, offset );

  proto_tree *t38FaxProfile_tree = (proto_tree*) NULL;
  proto_item *t38FaxProfile_ti = (proto_item*) NULL;
  t38FaxProfile_ti = proto_tree_add_text( tree, tvb, offset + m_t38FaxProfile.GetStartByte(), m_t38FaxProfile.GetByteLength(), "t38FaxProfile (T38FaxProfile)" );
  t38FaxProfile_tree = proto_item_add_subtree( t38FaxProfile_ti, hCont->h245_1.ett_h245_DataMode_application_t38fax_t38FaxProfile );

  m_t38FaxProfile.showEthereal( t38FaxProfile_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// MultilinkRequest_maximumHeaderInterval_requestType
//

H245_MultilinkRequest_maximumHeaderInterval_requestType::H245_MultilinkRequest_maximumHeaderInterval_requestType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "currentIntervalInformation "
        "requestedInterval "
#endif
    )
{
}


BOOL H245_MultilinkRequest_maximumHeaderInterval_requestType::CreateObject()
{
  switch (tag) {
    case e_currentIntervalInformation :
      choice = new PASN_Null();
      return TRUE;
    case e_requestedInterval :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_MultilinkRequest_maximumHeaderInterval_requestType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkRequest_maximumHeaderInterval_requestType::Class()), PInvalidCast);
#endif
  return new H245_MultilinkRequest_maximumHeaderInterval_requestType(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultilinkRequest_maximumHeaderInterval_requestType::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_currentIntervalInformation :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_requestedInterval :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_MultilinkRequest_maximumHeaderInterval_requestType::getSummary( void ) 
{
  return PString( "MultilinkRequest_maximumHeaderInterval_requestType" );
}

void H245_MultilinkRequest_maximumHeaderInterval_requestType::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "currentIntervalInformation" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MultilinkRequest_maximumHeaderInterval_requestType_currentIntervalInformation, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "requestedInterval" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MultilinkRequest_maximumHeaderInterval_requestType_requestedInterval, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// MultilinkResponse_addConnection_responseCode
//

H245_MultilinkResponse_addConnection_responseCode::H245_MultilinkResponse_addConnection_responseCode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "accepted "
        "rejected "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkResponse_addConnection_responseCode::operator H245_MultilinkResponse_addConnection_responseCode_rejected &() const
#else
H245_MultilinkResponse_addConnection_responseCode::operator H245_MultilinkResponse_addConnection_responseCode_rejected &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkResponse_addConnection_responseCode_rejected::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkResponse_addConnection_responseCode_rejected *)choice;
}


H245_MultilinkResponse_addConnection_responseCode::operator const H245_MultilinkResponse_addConnection_responseCode_rejected &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H245_MultilinkResponse_addConnection_responseCode_rejected::Class()), PInvalidCast);
#endif
  return *(H245_MultilinkResponse_addConnection_responseCode_rejected *)choice;
}


BOOL H245_MultilinkResponse_addConnection_responseCode::CreateObject()
{
  switch (tag) {
    case e_accepted :
      choice = new PASN_Null();
      return TRUE;
    case e_rejected :
      choice = new H245_MultilinkResponse_addConnection_responseCode_rejected();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_MultilinkResponse_addConnection_responseCode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkResponse_addConnection_responseCode::Class()), PInvalidCast);
#endif
  return new H245_MultilinkResponse_addConnection_responseCode(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultilinkResponse_addConnection_responseCode::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_accepted :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_rejected :
        ( ( H245_MultilinkResponse_addConnection_responseCode_rejected * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_MultilinkResponse_addConnection_responseCode::getSummary( void ) 
{
  return PString( "MultilinkResponse_addConnection_responseCode" );
}

void H245_MultilinkResponse_addConnection_responseCode::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "accepted" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MultilinkResponse_addConnection_responseCode_accepted, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h245_1.ett_h245_MultilinkResponse_addConnection_responseCode_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_CapabilityDescriptorNumber
//

H245_ArrayOf_CapabilityDescriptorNumber::H245_ArrayOf_CapabilityDescriptorNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_CapabilityDescriptorNumber::CreateObject() const
{
  return new H245_CapabilityDescriptorNumber;
}


H245_CapabilityDescriptorNumber & H245_ArrayOf_CapabilityDescriptorNumber::operator[](PINDEX i) const
{
  return (H245_CapabilityDescriptorNumber &)array[i];
}


PObject * H245_ArrayOf_CapabilityDescriptorNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_CapabilityDescriptorNumber::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_CapabilityDescriptorNumber(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ArrayOf_CapabilityDescriptorNumber::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H245_CapabilityDescriptorNumber& ) array[i] ).preShowEthereal();
  }
}

PString H245_ArrayOf_CapabilityDescriptorNumber::getSummary( void ) 
{
  return PString( "ArrayOf_CapabilityDescriptorNumber" );
}

void H245_ArrayOf_CapabilityDescriptorNumber::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  for (int i=0; i < array.GetSize(); i++ ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_ArrayOf_CapabilityDescriptorNumber_array, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), ( (PASN_Integer& ) array[i] ).GetValue() );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// MiscellaneousCommand_type_videoFastUpdateGOB
//

H245_MiscellaneousCommand_type_videoFastUpdateGOB::H245_MiscellaneousCommand_type_videoFastUpdateGOB(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
  m_firstGOB.SetConstraints(PASN_Object::FixedConstraint, 0, 17);
  m_numberOfGOBs.SetConstraints(PASN_Object::FixedConstraint, 1, 18);
}


#ifndef PASN_NOPRINTON
void H245_MiscellaneousCommand_type_videoFastUpdateGOB::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "firstGOB = " << setprecision(indent) << m_firstGOB << '\n';
  strm << setw(indent+15) << "numberOfGOBs = " << setprecision(indent) << m_numberOfGOBs << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MiscellaneousCommand_type_videoFastUpdateGOB::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MiscellaneousCommand_type_videoFastUpdateGOB::Class()), PInvalidCast);
#endif
  const H245_MiscellaneousCommand_type_videoFastUpdateGOB & other = (const H245_MiscellaneousCommand_type_videoFastUpdateGOB &)obj;

  Comparison result;

  if ((result = m_firstGOB.Compare(other.m_firstGOB)) != EqualTo)
    return result;
  if ((result = m_numberOfGOBs.Compare(other.m_numberOfGOBs)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MiscellaneousCommand_type_videoFastUpdateGOB::GetDataLength() const
{
  return m_firstGOB.GetObjectLength() +
         m_numberOfGOBs.GetObjectLength();
}


BOOL H245_MiscellaneousCommand_type_videoFastUpdateGOB::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_firstGOB.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_numberOfGOBs.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MiscellaneousCommand_type_videoFastUpdateGOB::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_firstGOB.Encode(strm);
  m_numberOfGOBs.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_firstGOB.Encode(strm);
  m_numberOfGOBs.Encode(strm);
}


PObject * H245_MiscellaneousCommand_type_videoFastUpdateGOB::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MiscellaneousCommand_type_videoFastUpdateGOB::Class()), PInvalidCast);
#endif
  return new H245_MiscellaneousCommand_type_videoFastUpdateGOB(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MiscellaneousCommand_type_videoFastUpdateGOB::preShowEthereal( void )
{
  m_firstGOB.preShowEthereal( );
  m_numberOfGOBs.preShowEthereal( );
}

PString H245_MiscellaneousCommand_type_videoFastUpdateGOB::getSummary( void ) 
{
  return PString( "MiscellaneousCommand_type_videoFastUpdateGOB" );
}

void H245_MiscellaneousCommand_type_videoFastUpdateGOB::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MiscellaneousCommand_type_videoFastUpdateGOB_firstGOB, tvb, offset + m_firstGOB.GetStartByte(), m_firstGOB.GetByteLength() , m_firstGOB.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MiscellaneousCommand_type_videoFastUpdateGOB_numberOfGOBs, tvb, offset + m_numberOfGOBs.GetStartByte(), m_numberOfGOBs.GetByteLength() , m_numberOfGOBs.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// MiscellaneousCommand_type_videoFastUpdateMB
//

H245_MiscellaneousCommand_type_videoFastUpdateMB::H245_MiscellaneousCommand_type_videoFastUpdateMB(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_firstGOB.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
  m_firstMB.SetConstraints(PASN_Object::FixedConstraint, 1, 8192);
  m_numberOfMBs.SetConstraints(PASN_Object::FixedConstraint, 1, 8192);
}


#ifndef PASN_NOPRINTON
void H245_MiscellaneousCommand_type_videoFastUpdateMB::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_firstGOB))
    strm << setw(indent+11) << "firstGOB = " << setprecision(indent) << m_firstGOB << '\n';
  if (HasOptionalField(e_firstMB))
    strm << setw(indent+10) << "firstMB = " << setprecision(indent) << m_firstMB << '\n';
  strm << setw(indent+14) << "numberOfMBs = " << setprecision(indent) << m_numberOfMBs << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MiscellaneousCommand_type_videoFastUpdateMB::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MiscellaneousCommand_type_videoFastUpdateMB::Class()), PInvalidCast);
#endif
  const H245_MiscellaneousCommand_type_videoFastUpdateMB & other = (const H245_MiscellaneousCommand_type_videoFastUpdateMB &)obj;

  Comparison result;

  if ((result = m_firstGOB.Compare(other.m_firstGOB)) != EqualTo)
    return result;
  if ((result = m_firstMB.Compare(other.m_firstMB)) != EqualTo)
    return result;
  if ((result = m_numberOfMBs.Compare(other.m_numberOfMBs)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MiscellaneousCommand_type_videoFastUpdateMB::GetDataLength() const
{
  return m_firstGOB.GetObjectLength() +
         m_firstMB.GetObjectLength() +
         m_numberOfMBs.GetObjectLength();
}


BOOL H245_MiscellaneousCommand_type_videoFastUpdateMB::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_firstGOB ) && !m_firstGOB.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_firstMB ) && !m_firstMB.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_numberOfMBs.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MiscellaneousCommand_type_videoFastUpdateMB::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_firstGOB))
    m_firstGOB.Encode(strm);
  if (HasOptionalField(e_firstMB))
    m_firstMB.Encode(strm);
  m_numberOfMBs.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_firstGOB))
    m_firstGOB.Encode(strm);
  if (HasOptionalField(e_firstMB))
    m_firstMB.Encode(strm);
  m_numberOfMBs.Encode(strm);
}


PObject * H245_MiscellaneousCommand_type_videoFastUpdateMB::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MiscellaneousCommand_type_videoFastUpdateMB::Class()), PInvalidCast);
#endif
  return new H245_MiscellaneousCommand_type_videoFastUpdateMB(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MiscellaneousCommand_type_videoFastUpdateMB::preShowEthereal( void )
{
  if ( HasOptionalField( e_firstGOB ) ) 
      m_firstGOB.preShowEthereal( );
  if ( HasOptionalField( e_firstMB ) ) 
      m_firstMB.preShowEthereal( );
  m_numberOfMBs.preShowEthereal( );
}

PString H245_MiscellaneousCommand_type_videoFastUpdateMB::getSummary( void ) 
{
  return PString( "MiscellaneousCommand_type_videoFastUpdateMB" );
}

void H245_MiscellaneousCommand_type_videoFastUpdateMB::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_firstGOB ) ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MiscellaneousCommand_type_videoFastUpdateMB_firstGOB, tvb, offset + m_firstGOB.GetStartByte(), m_firstGOB.GetByteLength() , m_firstGOB.GetValue() );
  }

  if ( HasOptionalField( e_firstMB ) ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MiscellaneousCommand_type_videoFastUpdateMB_firstMB, tvb, offset + m_firstMB.GetStartByte(), m_firstMB.GetByteLength() , m_firstMB.GetValue() );
  }

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MiscellaneousCommand_type_videoFastUpdateMB_numberOfMBs, tvb, offset + m_numberOfMBs.GetStartByte(), m_numberOfMBs.GetByteLength() , m_numberOfMBs.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// NewATMVCCommand_aal_aal5
//

H245_NewATMVCCommand_aal_aal5::H245_NewATMVCCommand_aal_aal5(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_forwardMaximumSDUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_backwardMaximumSDUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_NewATMVCCommand_aal_aal5::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "forwardMaximumSDUSize = " << setprecision(indent) << m_forwardMaximumSDUSize << '\n';
  strm << setw(indent+25) << "backwardMaximumSDUSize = " << setprecision(indent) << m_backwardMaximumSDUSize << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_NewATMVCCommand_aal_aal5::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_NewATMVCCommand_aal_aal5::Class()), PInvalidCast);
#endif
  const H245_NewATMVCCommand_aal_aal5 & other = (const H245_NewATMVCCommand_aal_aal5 &)obj;

  Comparison result;

  if ((result = m_forwardMaximumSDUSize.Compare(other.m_forwardMaximumSDUSize)) != EqualTo)
    return result;
  if ((result = m_backwardMaximumSDUSize.Compare(other.m_backwardMaximumSDUSize)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NewATMVCCommand_aal_aal5::GetDataLength() const
{
  return m_forwardMaximumSDUSize.GetObjectLength() +
         m_backwardMaximumSDUSize.GetObjectLength();
}


BOOL H245_NewATMVCCommand_aal_aal5::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_forwardMaximumSDUSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_backwardMaximumSDUSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_NewATMVCCommand_aal_aal5::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardMaximumSDUSize.Encode(strm);
  m_backwardMaximumSDUSize.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_forwardMaximumSDUSize.Encode(strm);
  m_backwardMaximumSDUSize.Encode(strm);
}


PObject * H245_NewATMVCCommand_aal_aal5::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCCommand_aal_aal5::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCCommand_aal_aal5(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NewATMVCCommand_aal_aal5::preShowEthereal( void )
{
  m_forwardMaximumSDUSize.preShowEthereal( );
  m_backwardMaximumSDUSize.preShowEthereal( );
}

PString H245_NewATMVCCommand_aal_aal5::getSummary( void ) 
{
  return PString( "NewATMVCCommand_aal_aal5" );
}

void H245_NewATMVCCommand_aal_aal5::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_NewATMVCCommand_aal_aal5_forwardMaximumSDUSize, tvb, offset + m_forwardMaximumSDUSize.GetStartByte(), m_forwardMaximumSDUSize.GetByteLength() , m_forwardMaximumSDUSize.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_NewATMVCCommand_aal_aal5_backwardMaximumSDUSize, tvb, offset + m_backwardMaximumSDUSize.GetStartByte(), m_backwardMaximumSDUSize.GetByteLength() , m_backwardMaximumSDUSize.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// NewATMVCCommand_reverseParameters_multiplex
//

H245_NewATMVCCommand_reverseParameters_multiplex::H245_NewATMVCCommand_reverseParameters_multiplex(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "noMultiplex "
        "transportStream "
        "programStream "
#endif
    )
{
}


BOOL H245_NewATMVCCommand_reverseParameters_multiplex::CreateObject()
{
  switch (tag) {
    case e_noMultiplex :
    case e_transportStream :
    case e_programStream :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_NewATMVCCommand_reverseParameters_multiplex::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCCommand_reverseParameters_multiplex::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCCommand_reverseParameters_multiplex(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NewATMVCCommand_reverseParameters_multiplex::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_noMultiplex :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_transportStream :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_programStream :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_NewATMVCCommand_reverseParameters_multiplex::getSummary( void ) 
{
  return PString( "NewATMVCCommand_reverseParameters_multiplex" );
}

void H245_NewATMVCCommand_reverseParameters_multiplex::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "noMultiplex" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCCommand_reverseParameters_multiplex_noMultiplex, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "transportStream" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCCommand_reverseParameters_multiplex_transportStream, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "programStream" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCCommand_reverseParameters_multiplex_programStream, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// MiscellaneousIndication_type_videoNotDecodedMBs
//

H245_MiscellaneousIndication_type_videoNotDecodedMBs::H245_MiscellaneousIndication_type_videoNotDecodedMBs(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_firstMB.SetConstraints(PASN_Object::FixedConstraint, 1, 8192);
  m_numberOfMBs.SetConstraints(PASN_Object::FixedConstraint, 1, 8192);
  m_temporalReference.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H245_MiscellaneousIndication_type_videoNotDecodedMBs::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "firstMB = " << setprecision(indent) << m_firstMB << '\n';
  strm << setw(indent+14) << "numberOfMBs = " << setprecision(indent) << m_numberOfMBs << '\n';
  strm << setw(indent+20) << "temporalReference = " << setprecision(indent) << m_temporalReference << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MiscellaneousIndication_type_videoNotDecodedMBs::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MiscellaneousIndication_type_videoNotDecodedMBs::Class()), PInvalidCast);
#endif
  const H245_MiscellaneousIndication_type_videoNotDecodedMBs & other = (const H245_MiscellaneousIndication_type_videoNotDecodedMBs &)obj;

  Comparison result;

  if ((result = m_firstMB.Compare(other.m_firstMB)) != EqualTo)
    return result;
  if ((result = m_numberOfMBs.Compare(other.m_numberOfMBs)) != EqualTo)
    return result;
  if ((result = m_temporalReference.Compare(other.m_temporalReference)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MiscellaneousIndication_type_videoNotDecodedMBs::GetDataLength() const
{
  return m_firstMB.GetObjectLength() +
         m_numberOfMBs.GetObjectLength() +
         m_temporalReference.GetObjectLength();
}


BOOL H245_MiscellaneousIndication_type_videoNotDecodedMBs::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_firstMB.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_numberOfMBs.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_temporalReference.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MiscellaneousIndication_type_videoNotDecodedMBs::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_firstMB.Encode(strm);
  m_numberOfMBs.Encode(strm);
  m_temporalReference.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_firstMB.Encode(strm);
  m_numberOfMBs.Encode(strm);
  m_temporalReference.Encode(strm);
}


PObject * H245_MiscellaneousIndication_type_videoNotDecodedMBs::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MiscellaneousIndication_type_videoNotDecodedMBs::Class()), PInvalidCast);
#endif
  return new H245_MiscellaneousIndication_type_videoNotDecodedMBs(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MiscellaneousIndication_type_videoNotDecodedMBs::preShowEthereal( void )
{
  m_firstMB.preShowEthereal( );
  m_numberOfMBs.preShowEthereal( );
  m_temporalReference.preShowEthereal( );
}

PString H245_MiscellaneousIndication_type_videoNotDecodedMBs::getSummary( void ) 
{
  return PString( "MiscellaneousIndication_type_videoNotDecodedMBs" );
}

void H245_MiscellaneousIndication_type_videoNotDecodedMBs::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MiscellaneousIndication_type_videoNotDecodedMBs_firstMB, tvb, offset + m_firstMB.GetStartByte(), m_firstMB.GetByteLength() , m_firstMB.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MiscellaneousIndication_type_videoNotDecodedMBs_numberOfMBs, tvb, offset + m_numberOfMBs.GetStartByte(), m_numberOfMBs.GetByteLength() , m_numberOfMBs.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_MiscellaneousIndication_type_videoNotDecodedMBs_temporalReference, tvb, offset + m_temporalReference.GetStartByte(), m_temporalReference.GetByteLength() , m_temporalReference.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// NewATMVCIndication_aal_aal5
//

H245_NewATMVCIndication_aal_aal5::H245_NewATMVCIndication_aal_aal5(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_forwardMaximumSDUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_backwardMaximumSDUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_NewATMVCIndication_aal_aal5::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "forwardMaximumSDUSize = " << setprecision(indent) << m_forwardMaximumSDUSize << '\n';
  strm << setw(indent+25) << "backwardMaximumSDUSize = " << setprecision(indent) << m_backwardMaximumSDUSize << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_NewATMVCIndication_aal_aal5::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_NewATMVCIndication_aal_aal5::Class()), PInvalidCast);
#endif
  const H245_NewATMVCIndication_aal_aal5 & other = (const H245_NewATMVCIndication_aal_aal5 &)obj;

  Comparison result;

  if ((result = m_forwardMaximumSDUSize.Compare(other.m_forwardMaximumSDUSize)) != EqualTo)
    return result;
  if ((result = m_backwardMaximumSDUSize.Compare(other.m_backwardMaximumSDUSize)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NewATMVCIndication_aal_aal5::GetDataLength() const
{
  return m_forwardMaximumSDUSize.GetObjectLength() +
         m_backwardMaximumSDUSize.GetObjectLength();
}


BOOL H245_NewATMVCIndication_aal_aal5::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_forwardMaximumSDUSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_backwardMaximumSDUSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_NewATMVCIndication_aal_aal5::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardMaximumSDUSize.Encode(strm);
  m_backwardMaximumSDUSize.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_forwardMaximumSDUSize.Encode(strm);
  m_backwardMaximumSDUSize.Encode(strm);
}


PObject * H245_NewATMVCIndication_aal_aal5::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCIndication_aal_aal5::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCIndication_aal_aal5(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NewATMVCIndication_aal_aal5::preShowEthereal( void )
{
  m_forwardMaximumSDUSize.preShowEthereal( );
  m_backwardMaximumSDUSize.preShowEthereal( );
}

PString H245_NewATMVCIndication_aal_aal5::getSummary( void ) 
{
  return PString( "NewATMVCIndication_aal_aal5" );
}

void H245_NewATMVCIndication_aal_aal5::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_NewATMVCIndication_aal_aal5_forwardMaximumSDUSize, tvb, offset + m_forwardMaximumSDUSize.GetStartByte(), m_forwardMaximumSDUSize.GetByteLength() , m_forwardMaximumSDUSize.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_NewATMVCIndication_aal_aal5_backwardMaximumSDUSize, tvb, offset + m_backwardMaximumSDUSize.GetStartByte(), m_backwardMaximumSDUSize.GetByteLength() , m_backwardMaximumSDUSize.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// NewATMVCIndication_reverseParameters_multiplex
//

H245_NewATMVCIndication_reverseParameters_multiplex::H245_NewATMVCIndication_reverseParameters_multiplex(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "noMultiplex "
        "transportStream "
        "programStream "
#endif
    )
{
}


BOOL H245_NewATMVCIndication_reverseParameters_multiplex::CreateObject()
{
  switch (tag) {
    case e_noMultiplex :
    case e_transportStream :
    case e_programStream :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_NewATMVCIndication_reverseParameters_multiplex::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCIndication_reverseParameters_multiplex::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCIndication_reverseParameters_multiplex(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NewATMVCIndication_reverseParameters_multiplex::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_noMultiplex :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_transportStream :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_programStream :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_NewATMVCIndication_reverseParameters_multiplex::getSummary( void ) 
{
  return PString( "NewATMVCIndication_reverseParameters_multiplex" );
}

void H245_NewATMVCIndication_reverseParameters_multiplex::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "noMultiplex" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCIndication_reverseParameters_multiplex_noMultiplex, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "transportStream" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCIndication_reverseParameters_multiplex_transportStream, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "programStream" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCIndication_reverseParameters_multiplex_programStream, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// UserInputIndication_signal_rtp
//

H245_UserInputIndication_signal_rtp::H245_UserInputIndication_signal_rtp(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_timestamp.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
  m_expirationTime.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H245_UserInputIndication_signal_rtp::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_timestamp))
    strm << setw(indent+12) << "timestamp = " << setprecision(indent) << m_timestamp << '\n';
  if (HasOptionalField(e_expirationTime))
    strm << setw(indent+17) << "expirationTime = " << setprecision(indent) << m_expirationTime << '\n';
  strm << setw(indent+23) << "logicalChannelNumber = " << setprecision(indent) << m_logicalChannelNumber << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_UserInputIndication_signal_rtp::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_UserInputIndication_signal_rtp::Class()), PInvalidCast);
#endif
  const H245_UserInputIndication_signal_rtp & other = (const H245_UserInputIndication_signal_rtp &)obj;

  Comparison result;

  if ((result = m_timestamp.Compare(other.m_timestamp)) != EqualTo)
    return result;
  if ((result = m_expirationTime.Compare(other.m_expirationTime)) != EqualTo)
    return result;
  if ((result = m_logicalChannelNumber.Compare(other.m_logicalChannelNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_UserInputIndication_signal_rtp::GetDataLength() const
{
  return m_timestamp.GetObjectLength() +
         m_expirationTime.GetObjectLength() +
         m_logicalChannelNumber.GetObjectLength();
}


BOOL H245_UserInputIndication_signal_rtp::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_timestamp ) && !m_timestamp.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_expirationTime ) && !m_expirationTime.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_logicalChannelNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_UserInputIndication_signal_rtp::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_timestamp))
    m_timestamp.Encode(strm);
  if (HasOptionalField(e_expirationTime))
    m_expirationTime.Encode(strm);
  m_logicalChannelNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_timestamp))
    m_timestamp.Encode(strm);
  if (HasOptionalField(e_expirationTime))
    m_expirationTime.Encode(strm);
  m_logicalChannelNumber.Encode(strm);
}


PObject * H245_UserInputIndication_signal_rtp::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UserInputIndication_signal_rtp::Class()), PInvalidCast);
#endif
  return new H245_UserInputIndication_signal_rtp(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_UserInputIndication_signal_rtp::preShowEthereal( void )
{
  if ( HasOptionalField( e_timestamp ) ) 
      m_timestamp.preShowEthereal( );
  if ( HasOptionalField( e_expirationTime ) ) 
      m_expirationTime.preShowEthereal( );
  m_logicalChannelNumber.preShowEthereal( );
}

PString H245_UserInputIndication_signal_rtp::getSummary( void ) 
{
  return PString( "UserInputIndication_signal_rtp" );
}

void H245_UserInputIndication_signal_rtp::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_timestamp ) ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_UserInputIndication_signal_rtp_timestamp, tvb, offset + m_timestamp.GetStartByte(), m_timestamp.GetByteLength() , m_timestamp.GetValue() );
  }

  if ( HasOptionalField( e_expirationTime ) ) {
    proto_tree_add_uint( tree, hCont->h245_1.hf_h245_UserInputIndication_signal_rtp_expirationTime, tvb, offset + m_expirationTime.GetStartByte(), m_expirationTime.GetByteLength() , m_expirationTime.GetValue() );
  }

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_UserInputIndication_signal_rtp_logicalChannelNumber, tvb, offset + m_logicalChannelNumber.GetStartByte(), m_logicalChannelNumber.GetByteLength() , m_logicalChannelNumber.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// UserInputIndication_signalUpdate_rtp
//

H245_UserInputIndication_signalUpdate_rtp::H245_UserInputIndication_signalUpdate_rtp(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_UserInputIndication_signalUpdate_rtp::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "logicalChannelNumber = " << setprecision(indent) << m_logicalChannelNumber << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_UserInputIndication_signalUpdate_rtp::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_UserInputIndication_signalUpdate_rtp::Class()), PInvalidCast);
#endif
  const H245_UserInputIndication_signalUpdate_rtp & other = (const H245_UserInputIndication_signalUpdate_rtp &)obj;

  Comparison result;

  if ((result = m_logicalChannelNumber.Compare(other.m_logicalChannelNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_UserInputIndication_signalUpdate_rtp::GetDataLength() const
{
  return m_logicalChannelNumber.GetObjectLength();
}


BOOL H245_UserInputIndication_signalUpdate_rtp::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_logicalChannelNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_UserInputIndication_signalUpdate_rtp::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_logicalChannelNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_logicalChannelNumber.Encode(strm);
}


PObject * H245_UserInputIndication_signalUpdate_rtp::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UserInputIndication_signalUpdate_rtp::Class()), PInvalidCast);
#endif
  return new H245_UserInputIndication_signalUpdate_rtp(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_UserInputIndication_signalUpdate_rtp::preShowEthereal( void )
{
  m_logicalChannelNumber.preShowEthereal( );
}

PString H245_UserInputIndication_signalUpdate_rtp::getSummary( void ) 
{
  return PString( "UserInputIndication_signalUpdate_rtp" );
}

void H245_UserInputIndication_signalUpdate_rtp::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_UserInputIndication_signalUpdate_rtp_logicalChannelNumber, tvb, offset + m_logicalChannelNumber.GetStartByte(), m_logicalChannelNumber.GetByteLength() , m_logicalChannelNumber.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// VCCapability_availableBitRates_type_rangeOfBitRates
//

H245_VCCapability_availableBitRates_type_rangeOfBitRates::H245_VCCapability_availableBitRates_type_rangeOfBitRates(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
  m_lowerBitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
  m_higherBitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H245_VCCapability_availableBitRates_type_rangeOfBitRates::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "lowerBitRate = " << setprecision(indent) << m_lowerBitRate << '\n';
  strm << setw(indent+16) << "higherBitRate = " << setprecision(indent) << m_higherBitRate << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_VCCapability_availableBitRates_type_rangeOfBitRates::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_VCCapability_availableBitRates_type_rangeOfBitRates::Class()), PInvalidCast);
#endif
  const H245_VCCapability_availableBitRates_type_rangeOfBitRates & other = (const H245_VCCapability_availableBitRates_type_rangeOfBitRates &)obj;

  Comparison result;

  if ((result = m_lowerBitRate.Compare(other.m_lowerBitRate)) != EqualTo)
    return result;
  if ((result = m_higherBitRate.Compare(other.m_higherBitRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_VCCapability_availableBitRates_type_rangeOfBitRates::GetDataLength() const
{
  return m_lowerBitRate.GetObjectLength() +
         m_higherBitRate.GetObjectLength();
}


BOOL H245_VCCapability_availableBitRates_type_rangeOfBitRates::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_lowerBitRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_higherBitRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_VCCapability_availableBitRates_type_rangeOfBitRates::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_lowerBitRate.Encode(strm);
  m_higherBitRate.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_lowerBitRate.Encode(strm);
  m_higherBitRate.Encode(strm);
}


PObject * H245_VCCapability_availableBitRates_type_rangeOfBitRates::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_VCCapability_availableBitRates_type_rangeOfBitRates::Class()), PInvalidCast);
#endif
  return new H245_VCCapability_availableBitRates_type_rangeOfBitRates(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_VCCapability_availableBitRates_type_rangeOfBitRates::preShowEthereal( void )
{
  m_lowerBitRate.preShowEthereal( );
  m_higherBitRate.preShowEthereal( );
}

PString H245_VCCapability_availableBitRates_type_rangeOfBitRates::getSummary( void ) 
{
  return PString( "VCCapability_availableBitRates_type_rangeOfBitRates" );
}

void H245_VCCapability_availableBitRates_type_rangeOfBitRates::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_VCCapability_availableBitRates_type_rangeOfBitRates_lowerBitRate, tvb, offset + m_lowerBitRate.GetStartByte(), m_lowerBitRate.GetByteLength() , m_lowerBitRate.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_VCCapability_availableBitRates_type_rangeOfBitRates_higherBitRate, tvb, offset + m_higherBitRate.GetStartByte(), m_higherBitRate.GetByteLength() , m_higherBitRate.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// CustomPictureFormat_mPI_customPCF_subtype
//

H245_CustomPictureFormat_mPI_customPCF_subtype::H245_CustomPictureFormat_mPI_customPCF_subtype(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_clockConversionCode.SetConstraints(PASN_Object::FixedConstraint, 1000, 1001);
  m_clockDivisor.SetConstraints(PASN_Object::FixedConstraint, 1, 127);
  m_customMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 2048);
}


#ifndef PASN_NOPRINTON
void H245_CustomPictureFormat_mPI_customPCF_subtype::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "clockConversionCode = " << setprecision(indent) << m_clockConversionCode << '\n';
  strm << setw(indent+15) << "clockDivisor = " << setprecision(indent) << m_clockDivisor << '\n';
  strm << setw(indent+12) << "customMPI = " << setprecision(indent) << m_customMPI << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_CustomPictureFormat_mPI_customPCF_subtype::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_CustomPictureFormat_mPI_customPCF_subtype::Class()), PInvalidCast);
#endif
  const H245_CustomPictureFormat_mPI_customPCF_subtype & other = (const H245_CustomPictureFormat_mPI_customPCF_subtype &)obj;

  Comparison result;

  if ((result = m_clockConversionCode.Compare(other.m_clockConversionCode)) != EqualTo)
    return result;
  if ((result = m_clockDivisor.Compare(other.m_clockDivisor)) != EqualTo)
    return result;
  if ((result = m_customMPI.Compare(other.m_customMPI)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_CustomPictureFormat_mPI_customPCF_subtype::GetDataLength() const
{
  return m_clockConversionCode.GetObjectLength() +
         m_clockDivisor.GetObjectLength() +
         m_customMPI.GetObjectLength();
}


BOOL H245_CustomPictureFormat_mPI_customPCF_subtype::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_clockConversionCode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_clockDivisor.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_customMPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_CustomPictureFormat_mPI_customPCF_subtype::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_clockConversionCode.Encode(strm);
  m_clockDivisor.Encode(strm);
  m_customMPI.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_clockConversionCode.Encode(strm);
  m_clockDivisor.Encode(strm);
  m_customMPI.Encode(strm);
}


PObject * H245_CustomPictureFormat_mPI_customPCF_subtype::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CustomPictureFormat_mPI_customPCF_subtype::Class()), PInvalidCast);
#endif
  return new H245_CustomPictureFormat_mPI_customPCF_subtype(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CustomPictureFormat_mPI_customPCF_subtype::preShowEthereal( void )
{
  m_clockConversionCode.preShowEthereal( );
  m_clockDivisor.preShowEthereal( );
  m_customMPI.preShowEthereal( );
}

PString H245_CustomPictureFormat_mPI_customPCF_subtype::getSummary( void ) 
{
  return PString( "CustomPictureFormat_mPI_customPCF_subtype" );
}

void H245_CustomPictureFormat_mPI_customPCF_subtype::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_CustomPictureFormat_mPI_customPCF_subtype_clockConversionCode, tvb, offset + m_clockConversionCode.GetStartByte(), m_clockConversionCode.GetByteLength() , m_clockConversionCode.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_CustomPictureFormat_mPI_customPCF_subtype_clockDivisor, tvb, offset + m_clockDivisor.GetStartByte(), m_clockDivisor.GetByteLength() , m_clockDivisor.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_CustomPictureFormat_mPI_customPCF_subtype_customMPI, tvb, offset + m_customMPI.GetStartByte(), m_customMPI.GetByteLength() , m_customMPI.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype
//

H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype::H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_width.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
  m_height.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
}


#ifndef PASN_NOPRINTON
void H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+8) << "width = " << setprecision(indent) << m_width << '\n';
  strm << setw(indent+9) << "height = " << setprecision(indent) << m_height << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype::Class()), PInvalidCast);
#endif
  const H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype & other = (const H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype &)obj;

  Comparison result;

  if ((result = m_width.Compare(other.m_width)) != EqualTo)
    return result;
  if ((result = m_height.Compare(other.m_height)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype::GetDataLength() const
{
  return m_width.GetObjectLength() +
         m_height.GetObjectLength();
}


BOOL H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_width.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_height.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_width.Encode(strm);
  m_height.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_width.Encode(strm);
  m_height.Encode(strm);
}


PObject * H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype::Class()), PInvalidCast);
#endif
  return new H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype::preShowEthereal( void )
{
  m_width.preShowEthereal( );
  m_height.preShowEthereal( );
}

PString H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype::getSummary( void ) 
{
  return PString( "CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype" );
}

void H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_width, tvb, offset + m_width.GetStartByte(), m_width.GetByteLength() , m_width.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_height, tvb, offset + m_height.GetStartByte(), m_height.GetByteLength() , m_height.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// V76LogicalChannelParameters_mode_eRM_recovery
//

H245_V76LogicalChannelParameters_mode_eRM_recovery::H245_V76LogicalChannelParameters_mode_eRM_recovery(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "rej "
        "sREJ "
        "mSREJ "
#endif
    )
{
}


BOOL H245_V76LogicalChannelParameters_mode_eRM_recovery::CreateObject()
{
  switch (tag) {
    case e_rej :
    case e_sREJ :
    case e_mSREJ :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_V76LogicalChannelParameters_mode_eRM_recovery::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_V76LogicalChannelParameters_mode_eRM_recovery::Class()), PInvalidCast);
#endif
  return new H245_V76LogicalChannelParameters_mode_eRM_recovery(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_V76LogicalChannelParameters_mode_eRM_recovery::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_rej :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_sREJ :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_mSREJ :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_V76LogicalChannelParameters_mode_eRM_recovery::getSummary( void ) 
{
  return PString( "V76LogicalChannelParameters_mode_eRM_recovery" );
}

void H245_V76LogicalChannelParameters_mode_eRM_recovery::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "rej" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_V76LogicalChannelParameters_mode_eRM_recovery_rej, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "sREJ" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_V76LogicalChannelParameters_mode_eRM_recovery_sREJ, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "mSREJ" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_V76LogicalChannelParameters_mode_eRM_recovery_mSREJ, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// MultilinkResponse_addConnection_responseCode_rejected
//

H245_MultilinkResponse_addConnection_responseCode_rejected::H245_MultilinkResponse_addConnection_responseCode_rejected(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "connectionsNotAvailable "
        "userRejected "
#endif
    )
{
}


BOOL H245_MultilinkResponse_addConnection_responseCode_rejected::CreateObject()
{
  switch (tag) {
    case e_connectionsNotAvailable :
    case e_userRejected :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_MultilinkResponse_addConnection_responseCode_rejected::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkResponse_addConnection_responseCode_rejected::Class()), PInvalidCast);
#endif
  return new H245_MultilinkResponse_addConnection_responseCode_rejected(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultilinkResponse_addConnection_responseCode_rejected::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_connectionsNotAvailable :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_userRejected :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_MultilinkResponse_addConnection_responseCode_rejected::getSummary( void ) 
{
  return PString( "MultilinkResponse_addConnection_responseCode_rejected" );
}

void H245_MultilinkResponse_addConnection_responseCode_rejected::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "connectionsNotAvailable" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MultilinkResponse_addConnection_responseCode_rejected_connectionsNotAvailable, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "userRejected" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MultilinkResponse_addConnection_responseCode_rejected_userRejected, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// MiscellaneousCommand_type_progressiveRefinementStart_repeatCount
//

H245_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount::H245_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "doOneProgression "
        "doContinuousProgressions "
        "doOneIndependentProgression "
        "doContinuousIndependentProgressions "
#endif
    )
{
}


BOOL H245_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount::CreateObject()
{
  switch (tag) {
    case e_doOneProgression :
    case e_doContinuousProgressions :
    case e_doOneIndependentProgression :
    case e_doContinuousIndependentProgressions :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount::Class()), PInvalidCast);
#endif
  return new H245_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_doOneProgression :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_doContinuousProgressions :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_doOneIndependentProgression :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_doContinuousIndependentProgressions :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount::getSummary( void ) 
{
  return PString( "MiscellaneousCommand_type_progressiveRefinementStart_repeatCount" );
}

void H245_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "doOneProgression" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount_doOneProgression, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "doContinuousProgressions" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount_doContinuousProgressions, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "doOneIndependentProgression" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount_doOneIndependentProgression, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "doContinuousIndependentProgressions" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount_doContinuousIndependentProgressions, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// NewATMVCCommand_aal_aal1_clockRecovery
//

H245_NewATMVCCommand_aal_aal1_clockRecovery::H245_NewATMVCCommand_aal_aal1_clockRecovery(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "nullClockRecovery "
        "srtsClockRecovery "
        "adaptiveClockRecovery "
#endif
    )
{
}


BOOL H245_NewATMVCCommand_aal_aal1_clockRecovery::CreateObject()
{
  switch (tag) {
    case e_nullClockRecovery :
    case e_srtsClockRecovery :
    case e_adaptiveClockRecovery :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_NewATMVCCommand_aal_aal1_clockRecovery::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCCommand_aal_aal1_clockRecovery::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCCommand_aal_aal1_clockRecovery(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NewATMVCCommand_aal_aal1_clockRecovery::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nullClockRecovery :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_srtsClockRecovery :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_adaptiveClockRecovery :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_NewATMVCCommand_aal_aal1_clockRecovery::getSummary( void ) 
{
  return PString( "NewATMVCCommand_aal_aal1_clockRecovery" );
}

void H245_NewATMVCCommand_aal_aal1_clockRecovery::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "nullClockRecovery" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCCommand_aal_aal1_clockRecovery_nullClockRecovery, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "srtsClockRecovery" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCCommand_aal_aal1_clockRecovery_srtsClockRecovery, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "adaptiveClockRecovery" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCCommand_aal_aal1_clockRecovery_adaptiveClockRecovery, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// NewATMVCCommand_aal_aal1_errorCorrection
//

H245_NewATMVCCommand_aal_aal1_errorCorrection::H245_NewATMVCCommand_aal_aal1_errorCorrection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "nullErrorCorrection "
        "longInterleaver "
        "shortInterleaver "
        "errorCorrectionOnly "
#endif
    )
{
}


BOOL H245_NewATMVCCommand_aal_aal1_errorCorrection::CreateObject()
{
  switch (tag) {
    case e_nullErrorCorrection :
    case e_longInterleaver :
    case e_shortInterleaver :
    case e_errorCorrectionOnly :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_NewATMVCCommand_aal_aal1_errorCorrection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCCommand_aal_aal1_errorCorrection::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCCommand_aal_aal1_errorCorrection(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NewATMVCCommand_aal_aal1_errorCorrection::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nullErrorCorrection :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_longInterleaver :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_shortInterleaver :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_errorCorrectionOnly :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_NewATMVCCommand_aal_aal1_errorCorrection::getSummary( void ) 
{
  return PString( "NewATMVCCommand_aal_aal1_errorCorrection" );
}

void H245_NewATMVCCommand_aal_aal1_errorCorrection::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "nullErrorCorrection" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCCommand_aal_aal1_errorCorrection_nullErrorCorrection, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "longInterleaver" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCCommand_aal_aal1_errorCorrection_longInterleaver, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "shortInterleaver" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCCommand_aal_aal1_errorCorrection_shortInterleaver, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "errorCorrectionOnly" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCCommand_aal_aal1_errorCorrection_errorCorrectionOnly, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// NewATMVCIndication_aal_aal1_clockRecovery
//

H245_NewATMVCIndication_aal_aal1_clockRecovery::H245_NewATMVCIndication_aal_aal1_clockRecovery(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "nullClockRecovery "
        "srtsClockRecovery "
        "adaptiveClockRecovery "
#endif
    )
{
}


BOOL H245_NewATMVCIndication_aal_aal1_clockRecovery::CreateObject()
{
  switch (tag) {
    case e_nullClockRecovery :
    case e_srtsClockRecovery :
    case e_adaptiveClockRecovery :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_NewATMVCIndication_aal_aal1_clockRecovery::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCIndication_aal_aal1_clockRecovery::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCIndication_aal_aal1_clockRecovery(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NewATMVCIndication_aal_aal1_clockRecovery::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nullClockRecovery :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_srtsClockRecovery :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_adaptiveClockRecovery :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_NewATMVCIndication_aal_aal1_clockRecovery::getSummary( void ) 
{
  return PString( "NewATMVCIndication_aal_aal1_clockRecovery" );
}

void H245_NewATMVCIndication_aal_aal1_clockRecovery::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "nullClockRecovery" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCIndication_aal_aal1_clockRecovery_nullClockRecovery, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "srtsClockRecovery" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCIndication_aal_aal1_clockRecovery_srtsClockRecovery, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "adaptiveClockRecovery" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCIndication_aal_aal1_clockRecovery_adaptiveClockRecovery, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// NewATMVCIndication_aal_aal1_errorCorrection
//

H245_NewATMVCIndication_aal_aal1_errorCorrection::H245_NewATMVCIndication_aal_aal1_errorCorrection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "nullErrorCorrection "
        "longInterleaver "
        "shortInterleaver "
        "errorCorrectionOnly "
#endif
    )
{
}


BOOL H245_NewATMVCIndication_aal_aal1_errorCorrection::CreateObject()
{
  switch (tag) {
    case e_nullErrorCorrection :
    case e_longInterleaver :
    case e_shortInterleaver :
    case e_errorCorrectionOnly :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H245_NewATMVCIndication_aal_aal1_errorCorrection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCIndication_aal_aal1_errorCorrection::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCIndication_aal_aal1_errorCorrection(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NewATMVCIndication_aal_aal1_errorCorrection::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nullErrorCorrection :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_longInterleaver :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_shortInterleaver :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_errorCorrectionOnly :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H245_NewATMVCIndication_aal_aal1_errorCorrection::getSummary( void ) 
{
  return PString( "NewATMVCIndication_aal_aal1_errorCorrection" );
}

void H245_NewATMVCIndication_aal_aal1_errorCorrection::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "nullErrorCorrection" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCIndication_aal_aal1_errorCorrection_nullErrorCorrection, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "longInterleaver" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCIndication_aal_aal1_errorCorrection_longInterleaver, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "shortInterleaver" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCIndication_aal_aal1_errorCorrection_shortInterleaver, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "errorCorrectionOnly" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h245_1.hf_h245_NewATMVCIndication_aal_aal1_errorCorrection_errorCorrectionOnly, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// NonStandardParameter
//

H245_NonStandardParameter::H245_NonStandardParameter(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_NonStandardParameter::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "nonStandardIdentifier = " << setprecision(indent) << m_nonStandardIdentifier << '\n';
  strm << setw(indent+7) << "data = " << setprecision(indent) << m_data << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_NonStandardParameter::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  const H245_NonStandardParameter & other = (const H245_NonStandardParameter &)obj;

  Comparison result;

  if ((result = m_nonStandardIdentifier.Compare(other.m_nonStandardIdentifier)) != EqualTo)
    return result;
  if ((result = m_data.Compare(other.m_data)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NonStandardParameter::GetDataLength() const
{
  return m_nonStandardIdentifier.GetObjectLength() +
         m_data.GetObjectLength();
}


BOOL H245_NonStandardParameter::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_nonStandardIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_data.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_NonStandardParameter::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nonStandardIdentifier.Encode(strm);
  m_data.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_nonStandardIdentifier.Encode(strm);
  m_data.Encode(strm);
}


PObject * H245_NonStandardParameter::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NonStandardParameter::Class()), PInvalidCast);
#endif
  return new H245_NonStandardParameter(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NonStandardParameter::preShowEthereal( void )
{
  m_nonStandardIdentifier.preShowEthereal( );
  m_data.preShowEthereal( );
}

PString H245_NonStandardParameter::getSummary( void ) 
{
  return PString( "NonStandardParameter" );
}

void H245_NonStandardParameter::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *nonStandardIdentifier_tree = (proto_tree*) NULL;
  proto_item *nonStandardIdentifier_ti = (proto_item*) NULL;
  nonStandardIdentifier_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardIdentifier.GetStartByte(), m_nonStandardIdentifier.GetByteLength(), "nonStandardIdentifier (%s)", ( const char* ) m_nonStandardIdentifier.GetTagName() );
  nonStandardIdentifier_tree = proto_item_add_subtree( nonStandardIdentifier_ti, hCont->h245_1.ett_h245_NonStandardParameter_nonStandardIdentifier );

  m_nonStandardIdentifier.showEthereal( nonStandardIdentifier_tree, tvb, offset );

  char* pdata = m_data.getValue();
  proto_tree_add_string( tree, hCont->h245_1.hf_h245_NonStandardParameter_data, tvb, offset + m_data.GetStartByte(), m_data.GetByteLength() , pdata );
  delete[] pdata;

}
#endif  //USE_FOR_ETHEREAL

//
// MasterSlaveDeterminationAck
//

H245_MasterSlaveDeterminationAck::H245_MasterSlaveDeterminationAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MasterSlaveDeterminationAck::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "decision = " << setprecision(indent) << m_decision << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MasterSlaveDeterminationAck::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MasterSlaveDeterminationAck::Class()), PInvalidCast);
#endif
  const H245_MasterSlaveDeterminationAck & other = (const H245_MasterSlaveDeterminationAck &)obj;

  Comparison result;

  if ((result = m_decision.Compare(other.m_decision)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MasterSlaveDeterminationAck::GetDataLength() const
{
  return m_decision.GetObjectLength();
}


BOOL H245_MasterSlaveDeterminationAck::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_decision.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MasterSlaveDeterminationAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_decision.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_decision.Encode(strm);
}


PObject * H245_MasterSlaveDeterminationAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MasterSlaveDeterminationAck::Class()), PInvalidCast);
#endif
  return new H245_MasterSlaveDeterminationAck(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MasterSlaveDeterminationAck::preShowEthereal( void )
{
  m_decision.preShowEthereal( );
}

PString H245_MasterSlaveDeterminationAck::getSummary( void ) 
{
  return PString( "MasterSlaveDeterminationAck" );
}

void H245_MasterSlaveDeterminationAck::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *decision_tree = (proto_tree*) NULL;
  proto_item *decision_ti = (proto_item*) NULL;
  decision_ti = proto_tree_add_text( tree, tvb, offset + m_decision.GetStartByte(), m_decision.GetByteLength(), "decision (%s)", ( const char* ) m_decision.GetTagName() );
  decision_tree = proto_item_add_subtree( decision_ti, hCont->h245_1.ett_h245_MasterSlaveDeterminationAck_decision );

  m_decision.showEthereal( decision_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// MasterSlaveDeterminationReject
//

H245_MasterSlaveDeterminationReject::H245_MasterSlaveDeterminationReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MasterSlaveDeterminationReject::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+8) << "cause = " << setprecision(indent) << m_cause << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MasterSlaveDeterminationReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MasterSlaveDeterminationReject::Class()), PInvalidCast);
#endif
  const H245_MasterSlaveDeterminationReject & other = (const H245_MasterSlaveDeterminationReject &)obj;

  Comparison result;

  if ((result = m_cause.Compare(other.m_cause)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MasterSlaveDeterminationReject::GetDataLength() const
{
  return m_cause.GetObjectLength();
}


BOOL H245_MasterSlaveDeterminationReject::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_cause.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MasterSlaveDeterminationReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_cause.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_cause.Encode(strm);
}


PObject * H245_MasterSlaveDeterminationReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MasterSlaveDeterminationReject::Class()), PInvalidCast);
#endif
  return new H245_MasterSlaveDeterminationReject(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MasterSlaveDeterminationReject::preShowEthereal( void )
{
  m_cause.preShowEthereal( );
}

PString H245_MasterSlaveDeterminationReject::getSummary( void ) 
{
  return PString( "MasterSlaveDeterminationReject" );
}

void H245_MasterSlaveDeterminationReject::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *cause_tree = (proto_tree*) NULL;
  proto_item *cause_ti = (proto_item*) NULL;
  cause_ti = proto_tree_add_text( tree, tvb, offset + m_cause.GetStartByte(), m_cause.GetByteLength(), "cause (%s)", ( const char* ) m_cause.GetTagName() );
  cause_tree = proto_item_add_subtree( cause_ti, hCont->h245_1.ett_h245_MasterSlaveDeterminationReject_cause );

  m_cause.showEthereal( cause_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// TerminalCapabilitySet
//

H245_TerminalCapabilitySet::H245_TerminalCapabilitySet(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
  m_capabilityTable.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
  m_capabilityDescriptors.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_TerminalCapabilitySet::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_multiplexCapability))
    strm << setw(indent+22) << "multiplexCapability = " << setprecision(indent) << m_multiplexCapability << '\n';
  if (HasOptionalField(e_capabilityTable))
    strm << setw(indent+18) << "capabilityTable = " << setprecision(indent) << m_capabilityTable << '\n';
  if (HasOptionalField(e_capabilityDescriptors))
    strm << setw(indent+24) << "capabilityDescriptors = " << setprecision(indent) << m_capabilityDescriptors << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_TerminalCapabilitySet::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_TerminalCapabilitySet::Class()), PInvalidCast);
#endif
  const H245_TerminalCapabilitySet & other = (const H245_TerminalCapabilitySet &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_multiplexCapability.Compare(other.m_multiplexCapability)) != EqualTo)
    return result;
  if ((result = m_capabilityTable.Compare(other.m_capabilityTable)) != EqualTo)
    return result;
  if ((result = m_capabilityDescriptors.Compare(other.m_capabilityDescriptors)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_TerminalCapabilitySet::GetDataLength() const
{
  return m_sequenceNumber.GetObjectLength() +
         m_protocolIdentifier.GetObjectLength() +
         m_multiplexCapability.GetObjectLength() +
         m_capabilityTable.GetObjectLength() +
         m_capabilityDescriptors.GetObjectLength();
}


BOOL H245_TerminalCapabilitySet::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sequenceNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_protocolIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_multiplexCapability ) && !m_multiplexCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_capabilityTable ) && !m_capabilityTable.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_capabilityDescriptors ) && !m_capabilityDescriptors.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_TerminalCapabilitySet::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_multiplexCapability))
    m_multiplexCapability.Encode(strm);
  if (HasOptionalField(e_capabilityTable))
    m_capabilityTable.Encode(strm);
  if (HasOptionalField(e_capabilityDescriptors))
    m_capabilityDescriptors.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_sequenceNumber.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_multiplexCapability))
    m_multiplexCapability.Encode(strm);
  if (HasOptionalField(e_capabilityTable))
    m_capabilityTable.Encode(strm);
  if (HasOptionalField(e_capabilityDescriptors))
    m_capabilityDescriptors.Encode(strm);
}


PObject * H245_TerminalCapabilitySet::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TerminalCapabilitySet::Class()), PInvalidCast);
#endif
  return new H245_TerminalCapabilitySet(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_TerminalCapabilitySet::preShowEthereal( void )
{
  m_sequenceNumber.preShowEthereal( );
  m_protocolIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_multiplexCapability ) ) 
      m_multiplexCapability.preShowEthereal( );
  if ( HasOptionalField( e_capabilityTable ) ) 
      m_capabilityTable.preShowEthereal( );
  if ( HasOptionalField( e_capabilityDescriptors ) ) 
      m_capabilityDescriptors.preShowEthereal( );
}

PString H245_TerminalCapabilitySet::getSummary( void ) 
{
  return PString( "TerminalCapabilitySet" );
}

void H245_TerminalCapabilitySet::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_TerminalCapabilitySet_sequenceNumber, tvb, offset + m_sequenceNumber.GetStartByte(), m_sequenceNumber.GetByteLength() , m_sequenceNumber.GetValue() );

  char* pprotocolIdentifier = m_protocolIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h245_1.hf_h245_TerminalCapabilitySet_protocolIdentifier, tvb, offset + m_protocolIdentifier.GetStartByte(), m_protocolIdentifier.GetByteLength() , pprotocolIdentifier );
  delete[] pprotocolIdentifier;

  if ( HasOptionalField( e_multiplexCapability ) ) {
    proto_tree *multiplexCapability_tree = (proto_tree*) NULL;
    proto_item *multiplexCapability_ti = (proto_item*) NULL;
    multiplexCapability_ti = proto_tree_add_text( tree, tvb, offset + m_multiplexCapability.GetStartByte(), m_multiplexCapability.GetByteLength(), "multiplexCapability (%s)", ( const char* ) m_multiplexCapability.GetTagName() );
    multiplexCapability_tree = proto_item_add_subtree( multiplexCapability_ti, hCont->h245_1.ett_h245_TerminalCapabilitySet_multiplexCapability );
    m_multiplexCapability.showEthereal( multiplexCapability_tree, tvb, offset );
  }

  if ( HasOptionalField( e_capabilityTable ) ) {
    proto_tree *capabilityTable_tree = (proto_tree*) NULL;
    proto_item *capabilityTable_ti = (proto_item*) NULL;
    capabilityTable_ti = proto_tree_add_text( tree, tvb, offset + m_capabilityTable.GetStartByte(), m_capabilityTable.GetByteLength(), "capabilityTable (CapabilityTableEntry)" );
    capabilityTable_tree = proto_item_add_subtree( capabilityTable_ti, hCont->h245_1.ett_h245_TerminalCapabilitySet_capabilityTable );
    m_capabilityTable.showEthereal( capabilityTable_tree, tvb, offset );
  }

  if ( HasOptionalField( e_capabilityDescriptors ) ) {
    proto_tree *capabilityDescriptors_tree = (proto_tree*) NULL;
    proto_item *capabilityDescriptors_ti = (proto_item*) NULL;
    capabilityDescriptors_ti = proto_tree_add_text( tree, tvb, offset + m_capabilityDescriptors.GetStartByte(), m_capabilityDescriptors.GetByteLength(), "capabilityDescriptors (CapabilityDescriptor)" );
    capabilityDescriptors_tree = proto_item_add_subtree( capabilityDescriptors_ti, hCont->h245_1.ett_h245_TerminalCapabilitySet_capabilityDescriptors );
    m_capabilityDescriptors.showEthereal( capabilityDescriptors_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CapabilityTableEntry
//

H245_CapabilityTableEntry::H245_CapabilityTableEntry(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_CapabilityTableEntry::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+29) << "capabilityTableEntryNumber = " << setprecision(indent) << m_capabilityTableEntryNumber << '\n';
  if (HasOptionalField(e_capability))
    strm << setw(indent+13) << "capability = " << setprecision(indent) << m_capability << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_CapabilityTableEntry::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_CapabilityTableEntry::Class()), PInvalidCast);
#endif
  const H245_CapabilityTableEntry & other = (const H245_CapabilityTableEntry &)obj;

  Comparison result;

  if ((result = m_capabilityTableEntryNumber.Compare(other.m_capabilityTableEntryNumber)) != EqualTo)
    return result;
  if ((result = m_capability.Compare(other.m_capability)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_CapabilityTableEntry::GetDataLength() const
{
  return m_capabilityTableEntryNumber.GetObjectLength() +
         m_capability.GetObjectLength();
}


BOOL H245_CapabilityTableEntry::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_capabilityTableEntryNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_capability ) && !m_capability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_CapabilityTableEntry::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_capabilityTableEntryNumber.Encode(strm);
  if (HasOptionalField(e_capability))
    m_capability.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_capabilityTableEntryNumber.Encode(strm);
  if (HasOptionalField(e_capability))
    m_capability.Encode(strm);
}


PObject * H245_CapabilityTableEntry::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CapabilityTableEntry::Class()), PInvalidCast);
#endif
  return new H245_CapabilityTableEntry(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CapabilityTableEntry::preShowEthereal( void )
{
  m_capabilityTableEntryNumber.preShowEthereal( );
  if ( HasOptionalField( e_capability ) ) 
      m_capability.preShowEthereal( );
}

PString H245_CapabilityTableEntry::getSummary( void ) 
{
  return PString( "CapabilityTableEntry" );
}

void H245_CapabilityTableEntry::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_CapabilityTableEntry_capabilityTableEntryNumber, tvb, offset + m_capabilityTableEntryNumber.GetStartByte(), m_capabilityTableEntryNumber.GetByteLength() , m_capabilityTableEntryNumber.GetValue() );

  if ( HasOptionalField( e_capability ) ) {
    proto_tree *capability_tree = (proto_tree*) NULL;
    proto_item *capability_ti = (proto_item*) NULL;
    capability_ti = proto_tree_add_text( tree, tvb, offset + m_capability.GetStartByte(), m_capability.GetByteLength(), "capability (%s)", ( const char* ) m_capability.GetTagName() );
    capability_tree = proto_item_add_subtree( capability_ti, hCont->h245_1.ett_h245_CapabilityTableEntry_capability );
    m_capability.showEthereal( capability_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CapabilityDescriptor
//

H245_CapabilityDescriptor::H245_CapabilityDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, FALSE, 0)
{
  m_simultaneousCapabilities.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_CapabilityDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+29) << "capabilityDescriptorNumber = " << setprecision(indent) << m_capabilityDescriptorNumber << '\n';
  if (HasOptionalField(e_simultaneousCapabilities))
    strm << setw(indent+27) << "simultaneousCapabilities = " << setprecision(indent) << m_simultaneousCapabilities << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_CapabilityDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_CapabilityDescriptor::Class()), PInvalidCast);
#endif
  const H245_CapabilityDescriptor & other = (const H245_CapabilityDescriptor &)obj;

  Comparison result;

  if ((result = m_capabilityDescriptorNumber.Compare(other.m_capabilityDescriptorNumber)) != EqualTo)
    return result;
  if ((result = m_simultaneousCapabilities.Compare(other.m_simultaneousCapabilities)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_CapabilityDescriptor::GetDataLength() const
{
  return m_capabilityDescriptorNumber.GetObjectLength() +
         m_simultaneousCapabilities.GetObjectLength();
}


BOOL H245_CapabilityDescriptor::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_capabilityDescriptorNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_simultaneousCapabilities ) && !m_simultaneousCapabilities.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_CapabilityDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_capabilityDescriptorNumber.Encode(strm);
  if (HasOptionalField(e_simultaneousCapabilities))
    m_simultaneousCapabilities.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_capabilityDescriptorNumber.Encode(strm);
  if (HasOptionalField(e_simultaneousCapabilities))
    m_simultaneousCapabilities.Encode(strm);
}


PObject * H245_CapabilityDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CapabilityDescriptor::Class()), PInvalidCast);
#endif
  return new H245_CapabilityDescriptor(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CapabilityDescriptor::preShowEthereal( void )
{
  m_capabilityDescriptorNumber.preShowEthereal( );
  if ( HasOptionalField( e_simultaneousCapabilities ) ) 
      m_simultaneousCapabilities.preShowEthereal( );
}

PString H245_CapabilityDescriptor::getSummary( void ) 
{
  return PString( "CapabilityDescriptor" );
}

void H245_CapabilityDescriptor::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_CapabilityDescriptor_capabilityDescriptorNumber, tvb, offset + m_capabilityDescriptorNumber.GetStartByte(), m_capabilityDescriptorNumber.GetByteLength() , m_capabilityDescriptorNumber.GetValue() );

  if ( HasOptionalField( e_simultaneousCapabilities ) ) {
    proto_tree *simultaneousCapabilities_tree = (proto_tree*) NULL;
    proto_item *simultaneousCapabilities_ti = (proto_item*) NULL;
    simultaneousCapabilities_ti = proto_tree_add_text( tree, tvb, offset + m_simultaneousCapabilities.GetStartByte(), m_simultaneousCapabilities.GetByteLength(), "simultaneousCapabilities (AlternativeCapabilitySet)" );
    simultaneousCapabilities_tree = proto_item_add_subtree( simultaneousCapabilities_ti, hCont->h245_1.ett_h245_CapabilityDescriptor_simultaneousCapabilities );
    m_simultaneousCapabilities.showEthereal( simultaneousCapabilities_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// TerminalCapabilitySetReject
//

H245_TerminalCapabilitySetReject::H245_TerminalCapabilitySetReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_TerminalCapabilitySetReject::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+8) << "cause = " << setprecision(indent) << m_cause << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_TerminalCapabilitySetReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_TerminalCapabilitySetReject::Class()), PInvalidCast);
#endif
  const H245_TerminalCapabilitySetReject & other = (const H245_TerminalCapabilitySetReject &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_cause.Compare(other.m_cause)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_TerminalCapabilitySetReject::GetDataLength() const
{
  return m_sequenceNumber.GetObjectLength() +
         m_cause.GetObjectLength();
}


BOOL H245_TerminalCapabilitySetReject::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sequenceNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_cause.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_TerminalCapabilitySetReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_cause.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_sequenceNumber.Encode(strm);
  m_cause.Encode(strm);
}


PObject * H245_TerminalCapabilitySetReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TerminalCapabilitySetReject::Class()), PInvalidCast);
#endif
  return new H245_TerminalCapabilitySetReject(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_TerminalCapabilitySetReject::preShowEthereal( void )
{
  m_sequenceNumber.preShowEthereal( );
  m_cause.preShowEthereal( );
}

PString H245_TerminalCapabilitySetReject::getSummary( void ) 
{
  return PString( "TerminalCapabilitySetReject" );
}

void H245_TerminalCapabilitySetReject::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_TerminalCapabilitySetReject_sequenceNumber, tvb, offset + m_sequenceNumber.GetStartByte(), m_sequenceNumber.GetByteLength() , m_sequenceNumber.GetValue() );

  proto_tree *cause_tree = (proto_tree*) NULL;
  proto_item *cause_ti = (proto_item*) NULL;
  cause_ti = proto_tree_add_text( tree, tvb, offset + m_cause.GetStartByte(), m_cause.GetByteLength(), "cause (%s)", ( const char* ) m_cause.GetTagName() );
  cause_tree = proto_item_add_subtree( cause_ti, hCont->h245_1.ett_h245_TerminalCapabilitySetReject_cause );

  m_cause.showEthereal( cause_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// H222Capability
//

H245_H222Capability::H245_H222Capability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_numberOfVCs.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_H222Capability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "numberOfVCs = " << setprecision(indent) << m_numberOfVCs << '\n';
  strm << setw(indent+15) << "vcCapability = " << setprecision(indent) << m_vcCapability << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H222Capability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H222Capability::Class()), PInvalidCast);
#endif
  const H245_H222Capability & other = (const H245_H222Capability &)obj;

  Comparison result;

  if ((result = m_numberOfVCs.Compare(other.m_numberOfVCs)) != EqualTo)
    return result;
  if ((result = m_vcCapability.Compare(other.m_vcCapability)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H222Capability::GetDataLength() const
{
  return m_numberOfVCs.GetObjectLength() +
         m_vcCapability.GetObjectLength();
}


BOOL H245_H222Capability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_numberOfVCs.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_vcCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H222Capability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_numberOfVCs.Encode(strm);
  m_vcCapability.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_numberOfVCs.Encode(strm);
  m_vcCapability.Encode(strm);
}


PObject * H245_H222Capability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H222Capability::Class()), PInvalidCast);
#endif
  return new H245_H222Capability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H222Capability::preShowEthereal( void )
{
  m_numberOfVCs.preShowEthereal( );
  m_vcCapability.preShowEthereal( );
}

PString H245_H222Capability::getSummary( void ) 
{
  return PString( "H222Capability" );
}

void H245_H222Capability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_H222Capability_numberOfVCs, tvb, offset + m_numberOfVCs.GetStartByte(), m_numberOfVCs.GetByteLength() , m_numberOfVCs.GetValue() );

  proto_tree *vcCapability_tree = (proto_tree*) NULL;
  proto_item *vcCapability_ti = (proto_item*) NULL;
  vcCapability_ti = proto_tree_add_text( tree, tvb, offset + m_vcCapability.GetStartByte(), m_vcCapability.GetByteLength(), "vcCapability (VCCapability)" );
  vcCapability_tree = proto_item_add_subtree( vcCapability_ti, hCont->h245_1.ett_h245_H222Capability_vcCapability );

  m_vcCapability.showEthereal( vcCapability_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// H223Capability
//

H245_H223Capability::H245_H223Capability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 4)
{
  m_maximumAl2SDUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_maximumAl3SDUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_maximumDelayJitter.SetConstraints(PASN_Object::FixedConstraint, 0, 1023);
  IncludeOptionalField(e_maxMUXPDUSizeCapability);
  IncludeOptionalField(e_nsrpSupport);
}


#ifndef PASN_NOPRINTON
void H245_H223Capability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "transportWithI_frames = " << setprecision(indent) << m_transportWithI_frames << '\n';
  strm << setw(indent+15) << "videoWithAL1 = " << setprecision(indent) << m_videoWithAL1 << '\n';
  strm << setw(indent+15) << "videoWithAL2 = " << setprecision(indent) << m_videoWithAL2 << '\n';
  strm << setw(indent+15) << "videoWithAL3 = " << setprecision(indent) << m_videoWithAL3 << '\n';
  strm << setw(indent+15) << "audioWithAL1 = " << setprecision(indent) << m_audioWithAL1 << '\n';
  strm << setw(indent+15) << "audioWithAL2 = " << setprecision(indent) << m_audioWithAL2 << '\n';
  strm << setw(indent+15) << "audioWithAL3 = " << setprecision(indent) << m_audioWithAL3 << '\n';
  strm << setw(indent+14) << "dataWithAL1 = " << setprecision(indent) << m_dataWithAL1 << '\n';
  strm << setw(indent+14) << "dataWithAL2 = " << setprecision(indent) << m_dataWithAL2 << '\n';
  strm << setw(indent+14) << "dataWithAL3 = " << setprecision(indent) << m_dataWithAL3 << '\n';
  strm << setw(indent+20) << "maximumAl2SDUSize = " << setprecision(indent) << m_maximumAl2SDUSize << '\n';
  strm << setw(indent+20) << "maximumAl3SDUSize = " << setprecision(indent) << m_maximumAl3SDUSize << '\n';
  strm << setw(indent+21) << "maximumDelayJitter = " << setprecision(indent) << m_maximumDelayJitter << '\n';
  strm << setw(indent+31) << "h223MultiplexTableCapability = " << setprecision(indent) << m_h223MultiplexTableCapability << '\n';
  if (HasOptionalField(e_maxMUXPDUSizeCapability))
    strm << setw(indent+26) << "maxMUXPDUSizeCapability = " << setprecision(indent) << m_maxMUXPDUSizeCapability << '\n';
  if (HasOptionalField(e_nsrpSupport))
    strm << setw(indent+14) << "nsrpSupport = " << setprecision(indent) << m_nsrpSupport << '\n';
  if (HasOptionalField(e_mobileOperationTransmitCapability))
    strm << setw(indent+36) << "mobileOperationTransmitCapability = " << setprecision(indent) << m_mobileOperationTransmitCapability << '\n';
  if (HasOptionalField(e_h223AnnexCCapability))
    strm << setw(indent+23) << "h223AnnexCCapability = " << setprecision(indent) << m_h223AnnexCCapability << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H223Capability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H223Capability::Class()), PInvalidCast);
#endif
  const H245_H223Capability & other = (const H245_H223Capability &)obj;

  Comparison result;

  if ((result = m_transportWithI_frames.Compare(other.m_transportWithI_frames)) != EqualTo)
    return result;
  if ((result = m_videoWithAL1.Compare(other.m_videoWithAL1)) != EqualTo)
    return result;
  if ((result = m_videoWithAL2.Compare(other.m_videoWithAL2)) != EqualTo)
    return result;
  if ((result = m_videoWithAL3.Compare(other.m_videoWithAL3)) != EqualTo)
    return result;
  if ((result = m_audioWithAL1.Compare(other.m_audioWithAL1)) != EqualTo)
    return result;
  if ((result = m_audioWithAL2.Compare(other.m_audioWithAL2)) != EqualTo)
    return result;
  if ((result = m_audioWithAL3.Compare(other.m_audioWithAL3)) != EqualTo)
    return result;
  if ((result = m_dataWithAL1.Compare(other.m_dataWithAL1)) != EqualTo)
    return result;
  if ((result = m_dataWithAL2.Compare(other.m_dataWithAL2)) != EqualTo)
    return result;
  if ((result = m_dataWithAL3.Compare(other.m_dataWithAL3)) != EqualTo)
    return result;
  if ((result = m_maximumAl2SDUSize.Compare(other.m_maximumAl2SDUSize)) != EqualTo)
    return result;
  if ((result = m_maximumAl3SDUSize.Compare(other.m_maximumAl3SDUSize)) != EqualTo)
    return result;
  if ((result = m_maximumDelayJitter.Compare(other.m_maximumDelayJitter)) != EqualTo)
    return result;
  if ((result = m_h223MultiplexTableCapability.Compare(other.m_h223MultiplexTableCapability)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223Capability::GetDataLength() const
{
  return m_transportWithI_frames.GetObjectLength() +
         m_videoWithAL1.GetObjectLength() +
         m_videoWithAL2.GetObjectLength() +
         m_videoWithAL3.GetObjectLength() +
         m_audioWithAL1.GetObjectLength() +
         m_audioWithAL2.GetObjectLength() +
         m_audioWithAL3.GetObjectLength() +
         m_dataWithAL1.GetObjectLength() +
         m_dataWithAL2.GetObjectLength() +
         m_dataWithAL3.GetObjectLength() +
         m_maximumAl2SDUSize.GetObjectLength() +
         m_maximumAl3SDUSize.GetObjectLength() +
         m_maximumDelayJitter.GetObjectLength() +
         m_h223MultiplexTableCapability.GetObjectLength();
}


BOOL H245_H223Capability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_transportWithI_frames.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_videoWithAL1.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_videoWithAL2.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_videoWithAL3.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioWithAL1.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioWithAL2.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioWithAL3.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_dataWithAL1.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_dataWithAL2.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_dataWithAL3.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maximumAl2SDUSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maximumAl3SDUSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maximumDelayJitter.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_h223MultiplexTableCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_maxMUXPDUSizeCapability, m_maxMUXPDUSizeCapability ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_nsrpSupport, m_nsrpSupport ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_mobileOperationTransmitCapability, m_mobileOperationTransmitCapability ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_h223AnnexCCapability, m_h223AnnexCCapability ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H223Capability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_transportWithI_frames.Encode(strm);
  m_videoWithAL1.Encode(strm);
  m_videoWithAL2.Encode(strm);
  m_videoWithAL3.Encode(strm);
  m_audioWithAL1.Encode(strm);
  m_audioWithAL2.Encode(strm);
  m_audioWithAL3.Encode(strm);
  m_dataWithAL1.Encode(strm);
  m_dataWithAL2.Encode(strm);
  m_dataWithAL3.Encode(strm);
  m_maximumAl2SDUSize.Encode(strm);
  m_maximumAl3SDUSize.Encode(strm);
  m_maximumDelayJitter.Encode(strm);
  m_h223MultiplexTableCapability.Encode(strm);
  KnownExtensionEncode(strm, e_maxMUXPDUSizeCapability, m_maxMUXPDUSizeCapability);
  KnownExtensionEncode(strm, e_nsrpSupport, m_nsrpSupport);
  KnownExtensionEncode(strm, e_mobileOperationTransmitCapability, m_mobileOperationTransmitCapability);
  KnownExtensionEncode(strm, e_h223AnnexCCapability, m_h223AnnexCCapability);

  UnknownExtensionsEncode(strm);
  m_transportWithI_frames.Encode(strm);
  m_videoWithAL1.Encode(strm);
  m_videoWithAL2.Encode(strm);
  m_videoWithAL3.Encode(strm);
  m_audioWithAL1.Encode(strm);
  m_audioWithAL2.Encode(strm);
  m_audioWithAL3.Encode(strm);
  m_dataWithAL1.Encode(strm);
  m_dataWithAL2.Encode(strm);
  m_dataWithAL3.Encode(strm);
  m_maximumAl2SDUSize.Encode(strm);
  m_maximumAl3SDUSize.Encode(strm);
  m_maximumDelayJitter.Encode(strm);
  m_h223MultiplexTableCapability.Encode(strm);
}


PObject * H245_H223Capability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223Capability::Class()), PInvalidCast);
#endif
  return new H245_H223Capability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223Capability::preShowEthereal( void )
{
  m_transportWithI_frames.preShowEthereal( );
  m_videoWithAL1.preShowEthereal( );
  m_videoWithAL2.preShowEthereal( );
  m_videoWithAL3.preShowEthereal( );
  m_audioWithAL1.preShowEthereal( );
  m_audioWithAL2.preShowEthereal( );
  m_audioWithAL3.preShowEthereal( );
  m_dataWithAL1.preShowEthereal( );
  m_dataWithAL2.preShowEthereal( );
  m_dataWithAL3.preShowEthereal( );
  m_maximumAl2SDUSize.preShowEthereal( );
  m_maximumAl3SDUSize.preShowEthereal( );
  m_maximumDelayJitter.preShowEthereal( );
  m_h223MultiplexTableCapability.preShowEthereal( );
  if ( HasOptionalField( e_maxMUXPDUSizeCapability ) ) 
      m_maxMUXPDUSizeCapability.preShowEthereal( );
  if ( HasOptionalField( e_nsrpSupport ) ) 
      m_nsrpSupport.preShowEthereal( );
  if ( HasOptionalField( e_mobileOperationTransmitCapability ) ) 
      m_mobileOperationTransmitCapability.preShowEthereal( );
  if ( HasOptionalField( e_h223AnnexCCapability ) ) 
      m_h223AnnexCCapability.preShowEthereal( );
}

PString H245_H223Capability::getSummary( void ) 
{
  return PString( "H223Capability" );
}

void H245_H223Capability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h245_1.hf_h245_H223Capability_transportWithI_frames, tvb, offset + m_transportWithI_frames.GetStartByte(), m_transportWithI_frames.GetByteLength() , m_transportWithI_frames.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_1.hf_h245_H223Capability_videoWithAL1, tvb, offset + m_videoWithAL1.GetStartByte(), m_videoWithAL1.GetByteLength() , m_videoWithAL1.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_1.hf_h245_H223Capability_videoWithAL2, tvb, offset + m_videoWithAL2.GetStartByte(), m_videoWithAL2.GetByteLength() , m_videoWithAL2.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_1.hf_h245_H223Capability_videoWithAL3, tvb, offset + m_videoWithAL3.GetStartByte(), m_videoWithAL3.GetByteLength() , m_videoWithAL3.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_1.hf_h245_H223Capability_audioWithAL1, tvb, offset + m_audioWithAL1.GetStartByte(), m_audioWithAL1.GetByteLength() , m_audioWithAL1.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_1.hf_h245_H223Capability_audioWithAL2, tvb, offset + m_audioWithAL2.GetStartByte(), m_audioWithAL2.GetByteLength() , m_audioWithAL2.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_1.hf_h245_H223Capability_audioWithAL3, tvb, offset + m_audioWithAL3.GetStartByte(), m_audioWithAL3.GetByteLength() , m_audioWithAL3.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_1.hf_h245_H223Capability_dataWithAL1, tvb, offset + m_dataWithAL1.GetStartByte(), m_dataWithAL1.GetByteLength() , m_dataWithAL1.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_1.hf_h245_H223Capability_dataWithAL2, tvb, offset + m_dataWithAL2.GetStartByte(), m_dataWithAL2.GetByteLength() , m_dataWithAL2.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_1.hf_h245_H223Capability_dataWithAL3, tvb, offset + m_dataWithAL3.GetStartByte(), m_dataWithAL3.GetByteLength() , m_dataWithAL3.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_H223Capability_maximumAl2SDUSize, tvb, offset + m_maximumAl2SDUSize.GetStartByte(), m_maximumAl2SDUSize.GetByteLength() , m_maximumAl2SDUSize.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_H223Capability_maximumAl3SDUSize, tvb, offset + m_maximumAl3SDUSize.GetStartByte(), m_maximumAl3SDUSize.GetByteLength() , m_maximumAl3SDUSize.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_1.hf_h245_H223Capability_maximumDelayJitter, tvb, offset + m_maximumDelayJitter.GetStartByte(), m_maximumDelayJitter.GetByteLength() , m_maximumDelayJitter.GetValue() );

  proto_tree *h223MultiplexTableCapability_tree = (proto_tree*) NULL;
  proto_item *h223MultiplexTableCapability_ti = (proto_item*) NULL;
  h223MultiplexTableCapability_ti = proto_tree_add_text( tree, tvb, offset + m_h223MultiplexTableCapability.GetStartByte(), m_h223MultiplexTableCapability.GetByteLength(), "h223MultiplexTableCapability (%s)", ( const char* ) m_h223MultiplexTableCapability.GetTagName() );
  h223MultiplexTableCapability_tree = proto_item_add_subtree( h223MultiplexTableCapability_ti, hCont->h245_1.ett_h245_H223Capability_h223MultiplexTableCapability );

  m_h223MultiplexTableCapability.showEthereal( h223MultiplexTableCapability_tree, tvb, offset );

  if ( HasOptionalField( e_maxMUXPDUSizeCapability ) ) {
    proto_tree_add_boolean( tree, hCont->h245_1.hf_h245_H223Capability_maxMUXPDUSizeCapability, tvb, offset + m_maxMUXPDUSizeCapability.GetStartByte(), m_maxMUXPDUSizeCapability.GetByteLength() , m_maxMUXPDUSizeCapability.GetValue() );
  }

  if ( HasOptionalField( e_nsrpSupport ) ) {
    proto_tree_add_boolean( tree, hCont->h245_1.hf_h245_H223Capability_nsrpSupport, tvb, offset + m_nsrpSupport.GetStartByte(), m_nsrpSupport.GetByteLength() , m_nsrpSupport.GetValue() );
  }

  if ( HasOptionalField( e_mobileOperationTransmitCapability ) ) {
    proto_tree *mobileOperationTransmitCapability_tree = (proto_tree*) NULL;
    proto_item *mobileOperationTransmitCapability_ti = (proto_item*) NULL;
    mobileOperationTransmitCapability_ti = proto_tree_add_text( tree, tvb, offset + m_mobileOperationTransmitCapability.GetStartByte(), m_mobileOperationTransmitCapability.GetByteLength(), "mobileOperationTransmitCapability (H223Capability-mobileOperationTransmitCapability)" );
    mobileOperationTransmitCapability_tree = proto_item_add_subtree( mobileOperationTransmitCapability_ti, hCont->h245_1.ett_h245_H223Capability_mobileOperationTransmitCapability );
    m_mobileOperationTransmitCapability.showEthereal( mobileOperationTransmitCapability_tree, tvb, offset );
  }

  if ( HasOptionalField( e_h223AnnexCCapability ) ) {
    proto_tree *h223AnnexCCapability_tree = (proto_tree*) NULL;
    proto_item *h223AnnexCCapability_ti = (proto_item*) NULL;
    h223AnnexCCapability_ti = proto_tree_add_text( tree, tvb, offset + m_h223AnnexCCapability.GetStartByte(), m_h223AnnexCCapability.GetByteLength(), "h223AnnexCCapability (H223AnnexCCapability)" );
    h223AnnexCCapability_tree = proto_item_add_subtree( h223AnnexCCapability_ti, hCont->h245_1.ett_h245_H223Capability_h223AnnexCCapability );
    m_h223AnnexCCapability.showEthereal( h223AnnexCCapability_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// V76Capability
//

H245_V76Capability::H245_V76Capability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_numOfDLCS.SetConstraints(PASN_Object::FixedConstraint, 2, 8191);
  m_n401Capability.SetConstraints(PASN_Object::FixedConstraint, 1, 4095);
  m_maxWindowSizeCapability.SetConstraints(PASN_Object::FixedConstraint, 1, 127);
}


#ifndef PASN_NOPRINTON
void H245_V76Capability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+34) << "suspendResumeCapabilitywAddress = " << setprecision(indent) << m_suspendResumeCapabilitywAddress << '\n';
  strm << setw(indent+35) << "suspendResumeCapabilitywoAddress = " << setprecision(indent) << m_suspendResumeCapabilitywoAddress << '\n';
  strm << setw(indent+16) << "rejCapability = " << setprecision(indent) << m_rejCapability << '\n';
  strm << setw(indent+17) << "sREJCapability = " << setprecision(indent) << m_sREJCapability << '\n';
  strm << setw(indent+17) << "mREJCapability = " << setprecision(indent) << m_mREJCapability << '\n';
  strm << setw(indent+20) << "crc8bitCapability = " << setprecision(indent) << m_crc8bitCapability << '\n';
  strm << setw(indent+21) << "crc16bitCapability = " << setprecision(indent) << m_crc16bitCapability << '\n';
  strm << setw(indent+21) << "crc32bitCapability = " << setprecision(indent) << m_crc32bitCapability << '\n';
  strm << setw(indent+16) << "uihCapability = " << setprecision(indent) << m_uihCapability << '\n';
  strm << setw(indent+12) << "numOfDLCS = " << setprecision(indent) << m_numOfDLCS << '\n';
  strm << setw(indent+33) << "twoOctetAddressFieldCapability = " << setprecision(indent) << m_twoOctetAddressFieldCapability << '\n';
  strm << setw(indent+25) << "loopBackTestCapability = " << setprecision(indent) << m_loopBackTestCapability << '\n';
  strm << setw(indent+17) << "n401Capability = " << setprecision(indent) << m_n401Capability << '\n';
  strm << setw(indent+26) << "maxWindowSizeCapability = " << setprecision(indent) << m_maxWindowSizeCapability << '\n';
  strm << setw(indent+16) << "v75Capability = " << setprecision(indent) << m_v75Capability << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_V76Capability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_V76Capability::Class()), PInvalidCast);
#endif
  const H245_V76Capability & other = (const H245_V76Capability &)obj;

  Comparison result;

  if ((result = m_suspendResumeCapabilitywAddress.Compare(other.m_suspendResumeCapabilitywAddress)) != EqualTo)
    return result;
  if ((result = m_suspendResumeCapabilitywoAddress.Compare(other.m_suspendResumeCapabilitywoAddress)) != EqualTo)
    return result;
  if ((result = m_rejCapability.Compare(other.m_rejCapability)) != EqualTo)
    return result;
  if ((result = m_sREJCapability.Compare(other.m_sREJCapability)) != EqualTo)
    return result;
  if ((result = m_mREJCapability.Compare(other.m_mREJCapability)) != EqualTo)
    return result;
  if ((result = m_crc8bitCapability.Compare(other.m_crc8bitCapability)) != EqualTo)
    return result;
  if ((result = m_crc16bitCapability.Compare(other.m_crc16bitCapability)) != EqualTo)
    return result;
  if ((result = m_crc32bitCapability.Compare(other.m_crc32bitCapability)) != EqualTo)
    return result;
  if ((result = m_uihCapability.Compare(other.m_uihCapability)) != EqualTo)
    return result;
  if ((result = m_numOfDLCS.Compare(other.m_numOfDLCS)) != EqualTo)
    return result;
  if ((result = m_twoOctetAddressFieldCapability.Compare(other.m_twoOctetAddressFieldCapability)) != EqualTo)
    return result;
  if ((result = m_loopBackTestCapability.Compare(other.m_loopBackTestCapability)) != EqualTo)
    return result;
  if ((result = m_n401Capability.Compare(other.m_n401Capability)) != EqualTo)
    return result;
  if ((result = m_maxWindowSizeCapability.Compare(other.m_maxWindowSizeCapability)) != EqualTo)
    return result;
  if ((result = m_v75Capability.Compare(other.m_v75Capability)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_V76Capability::GetDataLength() const
{
  return m_suspendResumeCapabilitywAddress.GetObjectLength() +
         m_suspendResumeCapabilitywoAddress.GetObjectLength() +
         m_rejCapability.GetObjectLength() +
         m_sREJCapability.GetObjectLength() +
         m_mREJCapability.GetObjectLength() +
         m_crc8bitCapability.GetObjectLength() +
         m_crc16bitCapability.GetObjectLength() +
         m_crc32bitCapability.GetObjectLength() +
         m_uihCapability.GetObjectLength() +
         m_numOfDLCS.GetObjectLength() +
         m_twoOctetAddressFieldCapability.GetObjectLength() +
         m_loopBackTestCapability.GetObjectLength() +
         m_n401Capability.GetObjectLength() +
         m_maxWindowSizeCapability.GetObjectLength() +
         m_v75Capability.GetObjectLength();
}


BOOL H245_V76Capability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_suspendResumeCapabilitywAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_suspendResumeCapabilitywoAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_rejCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sREJCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_mREJCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_crc8bitCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_crc16bitCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_crc32bitCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_uihCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_numOfDLCS.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_twoOctetAddressFieldCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_loopBackTestCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_n401Capability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maxWindowSizeCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_v75Capability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_V76Capability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_suspendResumeCapabilitywAddress.Encode(strm);
  m_suspendResumeCapabilitywoAddress.Encode(strm);
  m_rejCapability.Encode(strm);
  m_sREJCapability.Encode(strm);
  m_mREJCapability.Encode(strm);
  m_crc8bitCapability.Encode(strm);
  m_crc16bitCapability.Encode(strm);
  m_crc32bitCapability.Encode(strm);
  m_uihCapability.Encode(strm);
  m_numOfDLCS.Encode(strm);
  m_twoOctetAddressFieldCapability.Encode(strm);
  m_loopBackTestCapability.Encode(strm);
  m_n401Capability.Encode(strm);
  m_maxWindowSizeCapability.Encode(strm);
  m_v75Capability.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_suspendResumeCapabilitywAddress.Encode(strm);
  m_suspendResumeCapabilitywoAddress.Encode(strm);
  m_rejCapability.Encode(strm);
  m_sREJCapability.Encode(strm);
  m_mREJCapability.Encode(strm);
  m_crc8bitCapability.Encode(strm);
  m_crc16bitCapability.Encode(strm);
  m_crc32bitCapability.Encode(strm);
  m_uihCapability.Encode(strm);
  m_numOfDLCS.Encode(strm);
  m_twoOctetAddressFieldCapability.Encode(strm);
  m_loopBackTestCapability.Encode(strm);
  m_n401Capability.Encode(strm);
  m_maxWindowSizeCapability.Encode(strm);
  m_v75Capability.Encode(strm);
}


PObject * H245_V76Capability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_V76Capability::Class()), PInvalidCast);
#endif
  return new H245_V76Capability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_V76Capability::preShowEthereal( void )
{
  m_suspendResumeCapabilitywAddress.preShowEthereal( );
  m_suspendResumeCapabilitywoAddress.preShowEthereal( );
  m_rejCapability.preShowEthereal( );
  m_sREJCapability.preShowEthereal( );
  m_mREJCapability.preShowEthereal( );
  m_crc8bitCapability.preShowEthereal( );
  m_crc16bitCapability.preShowEthereal( );
  m_crc32bitCapability.preShowEthereal( );
  m_uihCapability.preShowEthereal( );
  m_numOfDLCS.preShowEthereal( );
  m_twoOctetAddressFieldCapability.preShowEthereal( );
  m_loopBackTestCapability.preShowEthereal( );
  m_n401Capability.preShowEthereal( );
  m_maxWindowSizeCapability.preShowEthereal( );
  m_v75Capability.preShowEthereal( );
}

PString H245_V76Capability::getSummary( void ) 
{
  return PString( "V76Capability" );
}

void H245_V76Capability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h245_1.hf_h245_V76Capability_suspendResumeCapabilitywAddress, tvb, offset + m_suspendResumeCapabilitywAddress.GetStartByte(), m_suspendResumeCapabilitywAddress.GetByteLength() , m_suspendResumeCapabilitywAddress.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_1.hf_h245_V76Capability_suspendResumeCapabilitywoAddress, tvb, offset + m_suspendResumeCapabilitywoAddress.GetStartByte(), m_suspendResumeCapabilitywoAddress.GetByteLength() , m_suspendResumeCapabilitywoAddress.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_1.hf_h245_V76Capability_rejCapability, tvb, offset + m_rejCapability.GetStartByte(), m_rejCapability.GetByteLength() , m_rejCapability.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_1.hf_h245_V76Capability_sREJCapability, tvb, offset + m_sREJCapability.GetStartByte(), m_sREJCapability.GetByteLength() , m_sREJCapability.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_V76Capability_mREJCapability, tvb, offset + m_mREJCapability.GetStartByte(), m_mREJCapability.GetByteLength() , m_mREJCapability.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_V76Capability_crc8bitCapability, tvb, offset + m_crc8bitCapability.GetStartByte(), m_crc8bitCapability.GetByteLength() , m_crc8bitCapability.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_V76Capability_crc16bitCapability, tvb, offset + m_crc16bitCapability.GetStartByte(), m_crc16bitCapability.GetByteLength() , m_crc16bitCapability.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_V76Capability_crc32bitCapability, tvb, offset + m_crc32bitCapability.GetStartByte(), m_crc32bitCapability.GetByteLength() , m_crc32bitCapability.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_V76Capability_uihCapability, tvb, offset + m_uihCapability.GetStartByte(), m_uihCapability.GetByteLength() , m_uihCapability.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_V76Capability_numOfDLCS, tvb, offset + m_numOfDLCS.GetStartByte(), m_numOfDLCS.GetByteLength() , m_numOfDLCS.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_V76Capability_twoOctetAddressFieldCapability, tvb, offset + m_twoOctetAddressFieldCapability.GetStartByte(), m_twoOctetAddressFieldCapability.GetByteLength() , m_twoOctetAddressFieldCapability.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_V76Capability_loopBackTestCapability, tvb, offset + m_loopBackTestCapability.GetStartByte(), m_loopBackTestCapability.GetByteLength() , m_loopBackTestCapability.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_V76Capability_n401Capability, tvb, offset + m_n401Capability.GetStartByte(), m_n401Capability.GetByteLength() , m_n401Capability.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_V76Capability_maxWindowSizeCapability, tvb, offset + m_maxWindowSizeCapability.GetStartByte(), m_maxWindowSizeCapability.GetByteLength() , m_maxWindowSizeCapability.GetValue() );

  proto_tree *v75Capability_tree = (proto_tree*) NULL;
  proto_item *v75Capability_ti = (proto_item*) NULL;
  v75Capability_ti = proto_tree_add_text( tree, tvb, offset + m_v75Capability.GetStartByte(), m_v75Capability.GetByteLength(), "v75Capability (V75Capability)" );
  v75Capability_tree = proto_item_add_subtree( v75Capability_ti, hCont->h245_2.ett_h245_V76Capability_v75Capability );

  m_v75Capability.showEthereal( v75Capability_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// MediaPacketizationCapability
//

H245_MediaPacketizationCapability::H245_MediaPacketizationCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 1)
{
  m_rtpPayloadType.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_MediaPacketizationCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+26) << "h261aVideoPacketization = " << setprecision(indent) << m_h261aVideoPacketization << '\n';
  if (HasOptionalField(e_rtpPayloadType))
    strm << setw(indent+17) << "rtpPayloadType = " << setprecision(indent) << m_rtpPayloadType << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MediaPacketizationCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MediaPacketizationCapability::Class()), PInvalidCast);
#endif
  const H245_MediaPacketizationCapability & other = (const H245_MediaPacketizationCapability &)obj;

  Comparison result;

  if ((result = m_h261aVideoPacketization.Compare(other.m_h261aVideoPacketization)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MediaPacketizationCapability::GetDataLength() const
{
  return m_h261aVideoPacketization.GetObjectLength();
}


BOOL H245_MediaPacketizationCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_h261aVideoPacketization.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_rtpPayloadType, m_rtpPayloadType ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MediaPacketizationCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_h261aVideoPacketization.Encode(strm);
  KnownExtensionEncode(strm, e_rtpPayloadType, m_rtpPayloadType);

  UnknownExtensionsEncode(strm);
  m_h261aVideoPacketization.Encode(strm);
}


PObject * H245_MediaPacketizationCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MediaPacketizationCapability::Class()), PInvalidCast);
#endif
  return new H245_MediaPacketizationCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MediaPacketizationCapability::preShowEthereal( void )
{
  m_h261aVideoPacketization.preShowEthereal( );
  if ( HasOptionalField( e_rtpPayloadType ) ) 
      m_rtpPayloadType.preShowEthereal( );
}

PString H245_MediaPacketizationCapability::getSummary( void ) 
{
  return PString( "MediaPacketizationCapability" );
}

void H245_MediaPacketizationCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_MediaPacketizationCapability_h261aVideoPacketization, tvb, offset + m_h261aVideoPacketization.GetStartByte(), m_h261aVideoPacketization.GetByteLength() , m_h261aVideoPacketization.GetValue() );

  if ( HasOptionalField( e_rtpPayloadType ) ) {
    proto_tree *rtpPayloadType_tree = (proto_tree*) NULL;
    proto_item *rtpPayloadType_ti = (proto_item*) NULL;
    rtpPayloadType_ti = proto_tree_add_text( tree, tvb, offset + m_rtpPayloadType.GetStartByte(), m_rtpPayloadType.GetByteLength(), "rtpPayloadType (RTPPayloadType)" );
    rtpPayloadType_tree = proto_item_add_subtree( rtpPayloadType_ti, hCont->h245_2.ett_h245_MediaPacketizationCapability_rtpPayloadType );
    m_rtpPayloadType.showEthereal( rtpPayloadType_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// RSVPParameters
//

H245_RSVPParameters::H245_RSVPParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 6, TRUE, 0)
{
  m_tokenRate.SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
  m_bucketSize.SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
  m_peakRate.SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
  m_minPoliced.SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
  m_maxPktSize.SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H245_RSVPParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_qosMode))
    strm << setw(indent+10) << "qosMode = " << setprecision(indent) << m_qosMode << '\n';
  if (HasOptionalField(e_tokenRate))
    strm << setw(indent+12) << "tokenRate = " << setprecision(indent) << m_tokenRate << '\n';
  if (HasOptionalField(e_bucketSize))
    strm << setw(indent+13) << "bucketSize = " << setprecision(indent) << m_bucketSize << '\n';
  if (HasOptionalField(e_peakRate))
    strm << setw(indent+11) << "peakRate = " << setprecision(indent) << m_peakRate << '\n';
  if (HasOptionalField(e_minPoliced))
    strm << setw(indent+13) << "minPoliced = " << setprecision(indent) << m_minPoliced << '\n';
  if (HasOptionalField(e_maxPktSize))
    strm << setw(indent+13) << "maxPktSize = " << setprecision(indent) << m_maxPktSize << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RSVPParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RSVPParameters::Class()), PInvalidCast);
#endif
  const H245_RSVPParameters & other = (const H245_RSVPParameters &)obj;

  Comparison result;

  if ((result = m_qosMode.Compare(other.m_qosMode)) != EqualTo)
    return result;
  if ((result = m_tokenRate.Compare(other.m_tokenRate)) != EqualTo)
    return result;
  if ((result = m_bucketSize.Compare(other.m_bucketSize)) != EqualTo)
    return result;
  if ((result = m_peakRate.Compare(other.m_peakRate)) != EqualTo)
    return result;
  if ((result = m_minPoliced.Compare(other.m_minPoliced)) != EqualTo)
    return result;
  if ((result = m_maxPktSize.Compare(other.m_maxPktSize)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RSVPParameters::GetDataLength() const
{
  return m_qosMode.GetObjectLength() +
         m_tokenRate.GetObjectLength() +
         m_bucketSize.GetObjectLength() +
         m_peakRate.GetObjectLength() +
         m_minPoliced.GetObjectLength() +
         m_maxPktSize.GetObjectLength();
}


BOOL H245_RSVPParameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_qosMode ) && !m_qosMode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_tokenRate ) && !m_tokenRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_bucketSize ) && !m_bucketSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_peakRate ) && !m_peakRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_minPoliced ) && !m_minPoliced.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_maxPktSize ) && !m_maxPktSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RSVPParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_qosMode))
    m_qosMode.Encode(strm);
  if (HasOptionalField(e_tokenRate))
    m_tokenRate.Encode(strm);
  if (HasOptionalField(e_bucketSize))
    m_bucketSize.Encode(strm);
  if (HasOptionalField(e_peakRate))
    m_peakRate.Encode(strm);
  if (HasOptionalField(e_minPoliced))
    m_minPoliced.Encode(strm);
  if (HasOptionalField(e_maxPktSize))
    m_maxPktSize.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_qosMode))
    m_qosMode.Encode(strm);
  if (HasOptionalField(e_tokenRate))
    m_tokenRate.Encode(strm);
  if (HasOptionalField(e_bucketSize))
    m_bucketSize.Encode(strm);
  if (HasOptionalField(e_peakRate))
    m_peakRate.Encode(strm);
  if (HasOptionalField(e_minPoliced))
    m_minPoliced.Encode(strm);
  if (HasOptionalField(e_maxPktSize))
    m_maxPktSize.Encode(strm);
}


PObject * H245_RSVPParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RSVPParameters::Class()), PInvalidCast);
#endif
  return new H245_RSVPParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RSVPParameters::preShowEthereal( void )
{
  if ( HasOptionalField( e_qosMode ) ) 
      m_qosMode.preShowEthereal( );
  if ( HasOptionalField( e_tokenRate ) ) 
      m_tokenRate.preShowEthereal( );
  if ( HasOptionalField( e_bucketSize ) ) 
      m_bucketSize.preShowEthereal( );
  if ( HasOptionalField( e_peakRate ) ) 
      m_peakRate.preShowEthereal( );
  if ( HasOptionalField( e_minPoliced ) ) 
      m_minPoliced.preShowEthereal( );
  if ( HasOptionalField( e_maxPktSize ) ) 
      m_maxPktSize.preShowEthereal( );
}

PString H245_RSVPParameters::getSummary( void ) 
{
  return PString( "RSVPParameters" );
}

void H245_RSVPParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_qosMode ) ) {
    proto_tree *qosMode_tree = (proto_tree*) NULL;
    proto_item *qosMode_ti = (proto_item*) NULL;
    qosMode_ti = proto_tree_add_text( tree, tvb, offset + m_qosMode.GetStartByte(), m_qosMode.GetByteLength(), "qosMode (%s)", ( const char* ) m_qosMode.GetTagName() );
    qosMode_tree = proto_item_add_subtree( qosMode_ti, hCont->h245_2.ett_h245_RSVPParameters_qosMode );
    m_qosMode.showEthereal( qosMode_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokenRate ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_RSVPParameters_tokenRate, tvb, offset + m_tokenRate.GetStartByte(), m_tokenRate.GetByteLength() , m_tokenRate.GetValue() );
  }

  if ( HasOptionalField( e_bucketSize ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_RSVPParameters_bucketSize, tvb, offset + m_bucketSize.GetStartByte(), m_bucketSize.GetByteLength() , m_bucketSize.GetValue() );
  }

  if ( HasOptionalField( e_peakRate ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_RSVPParameters_peakRate, tvb, offset + m_peakRate.GetStartByte(), m_peakRate.GetByteLength() , m_peakRate.GetValue() );
  }

  if ( HasOptionalField( e_minPoliced ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_RSVPParameters_minPoliced, tvb, offset + m_minPoliced.GetStartByte(), m_minPoliced.GetByteLength() , m_minPoliced.GetValue() );
  }

  if ( HasOptionalField( e_maxPktSize ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_RSVPParameters_maxPktSize, tvb, offset + m_maxPktSize.GetStartByte(), m_maxPktSize.GetByteLength() , m_maxPktSize.GetValue() );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// QOSCapability
//

H245_QOSCapability::H245_QOSCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_QOSCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_rsvpParameters))
    strm << setw(indent+17) << "rsvpParameters = " << setprecision(indent) << m_rsvpParameters << '\n';
  if (HasOptionalField(e_atmParameters))
    strm << setw(indent+16) << "atmParameters = " << setprecision(indent) << m_atmParameters << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_QOSCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_QOSCapability::Class()), PInvalidCast);
#endif
  const H245_QOSCapability & other = (const H245_QOSCapability &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_rsvpParameters.Compare(other.m_rsvpParameters)) != EqualTo)
    return result;
  if ((result = m_atmParameters.Compare(other.m_atmParameters)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_QOSCapability::GetDataLength() const
{
  return m_nonStandardData.GetObjectLength() +
         m_rsvpParameters.GetObjectLength() +
         m_atmParameters.GetObjectLength();
}


BOOL H245_QOSCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_rsvpParameters ) && !m_rsvpParameters.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_atmParameters ) && !m_atmParameters.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_QOSCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_rsvpParameters))
    m_rsvpParameters.Encode(strm);
  if (HasOptionalField(e_atmParameters))
    m_atmParameters.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_rsvpParameters))
    m_rsvpParameters.Encode(strm);
  if (HasOptionalField(e_atmParameters))
    m_atmParameters.Encode(strm);
}


PObject * H245_QOSCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_QOSCapability::Class()), PInvalidCast);
#endif
  return new H245_QOSCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_QOSCapability::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_rsvpParameters ) ) 
      m_rsvpParameters.preShowEthereal( );
  if ( HasOptionalField( e_atmParameters ) ) 
      m_atmParameters.preShowEthereal( );
}

PString H245_QOSCapability::getSummary( void ) 
{
  return PString( "QOSCapability" );
}

void H245_QOSCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h245_2.ett_h245_QOSCapability_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_rsvpParameters ) ) {
    proto_tree *rsvpParameters_tree = (proto_tree*) NULL;
    proto_item *rsvpParameters_ti = (proto_item*) NULL;
    rsvpParameters_ti = proto_tree_add_text( tree, tvb, offset + m_rsvpParameters.GetStartByte(), m_rsvpParameters.GetByteLength(), "rsvpParameters (RSVPParameters)" );
    rsvpParameters_tree = proto_item_add_subtree( rsvpParameters_ti, hCont->h245_2.ett_h245_QOSCapability_rsvpParameters );
    m_rsvpParameters.showEthereal( rsvpParameters_tree, tvb, offset );
  }

  if ( HasOptionalField( e_atmParameters ) ) {
    proto_tree *atmParameters_tree = (proto_tree*) NULL;
    proto_item *atmParameters_ti = (proto_item*) NULL;
    atmParameters_ti = proto_tree_add_text( tree, tvb, offset + m_atmParameters.GetStartByte(), m_atmParameters.GetByteLength(), "atmParameters (ATMParameters)" );
    atmParameters_tree = proto_item_add_subtree( atmParameters_ti, hCont->h245_2.ett_h245_QOSCapability_atmParameters );
    m_atmParameters.showEthereal( atmParameters_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// TransportCapability
//

H245_TransportCapability::H245_TransportCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
  m_qOSCapabilities.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
  m_mediaChannelCapabilities.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_TransportCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandard))
    strm << setw(indent+14) << "nonStandard = " << setprecision(indent) << m_nonStandard << '\n';
  if (HasOptionalField(e_qOSCapabilities))
    strm << setw(indent+18) << "qOSCapabilities = " << setprecision(indent) << m_qOSCapabilities << '\n';
  if (HasOptionalField(e_mediaChannelCapabilities))
    strm << setw(indent+27) << "mediaChannelCapabilities = " << setprecision(indent) << m_mediaChannelCapabilities << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_TransportCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_TransportCapability::Class()), PInvalidCast);
#endif
  const H245_TransportCapability & other = (const H245_TransportCapability &)obj;

  Comparison result;

  if ((result = m_nonStandard.Compare(other.m_nonStandard)) != EqualTo)
    return result;
  if ((result = m_qOSCapabilities.Compare(other.m_qOSCapabilities)) != EqualTo)
    return result;
  if ((result = m_mediaChannelCapabilities.Compare(other.m_mediaChannelCapabilities)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_TransportCapability::GetDataLength() const
{
  return m_nonStandard.GetObjectLength() +
         m_qOSCapabilities.GetObjectLength() +
         m_mediaChannelCapabilities.GetObjectLength();
}


BOOL H245_TransportCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandard ) && !m_nonStandard.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_qOSCapabilities ) && !m_qOSCapabilities.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_mediaChannelCapabilities ) && !m_mediaChannelCapabilities.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_TransportCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
  if (HasOptionalField(e_qOSCapabilities))
    m_qOSCapabilities.Encode(strm);
  if (HasOptionalField(e_mediaChannelCapabilities))
    m_mediaChannelCapabilities.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
  if (HasOptionalField(e_qOSCapabilities))
    m_qOSCapabilities.Encode(strm);
  if (HasOptionalField(e_mediaChannelCapabilities))
    m_mediaChannelCapabilities.Encode(strm);
}


PObject * H245_TransportCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TransportCapability::Class()), PInvalidCast);
#endif
  return new H245_TransportCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_TransportCapability::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandard ) ) 
      m_nonStandard.preShowEthereal( );
  if ( HasOptionalField( e_qOSCapabilities ) ) 
      m_qOSCapabilities.preShowEthereal( );
  if ( HasOptionalField( e_mediaChannelCapabilities ) ) 
      m_mediaChannelCapabilities.preShowEthereal( );
}

PString H245_TransportCapability::getSummary( void ) 
{
  return PString( "TransportCapability" );
}

void H245_TransportCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandard ) ) {
    proto_tree *nonStandard_tree = (proto_tree*) NULL;
    proto_item *nonStandard_ti = (proto_item*) NULL;
    nonStandard_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandard.GetStartByte(), m_nonStandard.GetByteLength(), "nonStandard (NonStandardParameter)" );
    nonStandard_tree = proto_item_add_subtree( nonStandard_ti, hCont->h245_2.ett_h245_TransportCapability_nonStandard );
    m_nonStandard.showEthereal( nonStandard_tree, tvb, offset );
  }

  if ( HasOptionalField( e_qOSCapabilities ) ) {
    proto_tree *qOSCapabilities_tree = (proto_tree*) NULL;
    proto_item *qOSCapabilities_ti = (proto_item*) NULL;
    qOSCapabilities_ti = proto_tree_add_text( tree, tvb, offset + m_qOSCapabilities.GetStartByte(), m_qOSCapabilities.GetByteLength(), "qOSCapabilities (QOSCapability)" );
    qOSCapabilities_tree = proto_item_add_subtree( qOSCapabilities_ti, hCont->h245_2.ett_h245_TransportCapability_qOSCapabilities );
    m_qOSCapabilities.showEthereal( qOSCapabilities_tree, tvb, offset );
  }

  if ( HasOptionalField( e_mediaChannelCapabilities ) ) {
    proto_tree *mediaChannelCapabilities_tree = (proto_tree*) NULL;
    proto_item *mediaChannelCapabilities_ti = (proto_item*) NULL;
    mediaChannelCapabilities_ti = proto_tree_add_text( tree, tvb, offset + m_mediaChannelCapabilities.GetStartByte(), m_mediaChannelCapabilities.GetByteLength(), "mediaChannelCapabilities (MediaChannelCapability)" );
    mediaChannelCapabilities_tree = proto_item_add_subtree( mediaChannelCapabilities_ti, hCont->h245_2.ett_h245_TransportCapability_mediaChannelCapabilities );
    m_mediaChannelCapabilities.showEthereal( mediaChannelCapabilities_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// RedundancyEncodingCapability
//

H245_RedundancyEncodingCapability::H245_RedundancyEncodingCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_secondaryEncoding.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_RedundancyEncodingCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+27) << "redundancyEncodingMethod = " << setprecision(indent) << m_redundancyEncodingMethod << '\n';
  strm << setw(indent+18) << "primaryEncoding = " << setprecision(indent) << m_primaryEncoding << '\n';
  if (HasOptionalField(e_secondaryEncoding))
    strm << setw(indent+20) << "secondaryEncoding = " << setprecision(indent) << m_secondaryEncoding << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RedundancyEncodingCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RedundancyEncodingCapability::Class()), PInvalidCast);
#endif
  const H245_RedundancyEncodingCapability & other = (const H245_RedundancyEncodingCapability &)obj;

  Comparison result;

  if ((result = m_redundancyEncodingMethod.Compare(other.m_redundancyEncodingMethod)) != EqualTo)
    return result;
  if ((result = m_primaryEncoding.Compare(other.m_primaryEncoding)) != EqualTo)
    return result;
  if ((result = m_secondaryEncoding.Compare(other.m_secondaryEncoding)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RedundancyEncodingCapability::GetDataLength() const
{
  return m_redundancyEncodingMethod.GetObjectLength() +
         m_primaryEncoding.GetObjectLength() +
         m_secondaryEncoding.GetObjectLength();
}


BOOL H245_RedundancyEncodingCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_redundancyEncodingMethod.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_primaryEncoding.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_secondaryEncoding ) && !m_secondaryEncoding.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RedundancyEncodingCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_redundancyEncodingMethod.Encode(strm);
  m_primaryEncoding.Encode(strm);
  if (HasOptionalField(e_secondaryEncoding))
    m_secondaryEncoding.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_redundancyEncodingMethod.Encode(strm);
  m_primaryEncoding.Encode(strm);
  if (HasOptionalField(e_secondaryEncoding))
    m_secondaryEncoding.Encode(strm);
}


PObject * H245_RedundancyEncodingCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RedundancyEncodingCapability::Class()), PInvalidCast);
#endif
  return new H245_RedundancyEncodingCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RedundancyEncodingCapability::preShowEthereal( void )
{
  m_redundancyEncodingMethod.preShowEthereal( );
  m_primaryEncoding.preShowEthereal( );
  if ( HasOptionalField( e_secondaryEncoding ) ) 
      m_secondaryEncoding.preShowEthereal( );
}

PString H245_RedundancyEncodingCapability::getSummary( void ) 
{
  return PString( "RedundancyEncodingCapability" );
}

void H245_RedundancyEncodingCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *redundancyEncodingMethod_tree = (proto_tree*) NULL;
  proto_item *redundancyEncodingMethod_ti = (proto_item*) NULL;
  redundancyEncodingMethod_ti = proto_tree_add_text( tree, tvb, offset + m_redundancyEncodingMethod.GetStartByte(), m_redundancyEncodingMethod.GetByteLength(), "redundancyEncodingMethod (%s)", ( const char* ) m_redundancyEncodingMethod.GetTagName() );
  redundancyEncodingMethod_tree = proto_item_add_subtree( redundancyEncodingMethod_ti, hCont->h245_2.ett_h245_RedundancyEncodingCapability_redundancyEncodingMethod );

  m_redundancyEncodingMethod.showEthereal( redundancyEncodingMethod_tree, tvb, offset );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_RedundancyEncodingCapability_primaryEncoding, tvb, offset + m_primaryEncoding.GetStartByte(), m_primaryEncoding.GetByteLength() , m_primaryEncoding.GetValue() );

  if ( HasOptionalField( e_secondaryEncoding ) ) {
    proto_tree *secondaryEncoding_tree = (proto_tree*) NULL;
    proto_item *secondaryEncoding_ti = (proto_item*) NULL;
    secondaryEncoding_ti = proto_tree_add_text( tree, tvb, offset + m_secondaryEncoding.GetStartByte(), m_secondaryEncoding.GetByteLength(), "secondaryEncoding (CapabilityTableEntryNumber)" );
    secondaryEncoding_tree = proto_item_add_subtree( secondaryEncoding_ti, hCont->h245_2.ett_h245_RedundancyEncodingCapability_secondaryEncoding );
    m_secondaryEncoding.showEthereal( secondaryEncoding_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// RTPH263VideoRedundancyEncoding
//

H245_RTPH263VideoRedundancyEncoding::H245_RTPH263VideoRedundancyEncoding(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_numberOfThreads.SetConstraints(PASN_Object::FixedConstraint, 1, 16);
  m_framesBetweenSyncPoints.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_RTPH263VideoRedundancyEncoding::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+18) << "numberOfThreads = " << setprecision(indent) << m_numberOfThreads << '\n';
  strm << setw(indent+26) << "framesBetweenSyncPoints = " << setprecision(indent) << m_framesBetweenSyncPoints << '\n';
  strm << setw(indent+23) << "frameToThreadMapping = " << setprecision(indent) << m_frameToThreadMapping << '\n';
  if (HasOptionalField(e_containedThreads))
    strm << setw(indent+19) << "containedThreads = " << setprecision(indent) << m_containedThreads << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RTPH263VideoRedundancyEncoding::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RTPH263VideoRedundancyEncoding::Class()), PInvalidCast);
#endif
  const H245_RTPH263VideoRedundancyEncoding & other = (const H245_RTPH263VideoRedundancyEncoding &)obj;

  Comparison result;

  if ((result = m_numberOfThreads.Compare(other.m_numberOfThreads)) != EqualTo)
    return result;
  if ((result = m_framesBetweenSyncPoints.Compare(other.m_framesBetweenSyncPoints)) != EqualTo)
    return result;
  if ((result = m_frameToThreadMapping.Compare(other.m_frameToThreadMapping)) != EqualTo)
    return result;
  if ((result = m_containedThreads.Compare(other.m_containedThreads)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RTPH263VideoRedundancyEncoding::GetDataLength() const
{
  return m_numberOfThreads.GetObjectLength() +
         m_framesBetweenSyncPoints.GetObjectLength() +
         m_frameToThreadMapping.GetObjectLength() +
         m_containedThreads.GetObjectLength();
}


BOOL H245_RTPH263VideoRedundancyEncoding::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_numberOfThreads.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_framesBetweenSyncPoints.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_frameToThreadMapping.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_containedThreads ) && !m_containedThreads.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RTPH263VideoRedundancyEncoding::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_numberOfThreads.Encode(strm);
  m_framesBetweenSyncPoints.Encode(strm);
  m_frameToThreadMapping.Encode(strm);
  if (HasOptionalField(e_containedThreads))
    m_containedThreads.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_numberOfThreads.Encode(strm);
  m_framesBetweenSyncPoints.Encode(strm);
  m_frameToThreadMapping.Encode(strm);
  if (HasOptionalField(e_containedThreads))
    m_containedThreads.Encode(strm);
}


PObject * H245_RTPH263VideoRedundancyEncoding::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RTPH263VideoRedundancyEncoding::Class()), PInvalidCast);
#endif
  return new H245_RTPH263VideoRedundancyEncoding(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RTPH263VideoRedundancyEncoding::preShowEthereal( void )
{
  m_numberOfThreads.preShowEthereal( );
  m_framesBetweenSyncPoints.preShowEthereal( );
  m_frameToThreadMapping.preShowEthereal( );
  if ( HasOptionalField( e_containedThreads ) ) 
      m_containedThreads.preShowEthereal( );
}

PString H245_RTPH263VideoRedundancyEncoding::getSummary( void ) 
{
  return PString( "RTPH263VideoRedundancyEncoding" );
}

void H245_RTPH263VideoRedundancyEncoding::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_RTPH263VideoRedundancyEncoding_numberOfThreads, tvb, offset + m_numberOfThreads.GetStartByte(), m_numberOfThreads.GetByteLength() , m_numberOfThreads.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_RTPH263VideoRedundancyEncoding_framesBetweenSyncPoints, tvb, offset + m_framesBetweenSyncPoints.GetStartByte(), m_framesBetweenSyncPoints.GetByteLength() , m_framesBetweenSyncPoints.GetValue() );

  proto_tree *frameToThreadMapping_tree = (proto_tree*) NULL;
  proto_item *frameToThreadMapping_ti = (proto_item*) NULL;
  frameToThreadMapping_ti = proto_tree_add_text( tree, tvb, offset + m_frameToThreadMapping.GetStartByte(), m_frameToThreadMapping.GetByteLength(), "frameToThreadMapping (%s)", ( const char* ) m_frameToThreadMapping.GetTagName() );
  frameToThreadMapping_tree = proto_item_add_subtree( frameToThreadMapping_ti, hCont->h245_2.ett_h245_RTPH263VideoRedundancyEncoding_frameToThreadMapping );

  m_frameToThreadMapping.showEthereal( frameToThreadMapping_tree, tvb, offset );

  if ( HasOptionalField( e_containedThreads ) ) {
    proto_tree *containedThreads_tree = (proto_tree*) NULL;
    proto_item *containedThreads_ti = (proto_item*) NULL;
    containedThreads_ti = proto_tree_add_text( tree, tvb, offset + m_containedThreads.GetStartByte(), m_containedThreads.GetByteLength(), "containedThreads (RTPH263VideoRedundancyEncoding-containedThreads)" );
    containedThreads_tree = proto_item_add_subtree( containedThreads_ti, hCont->h245_2.ett_h245_RTPH263VideoRedundancyEncoding_containedThreads );
    m_containedThreads.showEthereal( containedThreads_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// RTPH263VideoRedundancyFrameMapping
//

H245_RTPH263VideoRedundancyFrameMapping::H245_RTPH263VideoRedundancyFrameMapping(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_threadNumber.SetConstraints(PASN_Object::FixedConstraint, 0, 15);
}


#ifndef PASN_NOPRINTON
void H245_RTPH263VideoRedundancyFrameMapping::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "threadNumber = " << setprecision(indent) << m_threadNumber << '\n';
  strm << setw(indent+16) << "frameSequence = " << setprecision(indent) << m_frameSequence << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RTPH263VideoRedundancyFrameMapping::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RTPH263VideoRedundancyFrameMapping::Class()), PInvalidCast);
#endif
  const H245_RTPH263VideoRedundancyFrameMapping & other = (const H245_RTPH263VideoRedundancyFrameMapping &)obj;

  Comparison result;

  if ((result = m_threadNumber.Compare(other.m_threadNumber)) != EqualTo)
    return result;
  if ((result = m_frameSequence.Compare(other.m_frameSequence)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RTPH263VideoRedundancyFrameMapping::GetDataLength() const
{
  return m_threadNumber.GetObjectLength() +
         m_frameSequence.GetObjectLength();
}


BOOL H245_RTPH263VideoRedundancyFrameMapping::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_threadNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_frameSequence.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RTPH263VideoRedundancyFrameMapping::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_threadNumber.Encode(strm);
  m_frameSequence.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_threadNumber.Encode(strm);
  m_frameSequence.Encode(strm);
}


PObject * H245_RTPH263VideoRedundancyFrameMapping::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RTPH263VideoRedundancyFrameMapping::Class()), PInvalidCast);
#endif
  return new H245_RTPH263VideoRedundancyFrameMapping(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RTPH263VideoRedundancyFrameMapping::preShowEthereal( void )
{
  m_threadNumber.preShowEthereal( );
  m_frameSequence.preShowEthereal( );
}

PString H245_RTPH263VideoRedundancyFrameMapping::getSummary( void ) 
{
  return PString( "RTPH263VideoRedundancyFrameMapping" );
}

void H245_RTPH263VideoRedundancyFrameMapping::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_RTPH263VideoRedundancyFrameMapping_threadNumber, tvb, offset + m_threadNumber.GetStartByte(), m_threadNumber.GetByteLength() , m_threadNumber.GetValue() );

  proto_tree *frameSequence_tree = (proto_tree*) NULL;
  proto_item *frameSequence_ti = (proto_item*) NULL;
  frameSequence_ti = proto_tree_add_text( tree, tvb, offset + m_frameSequence.GetStartByte(), m_frameSequence.GetByteLength(), "frameSequence (RTPH263VideoRedundancyFrameMapping-frameSequence)" );
  frameSequence_tree = proto_item_add_subtree( frameSequence_ti, hCont->h245_2.ett_h245_RTPH263VideoRedundancyFrameMapping_frameSequence );

  m_frameSequence.showEthereal( frameSequence_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// MultipointCapability
//

H245_MultipointCapability::H245_MultipointCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultipointCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "multicastCapability = " << setprecision(indent) << m_multicastCapability << '\n';
  strm << setw(indent+25) << "multiUniCastConference = " << setprecision(indent) << m_multiUniCastConference << '\n';
  strm << setw(indent+30) << "mediaDistributionCapability = " << setprecision(indent) << m_mediaDistributionCapability << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MultipointCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MultipointCapability::Class()), PInvalidCast);
#endif
  const H245_MultipointCapability & other = (const H245_MultipointCapability &)obj;

  Comparison result;

  if ((result = m_multicastCapability.Compare(other.m_multicastCapability)) != EqualTo)
    return result;
  if ((result = m_multiUniCastConference.Compare(other.m_multiUniCastConference)) != EqualTo)
    return result;
  if ((result = m_mediaDistributionCapability.Compare(other.m_mediaDistributionCapability)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultipointCapability::GetDataLength() const
{
  return m_multicastCapability.GetObjectLength() +
         m_multiUniCastConference.GetObjectLength() +
         m_mediaDistributionCapability.GetObjectLength();
}


BOOL H245_MultipointCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_multicastCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_multiUniCastConference.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_mediaDistributionCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MultipointCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_multicastCapability.Encode(strm);
  m_multiUniCastConference.Encode(strm);
  m_mediaDistributionCapability.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_multicastCapability.Encode(strm);
  m_multiUniCastConference.Encode(strm);
  m_mediaDistributionCapability.Encode(strm);
}


PObject * H245_MultipointCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultipointCapability::Class()), PInvalidCast);
#endif
  return new H245_MultipointCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultipointCapability::preShowEthereal( void )
{
  m_multicastCapability.preShowEthereal( );
  m_multiUniCastConference.preShowEthereal( );
  m_mediaDistributionCapability.preShowEthereal( );
}

PString H245_MultipointCapability::getSummary( void ) 
{
  return PString( "MultipointCapability" );
}

void H245_MultipointCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_MultipointCapability_multicastCapability, tvb, offset + m_multicastCapability.GetStartByte(), m_multicastCapability.GetByteLength() , m_multicastCapability.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_MultipointCapability_multiUniCastConference, tvb, offset + m_multiUniCastConference.GetStartByte(), m_multiUniCastConference.GetByteLength() , m_multiUniCastConference.GetValue() );

  proto_tree *mediaDistributionCapability_tree = (proto_tree*) NULL;
  proto_item *mediaDistributionCapability_ti = (proto_item*) NULL;
  mediaDistributionCapability_ti = proto_tree_add_text( tree, tvb, offset + m_mediaDistributionCapability.GetStartByte(), m_mediaDistributionCapability.GetByteLength(), "mediaDistributionCapability (MediaDistributionCapability)" );
  mediaDistributionCapability_tree = proto_item_add_subtree( mediaDistributionCapability_ti, hCont->h245_2.ett_h245_MultipointCapability_mediaDistributionCapability );

  m_mediaDistributionCapability.showEthereal( mediaDistributionCapability_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// MediaDistributionCapability
//

H245_MediaDistributionCapability::H245_MediaDistributionCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MediaDistributionCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "centralizedControl = " << setprecision(indent) << m_centralizedControl << '\n';
  strm << setw(indent+21) << "distributedControl = " << setprecision(indent) << m_distributedControl << '\n';
  strm << setw(indent+19) << "centralizedAudio = " << setprecision(indent) << m_centralizedAudio << '\n';
  strm << setw(indent+19) << "distributedAudio = " << setprecision(indent) << m_distributedAudio << '\n';
  strm << setw(indent+19) << "centralizedVideo = " << setprecision(indent) << m_centralizedVideo << '\n';
  strm << setw(indent+19) << "distributedVideo = " << setprecision(indent) << m_distributedVideo << '\n';
  if (HasOptionalField(e_centralizedData))
    strm << setw(indent+18) << "centralizedData = " << setprecision(indent) << m_centralizedData << '\n';
  if (HasOptionalField(e_distributedData))
    strm << setw(indent+18) << "distributedData = " << setprecision(indent) << m_distributedData << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MediaDistributionCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MediaDistributionCapability::Class()), PInvalidCast);
#endif
  const H245_MediaDistributionCapability & other = (const H245_MediaDistributionCapability &)obj;

  Comparison result;

  if ((result = m_centralizedControl.Compare(other.m_centralizedControl)) != EqualTo)
    return result;
  if ((result = m_distributedControl.Compare(other.m_distributedControl)) != EqualTo)
    return result;
  if ((result = m_centralizedAudio.Compare(other.m_centralizedAudio)) != EqualTo)
    return result;
  if ((result = m_distributedAudio.Compare(other.m_distributedAudio)) != EqualTo)
    return result;
  if ((result = m_centralizedVideo.Compare(other.m_centralizedVideo)) != EqualTo)
    return result;
  if ((result = m_distributedVideo.Compare(other.m_distributedVideo)) != EqualTo)
    return result;
  if ((result = m_centralizedData.Compare(other.m_centralizedData)) != EqualTo)
    return result;
  if ((result = m_distributedData.Compare(other.m_distributedData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MediaDistributionCapability::GetDataLength() const
{
  return m_centralizedControl.GetObjectLength() +
         m_distributedControl.GetObjectLength() +
         m_centralizedAudio.GetObjectLength() +
         m_distributedAudio.GetObjectLength() +
         m_centralizedVideo.GetObjectLength() +
         m_distributedVideo.GetObjectLength() +
         m_centralizedData.GetObjectLength() +
         m_distributedData.GetObjectLength();
}


BOOL H245_MediaDistributionCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_centralizedControl.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_distributedControl.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_centralizedAudio.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_distributedAudio.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_centralizedVideo.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_distributedVideo.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_centralizedData ) && !m_centralizedData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_distributedData ) && !m_distributedData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MediaDistributionCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_centralizedControl.Encode(strm);
  m_distributedControl.Encode(strm);
  m_centralizedAudio.Encode(strm);
  m_distributedAudio.Encode(strm);
  m_centralizedVideo.Encode(strm);
  m_distributedVideo.Encode(strm);
  if (HasOptionalField(e_centralizedData))
    m_centralizedData.Encode(strm);
  if (HasOptionalField(e_distributedData))
    m_distributedData.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_centralizedControl.Encode(strm);
  m_distributedControl.Encode(strm);
  m_centralizedAudio.Encode(strm);
  m_distributedAudio.Encode(strm);
  m_centralizedVideo.Encode(strm);
  m_distributedVideo.Encode(strm);
  if (HasOptionalField(e_centralizedData))
    m_centralizedData.Encode(strm);
  if (HasOptionalField(e_distributedData))
    m_distributedData.Encode(strm);
}


PObject * H245_MediaDistributionCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MediaDistributionCapability::Class()), PInvalidCast);
#endif
  return new H245_MediaDistributionCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MediaDistributionCapability::preShowEthereal( void )
{
  m_centralizedControl.preShowEthereal( );
  m_distributedControl.preShowEthereal( );
  m_centralizedAudio.preShowEthereal( );
  m_distributedAudio.preShowEthereal( );
  m_centralizedVideo.preShowEthereal( );
  m_distributedVideo.preShowEthereal( );
  if ( HasOptionalField( e_centralizedData ) ) 
      m_centralizedData.preShowEthereal( );
  if ( HasOptionalField( e_distributedData ) ) 
      m_distributedData.preShowEthereal( );
}

PString H245_MediaDistributionCapability::getSummary( void ) 
{
  return PString( "MediaDistributionCapability" );
}

void H245_MediaDistributionCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_MediaDistributionCapability_centralizedControl, tvb, offset + m_centralizedControl.GetStartByte(), m_centralizedControl.GetByteLength() , m_centralizedControl.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_MediaDistributionCapability_distributedControl, tvb, offset + m_distributedControl.GetStartByte(), m_distributedControl.GetByteLength() , m_distributedControl.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_MediaDistributionCapability_centralizedAudio, tvb, offset + m_centralizedAudio.GetStartByte(), m_centralizedAudio.GetByteLength() , m_centralizedAudio.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_MediaDistributionCapability_distributedAudio, tvb, offset + m_distributedAudio.GetStartByte(), m_distributedAudio.GetByteLength() , m_distributedAudio.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_MediaDistributionCapability_centralizedVideo, tvb, offset + m_centralizedVideo.GetStartByte(), m_centralizedVideo.GetByteLength() , m_centralizedVideo.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_MediaDistributionCapability_distributedVideo, tvb, offset + m_distributedVideo.GetStartByte(), m_distributedVideo.GetByteLength() , m_distributedVideo.GetValue() );

  if ( HasOptionalField( e_centralizedData ) ) {
    proto_tree *centralizedData_tree = (proto_tree*) NULL;
    proto_item *centralizedData_ti = (proto_item*) NULL;
    centralizedData_ti = proto_tree_add_text( tree, tvb, offset + m_centralizedData.GetStartByte(), m_centralizedData.GetByteLength(), "centralizedData (DataApplicationCapability)" );
    centralizedData_tree = proto_item_add_subtree( centralizedData_ti, hCont->h245_2.ett_h245_MediaDistributionCapability_centralizedData );
    m_centralizedData.showEthereal( centralizedData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_distributedData ) ) {
    proto_tree *distributedData_tree = (proto_tree*) NULL;
    proto_item *distributedData_ti = (proto_item*) NULL;
    distributedData_ti = proto_tree_add_text( tree, tvb, offset + m_distributedData.GetStartByte(), m_distributedData.GetByteLength(), "distributedData (DataApplicationCapability)" );
    distributedData_tree = proto_item_add_subtree( distributedData_ti, hCont->h245_2.ett_h245_MediaDistributionCapability_distributedData );
    m_distributedData.showEthereal( distributedData_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// EnhancementLayerInfo
//

H245_EnhancementLayerInfo::H245_EnhancementLayerInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
  m_snrEnhancement.SetConstraints(PASN_Object::FixedConstraint, 1, 14);
  m_spatialEnhancement.SetConstraints(PASN_Object::FixedConstraint, 1, 14);
  m_bPictureEnhancement.SetConstraints(PASN_Object::FixedConstraint, 1, 14);
}


#ifndef PASN_NOPRINTON
void H245_EnhancementLayerInfo::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+25) << "baseBitRateConstrained = " << setprecision(indent) << m_baseBitRateConstrained << '\n';
  if (HasOptionalField(e_snrEnhancement))
    strm << setw(indent+17) << "snrEnhancement = " << setprecision(indent) << m_snrEnhancement << '\n';
  if (HasOptionalField(e_spatialEnhancement))
    strm << setw(indent+21) << "spatialEnhancement = " << setprecision(indent) << m_spatialEnhancement << '\n';
  if (HasOptionalField(e_bPictureEnhancement))
    strm << setw(indent+22) << "bPictureEnhancement = " << setprecision(indent) << m_bPictureEnhancement << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_EnhancementLayerInfo::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_EnhancementLayerInfo::Class()), PInvalidCast);
#endif
  const H245_EnhancementLayerInfo & other = (const H245_EnhancementLayerInfo &)obj;

  Comparison result;

  if ((result = m_baseBitRateConstrained.Compare(other.m_baseBitRateConstrained)) != EqualTo)
    return result;
  if ((result = m_snrEnhancement.Compare(other.m_snrEnhancement)) != EqualTo)
    return result;
  if ((result = m_spatialEnhancement.Compare(other.m_spatialEnhancement)) != EqualTo)
    return result;
  if ((result = m_bPictureEnhancement.Compare(other.m_bPictureEnhancement)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_EnhancementLayerInfo::GetDataLength() const
{
  return m_baseBitRateConstrained.GetObjectLength() +
         m_snrEnhancement.GetObjectLength() +
         m_spatialEnhancement.GetObjectLength() +
         m_bPictureEnhancement.GetObjectLength();
}


BOOL H245_EnhancementLayerInfo::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_baseBitRateConstrained.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_snrEnhancement ) && !m_snrEnhancement.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_spatialEnhancement ) && !m_spatialEnhancement.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_bPictureEnhancement ) && !m_bPictureEnhancement.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_EnhancementLayerInfo::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_baseBitRateConstrained.Encode(strm);
  if (HasOptionalField(e_snrEnhancement))
    m_snrEnhancement.Encode(strm);
  if (HasOptionalField(e_spatialEnhancement))
    m_spatialEnhancement.Encode(strm);
  if (HasOptionalField(e_bPictureEnhancement))
    m_bPictureEnhancement.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_baseBitRateConstrained.Encode(strm);
  if (HasOptionalField(e_snrEnhancement))
    m_snrEnhancement.Encode(strm);
  if (HasOptionalField(e_spatialEnhancement))
    m_spatialEnhancement.Encode(strm);
  if (HasOptionalField(e_bPictureEnhancement))
    m_bPictureEnhancement.Encode(strm);
}


PObject * H245_EnhancementLayerInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EnhancementLayerInfo::Class()), PInvalidCast);
#endif
  return new H245_EnhancementLayerInfo(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_EnhancementLayerInfo::preShowEthereal( void )
{
  m_baseBitRateConstrained.preShowEthereal( );
  if ( HasOptionalField( e_snrEnhancement ) ) 
      m_snrEnhancement.preShowEthereal( );
  if ( HasOptionalField( e_spatialEnhancement ) ) 
      m_spatialEnhancement.preShowEthereal( );
  if ( HasOptionalField( e_bPictureEnhancement ) ) 
      m_bPictureEnhancement.preShowEthereal( );
}

PString H245_EnhancementLayerInfo::getSummary( void ) 
{
  return PString( "EnhancementLayerInfo" );
}

void H245_EnhancementLayerInfo::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_EnhancementLayerInfo_baseBitRateConstrained, tvb, offset + m_baseBitRateConstrained.GetStartByte(), m_baseBitRateConstrained.GetByteLength() , m_baseBitRateConstrained.GetValue() );

  if ( HasOptionalField( e_snrEnhancement ) ) {
    proto_tree *snrEnhancement_tree = (proto_tree*) NULL;
    proto_item *snrEnhancement_ti = (proto_item*) NULL;
    snrEnhancement_ti = proto_tree_add_text( tree, tvb, offset + m_snrEnhancement.GetStartByte(), m_snrEnhancement.GetByteLength(), "snrEnhancement (EnhancementOptions)" );
    snrEnhancement_tree = proto_item_add_subtree( snrEnhancement_ti, hCont->h245_2.ett_h245_EnhancementLayerInfo_snrEnhancement );
    m_snrEnhancement.showEthereal( snrEnhancement_tree, tvb, offset );
  }

  if ( HasOptionalField( e_spatialEnhancement ) ) {
    proto_tree *spatialEnhancement_tree = (proto_tree*) NULL;
    proto_item *spatialEnhancement_ti = (proto_item*) NULL;
    spatialEnhancement_ti = proto_tree_add_text( tree, tvb, offset + m_spatialEnhancement.GetStartByte(), m_spatialEnhancement.GetByteLength(), "spatialEnhancement (EnhancementOptions)" );
    spatialEnhancement_tree = proto_item_add_subtree( spatialEnhancement_ti, hCont->h245_2.ett_h245_EnhancementLayerInfo_spatialEnhancement );
    m_spatialEnhancement.showEthereal( spatialEnhancement_tree, tvb, offset );
  }

  if ( HasOptionalField( e_bPictureEnhancement ) ) {
    proto_tree *bPictureEnhancement_tree = (proto_tree*) NULL;
    proto_item *bPictureEnhancement_ti = (proto_item*) NULL;
    bPictureEnhancement_ti = proto_tree_add_text( tree, tvb, offset + m_bPictureEnhancement.GetStartByte(), m_bPictureEnhancement.GetByteLength(), "bPictureEnhancement (BEnhancementParameters)" );
    bPictureEnhancement_tree = proto_item_add_subtree( bPictureEnhancement_ti, hCont->h245_2.ett_h245_EnhancementLayerInfo_bPictureEnhancement );
    m_bPictureEnhancement.showEthereal( bPictureEnhancement_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// RefPictureSelection
//

H245_RefPictureSelection::H245_RefPictureSelection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RefPictureSelection::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_additionalPictureMemory))
    strm << setw(indent+26) << "additionalPictureMemory = " << setprecision(indent) << m_additionalPictureMemory << '\n';
  strm << setw(indent+11) << "videoMux = " << setprecision(indent) << m_videoMux << '\n';
  strm << setw(indent+23) << "videoBackChannelSend = " << setprecision(indent) << m_videoBackChannelSend << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RefPictureSelection::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RefPictureSelection::Class()), PInvalidCast);
#endif
  const H245_RefPictureSelection & other = (const H245_RefPictureSelection &)obj;

  Comparison result;

  if ((result = m_additionalPictureMemory.Compare(other.m_additionalPictureMemory)) != EqualTo)
    return result;
  if ((result = m_videoMux.Compare(other.m_videoMux)) != EqualTo)
    return result;
  if ((result = m_videoBackChannelSend.Compare(other.m_videoBackChannelSend)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RefPictureSelection::GetDataLength() const
{
  return m_additionalPictureMemory.GetObjectLength() +
         m_videoMux.GetObjectLength() +
         m_videoBackChannelSend.GetObjectLength();
}


BOOL H245_RefPictureSelection::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_additionalPictureMemory ) && !m_additionalPictureMemory.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_videoMux.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_videoBackChannelSend.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RefPictureSelection::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_additionalPictureMemory))
    m_additionalPictureMemory.Encode(strm);
  m_videoMux.Encode(strm);
  m_videoBackChannelSend.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_additionalPictureMemory))
    m_additionalPictureMemory.Encode(strm);
  m_videoMux.Encode(strm);
  m_videoBackChannelSend.Encode(strm);
}


PObject * H245_RefPictureSelection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RefPictureSelection::Class()), PInvalidCast);
#endif
  return new H245_RefPictureSelection(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RefPictureSelection::preShowEthereal( void )
{
  if ( HasOptionalField( e_additionalPictureMemory ) ) 
      m_additionalPictureMemory.preShowEthereal( );
  m_videoMux.preShowEthereal( );
  m_videoBackChannelSend.preShowEthereal( );
}

PString H245_RefPictureSelection::getSummary( void ) 
{
  return PString( "RefPictureSelection" );
}

void H245_RefPictureSelection::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_additionalPictureMemory ) ) {
    proto_tree *additionalPictureMemory_tree = (proto_tree*) NULL;
    proto_item *additionalPictureMemory_ti = (proto_item*) NULL;
    additionalPictureMemory_ti = proto_tree_add_text( tree, tvb, offset + m_additionalPictureMemory.GetStartByte(), m_additionalPictureMemory.GetByteLength(), "additionalPictureMemory (RefPictureSelection-additionalPictureMemory)" );
    additionalPictureMemory_tree = proto_item_add_subtree( additionalPictureMemory_ti, hCont->h245_2.ett_h245_RefPictureSelection_additionalPictureMemory );
    m_additionalPictureMemory.showEthereal( additionalPictureMemory_tree, tvb, offset );
  }

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_RefPictureSelection_videoMux, tvb, offset + m_videoMux.GetStartByte(), m_videoMux.GetByteLength() , m_videoMux.GetValue() );

  proto_tree *videoBackChannelSend_tree = (proto_tree*) NULL;
  proto_item *videoBackChannelSend_ti = (proto_item*) NULL;
  videoBackChannelSend_ti = proto_tree_add_text( tree, tvb, offset + m_videoBackChannelSend.GetStartByte(), m_videoBackChannelSend.GetByteLength(), "videoBackChannelSend (%s)", ( const char* ) m_videoBackChannelSend.GetTagName() );
  videoBackChannelSend_tree = proto_item_add_subtree( videoBackChannelSend_ti, hCont->h245_2.ett_h245_RefPictureSelection_videoBackChannelSend );

  m_videoBackChannelSend.showEthereal( videoBackChannelSend_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// H263VideoModeCombos
//

H245_H263VideoModeCombos::H245_H263VideoModeCombos(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_h263VideoCoupledModes.SetConstraints(PASN_Object::FixedConstraint, 1, 16);
}


#ifndef PASN_NOPRINTON
void H245_H263VideoModeCombos::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+26) << "h263VideoUncoupledModes = " << setprecision(indent) << m_h263VideoUncoupledModes << '\n';
  strm << setw(indent+24) << "h263VideoCoupledModes = " << setprecision(indent) << m_h263VideoCoupledModes << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H263VideoModeCombos::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H263VideoModeCombos::Class()), PInvalidCast);
#endif
  const H245_H263VideoModeCombos & other = (const H245_H263VideoModeCombos &)obj;

  Comparison result;

  if ((result = m_h263VideoUncoupledModes.Compare(other.m_h263VideoUncoupledModes)) != EqualTo)
    return result;
  if ((result = m_h263VideoCoupledModes.Compare(other.m_h263VideoCoupledModes)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H263VideoModeCombos::GetDataLength() const
{
  return m_h263VideoUncoupledModes.GetObjectLength() +
         m_h263VideoCoupledModes.GetObjectLength();
}


BOOL H245_H263VideoModeCombos::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_h263VideoUncoupledModes.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_h263VideoCoupledModes.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H263VideoModeCombos::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_h263VideoUncoupledModes.Encode(strm);
  m_h263VideoCoupledModes.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_h263VideoUncoupledModes.Encode(strm);
  m_h263VideoCoupledModes.Encode(strm);
}


PObject * H245_H263VideoModeCombos::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H263VideoModeCombos::Class()), PInvalidCast);
#endif
  return new H245_H263VideoModeCombos(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H263VideoModeCombos::preShowEthereal( void )
{
  m_h263VideoUncoupledModes.preShowEthereal( );
  m_h263VideoCoupledModes.preShowEthereal( );
}

PString H245_H263VideoModeCombos::getSummary( void ) 
{
  return PString( "H263VideoModeCombos" );
}

void H245_H263VideoModeCombos::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *h263VideoUncoupledModes_tree = (proto_tree*) NULL;
  proto_item *h263VideoUncoupledModes_ti = (proto_item*) NULL;
  h263VideoUncoupledModes_ti = proto_tree_add_text( tree, tvb, offset + m_h263VideoUncoupledModes.GetStartByte(), m_h263VideoUncoupledModes.GetByteLength(), "h263VideoUncoupledModes (H263ModeComboFlags)" );
  h263VideoUncoupledModes_tree = proto_item_add_subtree( h263VideoUncoupledModes_ti, hCont->h245_2.ett_h245_H263VideoModeCombos_h263VideoUncoupledModes );

  m_h263VideoUncoupledModes.showEthereal( h263VideoUncoupledModes_tree, tvb, offset );

  proto_tree *h263VideoCoupledModes_tree = (proto_tree*) NULL;
  proto_item *h263VideoCoupledModes_ti = (proto_item*) NULL;
  h263VideoCoupledModes_ti = proto_tree_add_text( tree, tvb, offset + m_h263VideoCoupledModes.GetStartByte(), m_h263VideoCoupledModes.GetByteLength(), "h263VideoCoupledModes (H263ModeComboFlags)" );
  h263VideoCoupledModes_tree = proto_item_add_subtree( h263VideoCoupledModes_ti, hCont->h245_2.ett_h245_H263VideoModeCombos_h263VideoCoupledModes );

  m_h263VideoCoupledModes.showEthereal( h263VideoCoupledModes_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// G7231AnnexCCapability
//

H245_G7231AnnexCCapability::H245_G7231AnnexCCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_maxAl_sduAudioFrames.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_G7231AnnexCCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "maxAl_sduAudioFrames = " << setprecision(indent) << m_maxAl_sduAudioFrames << '\n';
  strm << setw(indent+21) << "silenceSuppression = " << setprecision(indent) << m_silenceSuppression << '\n';
  if (HasOptionalField(e_g723AnnexCAudioMode))
    strm << setw(indent+22) << "g723AnnexCAudioMode = " << setprecision(indent) << m_g723AnnexCAudioMode << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_G7231AnnexCCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_G7231AnnexCCapability::Class()), PInvalidCast);
#endif
  const H245_G7231AnnexCCapability & other = (const H245_G7231AnnexCCapability &)obj;

  Comparison result;

  if ((result = m_maxAl_sduAudioFrames.Compare(other.m_maxAl_sduAudioFrames)) != EqualTo)
    return result;
  if ((result = m_silenceSuppression.Compare(other.m_silenceSuppression)) != EqualTo)
    return result;
  if ((result = m_g723AnnexCAudioMode.Compare(other.m_g723AnnexCAudioMode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_G7231AnnexCCapability::GetDataLength() const
{
  return m_maxAl_sduAudioFrames.GetObjectLength() +
         m_silenceSuppression.GetObjectLength() +
         m_g723AnnexCAudioMode.GetObjectLength();
}


BOOL H245_G7231AnnexCCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maxAl_sduAudioFrames.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_silenceSuppression.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_g723AnnexCAudioMode ) && !m_g723AnnexCAudioMode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_G7231AnnexCCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_maxAl_sduAudioFrames.Encode(strm);
  m_silenceSuppression.Encode(strm);
  if (HasOptionalField(e_g723AnnexCAudioMode))
    m_g723AnnexCAudioMode.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_maxAl_sduAudioFrames.Encode(strm);
  m_silenceSuppression.Encode(strm);
  if (HasOptionalField(e_g723AnnexCAudioMode))
    m_g723AnnexCAudioMode.Encode(strm);
}


PObject * H245_G7231AnnexCCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_G7231AnnexCCapability::Class()), PInvalidCast);
#endif
  return new H245_G7231AnnexCCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_G7231AnnexCCapability::preShowEthereal( void )
{
  m_maxAl_sduAudioFrames.preShowEthereal( );
  m_silenceSuppression.preShowEthereal( );
  if ( HasOptionalField( e_g723AnnexCAudioMode ) ) 
      m_g723AnnexCAudioMode.preShowEthereal( );
}

PString H245_G7231AnnexCCapability::getSummary( void ) 
{
  return PString( "G7231AnnexCCapability" );
}

void H245_G7231AnnexCCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_G7231AnnexCCapability_maxAl_sduAudioFrames, tvb, offset + m_maxAl_sduAudioFrames.GetStartByte(), m_maxAl_sduAudioFrames.GetByteLength() , m_maxAl_sduAudioFrames.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_G7231AnnexCCapability_silenceSuppression, tvb, offset + m_silenceSuppression.GetStartByte(), m_silenceSuppression.GetByteLength() , m_silenceSuppression.GetValue() );

  if ( HasOptionalField( e_g723AnnexCAudioMode ) ) {
    proto_tree *g723AnnexCAudioMode_tree = (proto_tree*) NULL;
    proto_item *g723AnnexCAudioMode_ti = (proto_item*) NULL;
    g723AnnexCAudioMode_ti = proto_tree_add_text( tree, tvb, offset + m_g723AnnexCAudioMode.GetStartByte(), m_g723AnnexCAudioMode.GetByteLength(), "g723AnnexCAudioMode (G7231AnnexCCapability-g723AnnexCAudioMode)" );
    g723AnnexCAudioMode_tree = proto_item_add_subtree( g723AnnexCAudioMode_ti, hCont->h245_2.ett_h245_G7231AnnexCCapability_g723AnnexCAudioMode );
    m_g723AnnexCAudioMode.showEthereal( g723AnnexCAudioMode_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// DataApplicationCapability
//

H245_DataApplicationCapability::H245_DataApplicationCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_maxBitRate.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H245_DataApplicationCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "application = " << setprecision(indent) << m_application << '\n';
  strm << setw(indent+13) << "maxBitRate = " << setprecision(indent) << m_maxBitRate << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_DataApplicationCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_DataApplicationCapability::Class()), PInvalidCast);
#endif
  const H245_DataApplicationCapability & other = (const H245_DataApplicationCapability &)obj;

  Comparison result;

  if ((result = m_application.Compare(other.m_application)) != EqualTo)
    return result;
  if ((result = m_maxBitRate.Compare(other.m_maxBitRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DataApplicationCapability::GetDataLength() const
{
  return m_application.GetObjectLength() +
         m_maxBitRate.GetObjectLength();
}


BOOL H245_DataApplicationCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_application.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maxBitRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_DataApplicationCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_application.Encode(strm);
  m_maxBitRate.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_application.Encode(strm);
  m_maxBitRate.Encode(strm);
}


PObject * H245_DataApplicationCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataApplicationCapability::Class()), PInvalidCast);
#endif
  return new H245_DataApplicationCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_DataApplicationCapability::preShowEthereal( void )
{
  m_application.preShowEthereal( );
  m_maxBitRate.preShowEthereal( );
}

PString H245_DataApplicationCapability::getSummary( void ) 
{
  return PString( "DataApplicationCapability" );
}

void H245_DataApplicationCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *application_tree = (proto_tree*) NULL;
  proto_item *application_ti = (proto_item*) NULL;
  application_ti = proto_tree_add_text( tree, tvb, offset + m_application.GetStartByte(), m_application.GetByteLength(), "application (%s)", ( const char* ) m_application.GetTagName() );
  application_tree = proto_item_add_subtree( application_ti, hCont->h245_2.ett_h245_DataApplicationCapability_application );

  m_application.showEthereal( application_tree, tvb, offset );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_DataApplicationCapability_maxBitRate, tvb, offset + m_maxBitRate.GetStartByte(), m_maxBitRate.GetByteLength() , m_maxBitRate.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// AuthenticationCapability
//

H245_AuthenticationCapability::H245_AuthenticationCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_AuthenticationCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandard))
    strm << setw(indent+14) << "nonStandard = " << setprecision(indent) << m_nonStandard << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_AuthenticationCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_AuthenticationCapability::Class()), PInvalidCast);
#endif
  const H245_AuthenticationCapability & other = (const H245_AuthenticationCapability &)obj;

  Comparison result;

  if ((result = m_nonStandard.Compare(other.m_nonStandard)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_AuthenticationCapability::GetDataLength() const
{
  return m_nonStandard.GetObjectLength();
}


BOOL H245_AuthenticationCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandard ) && !m_nonStandard.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_AuthenticationCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
}


PObject * H245_AuthenticationCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_AuthenticationCapability::Class()), PInvalidCast);
#endif
  return new H245_AuthenticationCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_AuthenticationCapability::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandard ) ) 
      m_nonStandard.preShowEthereal( );
}

PString H245_AuthenticationCapability::getSummary( void ) 
{
  return PString( "AuthenticationCapability" );
}

void H245_AuthenticationCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandard ) ) {
    proto_tree *nonStandard_tree = (proto_tree*) NULL;
    proto_item *nonStandard_ti = (proto_item*) NULL;
    nonStandard_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandard.GetStartByte(), m_nonStandard.GetByteLength(), "nonStandard (NonStandardParameter)" );
    nonStandard_tree = proto_item_add_subtree( nonStandard_ti, hCont->h245_2.ett_h245_AuthenticationCapability_nonStandard );
    m_nonStandard.showEthereal( nonStandard_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// IntegrityCapability
//

H245_IntegrityCapability::H245_IntegrityCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_IntegrityCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandard))
    strm << setw(indent+14) << "nonStandard = " << setprecision(indent) << m_nonStandard << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_IntegrityCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_IntegrityCapability::Class()), PInvalidCast);
#endif
  const H245_IntegrityCapability & other = (const H245_IntegrityCapability &)obj;

  Comparison result;

  if ((result = m_nonStandard.Compare(other.m_nonStandard)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_IntegrityCapability::GetDataLength() const
{
  return m_nonStandard.GetObjectLength();
}


BOOL H245_IntegrityCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandard ) && !m_nonStandard.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_IntegrityCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
}


PObject * H245_IntegrityCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IntegrityCapability::Class()), PInvalidCast);
#endif
  return new H245_IntegrityCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_IntegrityCapability::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandard ) ) 
      m_nonStandard.preShowEthereal( );
}

PString H245_IntegrityCapability::getSummary( void ) 
{
  return PString( "IntegrityCapability" );
}

void H245_IntegrityCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandard ) ) {
    proto_tree *nonStandard_tree = (proto_tree*) NULL;
    proto_item *nonStandard_ti = (proto_item*) NULL;
    nonStandard_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandard.GetStartByte(), m_nonStandard.GetByteLength(), "nonStandard (NonStandardParameter)" );
    nonStandard_tree = proto_item_add_subtree( nonStandard_ti, hCont->h245_2.ett_h245_IntegrityCapability_nonStandard );
    m_nonStandard.showEthereal( nonStandard_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// ConferenceCapability
//

H245_ConferenceCapability::H245_ConferenceCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_ConferenceCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+25) << "chairControlCapability = " << setprecision(indent) << m_chairControlCapability << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_ConferenceCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_ConferenceCapability::Class()), PInvalidCast);
#endif
  const H245_ConferenceCapability & other = (const H245_ConferenceCapability &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_chairControlCapability.Compare(other.m_chairControlCapability)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ConferenceCapability::GetDataLength() const
{
  return m_nonStandardData.GetObjectLength() +
         m_chairControlCapability.GetObjectLength();
}


BOOL H245_ConferenceCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_chairControlCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_ConferenceCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_chairControlCapability.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_chairControlCapability.Encode(strm);
}


PObject * H245_ConferenceCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceCapability::Class()), PInvalidCast);
#endif
  return new H245_ConferenceCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ConferenceCapability::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  m_chairControlCapability.preShowEthereal( );
}

PString H245_ConferenceCapability::getSummary( void ) 
{
  return PString( "ConferenceCapability" );
}

void H245_ConferenceCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h245_2.ett_h245_ConferenceCapability_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_ConferenceCapability_chairControlCapability, tvb, offset + m_chairControlCapability.GetStartByte(), m_chairControlCapability.GetByteLength() , m_chairControlCapability.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// NetworkAccessParameters
//

H245_NetworkAccessParameters::H245_NetworkAccessParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 1)
{
  m_externalReference.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
}


#ifndef PASN_NOPRINTON
void H245_NetworkAccessParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_distribution))
    strm << setw(indent+15) << "distribution = " << setprecision(indent) << m_distribution << '\n';
  strm << setw(indent+17) << "networkAddress = " << setprecision(indent) << m_networkAddress << '\n';
  strm << setw(indent+22) << "associateConference = " << setprecision(indent) << m_associateConference << '\n';
  if (HasOptionalField(e_externalReference))
    strm << setw(indent+20) << "externalReference = " << setprecision(indent) << m_externalReference << '\n';
  if (HasOptionalField(e_t120SetupProcedure))
    strm << setw(indent+21) << "t120SetupProcedure = " << setprecision(indent) << m_t120SetupProcedure << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_NetworkAccessParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_NetworkAccessParameters::Class()), PInvalidCast);
#endif
  const H245_NetworkAccessParameters & other = (const H245_NetworkAccessParameters &)obj;

  Comparison result;

  if ((result = m_distribution.Compare(other.m_distribution)) != EqualTo)
    return result;
  if ((result = m_networkAddress.Compare(other.m_networkAddress)) != EqualTo)
    return result;
  if ((result = m_associateConference.Compare(other.m_associateConference)) != EqualTo)
    return result;
  if ((result = m_externalReference.Compare(other.m_externalReference)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NetworkAccessParameters::GetDataLength() const
{
  return m_distribution.GetObjectLength() +
         m_networkAddress.GetObjectLength() +
         m_associateConference.GetObjectLength() +
         m_externalReference.GetObjectLength();
}


BOOL H245_NetworkAccessParameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_distribution ) && !m_distribution.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_networkAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_associateConference.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_externalReference ) && !m_externalReference.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_t120SetupProcedure, m_t120SetupProcedure ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_NetworkAccessParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_distribution))
    m_distribution.Encode(strm);
  m_networkAddress.Encode(strm);
  m_associateConference.Encode(strm);
  if (HasOptionalField(e_externalReference))
    m_externalReference.Encode(strm);
  KnownExtensionEncode(strm, e_t120SetupProcedure, m_t120SetupProcedure);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_distribution))
    m_distribution.Encode(strm);
  m_networkAddress.Encode(strm);
  m_associateConference.Encode(strm);
  if (HasOptionalField(e_externalReference))
    m_externalReference.Encode(strm);
}


PObject * H245_NetworkAccessParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NetworkAccessParameters::Class()), PInvalidCast);
#endif
  return new H245_NetworkAccessParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NetworkAccessParameters::preShowEthereal( void )
{
  if ( HasOptionalField( e_distribution ) ) 
      m_distribution.preShowEthereal( );
  m_networkAddress.preShowEthereal( );
  m_associateConference.preShowEthereal( );
  if ( HasOptionalField( e_externalReference ) ) 
      m_externalReference.preShowEthereal( );
  if ( HasOptionalField( e_t120SetupProcedure ) ) 
      m_t120SetupProcedure.preShowEthereal( );
}

PString H245_NetworkAccessParameters::getSummary( void ) 
{
  return PString( "NetworkAccessParameters" );
}

void H245_NetworkAccessParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_distribution ) ) {
    proto_tree *distribution_tree = (proto_tree*) NULL;
    proto_item *distribution_ti = (proto_item*) NULL;
    distribution_ti = proto_tree_add_text( tree, tvb, offset + m_distribution.GetStartByte(), m_distribution.GetByteLength(), "distribution (%s)", ( const char* ) m_distribution.GetTagName() );
    distribution_tree = proto_item_add_subtree( distribution_ti, hCont->h245_2.ett_h245_NetworkAccessParameters_distribution );
    m_distribution.showEthereal( distribution_tree, tvb, offset );
  }

  proto_tree *networkAddress_tree = (proto_tree*) NULL;
  proto_item *networkAddress_ti = (proto_item*) NULL;
  networkAddress_ti = proto_tree_add_text( tree, tvb, offset + m_networkAddress.GetStartByte(), m_networkAddress.GetByteLength(), "networkAddress (%s)", ( const char* ) m_networkAddress.GetTagName() );
  networkAddress_tree = proto_item_add_subtree( networkAddress_ti, hCont->h245_2.ett_h245_NetworkAccessParameters_networkAddress );

  m_networkAddress.showEthereal( networkAddress_tree, tvb, offset );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_NetworkAccessParameters_associateConference, tvb, offset + m_associateConference.GetStartByte(), m_associateConference.GetByteLength() , m_associateConference.GetValue() );

  if ( HasOptionalField( e_externalReference ) ) {
    char* pexternalReference = m_externalReference.getValue();
    proto_tree_add_string( tree, hCont->h245_2.hf_h245_NetworkAccessParameters_externalReference, tvb, offset + m_externalReference.GetStartByte(), m_externalReference.GetByteLength() , pexternalReference );
    delete[] pexternalReference;
  }

  if ( HasOptionalField( e_t120SetupProcedure ) ) {
    proto_tree *t120SetupProcedure_tree = (proto_tree*) NULL;
    proto_item *t120SetupProcedure_ti = (proto_item*) NULL;
    t120SetupProcedure_ti = proto_tree_add_text( tree, tvb, offset + m_t120SetupProcedure.GetStartByte(), m_t120SetupProcedure.GetByteLength(), "t120SetupProcedure (%s)", ( const char* ) m_t120SetupProcedure.GetTagName() );
    t120SetupProcedure_tree = proto_item_add_subtree( t120SetupProcedure_ti, hCont->h245_2.ett_h245_NetworkAccessParameters_t120SetupProcedure );
    m_t120SetupProcedure.showEthereal( t120SetupProcedure_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// Q2931Address
//

H245_Q2931Address::H245_Q2931Address(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_subaddress.SetConstraints(PASN_Object::FixedConstraint, 1, 20);
}


#ifndef PASN_NOPRINTON
void H245_Q2931Address::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "address = " << setprecision(indent) << m_address << '\n';
  if (HasOptionalField(e_subaddress))
    strm << setw(indent+13) << "subaddress = " << setprecision(indent) << m_subaddress << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_Q2931Address::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_Q2931Address::Class()), PInvalidCast);
#endif
  const H245_Q2931Address & other = (const H245_Q2931Address &)obj;

  Comparison result;

  if ((result = m_address.Compare(other.m_address)) != EqualTo)
    return result;
  if ((result = m_subaddress.Compare(other.m_subaddress)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_Q2931Address::GetDataLength() const
{
  return m_address.GetObjectLength() +
         m_subaddress.GetObjectLength();
}


BOOL H245_Q2931Address::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_address.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_subaddress ) && !m_subaddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_Q2931Address::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_address.Encode(strm);
  if (HasOptionalField(e_subaddress))
    m_subaddress.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_address.Encode(strm);
  if (HasOptionalField(e_subaddress))
    m_subaddress.Encode(strm);
}


PObject * H245_Q2931Address::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_Q2931Address::Class()), PInvalidCast);
#endif
  return new H245_Q2931Address(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_Q2931Address::preShowEthereal( void )
{
  m_address.preShowEthereal( );
  if ( HasOptionalField( e_subaddress ) ) 
      m_subaddress.preShowEthereal( );
}

PString H245_Q2931Address::getSummary( void ) 
{
  return PString( "Q2931Address" );
}

void H245_Q2931Address::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *address_tree = (proto_tree*) NULL;
  proto_item *address_ti = (proto_item*) NULL;
  address_ti = proto_tree_add_text( tree, tvb, offset + m_address.GetStartByte(), m_address.GetByteLength(), "address (%s)", ( const char* ) m_address.GetTagName() );
  address_tree = proto_item_add_subtree( address_ti, hCont->h245_2.ett_h245_Q2931Address_address );

  m_address.showEthereal( address_tree, tvb, offset );

  if ( HasOptionalField( e_subaddress ) ) {
    char* psubaddress = m_subaddress.getValue();
    proto_tree_add_string( tree, hCont->h245_2.hf_h245_Q2931Address_subaddress, tvb, offset + m_subaddress.GetStartByte(), m_subaddress.GetByteLength() , psubaddress );
    delete[] psubaddress;
  }

}
#endif  //USE_FOR_ETHEREAL

//
// H223LogicalChannelParameters
//

H245_H223LogicalChannelParameters::H245_H223LogicalChannelParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_H223LogicalChannelParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "adaptationLayerType = " << setprecision(indent) << m_adaptationLayerType << '\n';
  strm << setw(indent+18) << "segmentableFlag = " << setprecision(indent) << m_segmentableFlag << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H223LogicalChannelParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H223LogicalChannelParameters::Class()), PInvalidCast);
#endif
  const H245_H223LogicalChannelParameters & other = (const H245_H223LogicalChannelParameters &)obj;

  Comparison result;

  if ((result = m_adaptationLayerType.Compare(other.m_adaptationLayerType)) != EqualTo)
    return result;
  if ((result = m_segmentableFlag.Compare(other.m_segmentableFlag)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223LogicalChannelParameters::GetDataLength() const
{
  return m_adaptationLayerType.GetObjectLength() +
         m_segmentableFlag.GetObjectLength();
}


BOOL H245_H223LogicalChannelParameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_adaptationLayerType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_segmentableFlag.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H223LogicalChannelParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_adaptationLayerType.Encode(strm);
  m_segmentableFlag.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_adaptationLayerType.Encode(strm);
  m_segmentableFlag.Encode(strm);
}


PObject * H245_H223LogicalChannelParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return new H245_H223LogicalChannelParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223LogicalChannelParameters::preShowEthereal( void )
{
  m_adaptationLayerType.preShowEthereal( );
  m_segmentableFlag.preShowEthereal( );
}

PString H245_H223LogicalChannelParameters::getSummary( void ) 
{
  return PString( "H223LogicalChannelParameters" );
}

void H245_H223LogicalChannelParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *adaptationLayerType_tree = (proto_tree*) NULL;
  proto_item *adaptationLayerType_ti = (proto_item*) NULL;
  adaptationLayerType_ti = proto_tree_add_text( tree, tvb, offset + m_adaptationLayerType.GetStartByte(), m_adaptationLayerType.GetByteLength(), "adaptationLayerType (%s)", ( const char* ) m_adaptationLayerType.GetTagName() );
  adaptationLayerType_tree = proto_item_add_subtree( adaptationLayerType_ti, hCont->h245_2.ett_h245_H223LogicalChannelParameters_adaptationLayerType );

  m_adaptationLayerType.showEthereal( adaptationLayerType_tree, tvb, offset );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H223LogicalChannelParameters_segmentableFlag, tvb, offset + m_segmentableFlag.GetStartByte(), m_segmentableFlag.GetByteLength() , m_segmentableFlag.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// H223AL1MParameters
//

H245_H223AL1MParameters::H245_H223AL1MParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_rcpcCodeRate.SetConstraints(PASN_Object::FixedConstraint, 8, 32);
}


#ifndef PASN_NOPRINTON
void H245_H223AL1MParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "transferMode = " << setprecision(indent) << m_transferMode << '\n';
  strm << setw(indent+12) << "headerFEC = " << setprecision(indent) << m_headerFEC << '\n';
  strm << setw(indent+12) << "crcLength = " << setprecision(indent) << m_crcLength << '\n';
  strm << setw(indent+15) << "rcpcCodeRate = " << setprecision(indent) << m_rcpcCodeRate << '\n';
  strm << setw(indent+10) << "arqType = " << setprecision(indent) << m_arqType << '\n';
  strm << setw(indent+20) << "alpduInterleaving = " << setprecision(indent) << m_alpduInterleaving << '\n';
  strm << setw(indent+17) << "alsduSplitting = " << setprecision(indent) << m_alsduSplitting << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H223AL1MParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H223AL1MParameters::Class()), PInvalidCast);
#endif
  const H245_H223AL1MParameters & other = (const H245_H223AL1MParameters &)obj;

  Comparison result;

  if ((result = m_transferMode.Compare(other.m_transferMode)) != EqualTo)
    return result;
  if ((result = m_headerFEC.Compare(other.m_headerFEC)) != EqualTo)
    return result;
  if ((result = m_crcLength.Compare(other.m_crcLength)) != EqualTo)
    return result;
  if ((result = m_rcpcCodeRate.Compare(other.m_rcpcCodeRate)) != EqualTo)
    return result;
  if ((result = m_arqType.Compare(other.m_arqType)) != EqualTo)
    return result;
  if ((result = m_alpduInterleaving.Compare(other.m_alpduInterleaving)) != EqualTo)
    return result;
  if ((result = m_alsduSplitting.Compare(other.m_alsduSplitting)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223AL1MParameters::GetDataLength() const
{
  return m_transferMode.GetObjectLength() +
         m_headerFEC.GetObjectLength() +
         m_crcLength.GetObjectLength() +
         m_rcpcCodeRate.GetObjectLength() +
         m_arqType.GetObjectLength() +
         m_alpduInterleaving.GetObjectLength() +
         m_alsduSplitting.GetObjectLength();
}


BOOL H245_H223AL1MParameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_transferMode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_headerFEC.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_crcLength.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_rcpcCodeRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_arqType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_alpduInterleaving.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_alsduSplitting.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H223AL1MParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_transferMode.Encode(strm);
  m_headerFEC.Encode(strm);
  m_crcLength.Encode(strm);
  m_rcpcCodeRate.Encode(strm);
  m_arqType.Encode(strm);
  m_alpduInterleaving.Encode(strm);
  m_alsduSplitting.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_transferMode.Encode(strm);
  m_headerFEC.Encode(strm);
  m_crcLength.Encode(strm);
  m_rcpcCodeRate.Encode(strm);
  m_arqType.Encode(strm);
  m_alpduInterleaving.Encode(strm);
  m_alsduSplitting.Encode(strm);
}


PObject * H245_H223AL1MParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AL1MParameters::Class()), PInvalidCast);
#endif
  return new H245_H223AL1MParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223AL1MParameters::preShowEthereal( void )
{
  m_transferMode.preShowEthereal( );
  m_headerFEC.preShowEthereal( );
  m_crcLength.preShowEthereal( );
  m_rcpcCodeRate.preShowEthereal( );
  m_arqType.preShowEthereal( );
  m_alpduInterleaving.preShowEthereal( );
  m_alsduSplitting.preShowEthereal( );
}

PString H245_H223AL1MParameters::getSummary( void ) 
{
  return PString( "H223AL1MParameters" );
}

void H245_H223AL1MParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *transferMode_tree = (proto_tree*) NULL;
  proto_item *transferMode_ti = (proto_item*) NULL;
  transferMode_ti = proto_tree_add_text( tree, tvb, offset + m_transferMode.GetStartByte(), m_transferMode.GetByteLength(), "transferMode (%s)", ( const char* ) m_transferMode.GetTagName() );
  transferMode_tree = proto_item_add_subtree( transferMode_ti, hCont->h245_2.ett_h245_H223AL1MParameters_transferMode );

  m_transferMode.showEthereal( transferMode_tree, tvb, offset );

  proto_tree *headerFEC_tree = (proto_tree*) NULL;
  proto_item *headerFEC_ti = (proto_item*) NULL;
  headerFEC_ti = proto_tree_add_text( tree, tvb, offset + m_headerFEC.GetStartByte(), m_headerFEC.GetByteLength(), "headerFEC (%s)", ( const char* ) m_headerFEC.GetTagName() );
  headerFEC_tree = proto_item_add_subtree( headerFEC_ti, hCont->h245_2.ett_h245_H223AL1MParameters_headerFEC );

  m_headerFEC.showEthereal( headerFEC_tree, tvb, offset );

  proto_tree *crcLength_tree = (proto_tree*) NULL;
  proto_item *crcLength_ti = (proto_item*) NULL;
  crcLength_ti = proto_tree_add_text( tree, tvb, offset + m_crcLength.GetStartByte(), m_crcLength.GetByteLength(), "crcLength (%s)", ( const char* ) m_crcLength.GetTagName() );
  crcLength_tree = proto_item_add_subtree( crcLength_ti, hCont->h245_2.ett_h245_H223AL1MParameters_crcLength );

  m_crcLength.showEthereal( crcLength_tree, tvb, offset );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_H223AL1MParameters_rcpcCodeRate, tvb, offset + m_rcpcCodeRate.GetStartByte(), m_rcpcCodeRate.GetByteLength() , m_rcpcCodeRate.GetValue() );

  proto_tree *arqType_tree = (proto_tree*) NULL;
  proto_item *arqType_ti = (proto_item*) NULL;
  arqType_ti = proto_tree_add_text( tree, tvb, offset + m_arqType.GetStartByte(), m_arqType.GetByteLength(), "arqType (%s)", ( const char* ) m_arqType.GetTagName() );
  arqType_tree = proto_item_add_subtree( arqType_ti, hCont->h245_2.ett_h245_H223AL1MParameters_arqType );

  m_arqType.showEthereal( arqType_tree, tvb, offset );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H223AL1MParameters_alpduInterleaving, tvb, offset + m_alpduInterleaving.GetStartByte(), m_alpduInterleaving.GetByteLength() , m_alpduInterleaving.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H223AL1MParameters_alsduSplitting, tvb, offset + m_alsduSplitting.GetStartByte(), m_alsduSplitting.GetByteLength() , m_alsduSplitting.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// H223AL2MParameters
//

H245_H223AL2MParameters::H245_H223AL2MParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_H223AL2MParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "headerFEC = " << setprecision(indent) << m_headerFEC << '\n';
  strm << setw(indent+20) << "alpduInterleaving = " << setprecision(indent) << m_alpduInterleaving << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H223AL2MParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H223AL2MParameters::Class()), PInvalidCast);
#endif
  const H245_H223AL2MParameters & other = (const H245_H223AL2MParameters &)obj;

  Comparison result;

  if ((result = m_headerFEC.Compare(other.m_headerFEC)) != EqualTo)
    return result;
  if ((result = m_alpduInterleaving.Compare(other.m_alpduInterleaving)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223AL2MParameters::GetDataLength() const
{
  return m_headerFEC.GetObjectLength() +
         m_alpduInterleaving.GetObjectLength();
}


BOOL H245_H223AL2MParameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_headerFEC.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_alpduInterleaving.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H223AL2MParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_headerFEC.Encode(strm);
  m_alpduInterleaving.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_headerFEC.Encode(strm);
  m_alpduInterleaving.Encode(strm);
}


PObject * H245_H223AL2MParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AL2MParameters::Class()), PInvalidCast);
#endif
  return new H245_H223AL2MParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223AL2MParameters::preShowEthereal( void )
{
  m_headerFEC.preShowEthereal( );
  m_alpduInterleaving.preShowEthereal( );
}

PString H245_H223AL2MParameters::getSummary( void ) 
{
  return PString( "H223AL2MParameters" );
}

void H245_H223AL2MParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *headerFEC_tree = (proto_tree*) NULL;
  proto_item *headerFEC_ti = (proto_item*) NULL;
  headerFEC_ti = proto_tree_add_text( tree, tvb, offset + m_headerFEC.GetStartByte(), m_headerFEC.GetByteLength(), "headerFEC (%s)", ( const char* ) m_headerFEC.GetTagName() );
  headerFEC_tree = proto_item_add_subtree( headerFEC_ti, hCont->h245_2.ett_h245_H223AL2MParameters_headerFEC );

  m_headerFEC.showEthereal( headerFEC_tree, tvb, offset );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H223AL2MParameters_alpduInterleaving, tvb, offset + m_alpduInterleaving.GetStartByte(), m_alpduInterleaving.GetByteLength() , m_alpduInterleaving.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// H223AL3MParameters
//

H245_H223AL3MParameters::H245_H223AL3MParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_rcpcCodeRate.SetConstraints(PASN_Object::FixedConstraint, 8, 32);
}


#ifndef PASN_NOPRINTON
void H245_H223AL3MParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "headerFormat = " << setprecision(indent) << m_headerFormat << '\n';
  strm << setw(indent+12) << "crcLength = " << setprecision(indent) << m_crcLength << '\n';
  strm << setw(indent+15) << "rcpcCodeRate = " << setprecision(indent) << m_rcpcCodeRate << '\n';
  strm << setw(indent+10) << "arqType = " << setprecision(indent) << m_arqType << '\n';
  strm << setw(indent+20) << "alpduInterleaving = " << setprecision(indent) << m_alpduInterleaving << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H223AL3MParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H223AL3MParameters::Class()), PInvalidCast);
#endif
  const H245_H223AL3MParameters & other = (const H245_H223AL3MParameters &)obj;

  Comparison result;

  if ((result = m_headerFormat.Compare(other.m_headerFormat)) != EqualTo)
    return result;
  if ((result = m_crcLength.Compare(other.m_crcLength)) != EqualTo)
    return result;
  if ((result = m_rcpcCodeRate.Compare(other.m_rcpcCodeRate)) != EqualTo)
    return result;
  if ((result = m_arqType.Compare(other.m_arqType)) != EqualTo)
    return result;
  if ((result = m_alpduInterleaving.Compare(other.m_alpduInterleaving)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223AL3MParameters::GetDataLength() const
{
  return m_headerFormat.GetObjectLength() +
         m_crcLength.GetObjectLength() +
         m_rcpcCodeRate.GetObjectLength() +
         m_arqType.GetObjectLength() +
         m_alpduInterleaving.GetObjectLength();
}


BOOL H245_H223AL3MParameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_headerFormat.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_crcLength.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_rcpcCodeRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_arqType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_alpduInterleaving.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H223AL3MParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_headerFormat.Encode(strm);
  m_crcLength.Encode(strm);
  m_rcpcCodeRate.Encode(strm);
  m_arqType.Encode(strm);
  m_alpduInterleaving.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_headerFormat.Encode(strm);
  m_crcLength.Encode(strm);
  m_rcpcCodeRate.Encode(strm);
  m_arqType.Encode(strm);
  m_alpduInterleaving.Encode(strm);
}


PObject * H245_H223AL3MParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AL3MParameters::Class()), PInvalidCast);
#endif
  return new H245_H223AL3MParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223AL3MParameters::preShowEthereal( void )
{
  m_headerFormat.preShowEthereal( );
  m_crcLength.preShowEthereal( );
  m_rcpcCodeRate.preShowEthereal( );
  m_arqType.preShowEthereal( );
  m_alpduInterleaving.preShowEthereal( );
}

PString H245_H223AL3MParameters::getSummary( void ) 
{
  return PString( "H223AL3MParameters" );
}

void H245_H223AL3MParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *headerFormat_tree = (proto_tree*) NULL;
  proto_item *headerFormat_ti = (proto_item*) NULL;
  headerFormat_ti = proto_tree_add_text( tree, tvb, offset + m_headerFormat.GetStartByte(), m_headerFormat.GetByteLength(), "headerFormat (%s)", ( const char* ) m_headerFormat.GetTagName() );
  headerFormat_tree = proto_item_add_subtree( headerFormat_ti, hCont->h245_2.ett_h245_H223AL3MParameters_headerFormat );

  m_headerFormat.showEthereal( headerFormat_tree, tvb, offset );

  proto_tree *crcLength_tree = (proto_tree*) NULL;
  proto_item *crcLength_ti = (proto_item*) NULL;
  crcLength_ti = proto_tree_add_text( tree, tvb, offset + m_crcLength.GetStartByte(), m_crcLength.GetByteLength(), "crcLength (%s)", ( const char* ) m_crcLength.GetTagName() );
  crcLength_tree = proto_item_add_subtree( crcLength_ti, hCont->h245_2.ett_h245_H223AL3MParameters_crcLength );

  m_crcLength.showEthereal( crcLength_tree, tvb, offset );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_H223AL3MParameters_rcpcCodeRate, tvb, offset + m_rcpcCodeRate.GetStartByte(), m_rcpcCodeRate.GetByteLength() , m_rcpcCodeRate.GetValue() );

  proto_tree *arqType_tree = (proto_tree*) NULL;
  proto_item *arqType_ti = (proto_item*) NULL;
  arqType_ti = proto_tree_add_text( tree, tvb, offset + m_arqType.GetStartByte(), m_arqType.GetByteLength(), "arqType (%s)", ( const char* ) m_arqType.GetTagName() );
  arqType_tree = proto_item_add_subtree( arqType_ti, hCont->h245_2.ett_h245_H223AL3MParameters_arqType );

  m_arqType.showEthereal( arqType_tree, tvb, offset );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H223AL3MParameters_alpduInterleaving, tvb, offset + m_alpduInterleaving.GetStartByte(), m_alpduInterleaving.GetByteLength() , m_alpduInterleaving.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// H223AnnexCArqParameters
//

H245_H223AnnexCArqParameters::H245_H223AnnexCArqParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_sendBufferSize.SetConstraints(PASN_Object::FixedConstraint, 0, 16777215);
}


#ifndef PASN_NOPRINTON
void H245_H223AnnexCArqParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+26) << "numberOfRetransmissions = " << setprecision(indent) << m_numberOfRetransmissions << '\n';
  strm << setw(indent+17) << "sendBufferSize = " << setprecision(indent) << m_sendBufferSize << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H223AnnexCArqParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H223AnnexCArqParameters::Class()), PInvalidCast);
#endif
  const H245_H223AnnexCArqParameters & other = (const H245_H223AnnexCArqParameters &)obj;

  Comparison result;

  if ((result = m_numberOfRetransmissions.Compare(other.m_numberOfRetransmissions)) != EqualTo)
    return result;
  if ((result = m_sendBufferSize.Compare(other.m_sendBufferSize)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223AnnexCArqParameters::GetDataLength() const
{
  return m_numberOfRetransmissions.GetObjectLength() +
         m_sendBufferSize.GetObjectLength();
}


BOOL H245_H223AnnexCArqParameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_numberOfRetransmissions.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sendBufferSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H223AnnexCArqParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_numberOfRetransmissions.Encode(strm);
  m_sendBufferSize.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_numberOfRetransmissions.Encode(strm);
  m_sendBufferSize.Encode(strm);
}


PObject * H245_H223AnnexCArqParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AnnexCArqParameters::Class()), PInvalidCast);
#endif
  return new H245_H223AnnexCArqParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223AnnexCArqParameters::preShowEthereal( void )
{
  m_numberOfRetransmissions.preShowEthereal( );
  m_sendBufferSize.preShowEthereal( );
}

PString H245_H223AnnexCArqParameters::getSummary( void ) 
{
  return PString( "H223AnnexCArqParameters" );
}

void H245_H223AnnexCArqParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *numberOfRetransmissions_tree = (proto_tree*) NULL;
  proto_item *numberOfRetransmissions_ti = (proto_item*) NULL;
  numberOfRetransmissions_ti = proto_tree_add_text( tree, tvb, offset + m_numberOfRetransmissions.GetStartByte(), m_numberOfRetransmissions.GetByteLength(), "numberOfRetransmissions (%s)", ( const char* ) m_numberOfRetransmissions.GetTagName() );
  numberOfRetransmissions_tree = proto_item_add_subtree( numberOfRetransmissions_ti, hCont->h245_2.ett_h245_H223AnnexCArqParameters_numberOfRetransmissions );

  m_numberOfRetransmissions.showEthereal( numberOfRetransmissions_tree, tvb, offset );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_H223AnnexCArqParameters_sendBufferSize, tvb, offset + m_sendBufferSize.GetStartByte(), m_sendBufferSize.GetByteLength() , m_sendBufferSize.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// V76HDLCParameters
//

H245_V76HDLCParameters::H245_V76HDLCParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_n401.SetConstraints(PASN_Object::FixedConstraint, 1, 4095);
}


#ifndef PASN_NOPRINTON
void H245_V76HDLCParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "crcLength = " << setprecision(indent) << m_crcLength << '\n';
  strm << setw(indent+7) << "n401 = " << setprecision(indent) << m_n401 << '\n';
  strm << setw(indent+24) << "loopbackTestProcedure = " << setprecision(indent) << m_loopbackTestProcedure << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_V76HDLCParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_V76HDLCParameters::Class()), PInvalidCast);
#endif
  const H245_V76HDLCParameters & other = (const H245_V76HDLCParameters &)obj;

  Comparison result;

  if ((result = m_crcLength.Compare(other.m_crcLength)) != EqualTo)
    return result;
  if ((result = m_n401.Compare(other.m_n401)) != EqualTo)
    return result;
  if ((result = m_loopbackTestProcedure.Compare(other.m_loopbackTestProcedure)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_V76HDLCParameters::GetDataLength() const
{
  return m_crcLength.GetObjectLength() +
         m_n401.GetObjectLength() +
         m_loopbackTestProcedure.GetObjectLength();
}


BOOL H245_V76HDLCParameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_crcLength.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_n401.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_loopbackTestProcedure.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_V76HDLCParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_crcLength.Encode(strm);
  m_n401.Encode(strm);
  m_loopbackTestProcedure.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_crcLength.Encode(strm);
  m_n401.Encode(strm);
  m_loopbackTestProcedure.Encode(strm);
}


PObject * H245_V76HDLCParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_V76HDLCParameters::Class()), PInvalidCast);
#endif
  return new H245_V76HDLCParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_V76HDLCParameters::preShowEthereal( void )
{
  m_crcLength.preShowEthereal( );
  m_n401.preShowEthereal( );
  m_loopbackTestProcedure.preShowEthereal( );
}

PString H245_V76HDLCParameters::getSummary( void ) 
{
  return PString( "V76HDLCParameters" );
}

void H245_V76HDLCParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *crcLength_tree = (proto_tree*) NULL;
  proto_item *crcLength_ti = (proto_item*) NULL;
  crcLength_ti = proto_tree_add_text( tree, tvb, offset + m_crcLength.GetStartByte(), m_crcLength.GetByteLength(), "crcLength (%s)", ( const char* ) m_crcLength.GetTagName() );
  crcLength_tree = proto_item_add_subtree( crcLength_ti, hCont->h245_2.ett_h245_V76HDLCParameters_crcLength );

  m_crcLength.showEthereal( crcLength_tree, tvb, offset );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_V76HDLCParameters_n401, tvb, offset + m_n401.GetStartByte(), m_n401.GetByteLength() , m_n401.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_V76HDLCParameters_loopbackTestProcedure, tvb, offset + m_loopbackTestProcedure.GetStartByte(), m_loopbackTestProcedure.GetByteLength() , m_loopbackTestProcedure.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// RTPPayloadType
//

H245_RTPPayloadType::H245_RTPPayloadType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_payloadType.SetConstraints(PASN_Object::FixedConstraint, 0, 127);
}


#ifndef PASN_NOPRINTON
void H245_RTPPayloadType::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+20) << "payloadDescriptor = " << setprecision(indent) << m_payloadDescriptor << '\n';
  if (HasOptionalField(e_payloadType))
    strm << setw(indent+14) << "payloadType = " << setprecision(indent) << m_payloadType << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RTPPayloadType::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RTPPayloadType::Class()), PInvalidCast);
#endif
  const H245_RTPPayloadType & other = (const H245_RTPPayloadType &)obj;

  Comparison result;

  if ((result = m_payloadDescriptor.Compare(other.m_payloadDescriptor)) != EqualTo)
    return result;
  if ((result = m_payloadType.Compare(other.m_payloadType)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RTPPayloadType::GetDataLength() const
{
  return m_payloadDescriptor.GetObjectLength() +
         m_payloadType.GetObjectLength();
}


BOOL H245_RTPPayloadType::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_payloadDescriptor.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_payloadType ) && !m_payloadType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RTPPayloadType::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_payloadDescriptor.Encode(strm);
  if (HasOptionalField(e_payloadType))
    m_payloadType.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_payloadDescriptor.Encode(strm);
  if (HasOptionalField(e_payloadType))
    m_payloadType.Encode(strm);
}


PObject * H245_RTPPayloadType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RTPPayloadType::Class()), PInvalidCast);
#endif
  return new H245_RTPPayloadType(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RTPPayloadType::preShowEthereal( void )
{
  m_payloadDescriptor.preShowEthereal( );
  if ( HasOptionalField( e_payloadType ) ) 
      m_payloadType.preShowEthereal( );
}

PString H245_RTPPayloadType::getSummary( void ) 
{
  return PString( "RTPPayloadType" );
}

void H245_RTPPayloadType::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *payloadDescriptor_tree = (proto_tree*) NULL;
  proto_item *payloadDescriptor_ti = (proto_item*) NULL;
  payloadDescriptor_ti = proto_tree_add_text( tree, tvb, offset + m_payloadDescriptor.GetStartByte(), m_payloadDescriptor.GetByteLength(), "payloadDescriptor (%s)", ( const char* ) m_payloadDescriptor.GetTagName() );
  payloadDescriptor_tree = proto_item_add_subtree( payloadDescriptor_ti, hCont->h245_2.ett_h245_RTPPayloadType_payloadDescriptor );

  m_payloadDescriptor.showEthereal( payloadDescriptor_tree, tvb, offset );

  if ( HasOptionalField( e_payloadType ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_RTPPayloadType_payloadType, tvb, offset + m_payloadType.GetStartByte(), m_payloadType.GetByteLength() , m_payloadType.GetValue() );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// EncryptionSync
//

H245_EncryptionSync::H245_EncryptionSync(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_synchFlag.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
  m_h235Key.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
  m_escrowentry.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_EncryptionSync::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandard))
    strm << setw(indent+14) << "nonStandard = " << setprecision(indent) << m_nonStandard << '\n';
  strm << setw(indent+12) << "synchFlag = " << setprecision(indent) << m_synchFlag << '\n';
  strm << setw(indent+10) << "h235Key = " << setprecision(indent) << m_h235Key << '\n';
  if (HasOptionalField(e_escrowentry))
    strm << setw(indent+14) << "escrowentry = " << setprecision(indent) << m_escrowentry << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_EncryptionSync::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_EncryptionSync::Class()), PInvalidCast);
#endif
  const H245_EncryptionSync & other = (const H245_EncryptionSync &)obj;

  Comparison result;

  if ((result = m_nonStandard.Compare(other.m_nonStandard)) != EqualTo)
    return result;
  if ((result = m_synchFlag.Compare(other.m_synchFlag)) != EqualTo)
    return result;
  if ((result = m_h235Key.Compare(other.m_h235Key)) != EqualTo)
    return result;
  if ((result = m_escrowentry.Compare(other.m_escrowentry)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_EncryptionSync::GetDataLength() const
{
  return m_nonStandard.GetObjectLength() +
         m_synchFlag.GetObjectLength() +
         m_h235Key.GetObjectLength() +
         m_escrowentry.GetObjectLength();
}


BOOL H245_EncryptionSync::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandard ) && !m_nonStandard.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_synchFlag.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_h235Key.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_escrowentry ) && !m_escrowentry.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_EncryptionSync::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
  m_synchFlag.Encode(strm);
  m_h235Key.Encode(strm);
  if (HasOptionalField(e_escrowentry))
    m_escrowentry.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
  m_synchFlag.Encode(strm);
  m_h235Key.Encode(strm);
  if (HasOptionalField(e_escrowentry))
    m_escrowentry.Encode(strm);
}


PObject * H245_EncryptionSync::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EncryptionSync::Class()), PInvalidCast);
#endif
  return new H245_EncryptionSync(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_EncryptionSync::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandard ) ) 
      m_nonStandard.preShowEthereal( );
  m_synchFlag.preShowEthereal( );
  m_h235Key.preShowEthereal( );
  if ( HasOptionalField( e_escrowentry ) ) 
      m_escrowentry.preShowEthereal( );
}

PString H245_EncryptionSync::getSummary( void ) 
{
  return PString( "EncryptionSync" );
}

void H245_EncryptionSync::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandard ) ) {
    proto_tree *nonStandard_tree = (proto_tree*) NULL;
    proto_item *nonStandard_ti = (proto_item*) NULL;
    nonStandard_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandard.GetStartByte(), m_nonStandard.GetByteLength(), "nonStandard (NonStandardParameter)" );
    nonStandard_tree = proto_item_add_subtree( nonStandard_ti, hCont->h245_2.ett_h245_EncryptionSync_nonStandard );
    m_nonStandard.showEthereal( nonStandard_tree, tvb, offset );
  }

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_EncryptionSync_synchFlag, tvb, offset + m_synchFlag.GetStartByte(), m_synchFlag.GetByteLength() , m_synchFlag.GetValue() );

  char* ph235Key = m_h235Key.getValue();
  proto_tree_add_string( tree, hCont->h245_2.hf_h245_EncryptionSync_h235Key, tvb, offset + m_h235Key.GetStartByte(), m_h235Key.GetByteLength() , ph235Key );
  delete[] ph235Key;

  if ( HasOptionalField( e_escrowentry ) ) {
    proto_tree *escrowentry_tree = (proto_tree*) NULL;
    proto_item *escrowentry_ti = (proto_item*) NULL;
    escrowentry_ti = proto_tree_add_text( tree, tvb, offset + m_escrowentry.GetStartByte(), m_escrowentry.GetByteLength(), "escrowentry (EscrowData)" );
    escrowentry_tree = proto_item_add_subtree( escrowentry_ti, hCont->h245_2.ett_h245_EncryptionSync_escrowentry );
    m_escrowentry.showEthereal( escrowentry_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// OpenLogicalChannelReject
//

H245_OpenLogicalChannelReject::H245_OpenLogicalChannelReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_OpenLogicalChannelReject::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+30) << "forwardLogicalChannelNumber = " << setprecision(indent) << m_forwardLogicalChannelNumber << '\n';
  strm << setw(indent+8) << "cause = " << setprecision(indent) << m_cause << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_OpenLogicalChannelReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_OpenLogicalChannelReject::Class()), PInvalidCast);
#endif
  const H245_OpenLogicalChannelReject & other = (const H245_OpenLogicalChannelReject &)obj;

  Comparison result;

  if ((result = m_forwardLogicalChannelNumber.Compare(other.m_forwardLogicalChannelNumber)) != EqualTo)
    return result;
  if ((result = m_cause.Compare(other.m_cause)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_OpenLogicalChannelReject::GetDataLength() const
{
  return m_forwardLogicalChannelNumber.GetObjectLength() +
         m_cause.GetObjectLength();
}


BOOL H245_OpenLogicalChannelReject::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_forwardLogicalChannelNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_cause.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_OpenLogicalChannelReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardLogicalChannelNumber.Encode(strm);
  m_cause.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_forwardLogicalChannelNumber.Encode(strm);
  m_cause.Encode(strm);
}


PObject * H245_OpenLogicalChannelReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannelReject::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannelReject(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_OpenLogicalChannelReject::preShowEthereal( void )
{
  m_forwardLogicalChannelNumber.preShowEthereal( );
  m_cause.preShowEthereal( );
}

PString H245_OpenLogicalChannelReject::getSummary( void ) 
{
  return PString( "OpenLogicalChannelReject" );
}

void H245_OpenLogicalChannelReject::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_OpenLogicalChannelReject_forwardLogicalChannelNumber, tvb, offset + m_forwardLogicalChannelNumber.GetStartByte(), m_forwardLogicalChannelNumber.GetByteLength() , m_forwardLogicalChannelNumber.GetValue() );

  proto_tree *cause_tree = (proto_tree*) NULL;
  proto_item *cause_ti = (proto_item*) NULL;
  cause_ti = proto_tree_add_text( tree, tvb, offset + m_cause.GetStartByte(), m_cause.GetByteLength(), "cause (%s)", ( const char* ) m_cause.GetTagName() );
  cause_tree = proto_item_add_subtree( cause_ti, hCont->h245_2.ett_h245_OpenLogicalChannelReject_cause );

  m_cause.showEthereal( cause_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// H2250LogicalChannelAckParameters
//

H245_H2250LogicalChannelAckParameters::H245_H2250LogicalChannelAckParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 5, TRUE, 2)
{
  m_sessionID.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
  m_dynamicRTPPayloadType.SetConstraints(PASN_Object::FixedConstraint, 96, 127);
  IncludeOptionalField(e_flowControlToZero);
  m_portNumber.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_H2250LogicalChannelAckParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandard))
    strm << setw(indent+14) << "nonStandard = " << setprecision(indent) << m_nonStandard << '\n';
  if (HasOptionalField(e_sessionID))
    strm << setw(indent+12) << "sessionID = " << setprecision(indent) << m_sessionID << '\n';
  if (HasOptionalField(e_mediaChannel))
    strm << setw(indent+15) << "mediaChannel = " << setprecision(indent) << m_mediaChannel << '\n';
  if (HasOptionalField(e_mediaControlChannel))
    strm << setw(indent+22) << "mediaControlChannel = " << setprecision(indent) << m_mediaControlChannel << '\n';
  if (HasOptionalField(e_dynamicRTPPayloadType))
    strm << setw(indent+24) << "dynamicRTPPayloadType = " << setprecision(indent) << m_dynamicRTPPayloadType << '\n';
  if (HasOptionalField(e_flowControlToZero))
    strm << setw(indent+20) << "flowControlToZero = " << setprecision(indent) << m_flowControlToZero << '\n';
  if (HasOptionalField(e_portNumber))
    strm << setw(indent+13) << "portNumber = " << setprecision(indent) << m_portNumber << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H2250LogicalChannelAckParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H2250LogicalChannelAckParameters::Class()), PInvalidCast);
#endif
  const H245_H2250LogicalChannelAckParameters & other = (const H245_H2250LogicalChannelAckParameters &)obj;

  Comparison result;

  if ((result = m_nonStandard.Compare(other.m_nonStandard)) != EqualTo)
    return result;
  if ((result = m_sessionID.Compare(other.m_sessionID)) != EqualTo)
    return result;
  if ((result = m_mediaChannel.Compare(other.m_mediaChannel)) != EqualTo)
    return result;
  if ((result = m_mediaControlChannel.Compare(other.m_mediaControlChannel)) != EqualTo)
    return result;
  if ((result = m_dynamicRTPPayloadType.Compare(other.m_dynamicRTPPayloadType)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H2250LogicalChannelAckParameters::GetDataLength() const
{
  return m_nonStandard.GetObjectLength() +
         m_sessionID.GetObjectLength() +
         m_mediaChannel.GetObjectLength() +
         m_mediaControlChannel.GetObjectLength() +
         m_dynamicRTPPayloadType.GetObjectLength();
}


BOOL H245_H2250LogicalChannelAckParameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandard ) && !m_nonStandard.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_sessionID ) && !m_sessionID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_mediaChannel ) && !m_mediaChannel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_mediaControlChannel ) && !m_mediaControlChannel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_dynamicRTPPayloadType ) && !m_dynamicRTPPayloadType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_flowControlToZero, m_flowControlToZero ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_portNumber, m_portNumber ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H2250LogicalChannelAckParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
  if (HasOptionalField(e_sessionID))
    m_sessionID.Encode(strm);
  if (HasOptionalField(e_mediaChannel))
    m_mediaChannel.Encode(strm);
  if (HasOptionalField(e_mediaControlChannel))
    m_mediaControlChannel.Encode(strm);
  if (HasOptionalField(e_dynamicRTPPayloadType))
    m_dynamicRTPPayloadType.Encode(strm);
  KnownExtensionEncode(strm, e_flowControlToZero, m_flowControlToZero);
  KnownExtensionEncode(strm, e_portNumber, m_portNumber);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
  if (HasOptionalField(e_sessionID))
    m_sessionID.Encode(strm);
  if (HasOptionalField(e_mediaChannel))
    m_mediaChannel.Encode(strm);
  if (HasOptionalField(e_mediaControlChannel))
    m_mediaControlChannel.Encode(strm);
  if (HasOptionalField(e_dynamicRTPPayloadType))
    m_dynamicRTPPayloadType.Encode(strm);
}


PObject * H245_H2250LogicalChannelAckParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H2250LogicalChannelAckParameters::Class()), PInvalidCast);
#endif
  return new H245_H2250LogicalChannelAckParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H2250LogicalChannelAckParameters::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandard ) ) 
      m_nonStandard.preShowEthereal( );
  if ( HasOptionalField( e_sessionID ) ) 
      m_sessionID.preShowEthereal( );
  if ( HasOptionalField( e_mediaChannel ) ) {
     m_mediaChannel.preShowEthereal( );
	  if ( m_mediaChannel.GetTagName() == "unicastAddress" ) {
			H245_UnicastAddress tmp_unicast = (H245_UnicastAddress) m_mediaChannel;
			if ( tmp_unicast.GetTagName() == "iPAddress" ) {
				H245_UnicastAddress_iPAddress tmpAddr = (H245_UnicastAddress_iPAddress) tmp_unicast;
				//rtp_add_address( (unsigned char*) tmpAddr.m_network.GetPointer(), tmpAddr.m_tsapIdentifier );
        address src_addr;
        conversation_t* pconv = ( conversation_t* ) NULL;
        
        src_addr.type = AT_IPv4;
        src_addr.len = 4;
        src_addr.data = (unsigned char*) tmpAddr.m_network.GetPointer();
        
        pconv = conversation_new( &src_addr, &src_addr, PT_UDP, tmpAddr.m_tsapIdentifier, 0, NO_ADDR2 + NO_PORT2 );
        
        conversation_set_dissector( pconv, find_dissector( "rtp" ) );
			}
		}
	}
  if ( HasOptionalField( e_mediaControlChannel ) ) {
     m_mediaControlChannel.preShowEthereal( );
	  if ( m_mediaControlChannel.GetTagName() == "unicastAddress" ) {
			H245_UnicastAddress tmp_unicast = (H245_UnicastAddress) m_mediaControlChannel;
			if ( tmp_unicast.GetTagName() == "iPAddress" ) {
				H245_UnicastAddress_iPAddress tmpAddr = (H245_UnicastAddress_iPAddress) tmp_unicast;
				//rtcp_add_address( (unsigned char*) tmpAddr.m_network.GetPointer(), tmpAddr.m_tsapIdentifier );
        address src_addr;
        conversation_t* pconv = ( conversation_t* ) NULL;
        
        src_addr.type = AT_IPv4;
        src_addr.len = 4;
        src_addr.data = (unsigned char*) tmpAddr.m_network.GetPointer();
        
        pconv = conversation_new( &src_addr, &src_addr, PT_UDP, tmpAddr.m_tsapIdentifier, 0, NO_ADDR2 + NO_PORT2 );
        
        conversation_set_dissector( pconv, find_dissector( "rtcp" ) );
			}
		}
	}

  if ( HasOptionalField( e_dynamicRTPPayloadType ) ) 
      m_dynamicRTPPayloadType.preShowEthereal( );
  if ( HasOptionalField( e_flowControlToZero ) ) 
      m_flowControlToZero.preShowEthereal( );
  if ( HasOptionalField( e_portNumber ) ) 
      m_portNumber.preShowEthereal( );
}

PString H245_H2250LogicalChannelAckParameters::getSummary( void ) 
{
  return PString( "H2250LogicalChannelAckParameters" );
}

void H245_H2250LogicalChannelAckParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandard ) ) {
    proto_tree *nonStandard_tree = (proto_tree*) NULL;
    proto_item *nonStandard_ti = (proto_item*) NULL;
    nonStandard_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandard.GetStartByte(), m_nonStandard.GetByteLength(), "nonStandard (NonStandardParameter)" );
    nonStandard_tree = proto_item_add_subtree( nonStandard_ti, hCont->h245_2.ett_h245_H2250LogicalChannelAckParameters_nonStandard );
    m_nonStandard.showEthereal( nonStandard_tree, tvb, offset );
  }

  if ( HasOptionalField( e_sessionID ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_H2250LogicalChannelAckParameters_sessionID, tvb, offset + m_sessionID.GetStartByte(), m_sessionID.GetByteLength() , m_sessionID.GetValue() );
  }

  if ( HasOptionalField( e_mediaChannel ) ) {
    proto_tree *mediaChannel_tree = (proto_tree*) NULL;
    proto_item *mediaChannel_ti = (proto_item*) NULL;
    mediaChannel_ti = proto_tree_add_text( tree, tvb, offset + m_mediaChannel.GetStartByte(), m_mediaChannel.GetByteLength(), "mediaChannel (%s)", ( const char* ) m_mediaChannel.GetTagName() );
    mediaChannel_tree = proto_item_add_subtree( mediaChannel_ti, hCont->h245_2.ett_h245_H2250LogicalChannelAckParameters_mediaChannel );
    m_mediaChannel.showEthereal( mediaChannel_tree, tvb, offset );
  }

  if ( HasOptionalField( e_mediaControlChannel ) ) {
    proto_tree *mediaControlChannel_tree = (proto_tree*) NULL;
    proto_item *mediaControlChannel_ti = (proto_item*) NULL;
    mediaControlChannel_ti = proto_tree_add_text( tree, tvb, offset + m_mediaControlChannel.GetStartByte(), m_mediaControlChannel.GetByteLength(), "mediaControlChannel (%s)", ( const char* ) m_mediaControlChannel.GetTagName() );
    mediaControlChannel_tree = proto_item_add_subtree( mediaControlChannel_ti, hCont->h245_2.ett_h245_H2250LogicalChannelAckParameters_mediaControlChannel );
    m_mediaControlChannel.showEthereal( mediaControlChannel_tree, tvb, offset );
  }

  if ( HasOptionalField( e_dynamicRTPPayloadType ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_H2250LogicalChannelAckParameters_dynamicRTPPayloadType, tvb, offset + m_dynamicRTPPayloadType.GetStartByte(), m_dynamicRTPPayloadType.GetByteLength() , m_dynamicRTPPayloadType.GetValue() );
  }

  if ( HasOptionalField( e_flowControlToZero ) ) {
    proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H2250LogicalChannelAckParameters_flowControlToZero, tvb, offset + m_flowControlToZero.GetStartByte(), m_flowControlToZero.GetByteLength() , m_flowControlToZero.GetValue() );
  }

  if ( HasOptionalField( e_portNumber ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_H2250LogicalChannelAckParameters_portNumber, tvb, offset + m_portNumber.GetStartByte(), m_portNumber.GetByteLength() , m_portNumber.GetValue() );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CloseLogicalChannel
//

H245_CloseLogicalChannel::H245_CloseLogicalChannel(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 1)
{
  IncludeOptionalField(e_reason);
}


#ifndef PASN_NOPRINTON
void H245_CloseLogicalChannel::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+30) << "forwardLogicalChannelNumber = " << setprecision(indent) << m_forwardLogicalChannelNumber << '\n';
  strm << setw(indent+9) << "source = " << setprecision(indent) << m_source << '\n';
  if (HasOptionalField(e_reason))
    strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_CloseLogicalChannel::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_CloseLogicalChannel::Class()), PInvalidCast);
#endif
  const H245_CloseLogicalChannel & other = (const H245_CloseLogicalChannel &)obj;

  Comparison result;

  if ((result = m_forwardLogicalChannelNumber.Compare(other.m_forwardLogicalChannelNumber)) != EqualTo)
    return result;
  if ((result = m_source.Compare(other.m_source)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_CloseLogicalChannel::GetDataLength() const
{
  return m_forwardLogicalChannelNumber.GetObjectLength() +
         m_source.GetObjectLength();
}


BOOL H245_CloseLogicalChannel::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_forwardLogicalChannelNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_source.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_reason, m_reason ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_CloseLogicalChannel::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardLogicalChannelNumber.Encode(strm);
  m_source.Encode(strm);
  KnownExtensionEncode(strm, e_reason, m_reason);

  UnknownExtensionsEncode(strm);
  m_forwardLogicalChannelNumber.Encode(strm);
  m_source.Encode(strm);
}


PObject * H245_CloseLogicalChannel::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CloseLogicalChannel::Class()), PInvalidCast);
#endif
  return new H245_CloseLogicalChannel(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CloseLogicalChannel::preShowEthereal( void )
{
  m_forwardLogicalChannelNumber.preShowEthereal( );
  m_source.preShowEthereal( );
  if ( HasOptionalField( e_reason ) ) 
      m_reason.preShowEthereal( );
}

PString H245_CloseLogicalChannel::getSummary( void ) 
{
  return PString( "CloseLogicalChannel" );
}

void H245_CloseLogicalChannel::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_CloseLogicalChannel_forwardLogicalChannelNumber, tvb, offset + m_forwardLogicalChannelNumber.GetStartByte(), m_forwardLogicalChannelNumber.GetByteLength() , m_forwardLogicalChannelNumber.GetValue() );

  proto_tree *source_tree = (proto_tree*) NULL;
  proto_item *source_ti = (proto_item*) NULL;
  source_ti = proto_tree_add_text( tree, tvb, offset + m_source.GetStartByte(), m_source.GetByteLength(), "source (%s)", ( const char* ) m_source.GetTagName() );
  source_tree = proto_item_add_subtree( source_ti, hCont->h245_2.ett_h245_CloseLogicalChannel_source );

  m_source.showEthereal( source_tree, tvb, offset );

  if ( HasOptionalField( e_reason ) ) {
    proto_tree *reason_tree = (proto_tree*) NULL;
    proto_item *reason_ti = (proto_item*) NULL;
    reason_ti = proto_tree_add_text( tree, tvb, offset + m_reason.GetStartByte(), m_reason.GetByteLength(), "reason (%s)", ( const char* ) m_reason.GetTagName() );
    reason_tree = proto_item_add_subtree( reason_ti, hCont->h245_2.ett_h245_CloseLogicalChannel_reason );
    m_reason.showEthereal( reason_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// RequestChannelClose
//

H245_RequestChannelClose::H245_RequestChannelClose(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 2)
{
  IncludeOptionalField(e_reason);
}


#ifndef PASN_NOPRINTON
void H245_RequestChannelClose::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+30) << "forwardLogicalChannelNumber = " << setprecision(indent) << m_forwardLogicalChannelNumber << '\n';
  if (HasOptionalField(e_qosCapability))
    strm << setw(indent+16) << "qosCapability = " << setprecision(indent) << m_qosCapability << '\n';
  if (HasOptionalField(e_reason))
    strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RequestChannelClose::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RequestChannelClose::Class()), PInvalidCast);
#endif
  const H245_RequestChannelClose & other = (const H245_RequestChannelClose &)obj;

  Comparison result;

  if ((result = m_forwardLogicalChannelNumber.Compare(other.m_forwardLogicalChannelNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestChannelClose::GetDataLength() const
{
  return m_forwardLogicalChannelNumber.GetObjectLength();
}


BOOL H245_RequestChannelClose::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_forwardLogicalChannelNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_qosCapability, m_qosCapability ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_reason, m_reason ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RequestChannelClose::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardLogicalChannelNumber.Encode(strm);
  KnownExtensionEncode(strm, e_qosCapability, m_qosCapability);
  KnownExtensionEncode(strm, e_reason, m_reason);

  UnknownExtensionsEncode(strm);
  m_forwardLogicalChannelNumber.Encode(strm);
}


PObject * H245_RequestChannelClose::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestChannelClose::Class()), PInvalidCast);
#endif
  return new H245_RequestChannelClose(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RequestChannelClose::preShowEthereal( void )
{
  m_forwardLogicalChannelNumber.preShowEthereal( );
  if ( HasOptionalField( e_qosCapability ) ) 
      m_qosCapability.preShowEthereal( );
  if ( HasOptionalField( e_reason ) ) 
      m_reason.preShowEthereal( );
}

PString H245_RequestChannelClose::getSummary( void ) 
{
  return PString( "RequestChannelClose" );
}

void H245_RequestChannelClose::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_RequestChannelClose_forwardLogicalChannelNumber, tvb, offset + m_forwardLogicalChannelNumber.GetStartByte(), m_forwardLogicalChannelNumber.GetByteLength() , m_forwardLogicalChannelNumber.GetValue() );

  if ( HasOptionalField( e_qosCapability ) ) {
    proto_tree *qosCapability_tree = (proto_tree*) NULL;
    proto_item *qosCapability_ti = (proto_item*) NULL;
    qosCapability_ti = proto_tree_add_text( tree, tvb, offset + m_qosCapability.GetStartByte(), m_qosCapability.GetByteLength(), "qosCapability (QOSCapability)" );
    qosCapability_tree = proto_item_add_subtree( qosCapability_ti, hCont->h245_2.ett_h245_RequestChannelClose_qosCapability );
    m_qosCapability.showEthereal( qosCapability_tree, tvb, offset );
  }

  if ( HasOptionalField( e_reason ) ) {
    proto_tree *reason_tree = (proto_tree*) NULL;
    proto_item *reason_ti = (proto_item*) NULL;
    reason_ti = proto_tree_add_text( tree, tvb, offset + m_reason.GetStartByte(), m_reason.GetByteLength(), "reason (%s)", ( const char* ) m_reason.GetTagName() );
    reason_tree = proto_item_add_subtree( reason_ti, hCont->h245_2.ett_h245_RequestChannelClose_reason );
    m_reason.showEthereal( reason_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// RequestChannelCloseReject
//

H245_RequestChannelCloseReject::H245_RequestChannelCloseReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RequestChannelCloseReject::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+30) << "forwardLogicalChannelNumber = " << setprecision(indent) << m_forwardLogicalChannelNumber << '\n';
  strm << setw(indent+8) << "cause = " << setprecision(indent) << m_cause << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RequestChannelCloseReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RequestChannelCloseReject::Class()), PInvalidCast);
#endif
  const H245_RequestChannelCloseReject & other = (const H245_RequestChannelCloseReject &)obj;

  Comparison result;

  if ((result = m_forwardLogicalChannelNumber.Compare(other.m_forwardLogicalChannelNumber)) != EqualTo)
    return result;
  if ((result = m_cause.Compare(other.m_cause)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestChannelCloseReject::GetDataLength() const
{
  return m_forwardLogicalChannelNumber.GetObjectLength() +
         m_cause.GetObjectLength();
}


BOOL H245_RequestChannelCloseReject::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_forwardLogicalChannelNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_cause.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RequestChannelCloseReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardLogicalChannelNumber.Encode(strm);
  m_cause.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_forwardLogicalChannelNumber.Encode(strm);
  m_cause.Encode(strm);
}


PObject * H245_RequestChannelCloseReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestChannelCloseReject::Class()), PInvalidCast);
#endif
  return new H245_RequestChannelCloseReject(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RequestChannelCloseReject::preShowEthereal( void )
{
  m_forwardLogicalChannelNumber.preShowEthereal( );
  m_cause.preShowEthereal( );
}

PString H245_RequestChannelCloseReject::getSummary( void ) 
{
  return PString( "RequestChannelCloseReject" );
}

void H245_RequestChannelCloseReject::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_RequestChannelCloseReject_forwardLogicalChannelNumber, tvb, offset + m_forwardLogicalChannelNumber.GetStartByte(), m_forwardLogicalChannelNumber.GetByteLength() , m_forwardLogicalChannelNumber.GetValue() );

  proto_tree *cause_tree = (proto_tree*) NULL;
  proto_item *cause_ti = (proto_item*) NULL;
  cause_ti = proto_tree_add_text( tree, tvb, offset + m_cause.GetStartByte(), m_cause.GetByteLength(), "cause (%s)", ( const char* ) m_cause.GetTagName() );
  cause_tree = proto_item_add_subtree( cause_ti, hCont->h245_2.ett_h245_RequestChannelCloseReject_cause );

  m_cause.showEthereal( cause_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// MultiplexEntrySend
//

H245_MultiplexEntrySend::H245_MultiplexEntrySend(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_multiplexEntryDescriptors.SetConstraints(PASN_Object::FixedConstraint, 1, 15);
}


#ifndef PASN_NOPRINTON
void H245_MultiplexEntrySend::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+28) << "multiplexEntryDescriptors = " << setprecision(indent) << m_multiplexEntryDescriptors << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MultiplexEntrySend::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MultiplexEntrySend::Class()), PInvalidCast);
#endif
  const H245_MultiplexEntrySend & other = (const H245_MultiplexEntrySend &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_multiplexEntryDescriptors.Compare(other.m_multiplexEntryDescriptors)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultiplexEntrySend::GetDataLength() const
{
  return m_sequenceNumber.GetObjectLength() +
         m_multiplexEntryDescriptors.GetObjectLength();
}


BOOL H245_MultiplexEntrySend::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sequenceNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_multiplexEntryDescriptors.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MultiplexEntrySend::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_multiplexEntryDescriptors.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_sequenceNumber.Encode(strm);
  m_multiplexEntryDescriptors.Encode(strm);
}


PObject * H245_MultiplexEntrySend::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexEntrySend::Class()), PInvalidCast);
#endif
  return new H245_MultiplexEntrySend(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultiplexEntrySend::preShowEthereal( void )
{
  m_sequenceNumber.preShowEthereal( );
  m_multiplexEntryDescriptors.preShowEthereal( );
}

PString H245_MultiplexEntrySend::getSummary( void ) 
{
  return PString( "MultiplexEntrySend" );
}

void H245_MultiplexEntrySend::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_MultiplexEntrySend_sequenceNumber, tvb, offset + m_sequenceNumber.GetStartByte(), m_sequenceNumber.GetByteLength() , m_sequenceNumber.GetValue() );

  proto_tree *multiplexEntryDescriptors_tree = (proto_tree*) NULL;
  proto_item *multiplexEntryDescriptors_ti = (proto_item*) NULL;
  multiplexEntryDescriptors_ti = proto_tree_add_text( tree, tvb, offset + m_multiplexEntryDescriptors.GetStartByte(), m_multiplexEntryDescriptors.GetByteLength(), "multiplexEntryDescriptors (MultiplexEntryDescriptor)" );
  multiplexEntryDescriptors_tree = proto_item_add_subtree( multiplexEntryDescriptors_ti, hCont->h245_2.ett_h245_MultiplexEntrySend_multiplexEntryDescriptors );

  m_multiplexEntryDescriptors.showEthereal( multiplexEntryDescriptors_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// MultiplexEntryDescriptor
//

H245_MultiplexEntryDescriptor::H245_MultiplexEntryDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, FALSE, 0)
{
  m_elementList.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_MultiplexEntryDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+28) << "multiplexTableEntryNumber = " << setprecision(indent) << m_multiplexTableEntryNumber << '\n';
  if (HasOptionalField(e_elementList))
    strm << setw(indent+14) << "elementList = " << setprecision(indent) << m_elementList << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MultiplexEntryDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MultiplexEntryDescriptor::Class()), PInvalidCast);
#endif
  const H245_MultiplexEntryDescriptor & other = (const H245_MultiplexEntryDescriptor &)obj;

  Comparison result;

  if ((result = m_multiplexTableEntryNumber.Compare(other.m_multiplexTableEntryNumber)) != EqualTo)
    return result;
  if ((result = m_elementList.Compare(other.m_elementList)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultiplexEntryDescriptor::GetDataLength() const
{
  return m_multiplexTableEntryNumber.GetObjectLength() +
         m_elementList.GetObjectLength();
}


BOOL H245_MultiplexEntryDescriptor::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_multiplexTableEntryNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_elementList ) && !m_elementList.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MultiplexEntryDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_multiplexTableEntryNumber.Encode(strm);
  if (HasOptionalField(e_elementList))
    m_elementList.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_multiplexTableEntryNumber.Encode(strm);
  if (HasOptionalField(e_elementList))
    m_elementList.Encode(strm);
}


PObject * H245_MultiplexEntryDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexEntryDescriptor::Class()), PInvalidCast);
#endif
  return new H245_MultiplexEntryDescriptor(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultiplexEntryDescriptor::preShowEthereal( void )
{
  m_multiplexTableEntryNumber.preShowEthereal( );
  if ( HasOptionalField( e_elementList ) ) 
      m_elementList.preShowEthereal( );
}

PString H245_MultiplexEntryDescriptor::getSummary( void ) 
{
  return PString( "MultiplexEntryDescriptor" );
}

void H245_MultiplexEntryDescriptor::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_MultiplexEntryDescriptor_multiplexTableEntryNumber, tvb, offset + m_multiplexTableEntryNumber.GetStartByte(), m_multiplexTableEntryNumber.GetByteLength() , m_multiplexTableEntryNumber.GetValue() );

  if ( HasOptionalField( e_elementList ) ) {
    proto_tree *elementList_tree = (proto_tree*) NULL;
    proto_item *elementList_ti = (proto_item*) NULL;
    elementList_ti = proto_tree_add_text( tree, tvb, offset + m_elementList.GetStartByte(), m_elementList.GetByteLength(), "elementList (MultiplexElement)" );
    elementList_tree = proto_item_add_subtree( elementList_ti, hCont->h245_2.ett_h245_MultiplexEntryDescriptor_elementList );
    m_elementList.showEthereal( elementList_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// MultiplexElement
//

H245_MultiplexElement::H245_MultiplexElement(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultiplexElement::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "type = " << setprecision(indent) << m_type << '\n';
  strm << setw(indent+14) << "repeatCount = " << setprecision(indent) << m_repeatCount << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MultiplexElement::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MultiplexElement::Class()), PInvalidCast);
#endif
  const H245_MultiplexElement & other = (const H245_MultiplexElement &)obj;

  Comparison result;

  if ((result = m_type.Compare(other.m_type)) != EqualTo)
    return result;
  if ((result = m_repeatCount.Compare(other.m_repeatCount)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultiplexElement::GetDataLength() const
{
  return m_type.GetObjectLength() +
         m_repeatCount.GetObjectLength();
}


BOOL H245_MultiplexElement::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_type.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_repeatCount.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MultiplexElement::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_type.Encode(strm);
  m_repeatCount.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_type.Encode(strm);
  m_repeatCount.Encode(strm);
}


PObject * H245_MultiplexElement::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexElement::Class()), PInvalidCast);
#endif
  return new H245_MultiplexElement(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultiplexElement::preShowEthereal( void )
{
  m_type.preShowEthereal( );
  m_repeatCount.preShowEthereal( );
}

PString H245_MultiplexElement::getSummary( void ) 
{
  return PString( "MultiplexElement" );
}

void H245_MultiplexElement::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *type_tree = (proto_tree*) NULL;
  proto_item *type_ti = (proto_item*) NULL;
  type_ti = proto_tree_add_text( tree, tvb, offset + m_type.GetStartByte(), m_type.GetByteLength(), "type (%s)", ( const char* ) m_type.GetTagName() );
  type_tree = proto_item_add_subtree( type_ti, hCont->h245_2.ett_h245_MultiplexElement_type );

  m_type.showEthereal( type_tree, tvb, offset );

  proto_tree *repeatCount_tree = (proto_tree*) NULL;
  proto_item *repeatCount_ti = (proto_item*) NULL;
  repeatCount_ti = proto_tree_add_text( tree, tvb, offset + m_repeatCount.GetStartByte(), m_repeatCount.GetByteLength(), "repeatCount (%s)", ( const char* ) m_repeatCount.GetTagName() );
  repeatCount_tree = proto_item_add_subtree( repeatCount_ti, hCont->h245_2.ett_h245_MultiplexElement_repeatCount );

  m_repeatCount.showEthereal( repeatCount_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// MultiplexEntrySendAck
//

H245_MultiplexEntrySendAck::H245_MultiplexEntrySendAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_multiplexTableEntryNumber.SetConstraints(PASN_Object::FixedConstraint, 1, 15);
}


#ifndef PASN_NOPRINTON
void H245_MultiplexEntrySendAck::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+28) << "multiplexTableEntryNumber = " << setprecision(indent) << m_multiplexTableEntryNumber << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MultiplexEntrySendAck::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MultiplexEntrySendAck::Class()), PInvalidCast);
#endif
  const H245_MultiplexEntrySendAck & other = (const H245_MultiplexEntrySendAck &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_multiplexTableEntryNumber.Compare(other.m_multiplexTableEntryNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultiplexEntrySendAck::GetDataLength() const
{
  return m_sequenceNumber.GetObjectLength() +
         m_multiplexTableEntryNumber.GetObjectLength();
}


BOOL H245_MultiplexEntrySendAck::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sequenceNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_multiplexTableEntryNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MultiplexEntrySendAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_multiplexTableEntryNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_sequenceNumber.Encode(strm);
  m_multiplexTableEntryNumber.Encode(strm);
}


PObject * H245_MultiplexEntrySendAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexEntrySendAck::Class()), PInvalidCast);
#endif
  return new H245_MultiplexEntrySendAck(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultiplexEntrySendAck::preShowEthereal( void )
{
  m_sequenceNumber.preShowEthereal( );
  m_multiplexTableEntryNumber.preShowEthereal( );
}

PString H245_MultiplexEntrySendAck::getSummary( void ) 
{
  return PString( "MultiplexEntrySendAck" );
}

void H245_MultiplexEntrySendAck::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_MultiplexEntrySendAck_sequenceNumber, tvb, offset + m_sequenceNumber.GetStartByte(), m_sequenceNumber.GetByteLength() , m_sequenceNumber.GetValue() );

  proto_tree *multiplexTableEntryNumber_tree = (proto_tree*) NULL;
  proto_item *multiplexTableEntryNumber_ti = (proto_item*) NULL;
  multiplexTableEntryNumber_ti = proto_tree_add_text( tree, tvb, offset + m_multiplexTableEntryNumber.GetStartByte(), m_multiplexTableEntryNumber.GetByteLength(), "multiplexTableEntryNumber (MultiplexTableEntryNumber)" );
  multiplexTableEntryNumber_tree = proto_item_add_subtree( multiplexTableEntryNumber_ti, hCont->h245_2.ett_h245_MultiplexEntrySendAck_multiplexTableEntryNumber );

  m_multiplexTableEntryNumber.showEthereal( multiplexTableEntryNumber_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// MultiplexEntrySendReject
//

H245_MultiplexEntrySendReject::H245_MultiplexEntrySendReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_rejectionDescriptions.SetConstraints(PASN_Object::FixedConstraint, 1, 15);
}


#ifndef PASN_NOPRINTON
void H245_MultiplexEntrySendReject::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+24) << "rejectionDescriptions = " << setprecision(indent) << m_rejectionDescriptions << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MultiplexEntrySendReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MultiplexEntrySendReject::Class()), PInvalidCast);
#endif
  const H245_MultiplexEntrySendReject & other = (const H245_MultiplexEntrySendReject &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_rejectionDescriptions.Compare(other.m_rejectionDescriptions)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultiplexEntrySendReject::GetDataLength() const
{
  return m_sequenceNumber.GetObjectLength() +
         m_rejectionDescriptions.GetObjectLength();
}


BOOL H245_MultiplexEntrySendReject::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sequenceNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_rejectionDescriptions.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MultiplexEntrySendReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_rejectionDescriptions.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_sequenceNumber.Encode(strm);
  m_rejectionDescriptions.Encode(strm);
}


PObject * H245_MultiplexEntrySendReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexEntrySendReject::Class()), PInvalidCast);
#endif
  return new H245_MultiplexEntrySendReject(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultiplexEntrySendReject::preShowEthereal( void )
{
  m_sequenceNumber.preShowEthereal( );
  m_rejectionDescriptions.preShowEthereal( );
}

PString H245_MultiplexEntrySendReject::getSummary( void ) 
{
  return PString( "MultiplexEntrySendReject" );
}

void H245_MultiplexEntrySendReject::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_MultiplexEntrySendReject_sequenceNumber, tvb, offset + m_sequenceNumber.GetStartByte(), m_sequenceNumber.GetByteLength() , m_sequenceNumber.GetValue() );

  proto_tree *rejectionDescriptions_tree = (proto_tree*) NULL;
  proto_item *rejectionDescriptions_ti = (proto_item*) NULL;
  rejectionDescriptions_ti = proto_tree_add_text( tree, tvb, offset + m_rejectionDescriptions.GetStartByte(), m_rejectionDescriptions.GetByteLength(), "rejectionDescriptions (MultiplexEntryRejectionDescriptions)" );
  rejectionDescriptions_tree = proto_item_add_subtree( rejectionDescriptions_ti, hCont->h245_2.ett_h245_MultiplexEntrySendReject_rejectionDescriptions );

  m_rejectionDescriptions.showEthereal( rejectionDescriptions_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// MultiplexEntryRejectionDescriptions
//

H245_MultiplexEntryRejectionDescriptions::H245_MultiplexEntryRejectionDescriptions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultiplexEntryRejectionDescriptions::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+28) << "multiplexTableEntryNumber = " << setprecision(indent) << m_multiplexTableEntryNumber << '\n';
  strm << setw(indent+8) << "cause = " << setprecision(indent) << m_cause << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MultiplexEntryRejectionDescriptions::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MultiplexEntryRejectionDescriptions::Class()), PInvalidCast);
#endif
  const H245_MultiplexEntryRejectionDescriptions & other = (const H245_MultiplexEntryRejectionDescriptions &)obj;

  Comparison result;

  if ((result = m_multiplexTableEntryNumber.Compare(other.m_multiplexTableEntryNumber)) != EqualTo)
    return result;
  if ((result = m_cause.Compare(other.m_cause)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultiplexEntryRejectionDescriptions::GetDataLength() const
{
  return m_multiplexTableEntryNumber.GetObjectLength() +
         m_cause.GetObjectLength();
}


BOOL H245_MultiplexEntryRejectionDescriptions::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_multiplexTableEntryNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_cause.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MultiplexEntryRejectionDescriptions::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_multiplexTableEntryNumber.Encode(strm);
  m_cause.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_multiplexTableEntryNumber.Encode(strm);
  m_cause.Encode(strm);
}


PObject * H245_MultiplexEntryRejectionDescriptions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexEntryRejectionDescriptions::Class()), PInvalidCast);
#endif
  return new H245_MultiplexEntryRejectionDescriptions(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultiplexEntryRejectionDescriptions::preShowEthereal( void )
{
  m_multiplexTableEntryNumber.preShowEthereal( );
  m_cause.preShowEthereal( );
}

PString H245_MultiplexEntryRejectionDescriptions::getSummary( void ) 
{
  return PString( "MultiplexEntryRejectionDescriptions" );
}

void H245_MultiplexEntryRejectionDescriptions::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_MultiplexEntryRejectionDescriptions_multiplexTableEntryNumber, tvb, offset + m_multiplexTableEntryNumber.GetStartByte(), m_multiplexTableEntryNumber.GetByteLength() , m_multiplexTableEntryNumber.GetValue() );

  proto_tree *cause_tree = (proto_tree*) NULL;
  proto_item *cause_ti = (proto_item*) NULL;
  cause_ti = proto_tree_add_text( tree, tvb, offset + m_cause.GetStartByte(), m_cause.GetByteLength(), "cause (%s)", ( const char* ) m_cause.GetTagName() );
  cause_tree = proto_item_add_subtree( cause_ti, hCont->h245_2.ett_h245_MultiplexEntryRejectionDescriptions_cause );

  m_cause.showEthereal( cause_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// MultiplexEntrySendRelease
//

H245_MultiplexEntrySendRelease::H245_MultiplexEntrySendRelease(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_multiplexTableEntryNumber.SetConstraints(PASN_Object::FixedConstraint, 1, 15);
}


#ifndef PASN_NOPRINTON
void H245_MultiplexEntrySendRelease::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+28) << "multiplexTableEntryNumber = " << setprecision(indent) << m_multiplexTableEntryNumber << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MultiplexEntrySendRelease::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MultiplexEntrySendRelease::Class()), PInvalidCast);
#endif
  const H245_MultiplexEntrySendRelease & other = (const H245_MultiplexEntrySendRelease &)obj;

  Comparison result;

  if ((result = m_multiplexTableEntryNumber.Compare(other.m_multiplexTableEntryNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultiplexEntrySendRelease::GetDataLength() const
{
  return m_multiplexTableEntryNumber.GetObjectLength();
}


BOOL H245_MultiplexEntrySendRelease::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_multiplexTableEntryNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MultiplexEntrySendRelease::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_multiplexTableEntryNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_multiplexTableEntryNumber.Encode(strm);
}


PObject * H245_MultiplexEntrySendRelease::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexEntrySendRelease::Class()), PInvalidCast);
#endif
  return new H245_MultiplexEntrySendRelease(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultiplexEntrySendRelease::preShowEthereal( void )
{
  m_multiplexTableEntryNumber.preShowEthereal( );
}

PString H245_MultiplexEntrySendRelease::getSummary( void ) 
{
  return PString( "MultiplexEntrySendRelease" );
}

void H245_MultiplexEntrySendRelease::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *multiplexTableEntryNumber_tree = (proto_tree*) NULL;
  proto_item *multiplexTableEntryNumber_ti = (proto_item*) NULL;
  multiplexTableEntryNumber_ti = proto_tree_add_text( tree, tvb, offset + m_multiplexTableEntryNumber.GetStartByte(), m_multiplexTableEntryNumber.GetByteLength(), "multiplexTableEntryNumber (MultiplexTableEntryNumber)" );
  multiplexTableEntryNumber_tree = proto_item_add_subtree( multiplexTableEntryNumber_ti, hCont->h245_2.ett_h245_MultiplexEntrySendRelease_multiplexTableEntryNumber );

  m_multiplexTableEntryNumber.showEthereal( multiplexTableEntryNumber_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// RequestMultiplexEntry
//

H245_RequestMultiplexEntry::H245_RequestMultiplexEntry(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_entryNumbers.SetConstraints(PASN_Object::FixedConstraint, 1, 15);
}


#ifndef PASN_NOPRINTON
void H245_RequestMultiplexEntry::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "entryNumbers = " << setprecision(indent) << m_entryNumbers << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RequestMultiplexEntry::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RequestMultiplexEntry::Class()), PInvalidCast);
#endif
  const H245_RequestMultiplexEntry & other = (const H245_RequestMultiplexEntry &)obj;

  Comparison result;

  if ((result = m_entryNumbers.Compare(other.m_entryNumbers)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestMultiplexEntry::GetDataLength() const
{
  return m_entryNumbers.GetObjectLength();
}


BOOL H245_RequestMultiplexEntry::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_entryNumbers.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RequestMultiplexEntry::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_entryNumbers.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_entryNumbers.Encode(strm);
}


PObject * H245_RequestMultiplexEntry::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestMultiplexEntry::Class()), PInvalidCast);
#endif
  return new H245_RequestMultiplexEntry(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RequestMultiplexEntry::preShowEthereal( void )
{
  m_entryNumbers.preShowEthereal( );
}

PString H245_RequestMultiplexEntry::getSummary( void ) 
{
  return PString( "RequestMultiplexEntry" );
}

void H245_RequestMultiplexEntry::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *entryNumbers_tree = (proto_tree*) NULL;
  proto_item *entryNumbers_ti = (proto_item*) NULL;
  entryNumbers_ti = proto_tree_add_text( tree, tvb, offset + m_entryNumbers.GetStartByte(), m_entryNumbers.GetByteLength(), "entryNumbers (MultiplexTableEntryNumber)" );
  entryNumbers_tree = proto_item_add_subtree( entryNumbers_ti, hCont->h245_2.ett_h245_RequestMultiplexEntry_entryNumbers );

  m_entryNumbers.showEthereal( entryNumbers_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// RequestMultiplexEntryAck
//

H245_RequestMultiplexEntryAck::H245_RequestMultiplexEntryAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_entryNumbers.SetConstraints(PASN_Object::FixedConstraint, 1, 15);
}


#ifndef PASN_NOPRINTON
void H245_RequestMultiplexEntryAck::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "entryNumbers = " << setprecision(indent) << m_entryNumbers << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RequestMultiplexEntryAck::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RequestMultiplexEntryAck::Class()), PInvalidCast);
#endif
  const H245_RequestMultiplexEntryAck & other = (const H245_RequestMultiplexEntryAck &)obj;

  Comparison result;

  if ((result = m_entryNumbers.Compare(other.m_entryNumbers)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestMultiplexEntryAck::GetDataLength() const
{
  return m_entryNumbers.GetObjectLength();
}


BOOL H245_RequestMultiplexEntryAck::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_entryNumbers.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RequestMultiplexEntryAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_entryNumbers.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_entryNumbers.Encode(strm);
}


PObject * H245_RequestMultiplexEntryAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestMultiplexEntryAck::Class()), PInvalidCast);
#endif
  return new H245_RequestMultiplexEntryAck(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RequestMultiplexEntryAck::preShowEthereal( void )
{
  m_entryNumbers.preShowEthereal( );
}

PString H245_RequestMultiplexEntryAck::getSummary( void ) 
{
  return PString( "RequestMultiplexEntryAck" );
}

void H245_RequestMultiplexEntryAck::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *entryNumbers_tree = (proto_tree*) NULL;
  proto_item *entryNumbers_ti = (proto_item*) NULL;
  entryNumbers_ti = proto_tree_add_text( tree, tvb, offset + m_entryNumbers.GetStartByte(), m_entryNumbers.GetByteLength(), "entryNumbers (MultiplexTableEntryNumber)" );
  entryNumbers_tree = proto_item_add_subtree( entryNumbers_ti, hCont->h245_2.ett_h245_RequestMultiplexEntryAck_entryNumbers );

  m_entryNumbers.showEthereal( entryNumbers_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// RequestMultiplexEntryReject
//

H245_RequestMultiplexEntryReject::H245_RequestMultiplexEntryReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_entryNumbers.SetConstraints(PASN_Object::FixedConstraint, 1, 15);
  m_rejectionDescriptions.SetConstraints(PASN_Object::FixedConstraint, 1, 15);
}


#ifndef PASN_NOPRINTON
void H245_RequestMultiplexEntryReject::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "entryNumbers = " << setprecision(indent) << m_entryNumbers << '\n';
  strm << setw(indent+24) << "rejectionDescriptions = " << setprecision(indent) << m_rejectionDescriptions << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RequestMultiplexEntryReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RequestMultiplexEntryReject::Class()), PInvalidCast);
#endif
  const H245_RequestMultiplexEntryReject & other = (const H245_RequestMultiplexEntryReject &)obj;

  Comparison result;

  if ((result = m_entryNumbers.Compare(other.m_entryNumbers)) != EqualTo)
    return result;
  if ((result = m_rejectionDescriptions.Compare(other.m_rejectionDescriptions)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestMultiplexEntryReject::GetDataLength() const
{
  return m_entryNumbers.GetObjectLength() +
         m_rejectionDescriptions.GetObjectLength();
}


BOOL H245_RequestMultiplexEntryReject::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_entryNumbers.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_rejectionDescriptions.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RequestMultiplexEntryReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_entryNumbers.Encode(strm);
  m_rejectionDescriptions.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_entryNumbers.Encode(strm);
  m_rejectionDescriptions.Encode(strm);
}


PObject * H245_RequestMultiplexEntryReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestMultiplexEntryReject::Class()), PInvalidCast);
#endif
  return new H245_RequestMultiplexEntryReject(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RequestMultiplexEntryReject::preShowEthereal( void )
{
  m_entryNumbers.preShowEthereal( );
  m_rejectionDescriptions.preShowEthereal( );
}

PString H245_RequestMultiplexEntryReject::getSummary( void ) 
{
  return PString( "RequestMultiplexEntryReject" );
}

void H245_RequestMultiplexEntryReject::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *entryNumbers_tree = (proto_tree*) NULL;
  proto_item *entryNumbers_ti = (proto_item*) NULL;
  entryNumbers_ti = proto_tree_add_text( tree, tvb, offset + m_entryNumbers.GetStartByte(), m_entryNumbers.GetByteLength(), "entryNumbers (MultiplexTableEntryNumber)" );
  entryNumbers_tree = proto_item_add_subtree( entryNumbers_ti, hCont->h245_2.ett_h245_RequestMultiplexEntryReject_entryNumbers );

  m_entryNumbers.showEthereal( entryNumbers_tree, tvb, offset );

  proto_tree *rejectionDescriptions_tree = (proto_tree*) NULL;
  proto_item *rejectionDescriptions_ti = (proto_item*) NULL;
  rejectionDescriptions_ti = proto_tree_add_text( tree, tvb, offset + m_rejectionDescriptions.GetStartByte(), m_rejectionDescriptions.GetByteLength(), "rejectionDescriptions (RequestMultiplexEntryRejectionDescriptions)" );
  rejectionDescriptions_tree = proto_item_add_subtree( rejectionDescriptions_ti, hCont->h245_2.ett_h245_RequestMultiplexEntryReject_rejectionDescriptions );

  m_rejectionDescriptions.showEthereal( rejectionDescriptions_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// RequestMultiplexEntryRejectionDescriptions
//

H245_RequestMultiplexEntryRejectionDescriptions::H245_RequestMultiplexEntryRejectionDescriptions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RequestMultiplexEntryRejectionDescriptions::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+28) << "multiplexTableEntryNumber = " << setprecision(indent) << m_multiplexTableEntryNumber << '\n';
  strm << setw(indent+8) << "cause = " << setprecision(indent) << m_cause << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RequestMultiplexEntryRejectionDescriptions::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RequestMultiplexEntryRejectionDescriptions::Class()), PInvalidCast);
#endif
  const H245_RequestMultiplexEntryRejectionDescriptions & other = (const H245_RequestMultiplexEntryRejectionDescriptions &)obj;

  Comparison result;

  if ((result = m_multiplexTableEntryNumber.Compare(other.m_multiplexTableEntryNumber)) != EqualTo)
    return result;
  if ((result = m_cause.Compare(other.m_cause)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestMultiplexEntryRejectionDescriptions::GetDataLength() const
{
  return m_multiplexTableEntryNumber.GetObjectLength() +
         m_cause.GetObjectLength();
}


BOOL H245_RequestMultiplexEntryRejectionDescriptions::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_multiplexTableEntryNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_cause.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RequestMultiplexEntryRejectionDescriptions::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_multiplexTableEntryNumber.Encode(strm);
  m_cause.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_multiplexTableEntryNumber.Encode(strm);
  m_cause.Encode(strm);
}


PObject * H245_RequestMultiplexEntryRejectionDescriptions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestMultiplexEntryRejectionDescriptions::Class()), PInvalidCast);
#endif
  return new H245_RequestMultiplexEntryRejectionDescriptions(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RequestMultiplexEntryRejectionDescriptions::preShowEthereal( void )
{
  m_multiplexTableEntryNumber.preShowEthereal( );
  m_cause.preShowEthereal( );
}

PString H245_RequestMultiplexEntryRejectionDescriptions::getSummary( void ) 
{
  return PString( "RequestMultiplexEntryRejectionDescriptions" );
}

void H245_RequestMultiplexEntryRejectionDescriptions::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_RequestMultiplexEntryRejectionDescriptions_multiplexTableEntryNumber, tvb, offset + m_multiplexTableEntryNumber.GetStartByte(), m_multiplexTableEntryNumber.GetByteLength() , m_multiplexTableEntryNumber.GetValue() );

  proto_tree *cause_tree = (proto_tree*) NULL;
  proto_item *cause_ti = (proto_item*) NULL;
  cause_ti = proto_tree_add_text( tree, tvb, offset + m_cause.GetStartByte(), m_cause.GetByteLength(), "cause (%s)", ( const char* ) m_cause.GetTagName() );
  cause_tree = proto_item_add_subtree( cause_ti, hCont->h245_2.ett_h245_RequestMultiplexEntryRejectionDescriptions_cause );

  m_cause.showEthereal( cause_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// RequestMultiplexEntryRelease
//

H245_RequestMultiplexEntryRelease::H245_RequestMultiplexEntryRelease(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_entryNumbers.SetConstraints(PASN_Object::FixedConstraint, 1, 15);
}


#ifndef PASN_NOPRINTON
void H245_RequestMultiplexEntryRelease::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "entryNumbers = " << setprecision(indent) << m_entryNumbers << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RequestMultiplexEntryRelease::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RequestMultiplexEntryRelease::Class()), PInvalidCast);
#endif
  const H245_RequestMultiplexEntryRelease & other = (const H245_RequestMultiplexEntryRelease &)obj;

  Comparison result;

  if ((result = m_entryNumbers.Compare(other.m_entryNumbers)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestMultiplexEntryRelease::GetDataLength() const
{
  return m_entryNumbers.GetObjectLength();
}


BOOL H245_RequestMultiplexEntryRelease::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_entryNumbers.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RequestMultiplexEntryRelease::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_entryNumbers.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_entryNumbers.Encode(strm);
}


PObject * H245_RequestMultiplexEntryRelease::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestMultiplexEntryRelease::Class()), PInvalidCast);
#endif
  return new H245_RequestMultiplexEntryRelease(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RequestMultiplexEntryRelease::preShowEthereal( void )
{
  m_entryNumbers.preShowEthereal( );
}

PString H245_RequestMultiplexEntryRelease::getSummary( void ) 
{
  return PString( "RequestMultiplexEntryRelease" );
}

void H245_RequestMultiplexEntryRelease::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *entryNumbers_tree = (proto_tree*) NULL;
  proto_item *entryNumbers_ti = (proto_item*) NULL;
  entryNumbers_ti = proto_tree_add_text( tree, tvb, offset + m_entryNumbers.GetStartByte(), m_entryNumbers.GetByteLength(), "entryNumbers (MultiplexTableEntryNumber)" );
  entryNumbers_tree = proto_item_add_subtree( entryNumbers_ti, hCont->h245_2.ett_h245_RequestMultiplexEntryRelease_entryNumbers );

  m_entryNumbers.showEthereal( entryNumbers_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// RequestMode
//

H245_RequestMode::H245_RequestMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_requestedModes.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_RequestMode::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+17) << "requestedModes = " << setprecision(indent) << m_requestedModes << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RequestMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RequestMode::Class()), PInvalidCast);
#endif
  const H245_RequestMode & other = (const H245_RequestMode &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_requestedModes.Compare(other.m_requestedModes)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestMode::GetDataLength() const
{
  return m_sequenceNumber.GetObjectLength() +
         m_requestedModes.GetObjectLength();
}


BOOL H245_RequestMode::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sequenceNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestedModes.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RequestMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_requestedModes.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_sequenceNumber.Encode(strm);
  m_requestedModes.Encode(strm);
}


PObject * H245_RequestMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestMode::Class()), PInvalidCast);
#endif
  return new H245_RequestMode(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RequestMode::preShowEthereal( void )
{
  m_sequenceNumber.preShowEthereal( );
  m_requestedModes.preShowEthereal( );
}

PString H245_RequestMode::getSummary( void ) 
{
  return PString( "RequestMode" );
}

void H245_RequestMode::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_RequestMode_sequenceNumber, tvb, offset + m_sequenceNumber.GetStartByte(), m_sequenceNumber.GetByteLength() , m_sequenceNumber.GetValue() );

  proto_tree *requestedModes_tree = (proto_tree*) NULL;
  proto_item *requestedModes_ti = (proto_item*) NULL;
  requestedModes_ti = proto_tree_add_text( tree, tvb, offset + m_requestedModes.GetStartByte(), m_requestedModes.GetByteLength(), "requestedModes (ModeDescription)" );
  requestedModes_tree = proto_item_add_subtree( requestedModes_ti, hCont->h245_2.ett_h245_RequestMode_requestedModes );

  m_requestedModes.showEthereal( requestedModes_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// RequestModeAck
//

H245_RequestModeAck::H245_RequestModeAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RequestModeAck::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+11) << "response = " << setprecision(indent) << m_response << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RequestModeAck::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RequestModeAck::Class()), PInvalidCast);
#endif
  const H245_RequestModeAck & other = (const H245_RequestModeAck &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_response.Compare(other.m_response)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestModeAck::GetDataLength() const
{
  return m_sequenceNumber.GetObjectLength() +
         m_response.GetObjectLength();
}


BOOL H245_RequestModeAck::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sequenceNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_response.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RequestModeAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_response.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_sequenceNumber.Encode(strm);
  m_response.Encode(strm);
}


PObject * H245_RequestModeAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestModeAck::Class()), PInvalidCast);
#endif
  return new H245_RequestModeAck(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RequestModeAck::preShowEthereal( void )
{
  m_sequenceNumber.preShowEthereal( );
  m_response.preShowEthereal( );
}

PString H245_RequestModeAck::getSummary( void ) 
{
  return PString( "RequestModeAck" );
}

void H245_RequestModeAck::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_RequestModeAck_sequenceNumber, tvb, offset + m_sequenceNumber.GetStartByte(), m_sequenceNumber.GetByteLength() , m_sequenceNumber.GetValue() );

  proto_tree *response_tree = (proto_tree*) NULL;
  proto_item *response_ti = (proto_item*) NULL;
  response_ti = proto_tree_add_text( tree, tvb, offset + m_response.GetStartByte(), m_response.GetByteLength(), "response (%s)", ( const char* ) m_response.GetTagName() );
  response_tree = proto_item_add_subtree( response_ti, hCont->h245_2.ett_h245_RequestModeAck_response );

  m_response.showEthereal( response_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// RequestModeReject
//

H245_RequestModeReject::H245_RequestModeReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RequestModeReject::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+8) << "cause = " << setprecision(indent) << m_cause << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RequestModeReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RequestModeReject::Class()), PInvalidCast);
#endif
  const H245_RequestModeReject & other = (const H245_RequestModeReject &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_cause.Compare(other.m_cause)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestModeReject::GetDataLength() const
{
  return m_sequenceNumber.GetObjectLength() +
         m_cause.GetObjectLength();
}


BOOL H245_RequestModeReject::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sequenceNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_cause.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RequestModeReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_cause.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_sequenceNumber.Encode(strm);
  m_cause.Encode(strm);
}


PObject * H245_RequestModeReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestModeReject::Class()), PInvalidCast);
#endif
  return new H245_RequestModeReject(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RequestModeReject::preShowEthereal( void )
{
  m_sequenceNumber.preShowEthereal( );
  m_cause.preShowEthereal( );
}

PString H245_RequestModeReject::getSummary( void ) 
{
  return PString( "RequestModeReject" );
}

void H245_RequestModeReject::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_RequestModeReject_sequenceNumber, tvb, offset + m_sequenceNumber.GetStartByte(), m_sequenceNumber.GetByteLength() , m_sequenceNumber.GetValue() );

  proto_tree *cause_tree = (proto_tree*) NULL;
  proto_item *cause_ti = (proto_item*) NULL;
  cause_ti = proto_tree_add_text( tree, tvb, offset + m_cause.GetStartByte(), m_cause.GetByteLength(), "cause (%s)", ( const char* ) m_cause.GetTagName() );
  cause_tree = proto_item_add_subtree( cause_ti, hCont->h245_2.ett_h245_RequestModeReject_cause );

  m_cause.showEthereal( cause_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// H223ModeParameters
//

H245_H223ModeParameters::H245_H223ModeParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_H223ModeParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "adaptationLayerType = " << setprecision(indent) << m_adaptationLayerType << '\n';
  strm << setw(indent+18) << "segmentableFlag = " << setprecision(indent) << m_segmentableFlag << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H223ModeParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H223ModeParameters::Class()), PInvalidCast);
#endif
  const H245_H223ModeParameters & other = (const H245_H223ModeParameters &)obj;

  Comparison result;

  if ((result = m_adaptationLayerType.Compare(other.m_adaptationLayerType)) != EqualTo)
    return result;
  if ((result = m_segmentableFlag.Compare(other.m_segmentableFlag)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223ModeParameters::GetDataLength() const
{
  return m_adaptationLayerType.GetObjectLength() +
         m_segmentableFlag.GetObjectLength();
}


BOOL H245_H223ModeParameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_adaptationLayerType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_segmentableFlag.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H223ModeParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_adaptationLayerType.Encode(strm);
  m_segmentableFlag.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_adaptationLayerType.Encode(strm);
  m_segmentableFlag.Encode(strm);
}


PObject * H245_H223ModeParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223ModeParameters::Class()), PInvalidCast);
#endif
  return new H245_H223ModeParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H223ModeParameters::preShowEthereal( void )
{
  m_adaptationLayerType.preShowEthereal( );
  m_segmentableFlag.preShowEthereal( );
}

PString H245_H223ModeParameters::getSummary( void ) 
{
  return PString( "H223ModeParameters" );
}

void H245_H223ModeParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *adaptationLayerType_tree = (proto_tree*) NULL;
  proto_item *adaptationLayerType_ti = (proto_item*) NULL;
  adaptationLayerType_ti = proto_tree_add_text( tree, tvb, offset + m_adaptationLayerType.GetStartByte(), m_adaptationLayerType.GetByteLength(), "adaptationLayerType (%s)", ( const char* ) m_adaptationLayerType.GetTagName() );
  adaptationLayerType_tree = proto_item_add_subtree( adaptationLayerType_ti, hCont->h245_2.ett_h245_H223ModeParameters_adaptationLayerType );

  m_adaptationLayerType.showEthereal( adaptationLayerType_tree, tvb, offset );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H223ModeParameters_segmentableFlag, tvb, offset + m_segmentableFlag.GetStartByte(), m_segmentableFlag.GetByteLength() , m_segmentableFlag.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// RedundancyEncodingMode
//

H245_RedundancyEncodingMode::H245_RedundancyEncodingMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RedundancyEncodingMode::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+27) << "redundancyEncodingMethod = " << setprecision(indent) << m_redundancyEncodingMethod << '\n';
  if (HasOptionalField(e_secondaryEncoding))
    strm << setw(indent+20) << "secondaryEncoding = " << setprecision(indent) << m_secondaryEncoding << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RedundancyEncodingMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RedundancyEncodingMode::Class()), PInvalidCast);
#endif
  const H245_RedundancyEncodingMode & other = (const H245_RedundancyEncodingMode &)obj;

  Comparison result;

  if ((result = m_redundancyEncodingMethod.Compare(other.m_redundancyEncodingMethod)) != EqualTo)
    return result;
  if ((result = m_secondaryEncoding.Compare(other.m_secondaryEncoding)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RedundancyEncodingMode::GetDataLength() const
{
  return m_redundancyEncodingMethod.GetObjectLength() +
         m_secondaryEncoding.GetObjectLength();
}


BOOL H245_RedundancyEncodingMode::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_redundancyEncodingMethod.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_secondaryEncoding ) && !m_secondaryEncoding.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RedundancyEncodingMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_redundancyEncodingMethod.Encode(strm);
  if (HasOptionalField(e_secondaryEncoding))
    m_secondaryEncoding.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_redundancyEncodingMethod.Encode(strm);
  if (HasOptionalField(e_secondaryEncoding))
    m_secondaryEncoding.Encode(strm);
}


PObject * H245_RedundancyEncodingMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RedundancyEncodingMode::Class()), PInvalidCast);
#endif
  return new H245_RedundancyEncodingMode(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RedundancyEncodingMode::preShowEthereal( void )
{
  m_redundancyEncodingMethod.preShowEthereal( );
  if ( HasOptionalField( e_secondaryEncoding ) ) 
      m_secondaryEncoding.preShowEthereal( );
}

PString H245_RedundancyEncodingMode::getSummary( void ) 
{
  return PString( "RedundancyEncodingMode" );
}

void H245_RedundancyEncodingMode::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *redundancyEncodingMethod_tree = (proto_tree*) NULL;
  proto_item *redundancyEncodingMethod_ti = (proto_item*) NULL;
  redundancyEncodingMethod_ti = proto_tree_add_text( tree, tvb, offset + m_redundancyEncodingMethod.GetStartByte(), m_redundancyEncodingMethod.GetByteLength(), "redundancyEncodingMethod (%s)", ( const char* ) m_redundancyEncodingMethod.GetTagName() );
  redundancyEncodingMethod_tree = proto_item_add_subtree( redundancyEncodingMethod_ti, hCont->h245_2.ett_h245_RedundancyEncodingMode_redundancyEncodingMethod );

  m_redundancyEncodingMethod.showEthereal( redundancyEncodingMethod_tree, tvb, offset );

  if ( HasOptionalField( e_secondaryEncoding ) ) {
    proto_tree *secondaryEncoding_tree = (proto_tree*) NULL;
    proto_item *secondaryEncoding_ti = (proto_item*) NULL;
    secondaryEncoding_ti = proto_tree_add_text( tree, tvb, offset + m_secondaryEncoding.GetStartByte(), m_secondaryEncoding.GetByteLength(), "secondaryEncoding (%s)", ( const char* ) m_secondaryEncoding.GetTagName() );
    secondaryEncoding_tree = proto_item_add_subtree( secondaryEncoding_ti, hCont->h245_2.ett_h245_RedundancyEncodingMode_secondaryEncoding );
    m_secondaryEncoding.showEthereal( secondaryEncoding_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// H261VideoMode
//

H245_H261VideoMode::H245_H261VideoMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_bitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 19200);
}


#ifndef PASN_NOPRINTON
void H245_H261VideoMode::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "resolution = " << setprecision(indent) << m_resolution << '\n';
  strm << setw(indent+10) << "bitRate = " << setprecision(indent) << m_bitRate << '\n';
  strm << setw(indent+25) << "stillImageTransmission = " << setprecision(indent) << m_stillImageTransmission << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H261VideoMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H261VideoMode::Class()), PInvalidCast);
#endif
  const H245_H261VideoMode & other = (const H245_H261VideoMode &)obj;

  Comparison result;

  if ((result = m_resolution.Compare(other.m_resolution)) != EqualTo)
    return result;
  if ((result = m_bitRate.Compare(other.m_bitRate)) != EqualTo)
    return result;
  if ((result = m_stillImageTransmission.Compare(other.m_stillImageTransmission)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H261VideoMode::GetDataLength() const
{
  return m_resolution.GetObjectLength() +
         m_bitRate.GetObjectLength() +
         m_stillImageTransmission.GetObjectLength();
}


BOOL H245_H261VideoMode::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_resolution.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bitRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_stillImageTransmission.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H261VideoMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_resolution.Encode(strm);
  m_bitRate.Encode(strm);
  m_stillImageTransmission.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_resolution.Encode(strm);
  m_bitRate.Encode(strm);
  m_stillImageTransmission.Encode(strm);
}


PObject * H245_H261VideoMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H261VideoMode::Class()), PInvalidCast);
#endif
  return new H245_H261VideoMode(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H261VideoMode::preShowEthereal( void )
{
  m_resolution.preShowEthereal( );
  m_bitRate.preShowEthereal( );
  m_stillImageTransmission.preShowEthereal( );
}

PString H245_H261VideoMode::getSummary( void ) 
{
  return PString( "H261VideoMode" );
}

void H245_H261VideoMode::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *resolution_tree = (proto_tree*) NULL;
  proto_item *resolution_ti = (proto_item*) NULL;
  resolution_ti = proto_tree_add_text( tree, tvb, offset + m_resolution.GetStartByte(), m_resolution.GetByteLength(), "resolution (%s)", ( const char* ) m_resolution.GetTagName() );
  resolution_tree = proto_item_add_subtree( resolution_ti, hCont->h245_2.ett_h245_H261VideoMode_resolution );

  m_resolution.showEthereal( resolution_tree, tvb, offset );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_H261VideoMode_bitRate, tvb, offset + m_bitRate.GetStartByte(), m_bitRate.GetByteLength() , m_bitRate.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H261VideoMode_stillImageTransmission, tvb, offset + m_stillImageTransmission.GetStartByte(), m_stillImageTransmission.GetByteLength() , m_stillImageTransmission.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// H262VideoMode
//

H245_H262VideoMode::H245_H262VideoMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 6, TRUE, 0)
{
  m_videoBitRate.SetConstraints(PASN_Object::FixedConstraint, 0, 1073741823);
  m_vbvBufferSize.SetConstraints(PASN_Object::FixedConstraint, 0, 262143);
  m_samplesPerLine.SetConstraints(PASN_Object::FixedConstraint, 0, 16383);
  m_linesPerFrame.SetConstraints(PASN_Object::FixedConstraint, 0, 16383);
  m_framesPerSecond.SetConstraints(PASN_Object::FixedConstraint, 0, 15);
  m_luminanceSampleRate.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H245_H262VideoMode::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+18) << "profileAndLevel = " << setprecision(indent) << m_profileAndLevel << '\n';
  if (HasOptionalField(e_videoBitRate))
    strm << setw(indent+15) << "videoBitRate = " << setprecision(indent) << m_videoBitRate << '\n';
  if (HasOptionalField(e_vbvBufferSize))
    strm << setw(indent+16) << "vbvBufferSize = " << setprecision(indent) << m_vbvBufferSize << '\n';
  if (HasOptionalField(e_samplesPerLine))
    strm << setw(indent+17) << "samplesPerLine = " << setprecision(indent) << m_samplesPerLine << '\n';
  if (HasOptionalField(e_linesPerFrame))
    strm << setw(indent+16) << "linesPerFrame = " << setprecision(indent) << m_linesPerFrame << '\n';
  if (HasOptionalField(e_framesPerSecond))
    strm << setw(indent+18) << "framesPerSecond = " << setprecision(indent) << m_framesPerSecond << '\n';
  if (HasOptionalField(e_luminanceSampleRate))
    strm << setw(indent+22) << "luminanceSampleRate = " << setprecision(indent) << m_luminanceSampleRate << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H262VideoMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H262VideoMode::Class()), PInvalidCast);
#endif
  const H245_H262VideoMode & other = (const H245_H262VideoMode &)obj;

  Comparison result;

  if ((result = m_profileAndLevel.Compare(other.m_profileAndLevel)) != EqualTo)
    return result;
  if ((result = m_videoBitRate.Compare(other.m_videoBitRate)) != EqualTo)
    return result;
  if ((result = m_vbvBufferSize.Compare(other.m_vbvBufferSize)) != EqualTo)
    return result;
  if ((result = m_samplesPerLine.Compare(other.m_samplesPerLine)) != EqualTo)
    return result;
  if ((result = m_linesPerFrame.Compare(other.m_linesPerFrame)) != EqualTo)
    return result;
  if ((result = m_framesPerSecond.Compare(other.m_framesPerSecond)) != EqualTo)
    return result;
  if ((result = m_luminanceSampleRate.Compare(other.m_luminanceSampleRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H262VideoMode::GetDataLength() const
{
  return m_profileAndLevel.GetObjectLength() +
         m_videoBitRate.GetObjectLength() +
         m_vbvBufferSize.GetObjectLength() +
         m_samplesPerLine.GetObjectLength() +
         m_linesPerFrame.GetObjectLength() +
         m_framesPerSecond.GetObjectLength() +
         m_luminanceSampleRate.GetObjectLength();
}


BOOL H245_H262VideoMode::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_profileAndLevel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_videoBitRate ) && !m_videoBitRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_vbvBufferSize ) && !m_vbvBufferSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_samplesPerLine ) && !m_samplesPerLine.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_linesPerFrame ) && !m_linesPerFrame.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_framesPerSecond ) && !m_framesPerSecond.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_luminanceSampleRate ) && !m_luminanceSampleRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H262VideoMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_profileAndLevel.Encode(strm);
  if (HasOptionalField(e_videoBitRate))
    m_videoBitRate.Encode(strm);
  if (HasOptionalField(e_vbvBufferSize))
    m_vbvBufferSize.Encode(strm);
  if (HasOptionalField(e_samplesPerLine))
    m_samplesPerLine.Encode(strm);
  if (HasOptionalField(e_linesPerFrame))
    m_linesPerFrame.Encode(strm);
  if (HasOptionalField(e_framesPerSecond))
    m_framesPerSecond.Encode(strm);
  if (HasOptionalField(e_luminanceSampleRate))
    m_luminanceSampleRate.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_profileAndLevel.Encode(strm);
  if (HasOptionalField(e_videoBitRate))
    m_videoBitRate.Encode(strm);
  if (HasOptionalField(e_vbvBufferSize))
    m_vbvBufferSize.Encode(strm);
  if (HasOptionalField(e_samplesPerLine))
    m_samplesPerLine.Encode(strm);
  if (HasOptionalField(e_linesPerFrame))
    m_linesPerFrame.Encode(strm);
  if (HasOptionalField(e_framesPerSecond))
    m_framesPerSecond.Encode(strm);
  if (HasOptionalField(e_luminanceSampleRate))
    m_luminanceSampleRate.Encode(strm);
}


PObject * H245_H262VideoMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H262VideoMode::Class()), PInvalidCast);
#endif
  return new H245_H262VideoMode(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H262VideoMode::preShowEthereal( void )
{
  m_profileAndLevel.preShowEthereal( );
  if ( HasOptionalField( e_videoBitRate ) ) 
      m_videoBitRate.preShowEthereal( );
  if ( HasOptionalField( e_vbvBufferSize ) ) 
      m_vbvBufferSize.preShowEthereal( );
  if ( HasOptionalField( e_samplesPerLine ) ) 
      m_samplesPerLine.preShowEthereal( );
  if ( HasOptionalField( e_linesPerFrame ) ) 
      m_linesPerFrame.preShowEthereal( );
  if ( HasOptionalField( e_framesPerSecond ) ) 
      m_framesPerSecond.preShowEthereal( );
  if ( HasOptionalField( e_luminanceSampleRate ) ) 
      m_luminanceSampleRate.preShowEthereal( );
}

PString H245_H262VideoMode::getSummary( void ) 
{
  return PString( "H262VideoMode" );
}

void H245_H262VideoMode::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *profileAndLevel_tree = (proto_tree*) NULL;
  proto_item *profileAndLevel_ti = (proto_item*) NULL;
  profileAndLevel_ti = proto_tree_add_text( tree, tvb, offset + m_profileAndLevel.GetStartByte(), m_profileAndLevel.GetByteLength(), "profileAndLevel (%s)", ( const char* ) m_profileAndLevel.GetTagName() );
  profileAndLevel_tree = proto_item_add_subtree( profileAndLevel_ti, hCont->h245_2.ett_h245_H262VideoMode_profileAndLevel );

  m_profileAndLevel.showEthereal( profileAndLevel_tree, tvb, offset );

  if ( HasOptionalField( e_videoBitRate ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_H262VideoMode_videoBitRate, tvb, offset + m_videoBitRate.GetStartByte(), m_videoBitRate.GetByteLength() , m_videoBitRate.GetValue() );
  }

  if ( HasOptionalField( e_vbvBufferSize ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_H262VideoMode_vbvBufferSize, tvb, offset + m_vbvBufferSize.GetStartByte(), m_vbvBufferSize.GetByteLength() , m_vbvBufferSize.GetValue() );
  }

  if ( HasOptionalField( e_samplesPerLine ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_H262VideoMode_samplesPerLine, tvb, offset + m_samplesPerLine.GetStartByte(), m_samplesPerLine.GetByteLength() , m_samplesPerLine.GetValue() );
  }

  if ( HasOptionalField( e_linesPerFrame ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_H262VideoMode_linesPerFrame, tvb, offset + m_linesPerFrame.GetStartByte(), m_linesPerFrame.GetByteLength() , m_linesPerFrame.GetValue() );
  }

  if ( HasOptionalField( e_framesPerSecond ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_H262VideoMode_framesPerSecond, tvb, offset + m_framesPerSecond.GetStartByte(), m_framesPerSecond.GetByteLength() , m_framesPerSecond.GetValue() );
  }

  if ( HasOptionalField( e_luminanceSampleRate ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_H262VideoMode_luminanceSampleRate, tvb, offset + m_luminanceSampleRate.GetStartByte(), m_luminanceSampleRate.GetByteLength() , m_luminanceSampleRate.GetValue() );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// IS11172AudioMode
//

H245_IS11172AudioMode::H245_IS11172AudioMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_bitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 448);
}


#ifndef PASN_NOPRINTON
void H245_IS11172AudioMode::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "audioLayer = " << setprecision(indent) << m_audioLayer << '\n';
  strm << setw(indent+16) << "audioSampling = " << setprecision(indent) << m_audioSampling << '\n';
  strm << setw(indent+19) << "multichannelType = " << setprecision(indent) << m_multichannelType << '\n';
  strm << setw(indent+10) << "bitRate = " << setprecision(indent) << m_bitRate << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_IS11172AudioMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_IS11172AudioMode::Class()), PInvalidCast);
#endif
  const H245_IS11172AudioMode & other = (const H245_IS11172AudioMode &)obj;

  Comparison result;

  if ((result = m_audioLayer.Compare(other.m_audioLayer)) != EqualTo)
    return result;
  if ((result = m_audioSampling.Compare(other.m_audioSampling)) != EqualTo)
    return result;
  if ((result = m_multichannelType.Compare(other.m_multichannelType)) != EqualTo)
    return result;
  if ((result = m_bitRate.Compare(other.m_bitRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_IS11172AudioMode::GetDataLength() const
{
  return m_audioLayer.GetObjectLength() +
         m_audioSampling.GetObjectLength() +
         m_multichannelType.GetObjectLength() +
         m_bitRate.GetObjectLength();
}


BOOL H245_IS11172AudioMode::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioLayer.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioSampling.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_multichannelType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bitRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_IS11172AudioMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_audioLayer.Encode(strm);
  m_audioSampling.Encode(strm);
  m_multichannelType.Encode(strm);
  m_bitRate.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_audioLayer.Encode(strm);
  m_audioSampling.Encode(strm);
  m_multichannelType.Encode(strm);
  m_bitRate.Encode(strm);
}


PObject * H245_IS11172AudioMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS11172AudioMode::Class()), PInvalidCast);
#endif
  return new H245_IS11172AudioMode(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_IS11172AudioMode::preShowEthereal( void )
{
  m_audioLayer.preShowEthereal( );
  m_audioSampling.preShowEthereal( );
  m_multichannelType.preShowEthereal( );
  m_bitRate.preShowEthereal( );
}

PString H245_IS11172AudioMode::getSummary( void ) 
{
  return PString( "IS11172AudioMode" );
}

void H245_IS11172AudioMode::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *audioLayer_tree = (proto_tree*) NULL;
  proto_item *audioLayer_ti = (proto_item*) NULL;
  audioLayer_ti = proto_tree_add_text( tree, tvb, offset + m_audioLayer.GetStartByte(), m_audioLayer.GetByteLength(), "audioLayer (%s)", ( const char* ) m_audioLayer.GetTagName() );
  audioLayer_tree = proto_item_add_subtree( audioLayer_ti, hCont->h245_2.ett_h245_IS11172AudioMode_audioLayer );

  m_audioLayer.showEthereal( audioLayer_tree, tvb, offset );

  proto_tree *audioSampling_tree = (proto_tree*) NULL;
  proto_item *audioSampling_ti = (proto_item*) NULL;
  audioSampling_ti = proto_tree_add_text( tree, tvb, offset + m_audioSampling.GetStartByte(), m_audioSampling.GetByteLength(), "audioSampling (%s)", ( const char* ) m_audioSampling.GetTagName() );
  audioSampling_tree = proto_item_add_subtree( audioSampling_ti, hCont->h245_2.ett_h245_IS11172AudioMode_audioSampling );

  m_audioSampling.showEthereal( audioSampling_tree, tvb, offset );

  proto_tree *multichannelType_tree = (proto_tree*) NULL;
  proto_item *multichannelType_ti = (proto_item*) NULL;
  multichannelType_ti = proto_tree_add_text( tree, tvb, offset + m_multichannelType.GetStartByte(), m_multichannelType.GetByteLength(), "multichannelType (%s)", ( const char* ) m_multichannelType.GetTagName() );
  multichannelType_tree = proto_item_add_subtree( multichannelType_ti, hCont->h245_2.ett_h245_IS11172AudioMode_multichannelType );

  m_multichannelType.showEthereal( multichannelType_tree, tvb, offset );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_IS11172AudioMode_bitRate, tvb, offset + m_bitRate.GetStartByte(), m_bitRate.GetByteLength() , m_bitRate.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// IS13818AudioMode
//

H245_IS13818AudioMode::H245_IS13818AudioMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_bitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 1130);
}


#ifndef PASN_NOPRINTON
void H245_IS13818AudioMode::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "audioLayer = " << setprecision(indent) << m_audioLayer << '\n';
  strm << setw(indent+16) << "audioSampling = " << setprecision(indent) << m_audioSampling << '\n';
  strm << setw(indent+19) << "multichannelType = " << setprecision(indent) << m_multichannelType << '\n';
  strm << setw(indent+26) << "lowFrequencyEnhancement = " << setprecision(indent) << m_lowFrequencyEnhancement << '\n';
  strm << setw(indent+15) << "multilingual = " << setprecision(indent) << m_multilingual << '\n';
  strm << setw(indent+10) << "bitRate = " << setprecision(indent) << m_bitRate << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_IS13818AudioMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_IS13818AudioMode::Class()), PInvalidCast);
#endif
  const H245_IS13818AudioMode & other = (const H245_IS13818AudioMode &)obj;

  Comparison result;

  if ((result = m_audioLayer.Compare(other.m_audioLayer)) != EqualTo)
    return result;
  if ((result = m_audioSampling.Compare(other.m_audioSampling)) != EqualTo)
    return result;
  if ((result = m_multichannelType.Compare(other.m_multichannelType)) != EqualTo)
    return result;
  if ((result = m_lowFrequencyEnhancement.Compare(other.m_lowFrequencyEnhancement)) != EqualTo)
    return result;
  if ((result = m_multilingual.Compare(other.m_multilingual)) != EqualTo)
    return result;
  if ((result = m_bitRate.Compare(other.m_bitRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_IS13818AudioMode::GetDataLength() const
{
  return m_audioLayer.GetObjectLength() +
         m_audioSampling.GetObjectLength() +
         m_multichannelType.GetObjectLength() +
         m_lowFrequencyEnhancement.GetObjectLength() +
         m_multilingual.GetObjectLength() +
         m_bitRate.GetObjectLength();
}


BOOL H245_IS13818AudioMode::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioLayer.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_audioSampling.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_multichannelType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_lowFrequencyEnhancement.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_multilingual.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bitRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_IS13818AudioMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_audioLayer.Encode(strm);
  m_audioSampling.Encode(strm);
  m_multichannelType.Encode(strm);
  m_lowFrequencyEnhancement.Encode(strm);
  m_multilingual.Encode(strm);
  m_bitRate.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_audioLayer.Encode(strm);
  m_audioSampling.Encode(strm);
  m_multichannelType.Encode(strm);
  m_lowFrequencyEnhancement.Encode(strm);
  m_multilingual.Encode(strm);
  m_bitRate.Encode(strm);
}


PObject * H245_IS13818AudioMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS13818AudioMode::Class()), PInvalidCast);
#endif
  return new H245_IS13818AudioMode(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_IS13818AudioMode::preShowEthereal( void )
{
  m_audioLayer.preShowEthereal( );
  m_audioSampling.preShowEthereal( );
  m_multichannelType.preShowEthereal( );
  m_lowFrequencyEnhancement.preShowEthereal( );
  m_multilingual.preShowEthereal( );
  m_bitRate.preShowEthereal( );
}

PString H245_IS13818AudioMode::getSummary( void ) 
{
  return PString( "IS13818AudioMode" );
}

void H245_IS13818AudioMode::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *audioLayer_tree = (proto_tree*) NULL;
  proto_item *audioLayer_ti = (proto_item*) NULL;
  audioLayer_ti = proto_tree_add_text( tree, tvb, offset + m_audioLayer.GetStartByte(), m_audioLayer.GetByteLength(), "audioLayer (%s)", ( const char* ) m_audioLayer.GetTagName() );
  audioLayer_tree = proto_item_add_subtree( audioLayer_ti, hCont->h245_2.ett_h245_IS13818AudioMode_audioLayer );

  m_audioLayer.showEthereal( audioLayer_tree, tvb, offset );

  proto_tree *audioSampling_tree = (proto_tree*) NULL;
  proto_item *audioSampling_ti = (proto_item*) NULL;
  audioSampling_ti = proto_tree_add_text( tree, tvb, offset + m_audioSampling.GetStartByte(), m_audioSampling.GetByteLength(), "audioSampling (%s)", ( const char* ) m_audioSampling.GetTagName() );
  audioSampling_tree = proto_item_add_subtree( audioSampling_ti, hCont->h245_2.ett_h245_IS13818AudioMode_audioSampling );

  m_audioSampling.showEthereal( audioSampling_tree, tvb, offset );

  proto_tree *multichannelType_tree = (proto_tree*) NULL;
  proto_item *multichannelType_ti = (proto_item*) NULL;
  multichannelType_ti = proto_tree_add_text( tree, tvb, offset + m_multichannelType.GetStartByte(), m_multichannelType.GetByteLength(), "multichannelType (%s)", ( const char* ) m_multichannelType.GetTagName() );
  multichannelType_tree = proto_item_add_subtree( multichannelType_ti, hCont->h245_2.ett_h245_IS13818AudioMode_multichannelType );

  m_multichannelType.showEthereal( multichannelType_tree, tvb, offset );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_IS13818AudioMode_lowFrequencyEnhancement, tvb, offset + m_lowFrequencyEnhancement.GetStartByte(), m_lowFrequencyEnhancement.GetByteLength() , m_lowFrequencyEnhancement.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_IS13818AudioMode_multilingual, tvb, offset + m_multilingual.GetStartByte(), m_multilingual.GetByteLength() , m_multilingual.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_IS13818AudioMode_bitRate, tvb, offset + m_bitRate.GetStartByte(), m_bitRate.GetByteLength() , m_bitRate.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// G7231AnnexCMode
//

H245_G7231AnnexCMode::H245_G7231AnnexCMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_maxAl_sduAudioFrames.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_G7231AnnexCMode::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "maxAl_sduAudioFrames = " << setprecision(indent) << m_maxAl_sduAudioFrames << '\n';
  strm << setw(indent+21) << "silenceSuppression = " << setprecision(indent) << m_silenceSuppression << '\n';
  strm << setw(indent+22) << "g723AnnexCAudioMode = " << setprecision(indent) << m_g723AnnexCAudioMode << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_G7231AnnexCMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_G7231AnnexCMode::Class()), PInvalidCast);
#endif
  const H245_G7231AnnexCMode & other = (const H245_G7231AnnexCMode &)obj;

  Comparison result;

  if ((result = m_maxAl_sduAudioFrames.Compare(other.m_maxAl_sduAudioFrames)) != EqualTo)
    return result;
  if ((result = m_silenceSuppression.Compare(other.m_silenceSuppression)) != EqualTo)
    return result;
  if ((result = m_g723AnnexCAudioMode.Compare(other.m_g723AnnexCAudioMode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_G7231AnnexCMode::GetDataLength() const
{
  return m_maxAl_sduAudioFrames.GetObjectLength() +
         m_silenceSuppression.GetObjectLength() +
         m_g723AnnexCAudioMode.GetObjectLength();
}


BOOL H245_G7231AnnexCMode::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maxAl_sduAudioFrames.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_silenceSuppression.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_g723AnnexCAudioMode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_G7231AnnexCMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_maxAl_sduAudioFrames.Encode(strm);
  m_silenceSuppression.Encode(strm);
  m_g723AnnexCAudioMode.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_maxAl_sduAudioFrames.Encode(strm);
  m_silenceSuppression.Encode(strm);
  m_g723AnnexCAudioMode.Encode(strm);
}


PObject * H245_G7231AnnexCMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_G7231AnnexCMode::Class()), PInvalidCast);
#endif
  return new H245_G7231AnnexCMode(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_G7231AnnexCMode::preShowEthereal( void )
{
  m_maxAl_sduAudioFrames.preShowEthereal( );
  m_silenceSuppression.preShowEthereal( );
  m_g723AnnexCAudioMode.preShowEthereal( );
}

PString H245_G7231AnnexCMode::getSummary( void ) 
{
  return PString( "G7231AnnexCMode" );
}

void H245_G7231AnnexCMode::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_G7231AnnexCMode_maxAl_sduAudioFrames, tvb, offset + m_maxAl_sduAudioFrames.GetStartByte(), m_maxAl_sduAudioFrames.GetByteLength() , m_maxAl_sduAudioFrames.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_G7231AnnexCMode_silenceSuppression, tvb, offset + m_silenceSuppression.GetStartByte(), m_silenceSuppression.GetByteLength() , m_silenceSuppression.GetValue() );

  proto_tree *g723AnnexCAudioMode_tree = (proto_tree*) NULL;
  proto_item *g723AnnexCAudioMode_ti = (proto_item*) NULL;
  g723AnnexCAudioMode_ti = proto_tree_add_text( tree, tvb, offset + m_g723AnnexCAudioMode.GetStartByte(), m_g723AnnexCAudioMode.GetByteLength(), "g723AnnexCAudioMode (G7231AnnexCMode-g723AnnexCAudioMode)" );
  g723AnnexCAudioMode_tree = proto_item_add_subtree( g723AnnexCAudioMode_ti, hCont->h245_2.ett_h245_G7231AnnexCMode_g723AnnexCAudioMode );

  m_g723AnnexCAudioMode.showEthereal( g723AnnexCAudioMode_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// DataMode
//

H245_DataMode::H245_DataMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_bitRate.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H245_DataMode::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "application = " << setprecision(indent) << m_application << '\n';
  strm << setw(indent+10) << "bitRate = " << setprecision(indent) << m_bitRate << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_DataMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_DataMode::Class()), PInvalidCast);
#endif
  const H245_DataMode & other = (const H245_DataMode &)obj;

  Comparison result;

  if ((result = m_application.Compare(other.m_application)) != EqualTo)
    return result;
  if ((result = m_bitRate.Compare(other.m_bitRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DataMode::GetDataLength() const
{
  return m_application.GetObjectLength() +
         m_bitRate.GetObjectLength();
}


BOOL H245_DataMode::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_application.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bitRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_DataMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_application.Encode(strm);
  m_bitRate.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_application.Encode(strm);
  m_bitRate.Encode(strm);
}


PObject * H245_DataMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataMode::Class()), PInvalidCast);
#endif
  return new H245_DataMode(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_DataMode::preShowEthereal( void )
{
  m_application.preShowEthereal( );
  m_bitRate.preShowEthereal( );
}

PString H245_DataMode::getSummary( void ) 
{
  return PString( "DataMode" );
}

void H245_DataMode::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *application_tree = (proto_tree*) NULL;
  proto_item *application_ti = (proto_item*) NULL;
  application_ti = proto_tree_add_text( tree, tvb, offset + m_application.GetStartByte(), m_application.GetByteLength(), "application (%s)", ( const char* ) m_application.GetTagName() );
  application_tree = proto_item_add_subtree( application_ti, hCont->h245_2.ett_h245_DataMode_application );

  m_application.showEthereal( application_tree, tvb, offset );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_DataMode_bitRate, tvb, offset + m_bitRate.GetStartByte(), m_bitRate.GetByteLength() , m_bitRate.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// MaintenanceLoopRequest
//

H245_MaintenanceLoopRequest::H245_MaintenanceLoopRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MaintenanceLoopRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "type = " << setprecision(indent) << m_type << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MaintenanceLoopRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MaintenanceLoopRequest::Class()), PInvalidCast);
#endif
  const H245_MaintenanceLoopRequest & other = (const H245_MaintenanceLoopRequest &)obj;

  Comparison result;

  if ((result = m_type.Compare(other.m_type)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MaintenanceLoopRequest::GetDataLength() const
{
  return m_type.GetObjectLength();
}


BOOL H245_MaintenanceLoopRequest::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_type.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MaintenanceLoopRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_type.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_type.Encode(strm);
}


PObject * H245_MaintenanceLoopRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MaintenanceLoopRequest::Class()), PInvalidCast);
#endif
  return new H245_MaintenanceLoopRequest(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MaintenanceLoopRequest::preShowEthereal( void )
{
  m_type.preShowEthereal( );
}

PString H245_MaintenanceLoopRequest::getSummary( void ) 
{
  return PString( "MaintenanceLoopRequest" );
}

void H245_MaintenanceLoopRequest::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *type_tree = (proto_tree*) NULL;
  proto_item *type_ti = (proto_item*) NULL;
  type_ti = proto_tree_add_text( tree, tvb, offset + m_type.GetStartByte(), m_type.GetByteLength(), "type (%s)", ( const char* ) m_type.GetTagName() );
  type_tree = proto_item_add_subtree( type_ti, hCont->h245_2.ett_h245_MaintenanceLoopRequest_type );

  m_type.showEthereal( type_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// MaintenanceLoopAck
//

H245_MaintenanceLoopAck::H245_MaintenanceLoopAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MaintenanceLoopAck::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "type = " << setprecision(indent) << m_type << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MaintenanceLoopAck::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MaintenanceLoopAck::Class()), PInvalidCast);
#endif
  const H245_MaintenanceLoopAck & other = (const H245_MaintenanceLoopAck &)obj;

  Comparison result;

  if ((result = m_type.Compare(other.m_type)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MaintenanceLoopAck::GetDataLength() const
{
  return m_type.GetObjectLength();
}


BOOL H245_MaintenanceLoopAck::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_type.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MaintenanceLoopAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_type.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_type.Encode(strm);
}


PObject * H245_MaintenanceLoopAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MaintenanceLoopAck::Class()), PInvalidCast);
#endif
  return new H245_MaintenanceLoopAck(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MaintenanceLoopAck::preShowEthereal( void )
{
  m_type.preShowEthereal( );
}

PString H245_MaintenanceLoopAck::getSummary( void ) 
{
  return PString( "MaintenanceLoopAck" );
}

void H245_MaintenanceLoopAck::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *type_tree = (proto_tree*) NULL;
  proto_item *type_ti = (proto_item*) NULL;
  type_ti = proto_tree_add_text( tree, tvb, offset + m_type.GetStartByte(), m_type.GetByteLength(), "type (%s)", ( const char* ) m_type.GetTagName() );
  type_tree = proto_item_add_subtree( type_ti, hCont->h245_2.ett_h245_MaintenanceLoopAck_type );

  m_type.showEthereal( type_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// MaintenanceLoopReject
//

H245_MaintenanceLoopReject::H245_MaintenanceLoopReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MaintenanceLoopReject::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "type = " << setprecision(indent) << m_type << '\n';
  strm << setw(indent+8) << "cause = " << setprecision(indent) << m_cause << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MaintenanceLoopReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MaintenanceLoopReject::Class()), PInvalidCast);
#endif
  const H245_MaintenanceLoopReject & other = (const H245_MaintenanceLoopReject &)obj;

  Comparison result;

  if ((result = m_type.Compare(other.m_type)) != EqualTo)
    return result;
  if ((result = m_cause.Compare(other.m_cause)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MaintenanceLoopReject::GetDataLength() const
{
  return m_type.GetObjectLength() +
         m_cause.GetObjectLength();
}


BOOL H245_MaintenanceLoopReject::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_type.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_cause.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MaintenanceLoopReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_type.Encode(strm);
  m_cause.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_type.Encode(strm);
  m_cause.Encode(strm);
}


PObject * H245_MaintenanceLoopReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MaintenanceLoopReject::Class()), PInvalidCast);
#endif
  return new H245_MaintenanceLoopReject(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MaintenanceLoopReject::preShowEthereal( void )
{
  m_type.preShowEthereal( );
  m_cause.preShowEthereal( );
}

PString H245_MaintenanceLoopReject::getSummary( void ) 
{
  return PString( "MaintenanceLoopReject" );
}

void H245_MaintenanceLoopReject::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *type_tree = (proto_tree*) NULL;
  proto_item *type_ti = (proto_item*) NULL;
  type_ti = proto_tree_add_text( tree, tvb, offset + m_type.GetStartByte(), m_type.GetByteLength(), "type (%s)", ( const char* ) m_type.GetTagName() );
  type_tree = proto_item_add_subtree( type_ti, hCont->h245_2.ett_h245_MaintenanceLoopReject_type );

  m_type.showEthereal( type_tree, tvb, offset );

  proto_tree *cause_tree = (proto_tree*) NULL;
  proto_item *cause_ti = (proto_item*) NULL;
  cause_ti = proto_tree_add_text( tree, tvb, offset + m_cause.GetStartByte(), m_cause.GetByteLength(), "cause (%s)", ( const char* ) m_cause.GetTagName() );
  cause_tree = proto_item_add_subtree( cause_ti, hCont->h245_2.ett_h245_MaintenanceLoopReject_cause );

  m_cause.showEthereal( cause_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// CommunicationModeCommand
//

H245_CommunicationModeCommand::H245_CommunicationModeCommand(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_communicationModeTable.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_CommunicationModeCommand::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+25) << "communicationModeTable = " << setprecision(indent) << m_communicationModeTable << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_CommunicationModeCommand::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_CommunicationModeCommand::Class()), PInvalidCast);
#endif
  const H245_CommunicationModeCommand & other = (const H245_CommunicationModeCommand &)obj;

  Comparison result;

  if ((result = m_communicationModeTable.Compare(other.m_communicationModeTable)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_CommunicationModeCommand::GetDataLength() const
{
  return m_communicationModeTable.GetObjectLength();
}


BOOL H245_CommunicationModeCommand::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_communicationModeTable.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_CommunicationModeCommand::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_communicationModeTable.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_communicationModeTable.Encode(strm);
}


PObject * H245_CommunicationModeCommand::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CommunicationModeCommand::Class()), PInvalidCast);
#endif
  return new H245_CommunicationModeCommand(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CommunicationModeCommand::preShowEthereal( void )
{
  m_communicationModeTable.preShowEthereal( );
}

PString H245_CommunicationModeCommand::getSummary( void ) 
{
  return PString( "CommunicationModeCommand" );
}

void H245_CommunicationModeCommand::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *communicationModeTable_tree = (proto_tree*) NULL;
  proto_item *communicationModeTable_ti = (proto_item*) NULL;
  communicationModeTable_ti = proto_tree_add_text( tree, tvb, offset + m_communicationModeTable.GetStartByte(), m_communicationModeTable.GetByteLength(), "communicationModeTable (CommunicationModeTableEntry)" );
  communicationModeTable_tree = proto_item_add_subtree( communicationModeTable_ti, hCont->h245_2.ett_h245_CommunicationModeCommand_communicationModeTable );

  m_communicationModeTable.showEthereal( communicationModeTable_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// TerminalLabel
//

H245_TerminalLabel::H245_TerminalLabel(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_TerminalLabel::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "mcuNumber = " << setprecision(indent) << m_mcuNumber << '\n';
  strm << setw(indent+17) << "terminalNumber = " << setprecision(indent) << m_terminalNumber << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_TerminalLabel::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_TerminalLabel::Class()), PInvalidCast);
#endif
  const H245_TerminalLabel & other = (const H245_TerminalLabel &)obj;

  Comparison result;

  if ((result = m_mcuNumber.Compare(other.m_mcuNumber)) != EqualTo)
    return result;
  if ((result = m_terminalNumber.Compare(other.m_terminalNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_TerminalLabel::GetDataLength() const
{
  return m_mcuNumber.GetObjectLength() +
         m_terminalNumber.GetObjectLength();
}


BOOL H245_TerminalLabel::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_mcuNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_terminalNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_TerminalLabel::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_mcuNumber.Encode(strm);
  m_terminalNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_mcuNumber.Encode(strm);
  m_terminalNumber.Encode(strm);
}


PObject * H245_TerminalLabel::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TerminalLabel::Class()), PInvalidCast);
#endif
  return new H245_TerminalLabel(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_TerminalLabel::preShowEthereal( void )
{
  m_mcuNumber.preShowEthereal( );
  m_terminalNumber.preShowEthereal( );
}

PString H245_TerminalLabel::getSummary( void ) 
{
  return PString( "TerminalLabel" );
}

void H245_TerminalLabel::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_TerminalLabel_mcuNumber, tvb, offset + m_mcuNumber.GetStartByte(), m_mcuNumber.GetByteLength() , m_mcuNumber.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_TerminalLabel_terminalNumber, tvb, offset + m_terminalNumber.GetStartByte(), m_terminalNumber.GetByteLength() , m_terminalNumber.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// RequestAllTerminalIDsResponse
//

H245_RequestAllTerminalIDsResponse::H245_RequestAllTerminalIDsResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RequestAllTerminalIDsResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "terminalInformation = " << setprecision(indent) << m_terminalInformation << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_RequestAllTerminalIDsResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_RequestAllTerminalIDsResponse::Class()), PInvalidCast);
#endif
  const H245_RequestAllTerminalIDsResponse & other = (const H245_RequestAllTerminalIDsResponse &)obj;

  Comparison result;

  if ((result = m_terminalInformation.Compare(other.m_terminalInformation)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestAllTerminalIDsResponse::GetDataLength() const
{
  return m_terminalInformation.GetObjectLength();
}


BOOL H245_RequestAllTerminalIDsResponse::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_terminalInformation.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_RequestAllTerminalIDsResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminalInformation.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_terminalInformation.Encode(strm);
}


PObject * H245_RequestAllTerminalIDsResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestAllTerminalIDsResponse::Class()), PInvalidCast);
#endif
  return new H245_RequestAllTerminalIDsResponse(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_RequestAllTerminalIDsResponse::preShowEthereal( void )
{
  m_terminalInformation.preShowEthereal( );
}

PString H245_RequestAllTerminalIDsResponse::getSummary( void ) 
{
  return PString( "RequestAllTerminalIDsResponse" );
}

void H245_RequestAllTerminalIDsResponse::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *terminalInformation_tree = (proto_tree*) NULL;
  proto_item *terminalInformation_ti = (proto_item*) NULL;
  terminalInformation_ti = proto_tree_add_text( tree, tvb, offset + m_terminalInformation.GetStartByte(), m_terminalInformation.GetByteLength(), "terminalInformation (TerminalInformation)" );
  terminalInformation_tree = proto_item_add_subtree( terminalInformation_ti, hCont->h245_2.ett_h245_RequestAllTerminalIDsResponse_terminalInformation );

  m_terminalInformation.showEthereal( terminalInformation_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// TerminalInformation
//

H245_TerminalInformation::H245_TerminalInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_TerminalInformation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "terminalLabel = " << setprecision(indent) << m_terminalLabel << '\n';
  strm << setw(indent+13) << "terminalID = " << setprecision(indent) << m_terminalID << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_TerminalInformation::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_TerminalInformation::Class()), PInvalidCast);
#endif
  const H245_TerminalInformation & other = (const H245_TerminalInformation &)obj;

  Comparison result;

  if ((result = m_terminalLabel.Compare(other.m_terminalLabel)) != EqualTo)
    return result;
  if ((result = m_terminalID.Compare(other.m_terminalID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_TerminalInformation::GetDataLength() const
{
  return m_terminalLabel.GetObjectLength() +
         m_terminalID.GetObjectLength();
}


BOOL H245_TerminalInformation::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_terminalLabel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_terminalID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_TerminalInformation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminalLabel.Encode(strm);
  m_terminalID.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_terminalLabel.Encode(strm);
  m_terminalID.Encode(strm);
}


PObject * H245_TerminalInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TerminalInformation::Class()), PInvalidCast);
#endif
  return new H245_TerminalInformation(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_TerminalInformation::preShowEthereal( void )
{
  m_terminalLabel.preShowEthereal( );
  m_terminalID.preShowEthereal( );
}

PString H245_TerminalInformation::getSummary( void ) 
{
  return PString( "TerminalInformation" );
}

void H245_TerminalInformation::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *terminalLabel_tree = (proto_tree*) NULL;
  proto_item *terminalLabel_ti = (proto_item*) NULL;
  terminalLabel_ti = proto_tree_add_text( tree, tvb, offset + m_terminalLabel.GetStartByte(), m_terminalLabel.GetByteLength(), "terminalLabel (TerminalLabel)" );
  terminalLabel_tree = proto_item_add_subtree( terminalLabel_ti, hCont->h245_2.ett_h245_TerminalInformation_terminalLabel );

  m_terminalLabel.showEthereal( terminalLabel_tree, tvb, offset );

  char* pterminalID = m_terminalID.getValue();
  proto_tree_add_string( tree, hCont->h245_2.hf_h245_TerminalInformation_terminalID, tvb, offset + m_terminalID.GetStartByte(), m_terminalID.GetByteLength() , pterminalID );
  delete[] pterminalID;

}
#endif  //USE_FOR_ETHEREAL

//
// DiallingInformationNumber
//

H245_DiallingInformationNumber::H245_DiallingInformationNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_networkAddress.SetConstraints(PASN_Object::FixedConstraint, 0, 40);
  m_subAddress.SetConstraints(PASN_Object::FixedConstraint, 1, 40);
  m_networkType.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
}


#ifndef PASN_NOPRINTON
void H245_DiallingInformationNumber::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "networkAddress = " << setprecision(indent) << m_networkAddress << '\n';
  if (HasOptionalField(e_subAddress))
    strm << setw(indent+13) << "subAddress = " << setprecision(indent) << m_subAddress << '\n';
  strm << setw(indent+14) << "networkType = " << setprecision(indent) << m_networkType << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_DiallingInformationNumber::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_DiallingInformationNumber::Class()), PInvalidCast);
#endif
  const H245_DiallingInformationNumber & other = (const H245_DiallingInformationNumber &)obj;

  Comparison result;

  if ((result = m_networkAddress.Compare(other.m_networkAddress)) != EqualTo)
    return result;
  if ((result = m_subAddress.Compare(other.m_subAddress)) != EqualTo)
    return result;
  if ((result = m_networkType.Compare(other.m_networkType)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DiallingInformationNumber::GetDataLength() const
{
  return m_networkAddress.GetObjectLength() +
         m_subAddress.GetObjectLength() +
         m_networkType.GetObjectLength();
}


BOOL H245_DiallingInformationNumber::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_networkAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_subAddress ) && !m_subAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_networkType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_DiallingInformationNumber::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_networkAddress.Encode(strm);
  if (HasOptionalField(e_subAddress))
    m_subAddress.Encode(strm);
  m_networkType.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_networkAddress.Encode(strm);
  if (HasOptionalField(e_subAddress))
    m_subAddress.Encode(strm);
  m_networkType.Encode(strm);
}


PObject * H245_DiallingInformationNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DiallingInformationNumber::Class()), PInvalidCast);
#endif
  return new H245_DiallingInformationNumber(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_DiallingInformationNumber::preShowEthereal( void )
{
  m_networkAddress.preShowEthereal( );
  if ( HasOptionalField( e_subAddress ) ) 
      m_subAddress.preShowEthereal( );
  m_networkType.preShowEthereal( );
}

PString H245_DiallingInformationNumber::getSummary( void ) 
{
  return PString( "DiallingInformationNumber" );
}

void H245_DiallingInformationNumber::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pnetworkAddress = m_networkAddress.getValue();
  proto_tree_add_string( tree, hCont->h245_2.hf_h245_DiallingInformationNumber_networkAddress, tvb, offset + m_networkAddress.GetStartByte(), m_networkAddress.GetByteLength() , pnetworkAddress );
  delete[] pnetworkAddress;

  if ( HasOptionalField( e_subAddress ) ) {
    char* psubAddress = m_subAddress.getValue();
    proto_tree_add_string( tree, hCont->h245_2.hf_h245_DiallingInformationNumber_subAddress, tvb, offset + m_subAddress.GetStartByte(), m_subAddress.GetByteLength() , psubAddress );
    delete[] psubAddress;
  }

  proto_tree *networkType_tree = (proto_tree*) NULL;
  proto_item *networkType_ti = (proto_item*) NULL;
  networkType_ti = proto_tree_add_text( tree, tvb, offset + m_networkType.GetStartByte(), m_networkType.GetByteLength(), "networkType (DiallingInformationNetworkType)" );
  networkType_tree = proto_item_add_subtree( networkType_ti, hCont->h245_2.ett_h245_DiallingInformationNumber_networkType );

  m_networkType.showEthereal( networkType_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// FlowControlCommand
//

H245_FlowControlCommand::H245_FlowControlCommand(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_FlowControlCommand::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+8) << "scope = " << setprecision(indent) << m_scope << '\n';
  strm << setw(indent+14) << "restriction = " << setprecision(indent) << m_restriction << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_FlowControlCommand::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_FlowControlCommand::Class()), PInvalidCast);
#endif
  const H245_FlowControlCommand & other = (const H245_FlowControlCommand &)obj;

  Comparison result;

  if ((result = m_scope.Compare(other.m_scope)) != EqualTo)
    return result;
  if ((result = m_restriction.Compare(other.m_restriction)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_FlowControlCommand::GetDataLength() const
{
  return m_scope.GetObjectLength() +
         m_restriction.GetObjectLength();
}


BOOL H245_FlowControlCommand::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_scope.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_restriction.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_FlowControlCommand::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_scope.Encode(strm);
  m_restriction.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_scope.Encode(strm);
  m_restriction.Encode(strm);
}


PObject * H245_FlowControlCommand::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FlowControlCommand::Class()), PInvalidCast);
#endif
  return new H245_FlowControlCommand(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_FlowControlCommand::preShowEthereal( void )
{
  m_scope.preShowEthereal( );
  m_restriction.preShowEthereal( );
}

PString H245_FlowControlCommand::getSummary( void ) 
{
  return PString( "FlowControlCommand" );
}

void H245_FlowControlCommand::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *scope_tree = (proto_tree*) NULL;
  proto_item *scope_ti = (proto_item*) NULL;
  scope_ti = proto_tree_add_text( tree, tvb, offset + m_scope.GetStartByte(), m_scope.GetByteLength(), "scope (%s)", ( const char* ) m_scope.GetTagName() );
  scope_tree = proto_item_add_subtree( scope_ti, hCont->h245_2.ett_h245_FlowControlCommand_scope );

  m_scope.showEthereal( scope_tree, tvb, offset );

  proto_tree *restriction_tree = (proto_tree*) NULL;
  proto_item *restriction_ti = (proto_item*) NULL;
  restriction_ti = proto_tree_add_text( tree, tvb, offset + m_restriction.GetStartByte(), m_restriction.GetByteLength(), "restriction (%s)", ( const char* ) m_restriction.GetTagName() );
  restriction_tree = proto_item_add_subtree( restriction_ti, hCont->h245_2.ett_h245_FlowControlCommand_restriction );

  m_restriction.showEthereal( restriction_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// MiscellaneousCommand
//

H245_MiscellaneousCommand::H245_MiscellaneousCommand(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MiscellaneousCommand::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "logicalChannelNumber = " << setprecision(indent) << m_logicalChannelNumber << '\n';
  strm << setw(indent+7) << "type = " << setprecision(indent) << m_type << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MiscellaneousCommand::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MiscellaneousCommand::Class()), PInvalidCast);
#endif
  const H245_MiscellaneousCommand & other = (const H245_MiscellaneousCommand &)obj;

  Comparison result;

  if ((result = m_logicalChannelNumber.Compare(other.m_logicalChannelNumber)) != EqualTo)
    return result;
  if ((result = m_type.Compare(other.m_type)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MiscellaneousCommand::GetDataLength() const
{
  return m_logicalChannelNumber.GetObjectLength() +
         m_type.GetObjectLength();
}


BOOL H245_MiscellaneousCommand::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_logicalChannelNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_type.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MiscellaneousCommand::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_logicalChannelNumber.Encode(strm);
  m_type.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_logicalChannelNumber.Encode(strm);
  m_type.Encode(strm);
}


PObject * H245_MiscellaneousCommand::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MiscellaneousCommand::Class()), PInvalidCast);
#endif
  return new H245_MiscellaneousCommand(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MiscellaneousCommand::preShowEthereal( void )
{
  m_logicalChannelNumber.preShowEthereal( );
  m_type.preShowEthereal( );
}

PString H245_MiscellaneousCommand::getSummary( void ) 
{
  return PString( "MiscellaneousCommand" );
}

void H245_MiscellaneousCommand::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_MiscellaneousCommand_logicalChannelNumber, tvb, offset + m_logicalChannelNumber.GetStartByte(), m_logicalChannelNumber.GetByteLength() , m_logicalChannelNumber.GetValue() );

  proto_tree *type_tree = (proto_tree*) NULL;
  proto_item *type_ti = (proto_item*) NULL;
  type_ti = proto_tree_add_text( tree, tvb, offset + m_type.GetStartByte(), m_type.GetByteLength(), "type (%s)", ( const char* ) m_type.GetTagName() );
  type_tree = proto_item_add_subtree( type_ti, hCont->h245_2.ett_h245_MiscellaneousCommand_type );

  m_type.showEthereal( type_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// FunctionNotSupported
//

H245_FunctionNotSupported::H245_FunctionNotSupported(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_FunctionNotSupported::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+8) << "cause = " << setprecision(indent) << m_cause << '\n';
  if (HasOptionalField(e_returnedFunction))
    strm << setw(indent+19) << "returnedFunction = " << setprecision(indent) << m_returnedFunction << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_FunctionNotSupported::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_FunctionNotSupported::Class()), PInvalidCast);
#endif
  const H245_FunctionNotSupported & other = (const H245_FunctionNotSupported &)obj;

  Comparison result;

  if ((result = m_cause.Compare(other.m_cause)) != EqualTo)
    return result;
  if ((result = m_returnedFunction.Compare(other.m_returnedFunction)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_FunctionNotSupported::GetDataLength() const
{
  return m_cause.GetObjectLength() +
         m_returnedFunction.GetObjectLength();
}


BOOL H245_FunctionNotSupported::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_cause.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_returnedFunction ) && !m_returnedFunction.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_FunctionNotSupported::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_cause.Encode(strm);
  if (HasOptionalField(e_returnedFunction))
    m_returnedFunction.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_cause.Encode(strm);
  if (HasOptionalField(e_returnedFunction))
    m_returnedFunction.Encode(strm);
}


PObject * H245_FunctionNotSupported::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FunctionNotSupported::Class()), PInvalidCast);
#endif
  return new H245_FunctionNotSupported(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_FunctionNotSupported::preShowEthereal( void )
{
  m_cause.preShowEthereal( );
  if ( HasOptionalField( e_returnedFunction ) ) 
      m_returnedFunction.preShowEthereal( );
}

PString H245_FunctionNotSupported::getSummary( void ) 
{
  return PString( "FunctionNotSupported" );
}

void H245_FunctionNotSupported::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *cause_tree = (proto_tree*) NULL;
  proto_item *cause_ti = (proto_item*) NULL;
  cause_ti = proto_tree_add_text( tree, tvb, offset + m_cause.GetStartByte(), m_cause.GetByteLength(), "cause (%s)", ( const char* ) m_cause.GetTagName() );
  cause_tree = proto_item_add_subtree( cause_ti, hCont->h245_2.ett_h245_FunctionNotSupported_cause );

  m_cause.showEthereal( cause_tree, tvb, offset );

  if ( HasOptionalField( e_returnedFunction ) ) {
    char* preturnedFunction = m_returnedFunction.getValue();
    proto_tree_add_string( tree, hCont->h245_2.hf_h245_FunctionNotSupported_returnedFunction, tvb, offset + m_returnedFunction.GetStartByte(), m_returnedFunction.GetByteLength() , preturnedFunction );
    delete[] preturnedFunction;
  }

}
#endif  //USE_FOR_ETHEREAL

//
// MiscellaneousIndication
//

H245_MiscellaneousIndication::H245_MiscellaneousIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MiscellaneousIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "logicalChannelNumber = " << setprecision(indent) << m_logicalChannelNumber << '\n';
  strm << setw(indent+7) << "type = " << setprecision(indent) << m_type << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MiscellaneousIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MiscellaneousIndication::Class()), PInvalidCast);
#endif
  const H245_MiscellaneousIndication & other = (const H245_MiscellaneousIndication &)obj;

  Comparison result;

  if ((result = m_logicalChannelNumber.Compare(other.m_logicalChannelNumber)) != EqualTo)
    return result;
  if ((result = m_type.Compare(other.m_type)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MiscellaneousIndication::GetDataLength() const
{
  return m_logicalChannelNumber.GetObjectLength() +
         m_type.GetObjectLength();
}


BOOL H245_MiscellaneousIndication::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_logicalChannelNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_type.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MiscellaneousIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_logicalChannelNumber.Encode(strm);
  m_type.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_logicalChannelNumber.Encode(strm);
  m_type.Encode(strm);
}


PObject * H245_MiscellaneousIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MiscellaneousIndication::Class()), PInvalidCast);
#endif
  return new H245_MiscellaneousIndication(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MiscellaneousIndication::preShowEthereal( void )
{
  m_logicalChannelNumber.preShowEthereal( );
  m_type.preShowEthereal( );
}

PString H245_MiscellaneousIndication::getSummary( void ) 
{
  return PString( "MiscellaneousIndication" );
}

void H245_MiscellaneousIndication::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_MiscellaneousIndication_logicalChannelNumber, tvb, offset + m_logicalChannelNumber.GetStartByte(), m_logicalChannelNumber.GetByteLength() , m_logicalChannelNumber.GetValue() );

  proto_tree *type_tree = (proto_tree*) NULL;
  proto_item *type_ti = (proto_item*) NULL;
  type_ti = proto_tree_add_text( tree, tvb, offset + m_type.GetStartByte(), m_type.GetByteLength(), "type (%s)", ( const char* ) m_type.GetTagName() );
  type_tree = proto_item_add_subtree( type_ti, hCont->h245_2.ett_h245_MiscellaneousIndication_type );

  m_type.showEthereal( type_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// JitterIndication
//

H245_JitterIndication::H245_JitterIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_estimatedReceivedJitterMantissa.SetConstraints(PASN_Object::FixedConstraint, 0, 3);
  m_estimatedReceivedJitterExponent.SetConstraints(PASN_Object::FixedConstraint, 0, 7);
  m_skippedFrameCount.SetConstraints(PASN_Object::FixedConstraint, 0, 15);
  m_additionalDecoderBuffer.SetConstraints(PASN_Object::FixedConstraint, 0, 262143);
}


#ifndef PASN_NOPRINTON
void H245_JitterIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+8) << "scope = " << setprecision(indent) << m_scope << '\n';
  strm << setw(indent+34) << "estimatedReceivedJitterMantissa = " << setprecision(indent) << m_estimatedReceivedJitterMantissa << '\n';
  strm << setw(indent+34) << "estimatedReceivedJitterExponent = " << setprecision(indent) << m_estimatedReceivedJitterExponent << '\n';
  if (HasOptionalField(e_skippedFrameCount))
    strm << setw(indent+20) << "skippedFrameCount = " << setprecision(indent) << m_skippedFrameCount << '\n';
  if (HasOptionalField(e_additionalDecoderBuffer))
    strm << setw(indent+26) << "additionalDecoderBuffer = " << setprecision(indent) << m_additionalDecoderBuffer << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_JitterIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_JitterIndication::Class()), PInvalidCast);
#endif
  const H245_JitterIndication & other = (const H245_JitterIndication &)obj;

  Comparison result;

  if ((result = m_scope.Compare(other.m_scope)) != EqualTo)
    return result;
  if ((result = m_estimatedReceivedJitterMantissa.Compare(other.m_estimatedReceivedJitterMantissa)) != EqualTo)
    return result;
  if ((result = m_estimatedReceivedJitterExponent.Compare(other.m_estimatedReceivedJitterExponent)) != EqualTo)
    return result;
  if ((result = m_skippedFrameCount.Compare(other.m_skippedFrameCount)) != EqualTo)
    return result;
  if ((result = m_additionalDecoderBuffer.Compare(other.m_additionalDecoderBuffer)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_JitterIndication::GetDataLength() const
{
  return m_scope.GetObjectLength() +
         m_estimatedReceivedJitterMantissa.GetObjectLength() +
         m_estimatedReceivedJitterExponent.GetObjectLength() +
         m_skippedFrameCount.GetObjectLength() +
         m_additionalDecoderBuffer.GetObjectLength();
}


BOOL H245_JitterIndication::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_scope.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_estimatedReceivedJitterMantissa.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_estimatedReceivedJitterExponent.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_skippedFrameCount ) && !m_skippedFrameCount.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_additionalDecoderBuffer ) && !m_additionalDecoderBuffer.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_JitterIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_scope.Encode(strm);
  m_estimatedReceivedJitterMantissa.Encode(strm);
  m_estimatedReceivedJitterExponent.Encode(strm);
  if (HasOptionalField(e_skippedFrameCount))
    m_skippedFrameCount.Encode(strm);
  if (HasOptionalField(e_additionalDecoderBuffer))
    m_additionalDecoderBuffer.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_scope.Encode(strm);
  m_estimatedReceivedJitterMantissa.Encode(strm);
  m_estimatedReceivedJitterExponent.Encode(strm);
  if (HasOptionalField(e_skippedFrameCount))
    m_skippedFrameCount.Encode(strm);
  if (HasOptionalField(e_additionalDecoderBuffer))
    m_additionalDecoderBuffer.Encode(strm);
}


PObject * H245_JitterIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_JitterIndication::Class()), PInvalidCast);
#endif
  return new H245_JitterIndication(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_JitterIndication::preShowEthereal( void )
{
  m_scope.preShowEthereal( );
  m_estimatedReceivedJitterMantissa.preShowEthereal( );
  m_estimatedReceivedJitterExponent.preShowEthereal( );
  if ( HasOptionalField( e_skippedFrameCount ) ) 
      m_skippedFrameCount.preShowEthereal( );
  if ( HasOptionalField( e_additionalDecoderBuffer ) ) 
      m_additionalDecoderBuffer.preShowEthereal( );
}

PString H245_JitterIndication::getSummary( void ) 
{
  return PString( "JitterIndication" );
}

void H245_JitterIndication::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *scope_tree = (proto_tree*) NULL;
  proto_item *scope_ti = (proto_item*) NULL;
  scope_ti = proto_tree_add_text( tree, tvb, offset + m_scope.GetStartByte(), m_scope.GetByteLength(), "scope (%s)", ( const char* ) m_scope.GetTagName() );
  scope_tree = proto_item_add_subtree( scope_ti, hCont->h245_2.ett_h245_JitterIndication_scope );

  m_scope.showEthereal( scope_tree, tvb, offset );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_JitterIndication_estimatedReceivedJitterMantissa, tvb, offset + m_estimatedReceivedJitterMantissa.GetStartByte(), m_estimatedReceivedJitterMantissa.GetByteLength() , m_estimatedReceivedJitterMantissa.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_JitterIndication_estimatedReceivedJitterExponent, tvb, offset + m_estimatedReceivedJitterExponent.GetStartByte(), m_estimatedReceivedJitterExponent.GetByteLength() , m_estimatedReceivedJitterExponent.GetValue() );

  if ( HasOptionalField( e_skippedFrameCount ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_JitterIndication_skippedFrameCount, tvb, offset + m_skippedFrameCount.GetStartByte(), m_skippedFrameCount.GetByteLength() , m_skippedFrameCount.GetValue() );
  }

  if ( HasOptionalField( e_additionalDecoderBuffer ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_JitterIndication_additionalDecoderBuffer, tvb, offset + m_additionalDecoderBuffer.GetStartByte(), m_additionalDecoderBuffer.GetByteLength() , m_additionalDecoderBuffer.GetValue() );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// VCCapability_availableBitRates
//

H245_VCCapability_availableBitRates::H245_VCCapability_availableBitRates(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_VCCapability_availableBitRates::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "type = " << setprecision(indent) << m_type << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_VCCapability_availableBitRates::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_VCCapability_availableBitRates::Class()), PInvalidCast);
#endif
  const H245_VCCapability_availableBitRates & other = (const H245_VCCapability_availableBitRates &)obj;

  Comparison result;

  if ((result = m_type.Compare(other.m_type)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_VCCapability_availableBitRates::GetDataLength() const
{
  return m_type.GetObjectLength();
}


BOOL H245_VCCapability_availableBitRates::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_type.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_VCCapability_availableBitRates::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_type.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_type.Encode(strm);
}


PObject * H245_VCCapability_availableBitRates::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_VCCapability_availableBitRates::Class()), PInvalidCast);
#endif
  return new H245_VCCapability_availableBitRates(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_VCCapability_availableBitRates::preShowEthereal( void )
{
  m_type.preShowEthereal( );
}

PString H245_VCCapability_availableBitRates::getSummary( void ) 
{
  return PString( "VCCapability_availableBitRates" );
}

void H245_VCCapability_availableBitRates::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *type_tree = (proto_tree*) NULL;
  proto_item *type_ti = (proto_item*) NULL;
  type_ti = proto_tree_add_text( tree, tvb, offset + m_type.GetStartByte(), m_type.GetByteLength(), "type (%s)", ( const char* ) m_type.GetTagName() );
  type_tree = proto_item_add_subtree( type_ti, hCont->h245_2.ett_h245_VCCapability_availableBitRates_type );

  m_type.showEthereal( type_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// VCCapability_aal1ViaGateway
//

H245_VCCapability_aal1ViaGateway::H245_VCCapability_aal1ViaGateway(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_gatewayAddress.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_VCCapability_aal1ViaGateway::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "gatewayAddress = " << setprecision(indent) << m_gatewayAddress << '\n';
  strm << setw(indent+20) << "nullClockRecovery = " << setprecision(indent) << m_nullClockRecovery << '\n';
  strm << setw(indent+20) << "srtsClockRecovery = " << setprecision(indent) << m_srtsClockRecovery << '\n';
  strm << setw(indent+24) << "adaptiveClockRecovery = " << setprecision(indent) << m_adaptiveClockRecovery << '\n';
  strm << setw(indent+22) << "nullErrorCorrection = " << setprecision(indent) << m_nullErrorCorrection << '\n';
  strm << setw(indent+18) << "longInterleaver = " << setprecision(indent) << m_longInterleaver << '\n';
  strm << setw(indent+19) << "shortInterleaver = " << setprecision(indent) << m_shortInterleaver << '\n';
  strm << setw(indent+22) << "errorCorrectionOnly = " << setprecision(indent) << m_errorCorrectionOnly << '\n';
  strm << setw(indent+25) << "structuredDataTransfer = " << setprecision(indent) << m_structuredDataTransfer << '\n';
  strm << setw(indent+23) << "partiallyFilledCells = " << setprecision(indent) << m_partiallyFilledCells << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_VCCapability_aal1ViaGateway::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_VCCapability_aal1ViaGateway::Class()), PInvalidCast);
#endif
  const H245_VCCapability_aal1ViaGateway & other = (const H245_VCCapability_aal1ViaGateway &)obj;

  Comparison result;

  if ((result = m_gatewayAddress.Compare(other.m_gatewayAddress)) != EqualTo)
    return result;
  if ((result = m_nullClockRecovery.Compare(other.m_nullClockRecovery)) != EqualTo)
    return result;
  if ((result = m_srtsClockRecovery.Compare(other.m_srtsClockRecovery)) != EqualTo)
    return result;
  if ((result = m_adaptiveClockRecovery.Compare(other.m_adaptiveClockRecovery)) != EqualTo)
    return result;
  if ((result = m_nullErrorCorrection.Compare(other.m_nullErrorCorrection)) != EqualTo)
    return result;
  if ((result = m_longInterleaver.Compare(other.m_longInterleaver)) != EqualTo)
    return result;
  if ((result = m_shortInterleaver.Compare(other.m_shortInterleaver)) != EqualTo)
    return result;
  if ((result = m_errorCorrectionOnly.Compare(other.m_errorCorrectionOnly)) != EqualTo)
    return result;
  if ((result = m_structuredDataTransfer.Compare(other.m_structuredDataTransfer)) != EqualTo)
    return result;
  if ((result = m_partiallyFilledCells.Compare(other.m_partiallyFilledCells)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_VCCapability_aal1ViaGateway::GetDataLength() const
{
  return m_gatewayAddress.GetObjectLength() +
         m_nullClockRecovery.GetObjectLength() +
         m_srtsClockRecovery.GetObjectLength() +
         m_adaptiveClockRecovery.GetObjectLength() +
         m_nullErrorCorrection.GetObjectLength() +
         m_longInterleaver.GetObjectLength() +
         m_shortInterleaver.GetObjectLength() +
         m_errorCorrectionOnly.GetObjectLength() +
         m_structuredDataTransfer.GetObjectLength() +
         m_partiallyFilledCells.GetObjectLength();
}


BOOL H245_VCCapability_aal1ViaGateway::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_gatewayAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_nullClockRecovery.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_srtsClockRecovery.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_adaptiveClockRecovery.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_nullErrorCorrection.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_longInterleaver.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_shortInterleaver.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_errorCorrectionOnly.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_structuredDataTransfer.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_partiallyFilledCells.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_VCCapability_aal1ViaGateway::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_gatewayAddress.Encode(strm);
  m_nullClockRecovery.Encode(strm);
  m_srtsClockRecovery.Encode(strm);
  m_adaptiveClockRecovery.Encode(strm);
  m_nullErrorCorrection.Encode(strm);
  m_longInterleaver.Encode(strm);
  m_shortInterleaver.Encode(strm);
  m_errorCorrectionOnly.Encode(strm);
  m_structuredDataTransfer.Encode(strm);
  m_partiallyFilledCells.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_gatewayAddress.Encode(strm);
  m_nullClockRecovery.Encode(strm);
  m_srtsClockRecovery.Encode(strm);
  m_adaptiveClockRecovery.Encode(strm);
  m_nullErrorCorrection.Encode(strm);
  m_longInterleaver.Encode(strm);
  m_shortInterleaver.Encode(strm);
  m_errorCorrectionOnly.Encode(strm);
  m_structuredDataTransfer.Encode(strm);
  m_partiallyFilledCells.Encode(strm);
}


PObject * H245_VCCapability_aal1ViaGateway::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_VCCapability_aal1ViaGateway::Class()), PInvalidCast);
#endif
  return new H245_VCCapability_aal1ViaGateway(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_VCCapability_aal1ViaGateway::preShowEthereal( void )
{
  m_gatewayAddress.preShowEthereal( );
  m_nullClockRecovery.preShowEthereal( );
  m_srtsClockRecovery.preShowEthereal( );
  m_adaptiveClockRecovery.preShowEthereal( );
  m_nullErrorCorrection.preShowEthereal( );
  m_longInterleaver.preShowEthereal( );
  m_shortInterleaver.preShowEthereal( );
  m_errorCorrectionOnly.preShowEthereal( );
  m_structuredDataTransfer.preShowEthereal( );
  m_partiallyFilledCells.preShowEthereal( );
}

PString H245_VCCapability_aal1ViaGateway::getSummary( void ) 
{
  return PString( "VCCapability_aal1ViaGateway" );
}

void H245_VCCapability_aal1ViaGateway::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *gatewayAddress_tree = (proto_tree*) NULL;
  proto_item *gatewayAddress_ti = (proto_item*) NULL;
  gatewayAddress_ti = proto_tree_add_text( tree, tvb, offset + m_gatewayAddress.GetStartByte(), m_gatewayAddress.GetByteLength(), "gatewayAddress (Q2931Address)" );
  gatewayAddress_tree = proto_item_add_subtree( gatewayAddress_ti, hCont->h245_2.ett_h245_VCCapability_aal1ViaGateway_gatewayAddress );

  m_gatewayAddress.showEthereal( gatewayAddress_tree, tvb, offset );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_VCCapability_aal1ViaGateway_nullClockRecovery, tvb, offset + m_nullClockRecovery.GetStartByte(), m_nullClockRecovery.GetByteLength() , m_nullClockRecovery.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_VCCapability_aal1ViaGateway_srtsClockRecovery, tvb, offset + m_srtsClockRecovery.GetStartByte(), m_srtsClockRecovery.GetByteLength() , m_srtsClockRecovery.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_VCCapability_aal1ViaGateway_adaptiveClockRecovery, tvb, offset + m_adaptiveClockRecovery.GetStartByte(), m_adaptiveClockRecovery.GetByteLength() , m_adaptiveClockRecovery.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_VCCapability_aal1ViaGateway_nullErrorCorrection, tvb, offset + m_nullErrorCorrection.GetStartByte(), m_nullErrorCorrection.GetByteLength() , m_nullErrorCorrection.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_VCCapability_aal1ViaGateway_longInterleaver, tvb, offset + m_longInterleaver.GetStartByte(), m_longInterleaver.GetByteLength() , m_longInterleaver.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_VCCapability_aal1ViaGateway_shortInterleaver, tvb, offset + m_shortInterleaver.GetStartByte(), m_shortInterleaver.GetByteLength() , m_shortInterleaver.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_VCCapability_aal1ViaGateway_errorCorrectionOnly, tvb, offset + m_errorCorrectionOnly.GetStartByte(), m_errorCorrectionOnly.GetByteLength() , m_errorCorrectionOnly.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_VCCapability_aal1ViaGateway_structuredDataTransfer, tvb, offset + m_structuredDataTransfer.GetStartByte(), m_structuredDataTransfer.GetByteLength() , m_structuredDataTransfer.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_VCCapability_aal1ViaGateway_partiallyFilledCells, tvb, offset + m_partiallyFilledCells.GetStartByte(), m_partiallyFilledCells.GetByteLength() , m_partiallyFilledCells.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// CustomPictureFormat_mPI
//

H245_CustomPictureFormat_mPI::H245_CustomPictureFormat_mPI(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_standardMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 31);
}


#ifndef PASN_NOPRINTON
void H245_CustomPictureFormat_mPI::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_standardMPI))
    strm << setw(indent+14) << "standardMPI = " << setprecision(indent) << m_standardMPI << '\n';
  if (HasOptionalField(e_customPCF))
    strm << setw(indent+12) << "customPCF = " << setprecision(indent) << m_customPCF << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_CustomPictureFormat_mPI::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_CustomPictureFormat_mPI::Class()), PInvalidCast);
#endif
  const H245_CustomPictureFormat_mPI & other = (const H245_CustomPictureFormat_mPI &)obj;

  Comparison result;

  if ((result = m_standardMPI.Compare(other.m_standardMPI)) != EqualTo)
    return result;
  if ((result = m_customPCF.Compare(other.m_customPCF)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_CustomPictureFormat_mPI::GetDataLength() const
{
  return m_standardMPI.GetObjectLength() +
         m_customPCF.GetObjectLength();
}


BOOL H245_CustomPictureFormat_mPI::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_standardMPI ) && !m_standardMPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_customPCF ) && !m_customPCF.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_CustomPictureFormat_mPI::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_standardMPI))
    m_standardMPI.Encode(strm);
  if (HasOptionalField(e_customPCF))
    m_customPCF.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_standardMPI))
    m_standardMPI.Encode(strm);
  if (HasOptionalField(e_customPCF))
    m_customPCF.Encode(strm);
}


PObject * H245_CustomPictureFormat_mPI::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CustomPictureFormat_mPI::Class()), PInvalidCast);
#endif
  return new H245_CustomPictureFormat_mPI(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CustomPictureFormat_mPI::preShowEthereal( void )
{
  if ( HasOptionalField( e_standardMPI ) ) 
      m_standardMPI.preShowEthereal( );
  if ( HasOptionalField( e_customPCF ) ) 
      m_customPCF.preShowEthereal( );
}

PString H245_CustomPictureFormat_mPI::getSummary( void ) 
{
  return PString( "CustomPictureFormat_mPI" );
}

void H245_CustomPictureFormat_mPI::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_standardMPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_CustomPictureFormat_mPI_standardMPI, tvb, offset + m_standardMPI.GetStartByte(), m_standardMPI.GetByteLength() , m_standardMPI.GetValue() );
  }

  if ( HasOptionalField( e_customPCF ) ) {
    proto_tree *customPCF_tree = (proto_tree*) NULL;
    proto_item *customPCF_ti = (proto_item*) NULL;
    customPCF_ti = proto_tree_add_text( tree, tvb, offset + m_customPCF.GetStartByte(), m_customPCF.GetByteLength(), "customPCF (CustomPictureFormat-mPI-customPCF)" );
    customPCF_tree = proto_item_add_subtree( customPCF_ti, hCont->h245_2.ett_h245_CustomPictureFormat_mPI_customPCF );
    m_customPCF.showEthereal( customPCF_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// OpenLogicalChannel_forwardLogicalChannelParameters
//

H245_OpenLogicalChannel_forwardLogicalChannelParameters::H245_OpenLogicalChannel_forwardLogicalChannelParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 2)
{
  m_portNumber.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_OpenLogicalChannel_forwardLogicalChannelParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_portNumber))
    strm << setw(indent+13) << "portNumber = " << setprecision(indent) << m_portNumber << '\n';
  strm << setw(indent+11) << "dataType = " << setprecision(indent) << m_dataType << '\n';
  strm << setw(indent+22) << "multiplexParameters = " << setprecision(indent) << m_multiplexParameters << '\n';
  if (HasOptionalField(e_forwardLogicalChannelDependency))
    strm << setw(indent+34) << "forwardLogicalChannelDependency = " << setprecision(indent) << m_forwardLogicalChannelDependency << '\n';
  if (HasOptionalField(e_replacementFor))
    strm << setw(indent+17) << "replacementFor = " << setprecision(indent) << m_replacementFor << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_OpenLogicalChannel_forwardLogicalChannelParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_OpenLogicalChannel_forwardLogicalChannelParameters::Class()), PInvalidCast);
#endif
  const H245_OpenLogicalChannel_forwardLogicalChannelParameters & other = (const H245_OpenLogicalChannel_forwardLogicalChannelParameters &)obj;

  Comparison result;

  if ((result = m_portNumber.Compare(other.m_portNumber)) != EqualTo)
    return result;
  if ((result = m_dataType.Compare(other.m_dataType)) != EqualTo)
    return result;
  if ((result = m_multiplexParameters.Compare(other.m_multiplexParameters)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_OpenLogicalChannel_forwardLogicalChannelParameters::GetDataLength() const
{
  return m_portNumber.GetObjectLength() +
         m_dataType.GetObjectLength() +
         m_multiplexParameters.GetObjectLength();
}


BOOL H245_OpenLogicalChannel_forwardLogicalChannelParameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_portNumber ) && !m_portNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_dataType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_multiplexParameters.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_forwardLogicalChannelDependency, m_forwardLogicalChannelDependency ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_replacementFor, m_replacementFor ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_OpenLogicalChannel_forwardLogicalChannelParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_portNumber))
    m_portNumber.Encode(strm);
  m_dataType.Encode(strm);
  m_multiplexParameters.Encode(strm);
  KnownExtensionEncode(strm, e_forwardLogicalChannelDependency, m_forwardLogicalChannelDependency);
  KnownExtensionEncode(strm, e_replacementFor, m_replacementFor);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_portNumber))
    m_portNumber.Encode(strm);
  m_dataType.Encode(strm);
  m_multiplexParameters.Encode(strm);
}


PObject * H245_OpenLogicalChannel_forwardLogicalChannelParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannel_forwardLogicalChannelParameters::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannel_forwardLogicalChannelParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_OpenLogicalChannel_forwardLogicalChannelParameters::preShowEthereal( void )
{
  if ( HasOptionalField( e_portNumber ) ) 
      m_portNumber.preShowEthereal( );
  m_dataType.preShowEthereal( );
  m_multiplexParameters.preShowEthereal( );
  if ( HasOptionalField( e_forwardLogicalChannelDependency ) ) 
      m_forwardLogicalChannelDependency.preShowEthereal( );
  if ( HasOptionalField( e_replacementFor ) ) 
      m_replacementFor.preShowEthereal( );
}

PString H245_OpenLogicalChannel_forwardLogicalChannelParameters::getSummary( void ) 
{
  return PString( "OpenLogicalChannel_forwardLogicalChannelParameters" );
}

void H245_OpenLogicalChannel_forwardLogicalChannelParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_portNumber ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_OpenLogicalChannel_forwardLogicalChannelParameters_portNumber, tvb, offset + m_portNumber.GetStartByte(), m_portNumber.GetByteLength() , m_portNumber.GetValue() );
  }

  proto_tree *dataType_tree = (proto_tree*) NULL;
  proto_item *dataType_ti = (proto_item*) NULL;
  dataType_ti = proto_tree_add_text( tree, tvb, offset + m_dataType.GetStartByte(), m_dataType.GetByteLength(), "dataType (%s)", ( const char* ) m_dataType.GetTagName() );
  dataType_tree = proto_item_add_subtree( dataType_ti, hCont->h245_2.ett_h245_OpenLogicalChannel_forwardLogicalChannelParameters_dataType );

  m_dataType.showEthereal( dataType_tree, tvb, offset );

  proto_tree *multiplexParameters_tree = (proto_tree*) NULL;
  proto_item *multiplexParameters_ti = (proto_item*) NULL;
  multiplexParameters_ti = proto_tree_add_text( tree, tvb, offset + m_multiplexParameters.GetStartByte(), m_multiplexParameters.GetByteLength(), "multiplexParameters (%s)", ( const char* ) m_multiplexParameters.GetTagName() );
  multiplexParameters_tree = proto_item_add_subtree( multiplexParameters_ti, hCont->h245_2.ett_h245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters );

  m_multiplexParameters.showEthereal( multiplexParameters_tree, tvb, offset );

  if ( HasOptionalField( e_forwardLogicalChannelDependency ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_OpenLogicalChannel_forwardLogicalChannelParameters_forwardLogicalChannelDependency, tvb, offset + m_forwardLogicalChannelDependency.GetStartByte(), m_forwardLogicalChannelDependency.GetByteLength() , m_forwardLogicalChannelDependency.GetValue() );
  }

  if ( HasOptionalField( e_replacementFor ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_OpenLogicalChannel_forwardLogicalChannelParameters_replacementFor, tvb, offset + m_replacementFor.GetStartByte(), m_replacementFor.GetByteLength() , m_replacementFor.GetValue() );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// OpenLogicalChannel_reverseLogicalChannelParameters
//

H245_OpenLogicalChannel_reverseLogicalChannelParameters::H245_OpenLogicalChannel_reverseLogicalChannelParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 2)
{
}


#ifndef PASN_NOPRINTON
void H245_OpenLogicalChannel_reverseLogicalChannelParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "dataType = " << setprecision(indent) << m_dataType << '\n';
  if (HasOptionalField(e_multiplexParameters))
    strm << setw(indent+22) << "multiplexParameters = " << setprecision(indent) << m_multiplexParameters << '\n';
  if (HasOptionalField(e_reverseLogicalChannelDependency))
    strm << setw(indent+34) << "reverseLogicalChannelDependency = " << setprecision(indent) << m_reverseLogicalChannelDependency << '\n';
  if (HasOptionalField(e_replacementFor))
    strm << setw(indent+17) << "replacementFor = " << setprecision(indent) << m_replacementFor << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_OpenLogicalChannel_reverseLogicalChannelParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_OpenLogicalChannel_reverseLogicalChannelParameters::Class()), PInvalidCast);
#endif
  const H245_OpenLogicalChannel_reverseLogicalChannelParameters & other = (const H245_OpenLogicalChannel_reverseLogicalChannelParameters &)obj;

  Comparison result;

  if ((result = m_dataType.Compare(other.m_dataType)) != EqualTo)
    return result;
  if ((result = m_multiplexParameters.Compare(other.m_multiplexParameters)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_OpenLogicalChannel_reverseLogicalChannelParameters::GetDataLength() const
{
  return m_dataType.GetObjectLength() +
         m_multiplexParameters.GetObjectLength();
}


BOOL H245_OpenLogicalChannel_reverseLogicalChannelParameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_dataType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_multiplexParameters ) && !m_multiplexParameters.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_reverseLogicalChannelDependency, m_reverseLogicalChannelDependency ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_replacementFor, m_replacementFor ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_OpenLogicalChannel_reverseLogicalChannelParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_dataType.Encode(strm);
  if (HasOptionalField(e_multiplexParameters))
    m_multiplexParameters.Encode(strm);
  KnownExtensionEncode(strm, e_reverseLogicalChannelDependency, m_reverseLogicalChannelDependency);
  KnownExtensionEncode(strm, e_replacementFor, m_replacementFor);

  UnknownExtensionsEncode(strm);
  m_dataType.Encode(strm);
  if (HasOptionalField(e_multiplexParameters))
    m_multiplexParameters.Encode(strm);
}


PObject * H245_OpenLogicalChannel_reverseLogicalChannelParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannel_reverseLogicalChannelParameters::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannel_reverseLogicalChannelParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_OpenLogicalChannel_reverseLogicalChannelParameters::preShowEthereal( void )
{
  m_dataType.preShowEthereal( );
  if ( HasOptionalField( e_multiplexParameters ) ) 
      m_multiplexParameters.preShowEthereal( );
  if ( HasOptionalField( e_reverseLogicalChannelDependency ) ) 
      m_reverseLogicalChannelDependency.preShowEthereal( );
  if ( HasOptionalField( e_replacementFor ) ) 
      m_replacementFor.preShowEthereal( );
}

PString H245_OpenLogicalChannel_reverseLogicalChannelParameters::getSummary( void ) 
{
  return PString( "OpenLogicalChannel_reverseLogicalChannelParameters" );
}

void H245_OpenLogicalChannel_reverseLogicalChannelParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *dataType_tree = (proto_tree*) NULL;
  proto_item *dataType_ti = (proto_item*) NULL;
  dataType_ti = proto_tree_add_text( tree, tvb, offset + m_dataType.GetStartByte(), m_dataType.GetByteLength(), "dataType (%s)", ( const char* ) m_dataType.GetTagName() );
  dataType_tree = proto_item_add_subtree( dataType_ti, hCont->h245_2.ett_h245_OpenLogicalChannel_reverseLogicalChannelParameters_dataType );

  m_dataType.showEthereal( dataType_tree, tvb, offset );

  if ( HasOptionalField( e_multiplexParameters ) ) {
    proto_tree *multiplexParameters_tree = (proto_tree*) NULL;
    proto_item *multiplexParameters_ti = (proto_item*) NULL;
    multiplexParameters_ti = proto_tree_add_text( tree, tvb, offset + m_multiplexParameters.GetStartByte(), m_multiplexParameters.GetByteLength(), "multiplexParameters (%s)", ( const char* ) m_multiplexParameters.GetTagName() );
    multiplexParameters_tree = proto_item_add_subtree( multiplexParameters_ti, hCont->h245_2.ett_h245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters );
    m_multiplexParameters.showEthereal( multiplexParameters_tree, tvb, offset );
  }

  if ( HasOptionalField( e_reverseLogicalChannelDependency ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_OpenLogicalChannel_reverseLogicalChannelParameters_reverseLogicalChannelDependency, tvb, offset + m_reverseLogicalChannelDependency.GetStartByte(), m_reverseLogicalChannelDependency.GetByteLength() , m_reverseLogicalChannelDependency.GetValue() );
  }

  if ( HasOptionalField( e_replacementFor ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_OpenLogicalChannel_reverseLogicalChannelParameters_replacementFor, tvb, offset + m_replacementFor.GetStartByte(), m_replacementFor.GetByteLength() , m_replacementFor.GetValue() );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// UnicastAddress_iPSourceRouteAddress
//

H245_UnicastAddress_iPSourceRouteAddress::H245_UnicastAddress_iPSourceRouteAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_network.SetConstraints(PASN_Object::FixedConstraint, 4, 4);
  m_tsapIdentifier.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_UnicastAddress_iPSourceRouteAddress::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "routing = " << setprecision(indent) << m_routing << '\n';
  strm << setw(indent+10) << "network = " << setprecision(indent) << m_network << '\n';
  strm << setw(indent+17) << "tsapIdentifier = " << setprecision(indent) << m_tsapIdentifier << '\n';
  strm << setw(indent+8) << "route = " << setprecision(indent) << m_route << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_UnicastAddress_iPSourceRouteAddress::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_UnicastAddress_iPSourceRouteAddress::Class()), PInvalidCast);
#endif
  const H245_UnicastAddress_iPSourceRouteAddress & other = (const H245_UnicastAddress_iPSourceRouteAddress &)obj;

  Comparison result;

  if ((result = m_routing.Compare(other.m_routing)) != EqualTo)
    return result;
  if ((result = m_network.Compare(other.m_network)) != EqualTo)
    return result;
  if ((result = m_tsapIdentifier.Compare(other.m_tsapIdentifier)) != EqualTo)
    return result;
  if ((result = m_route.Compare(other.m_route)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_UnicastAddress_iPSourceRouteAddress::GetDataLength() const
{
  return m_routing.GetObjectLength() +
         m_network.GetObjectLength() +
         m_tsapIdentifier.GetObjectLength() +
         m_route.GetObjectLength();
}


BOOL H245_UnicastAddress_iPSourceRouteAddress::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_routing.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_network.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_tsapIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_route.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_UnicastAddress_iPSourceRouteAddress::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_routing.Encode(strm);
  m_network.Encode(strm);
  m_tsapIdentifier.Encode(strm);
  m_route.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_routing.Encode(strm);
  m_network.Encode(strm);
  m_tsapIdentifier.Encode(strm);
  m_route.Encode(strm);
}


PObject * H245_UnicastAddress_iPSourceRouteAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UnicastAddress_iPSourceRouteAddress::Class()), PInvalidCast);
#endif
  return new H245_UnicastAddress_iPSourceRouteAddress(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_UnicastAddress_iPSourceRouteAddress::preShowEthereal( void )
{
  m_routing.preShowEthereal( );
  m_network.preShowEthereal( );
  m_tsapIdentifier.preShowEthereal( );
  m_route.preShowEthereal( );
}

PString H245_UnicastAddress_iPSourceRouteAddress::getSummary( void ) 
{
  return PString( "UnicastAddress_iPSourceRouteAddress" );
}

void H245_UnicastAddress_iPSourceRouteAddress::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *routing_tree = (proto_tree*) NULL;
  proto_item *routing_ti = (proto_item*) NULL;
  routing_ti = proto_tree_add_text( tree, tvb, offset + m_routing.GetStartByte(), m_routing.GetByteLength(), "routing (%s)", ( const char* ) m_routing.GetTagName() );
  routing_tree = proto_item_add_subtree( routing_ti, hCont->h245_2.ett_h245_UnicastAddress_iPSourceRouteAddress_routing );

  m_routing.showEthereal( routing_tree, tvb, offset );

  char* pnetwork = m_network.getValue();
  proto_tree_add_string( tree, hCont->h245_2.hf_h245_UnicastAddress_iPSourceRouteAddress_network, tvb, offset + m_network.GetStartByte(), m_network.GetByteLength() , pnetwork );
  delete[] pnetwork;

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_UnicastAddress_iPSourceRouteAddress_tsapIdentifier, tvb, offset + m_tsapIdentifier.GetStartByte(), m_tsapIdentifier.GetByteLength() , m_tsapIdentifier.GetValue() );

  proto_tree *route_tree = (proto_tree*) NULL;
  proto_item *route_ti = (proto_item*) NULL;
  route_ti = proto_tree_add_text( tree, tvb, offset + m_route.GetStartByte(), m_route.GetByteLength(), "route (UnicastAddress-iPSourceRouteAddress-route)" );
  route_tree = proto_item_add_subtree( route_ti, hCont->h245_2.ett_h245_UnicastAddress_iPSourceRouteAddress_route );

  m_route.showEthereal( route_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// OpenLogicalChannelAck_reverseLogicalChannelParameters
//

H245_OpenLogicalChannelAck_reverseLogicalChannelParameters::H245_OpenLogicalChannelAck_reverseLogicalChannelParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 1)
{
  m_portNumber.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_OpenLogicalChannelAck_reverseLogicalChannelParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+30) << "reverseLogicalChannelNumber = " << setprecision(indent) << m_reverseLogicalChannelNumber << '\n';
  if (HasOptionalField(e_portNumber))
    strm << setw(indent+13) << "portNumber = " << setprecision(indent) << m_portNumber << '\n';
  if (HasOptionalField(e_multiplexParameters))
    strm << setw(indent+22) << "multiplexParameters = " << setprecision(indent) << m_multiplexParameters << '\n';
  if (HasOptionalField(e_replacementFor))
    strm << setw(indent+17) << "replacementFor = " << setprecision(indent) << m_replacementFor << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_OpenLogicalChannelAck_reverseLogicalChannelParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_OpenLogicalChannelAck_reverseLogicalChannelParameters::Class()), PInvalidCast);
#endif
  const H245_OpenLogicalChannelAck_reverseLogicalChannelParameters & other = (const H245_OpenLogicalChannelAck_reverseLogicalChannelParameters &)obj;

  Comparison result;

  if ((result = m_reverseLogicalChannelNumber.Compare(other.m_reverseLogicalChannelNumber)) != EqualTo)
    return result;
  if ((result = m_portNumber.Compare(other.m_portNumber)) != EqualTo)
    return result;
  if ((result = m_multiplexParameters.Compare(other.m_multiplexParameters)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_OpenLogicalChannelAck_reverseLogicalChannelParameters::GetDataLength() const
{
  return m_reverseLogicalChannelNumber.GetObjectLength() +
         m_portNumber.GetObjectLength() +
         m_multiplexParameters.GetObjectLength();
}


BOOL H245_OpenLogicalChannelAck_reverseLogicalChannelParameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_reverseLogicalChannelNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_portNumber ) && !m_portNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_multiplexParameters ) && !m_multiplexParameters.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_replacementFor, m_replacementFor ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_OpenLogicalChannelAck_reverseLogicalChannelParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_reverseLogicalChannelNumber.Encode(strm);
  if (HasOptionalField(e_portNumber))
    m_portNumber.Encode(strm);
  if (HasOptionalField(e_multiplexParameters))
    m_multiplexParameters.Encode(strm);
  KnownExtensionEncode(strm, e_replacementFor, m_replacementFor);

  UnknownExtensionsEncode(strm);
  m_reverseLogicalChannelNumber.Encode(strm);
  if (HasOptionalField(e_portNumber))
    m_portNumber.Encode(strm);
  if (HasOptionalField(e_multiplexParameters))
    m_multiplexParameters.Encode(strm);
}


PObject * H245_OpenLogicalChannelAck_reverseLogicalChannelParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannelAck_reverseLogicalChannelParameters::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannelAck_reverseLogicalChannelParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_OpenLogicalChannelAck_reverseLogicalChannelParameters::preShowEthereal( void )
{
  m_reverseLogicalChannelNumber.preShowEthereal( );
  if ( HasOptionalField( e_portNumber ) ) 
      m_portNumber.preShowEthereal( );
  if ( HasOptionalField( e_multiplexParameters ) ) 
      m_multiplexParameters.preShowEthereal( );
  if ( HasOptionalField( e_replacementFor ) ) 
      m_replacementFor.preShowEthereal( );
}

PString H245_OpenLogicalChannelAck_reverseLogicalChannelParameters::getSummary( void ) 
{
  return PString( "OpenLogicalChannelAck_reverseLogicalChannelParameters" );
}

void H245_OpenLogicalChannelAck_reverseLogicalChannelParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_OpenLogicalChannelAck_reverseLogicalChannelParameters_reverseLogicalChannelNumber, tvb, offset + m_reverseLogicalChannelNumber.GetStartByte(), m_reverseLogicalChannelNumber.GetByteLength() , m_reverseLogicalChannelNumber.GetValue() );

  if ( HasOptionalField( e_portNumber ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber, tvb, offset + m_portNumber.GetStartByte(), m_portNumber.GetByteLength() , m_portNumber.GetValue() );
  }

  if ( HasOptionalField( e_multiplexParameters ) ) {
    proto_tree *multiplexParameters_tree = (proto_tree*) NULL;
    proto_item *multiplexParameters_ti = (proto_item*) NULL;
    multiplexParameters_ti = proto_tree_add_text( tree, tvb, offset + m_multiplexParameters.GetStartByte(), m_multiplexParameters.GetByteLength(), "multiplexParameters (%s)", ( const char* ) m_multiplexParameters.GetTagName() );
    multiplexParameters_tree = proto_item_add_subtree( multiplexParameters_ti, hCont->h245_2.ett_h245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters );
    m_multiplexParameters.showEthereal( multiplexParameters_tree, tvb, offset );
  }

  if ( HasOptionalField( e_replacementFor ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_OpenLogicalChannelAck_reverseLogicalChannelParameters_replacementFor, tvb, offset + m_replacementFor.GetStartByte(), m_replacementFor.GetByteLength() , m_replacementFor.GetValue() );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// ConferenceRequest_requestTerminalCertificate
//

H245_ConferenceRequest_requestTerminalCertificate::H245_ConferenceRequest_requestTerminalCertificate(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
  m_sRandom.SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H245_ConferenceRequest_requestTerminalCertificate::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_terminalLabel))
    strm << setw(indent+16) << "terminalLabel = " << setprecision(indent) << m_terminalLabel << '\n';
  if (HasOptionalField(e_certSelectionCriteria))
    strm << setw(indent+24) << "certSelectionCriteria = " << setprecision(indent) << m_certSelectionCriteria << '\n';
  if (HasOptionalField(e_sRandom))
    strm << setw(indent+10) << "sRandom = " << setprecision(indent) << m_sRandom << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_ConferenceRequest_requestTerminalCertificate::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_ConferenceRequest_requestTerminalCertificate::Class()), PInvalidCast);
#endif
  const H245_ConferenceRequest_requestTerminalCertificate & other = (const H245_ConferenceRequest_requestTerminalCertificate &)obj;

  Comparison result;

  if ((result = m_terminalLabel.Compare(other.m_terminalLabel)) != EqualTo)
    return result;
  if ((result = m_certSelectionCriteria.Compare(other.m_certSelectionCriteria)) != EqualTo)
    return result;
  if ((result = m_sRandom.Compare(other.m_sRandom)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ConferenceRequest_requestTerminalCertificate::GetDataLength() const
{
  return m_terminalLabel.GetObjectLength() +
         m_certSelectionCriteria.GetObjectLength() +
         m_sRandom.GetObjectLength();
}


BOOL H245_ConferenceRequest_requestTerminalCertificate::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_terminalLabel ) && !m_terminalLabel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_certSelectionCriteria ) && !m_certSelectionCriteria.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_sRandom ) && !m_sRandom.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_ConferenceRequest_requestTerminalCertificate::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_terminalLabel))
    m_terminalLabel.Encode(strm);
  if (HasOptionalField(e_certSelectionCriteria))
    m_certSelectionCriteria.Encode(strm);
  if (HasOptionalField(e_sRandom))
    m_sRandom.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_terminalLabel))
    m_terminalLabel.Encode(strm);
  if (HasOptionalField(e_certSelectionCriteria))
    m_certSelectionCriteria.Encode(strm);
  if (HasOptionalField(e_sRandom))
    m_sRandom.Encode(strm);
}


PObject * H245_ConferenceRequest_requestTerminalCertificate::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceRequest_requestTerminalCertificate::Class()), PInvalidCast);
#endif
  return new H245_ConferenceRequest_requestTerminalCertificate(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ConferenceRequest_requestTerminalCertificate::preShowEthereal( void )
{
  if ( HasOptionalField( e_terminalLabel ) ) 
      m_terminalLabel.preShowEthereal( );
  if ( HasOptionalField( e_certSelectionCriteria ) ) 
      m_certSelectionCriteria.preShowEthereal( );
  if ( HasOptionalField( e_sRandom ) ) 
      m_sRandom.preShowEthereal( );
}

PString H245_ConferenceRequest_requestTerminalCertificate::getSummary( void ) 
{
  return PString( "ConferenceRequest_requestTerminalCertificate" );
}

void H245_ConferenceRequest_requestTerminalCertificate::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_terminalLabel ) ) {
    proto_tree *terminalLabel_tree = (proto_tree*) NULL;
    proto_item *terminalLabel_ti = (proto_item*) NULL;
    terminalLabel_ti = proto_tree_add_text( tree, tvb, offset + m_terminalLabel.GetStartByte(), m_terminalLabel.GetByteLength(), "terminalLabel (TerminalLabel)" );
    terminalLabel_tree = proto_item_add_subtree( terminalLabel_ti, hCont->h245_2.ett_h245_ConferenceRequest_requestTerminalCertificate_terminalLabel );
    m_terminalLabel.showEthereal( terminalLabel_tree, tvb, offset );
  }

  if ( HasOptionalField( e_certSelectionCriteria ) ) {
    proto_tree *certSelectionCriteria_tree = (proto_tree*) NULL;
    proto_item *certSelectionCriteria_ti = (proto_item*) NULL;
    certSelectionCriteria_ti = proto_tree_add_text( tree, tvb, offset + m_certSelectionCriteria.GetStartByte(), m_certSelectionCriteria.GetByteLength(), "certSelectionCriteria (CertSelectionCriteria)" );
    certSelectionCriteria_tree = proto_item_add_subtree( certSelectionCriteria_ti, hCont->h245_2.ett_h245_ConferenceRequest_requestTerminalCertificate_certSelectionCriteria );
    m_certSelectionCriteria.showEthereal( certSelectionCriteria_tree, tvb, offset );
  }

  if ( HasOptionalField( e_sRandom ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_ConferenceRequest_requestTerminalCertificate_sRandom, tvb, offset + m_sRandom.GetStartByte(), m_sRandom.GetByteLength() , m_sRandom.GetValue() );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// ConferenceResponse_mCTerminalIDResponse
//

H245_ConferenceResponse_mCTerminalIDResponse::H245_ConferenceResponse_mCTerminalIDResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_ConferenceResponse_mCTerminalIDResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "terminalLabel = " << setprecision(indent) << m_terminalLabel << '\n';
  strm << setw(indent+13) << "terminalID = " << setprecision(indent) << m_terminalID << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_ConferenceResponse_mCTerminalIDResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_ConferenceResponse_mCTerminalIDResponse::Class()), PInvalidCast);
#endif
  const H245_ConferenceResponse_mCTerminalIDResponse & other = (const H245_ConferenceResponse_mCTerminalIDResponse &)obj;

  Comparison result;

  if ((result = m_terminalLabel.Compare(other.m_terminalLabel)) != EqualTo)
    return result;
  if ((result = m_terminalID.Compare(other.m_terminalID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ConferenceResponse_mCTerminalIDResponse::GetDataLength() const
{
  return m_terminalLabel.GetObjectLength() +
         m_terminalID.GetObjectLength();
}


BOOL H245_ConferenceResponse_mCTerminalIDResponse::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_terminalLabel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_terminalID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_ConferenceResponse_mCTerminalIDResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminalLabel.Encode(strm);
  m_terminalID.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_terminalLabel.Encode(strm);
  m_terminalID.Encode(strm);
}


PObject * H245_ConferenceResponse_mCTerminalIDResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse_mCTerminalIDResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse_mCTerminalIDResponse(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ConferenceResponse_mCTerminalIDResponse::preShowEthereal( void )
{
  m_terminalLabel.preShowEthereal( );
  m_terminalID.preShowEthereal( );
}

PString H245_ConferenceResponse_mCTerminalIDResponse::getSummary( void ) 
{
  return PString( "ConferenceResponse_mCTerminalIDResponse" );
}

void H245_ConferenceResponse_mCTerminalIDResponse::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *terminalLabel_tree = (proto_tree*) NULL;
  proto_item *terminalLabel_ti = (proto_item*) NULL;
  terminalLabel_ti = proto_tree_add_text( tree, tvb, offset + m_terminalLabel.GetStartByte(), m_terminalLabel.GetByteLength(), "terminalLabel (TerminalLabel)" );
  terminalLabel_tree = proto_item_add_subtree( terminalLabel_ti, hCont->h245_2.ett_h245_ConferenceResponse_mCTerminalIDResponse_terminalLabel );

  m_terminalLabel.showEthereal( terminalLabel_tree, tvb, offset );

  char* pterminalID = m_terminalID.getValue();
  proto_tree_add_string( tree, hCont->h245_2.hf_h245_ConferenceResponse_mCTerminalIDResponse_terminalID, tvb, offset + m_terminalID.GetStartByte(), m_terminalID.GetByteLength() , pterminalID );
  delete[] pterminalID;

}
#endif  //USE_FOR_ETHEREAL

//
// ConferenceResponse_terminalIDResponse
//

H245_ConferenceResponse_terminalIDResponse::H245_ConferenceResponse_terminalIDResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_ConferenceResponse_terminalIDResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "terminalLabel = " << setprecision(indent) << m_terminalLabel << '\n';
  strm << setw(indent+13) << "terminalID = " << setprecision(indent) << m_terminalID << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_ConferenceResponse_terminalIDResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_ConferenceResponse_terminalIDResponse::Class()), PInvalidCast);
#endif
  const H245_ConferenceResponse_terminalIDResponse & other = (const H245_ConferenceResponse_terminalIDResponse &)obj;

  Comparison result;

  if ((result = m_terminalLabel.Compare(other.m_terminalLabel)) != EqualTo)
    return result;
  if ((result = m_terminalID.Compare(other.m_terminalID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ConferenceResponse_terminalIDResponse::GetDataLength() const
{
  return m_terminalLabel.GetObjectLength() +
         m_terminalID.GetObjectLength();
}


BOOL H245_ConferenceResponse_terminalIDResponse::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_terminalLabel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_terminalID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_ConferenceResponse_terminalIDResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminalLabel.Encode(strm);
  m_terminalID.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_terminalLabel.Encode(strm);
  m_terminalID.Encode(strm);
}


PObject * H245_ConferenceResponse_terminalIDResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse_terminalIDResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse_terminalIDResponse(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ConferenceResponse_terminalIDResponse::preShowEthereal( void )
{
  m_terminalLabel.preShowEthereal( );
  m_terminalID.preShowEthereal( );
}

PString H245_ConferenceResponse_terminalIDResponse::getSummary( void ) 
{
  return PString( "ConferenceResponse_terminalIDResponse" );
}

void H245_ConferenceResponse_terminalIDResponse::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *terminalLabel_tree = (proto_tree*) NULL;
  proto_item *terminalLabel_ti = (proto_item*) NULL;
  terminalLabel_ti = proto_tree_add_text( tree, tvb, offset + m_terminalLabel.GetStartByte(), m_terminalLabel.GetByteLength(), "terminalLabel (TerminalLabel)" );
  terminalLabel_tree = proto_item_add_subtree( terminalLabel_ti, hCont->h245_2.ett_h245_ConferenceResponse_terminalIDResponse_terminalLabel );

  m_terminalLabel.showEthereal( terminalLabel_tree, tvb, offset );

  char* pterminalID = m_terminalID.getValue();
  proto_tree_add_string( tree, hCont->h245_2.hf_h245_ConferenceResponse_terminalIDResponse_terminalID, tvb, offset + m_terminalID.GetStartByte(), m_terminalID.GetByteLength() , pterminalID );
  delete[] pterminalID;

}
#endif  //USE_FOR_ETHEREAL

//
// ConferenceResponse_conferenceIDResponse
//

H245_ConferenceResponse_conferenceIDResponse::H245_ConferenceResponse_conferenceIDResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_ConferenceResponse_conferenceIDResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "terminalLabel = " << setprecision(indent) << m_terminalLabel << '\n';
  strm << setw(indent+15) << "conferenceID = " << setprecision(indent) << m_conferenceID << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_ConferenceResponse_conferenceIDResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_ConferenceResponse_conferenceIDResponse::Class()), PInvalidCast);
#endif
  const H245_ConferenceResponse_conferenceIDResponse & other = (const H245_ConferenceResponse_conferenceIDResponse &)obj;

  Comparison result;

  if ((result = m_terminalLabel.Compare(other.m_terminalLabel)) != EqualTo)
    return result;
  if ((result = m_conferenceID.Compare(other.m_conferenceID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ConferenceResponse_conferenceIDResponse::GetDataLength() const
{
  return m_terminalLabel.GetObjectLength() +
         m_conferenceID.GetObjectLength();
}


BOOL H245_ConferenceResponse_conferenceIDResponse::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_terminalLabel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_conferenceID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_ConferenceResponse_conferenceIDResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminalLabel.Encode(strm);
  m_conferenceID.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_terminalLabel.Encode(strm);
  m_conferenceID.Encode(strm);
}


PObject * H245_ConferenceResponse_conferenceIDResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse_conferenceIDResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse_conferenceIDResponse(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ConferenceResponse_conferenceIDResponse::preShowEthereal( void )
{
  m_terminalLabel.preShowEthereal( );
  m_conferenceID.preShowEthereal( );
}

PString H245_ConferenceResponse_conferenceIDResponse::getSummary( void ) 
{
  return PString( "ConferenceResponse_conferenceIDResponse" );
}

void H245_ConferenceResponse_conferenceIDResponse::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *terminalLabel_tree = (proto_tree*) NULL;
  proto_item *terminalLabel_ti = (proto_item*) NULL;
  terminalLabel_ti = proto_tree_add_text( tree, tvb, offset + m_terminalLabel.GetStartByte(), m_terminalLabel.GetByteLength(), "terminalLabel (TerminalLabel)" );
  terminalLabel_tree = proto_item_add_subtree( terminalLabel_ti, hCont->h245_2.ett_h245_ConferenceResponse_conferenceIDResponse_terminalLabel );

  m_terminalLabel.showEthereal( terminalLabel_tree, tvb, offset );

  char* pconferenceID = m_conferenceID.getValue();
  proto_tree_add_string( tree, hCont->h245_2.hf_h245_ConferenceResponse_conferenceIDResponse_conferenceID, tvb, offset + m_conferenceID.GetStartByte(), m_conferenceID.GetByteLength() , pconferenceID );
  delete[] pconferenceID;

}
#endif  //USE_FOR_ETHEREAL

//
// ConferenceResponse_passwordResponse
//

H245_ConferenceResponse_passwordResponse::H245_ConferenceResponse_passwordResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_ConferenceResponse_passwordResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "terminalLabel = " << setprecision(indent) << m_terminalLabel << '\n';
  strm << setw(indent+11) << "password = " << setprecision(indent) << m_password << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_ConferenceResponse_passwordResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_ConferenceResponse_passwordResponse::Class()), PInvalidCast);
#endif
  const H245_ConferenceResponse_passwordResponse & other = (const H245_ConferenceResponse_passwordResponse &)obj;

  Comparison result;

  if ((result = m_terminalLabel.Compare(other.m_terminalLabel)) != EqualTo)
    return result;
  if ((result = m_password.Compare(other.m_password)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ConferenceResponse_passwordResponse::GetDataLength() const
{
  return m_terminalLabel.GetObjectLength() +
         m_password.GetObjectLength();
}


BOOL H245_ConferenceResponse_passwordResponse::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_terminalLabel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_password.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_ConferenceResponse_passwordResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminalLabel.Encode(strm);
  m_password.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_terminalLabel.Encode(strm);
  m_password.Encode(strm);
}


PObject * H245_ConferenceResponse_passwordResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse_passwordResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse_passwordResponse(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ConferenceResponse_passwordResponse::preShowEthereal( void )
{
  m_terminalLabel.preShowEthereal( );
  m_password.preShowEthereal( );
}

PString H245_ConferenceResponse_passwordResponse::getSummary( void ) 
{
  return PString( "ConferenceResponse_passwordResponse" );
}

void H245_ConferenceResponse_passwordResponse::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *terminalLabel_tree = (proto_tree*) NULL;
  proto_item *terminalLabel_ti = (proto_item*) NULL;
  terminalLabel_ti = proto_tree_add_text( tree, tvb, offset + m_terminalLabel.GetStartByte(), m_terminalLabel.GetByteLength(), "terminalLabel (TerminalLabel)" );
  terminalLabel_tree = proto_item_add_subtree( terminalLabel_ti, hCont->h245_2.ett_h245_ConferenceResponse_passwordResponse_terminalLabel );

  m_terminalLabel.showEthereal( terminalLabel_tree, tvb, offset );

  char* ppassword = m_password.getValue();
  proto_tree_add_string( tree, hCont->h245_2.hf_h245_ConferenceResponse_passwordResponse_password, tvb, offset + m_password.GetStartByte(), m_password.GetByteLength() , ppassword );
  delete[] ppassword;

}
#endif  //USE_FOR_ETHEREAL

//
// ConferenceResponse_chairTokenOwnerResponse
//

H245_ConferenceResponse_chairTokenOwnerResponse::H245_ConferenceResponse_chairTokenOwnerResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_ConferenceResponse_chairTokenOwnerResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "terminalLabel = " << setprecision(indent) << m_terminalLabel << '\n';
  strm << setw(indent+13) << "terminalID = " << setprecision(indent) << m_terminalID << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_ConferenceResponse_chairTokenOwnerResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_ConferenceResponse_chairTokenOwnerResponse::Class()), PInvalidCast);
#endif
  const H245_ConferenceResponse_chairTokenOwnerResponse & other = (const H245_ConferenceResponse_chairTokenOwnerResponse &)obj;

  Comparison result;

  if ((result = m_terminalLabel.Compare(other.m_terminalLabel)) != EqualTo)
    return result;
  if ((result = m_terminalID.Compare(other.m_terminalID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ConferenceResponse_chairTokenOwnerResponse::GetDataLength() const
{
  return m_terminalLabel.GetObjectLength() +
         m_terminalID.GetObjectLength();
}


BOOL H245_ConferenceResponse_chairTokenOwnerResponse::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_terminalLabel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_terminalID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_ConferenceResponse_chairTokenOwnerResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminalLabel.Encode(strm);
  m_terminalID.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_terminalLabel.Encode(strm);
  m_terminalID.Encode(strm);
}


PObject * H245_ConferenceResponse_chairTokenOwnerResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse_chairTokenOwnerResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse_chairTokenOwnerResponse(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ConferenceResponse_chairTokenOwnerResponse::preShowEthereal( void )
{
  m_terminalLabel.preShowEthereal( );
  m_terminalID.preShowEthereal( );
}

PString H245_ConferenceResponse_chairTokenOwnerResponse::getSummary( void ) 
{
  return PString( "ConferenceResponse_chairTokenOwnerResponse" );
}

void H245_ConferenceResponse_chairTokenOwnerResponse::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *terminalLabel_tree = (proto_tree*) NULL;
  proto_item *terminalLabel_ti = (proto_item*) NULL;
  terminalLabel_ti = proto_tree_add_text( tree, tvb, offset + m_terminalLabel.GetStartByte(), m_terminalLabel.GetByteLength(), "terminalLabel (TerminalLabel)" );
  terminalLabel_tree = proto_item_add_subtree( terminalLabel_ti, hCont->h245_2.ett_h245_ConferenceResponse_chairTokenOwnerResponse_terminalLabel );

  m_terminalLabel.showEthereal( terminalLabel_tree, tvb, offset );

  char* pterminalID = m_terminalID.getValue();
  proto_tree_add_string( tree, hCont->h245_2.hf_h245_ConferenceResponse_chairTokenOwnerResponse_terminalID, tvb, offset + m_terminalID.GetStartByte(), m_terminalID.GetByteLength() , pterminalID );
  delete[] pterminalID;

}
#endif  //USE_FOR_ETHEREAL

//
// ConferenceResponse_terminalCertificateResponse
//

H245_ConferenceResponse_terminalCertificateResponse::H245_ConferenceResponse_terminalCertificateResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_certificateResponse.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H245_ConferenceResponse_terminalCertificateResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_terminalLabel))
    strm << setw(indent+16) << "terminalLabel = " << setprecision(indent) << m_terminalLabel << '\n';
  if (HasOptionalField(e_certificateResponse))
    strm << setw(indent+22) << "certificateResponse = " << setprecision(indent) << m_certificateResponse << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_ConferenceResponse_terminalCertificateResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_ConferenceResponse_terminalCertificateResponse::Class()), PInvalidCast);
#endif
  const H245_ConferenceResponse_terminalCertificateResponse & other = (const H245_ConferenceResponse_terminalCertificateResponse &)obj;

  Comparison result;

  if ((result = m_terminalLabel.Compare(other.m_terminalLabel)) != EqualTo)
    return result;
  if ((result = m_certificateResponse.Compare(other.m_certificateResponse)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ConferenceResponse_terminalCertificateResponse::GetDataLength() const
{
  return m_terminalLabel.GetObjectLength() +
         m_certificateResponse.GetObjectLength();
}


BOOL H245_ConferenceResponse_terminalCertificateResponse::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_terminalLabel ) && !m_terminalLabel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_certificateResponse ) && !m_certificateResponse.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_ConferenceResponse_terminalCertificateResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_terminalLabel))
    m_terminalLabel.Encode(strm);
  if (HasOptionalField(e_certificateResponse))
    m_certificateResponse.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_terminalLabel))
    m_terminalLabel.Encode(strm);
  if (HasOptionalField(e_certificateResponse))
    m_certificateResponse.Encode(strm);
}


PObject * H245_ConferenceResponse_terminalCertificateResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse_terminalCertificateResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse_terminalCertificateResponse(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ConferenceResponse_terminalCertificateResponse::preShowEthereal( void )
{
  if ( HasOptionalField( e_terminalLabel ) ) 
      m_terminalLabel.preShowEthereal( );
  if ( HasOptionalField( e_certificateResponse ) ) 
      m_certificateResponse.preShowEthereal( );
}

PString H245_ConferenceResponse_terminalCertificateResponse::getSummary( void ) 
{
  return PString( "ConferenceResponse_terminalCertificateResponse" );
}

void H245_ConferenceResponse_terminalCertificateResponse::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_terminalLabel ) ) {
    proto_tree *terminalLabel_tree = (proto_tree*) NULL;
    proto_item *terminalLabel_ti = (proto_item*) NULL;
    terminalLabel_ti = proto_tree_add_text( tree, tvb, offset + m_terminalLabel.GetStartByte(), m_terminalLabel.GetByteLength(), "terminalLabel (TerminalLabel)" );
    terminalLabel_tree = proto_item_add_subtree( terminalLabel_ti, hCont->h245_2.ett_h245_ConferenceResponse_terminalCertificateResponse_terminalLabel );
    m_terminalLabel.showEthereal( terminalLabel_tree, tvb, offset );
  }

  if ( HasOptionalField( e_certificateResponse ) ) {
    char* pcertificateResponse = m_certificateResponse.getValue();
    proto_tree_add_string( tree, hCont->h245_2.hf_h245_ConferenceResponse_terminalCertificateResponse_certificateResponse, tvb, offset + m_certificateResponse.GetStartByte(), m_certificateResponse.GetByteLength() , pcertificateResponse );
    delete[] pcertificateResponse;
  }

}
#endif  //USE_FOR_ETHEREAL

//
// MultilinkRequest_maximumHeaderInterval
//

H245_MultilinkRequest_maximumHeaderInterval::H245_MultilinkRequest_maximumHeaderInterval(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultilinkRequest_maximumHeaderInterval::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "requestType = " << setprecision(indent) << m_requestType << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MultilinkRequest_maximumHeaderInterval::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MultilinkRequest_maximumHeaderInterval::Class()), PInvalidCast);
#endif
  const H245_MultilinkRequest_maximumHeaderInterval & other = (const H245_MultilinkRequest_maximumHeaderInterval &)obj;

  Comparison result;

  if ((result = m_requestType.Compare(other.m_requestType)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultilinkRequest_maximumHeaderInterval::GetDataLength() const
{
  return m_requestType.GetObjectLength();
}


BOOL H245_MultilinkRequest_maximumHeaderInterval::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MultilinkRequest_maximumHeaderInterval::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestType.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_requestType.Encode(strm);
}


PObject * H245_MultilinkRequest_maximumHeaderInterval::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkRequest_maximumHeaderInterval::Class()), PInvalidCast);
#endif
  return new H245_MultilinkRequest_maximumHeaderInterval(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultilinkRequest_maximumHeaderInterval::preShowEthereal( void )
{
  m_requestType.preShowEthereal( );
}

PString H245_MultilinkRequest_maximumHeaderInterval::getSummary( void ) 
{
  return PString( "MultilinkRequest_maximumHeaderInterval" );
}

void H245_MultilinkRequest_maximumHeaderInterval::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *requestType_tree = (proto_tree*) NULL;
  proto_item *requestType_ti = (proto_item*) NULL;
  requestType_ti = proto_tree_add_text( tree, tvb, offset + m_requestType.GetStartByte(), m_requestType.GetByteLength(), "requestType (%s)", ( const char* ) m_requestType.GetTagName() );
  requestType_tree = proto_item_add_subtree( requestType_ti, hCont->h245_2.ett_h245_MultilinkRequest_maximumHeaderInterval_requestType );

  m_requestType.showEthereal( requestType_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// MultilinkResponse_addConnection
//

H245_MultilinkResponse_addConnection::H245_MultilinkResponse_addConnection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultilinkResponse_addConnection::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+15) << "responseCode = " << setprecision(indent) << m_responseCode << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MultilinkResponse_addConnection::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MultilinkResponse_addConnection::Class()), PInvalidCast);
#endif
  const H245_MultilinkResponse_addConnection & other = (const H245_MultilinkResponse_addConnection &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_responseCode.Compare(other.m_responseCode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultilinkResponse_addConnection::GetDataLength() const
{
  return m_sequenceNumber.GetObjectLength() +
         m_responseCode.GetObjectLength();
}


BOOL H245_MultilinkResponse_addConnection::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sequenceNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_responseCode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MultilinkResponse_addConnection::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_responseCode.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_sequenceNumber.Encode(strm);
  m_responseCode.Encode(strm);
}


PObject * H245_MultilinkResponse_addConnection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkResponse_addConnection::Class()), PInvalidCast);
#endif
  return new H245_MultilinkResponse_addConnection(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MultilinkResponse_addConnection::preShowEthereal( void )
{
  m_sequenceNumber.preShowEthereal( );
  m_responseCode.preShowEthereal( );
}

PString H245_MultilinkResponse_addConnection::getSummary( void ) 
{
  return PString( "MultilinkResponse_addConnection" );
}

void H245_MultilinkResponse_addConnection::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_MultilinkResponse_addConnection_sequenceNumber, tvb, offset + m_sequenceNumber.GetStartByte(), m_sequenceNumber.GetByteLength() , m_sequenceNumber.GetValue() );

  proto_tree *responseCode_tree = (proto_tree*) NULL;
  proto_item *responseCode_ti = (proto_item*) NULL;
  responseCode_ti = proto_tree_add_text( tree, tvb, offset + m_responseCode.GetStartByte(), m_responseCode.GetByteLength(), "responseCode (%s)", ( const char* ) m_responseCode.GetTagName() );
  responseCode_tree = proto_item_add_subtree( responseCode_ti, hCont->h245_2.ett_h245_MultilinkResponse_addConnection_responseCode );

  m_responseCode.showEthereal( responseCode_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// SendTerminalCapabilitySet_specificRequest
//

H245_SendTerminalCapabilitySet_specificRequest::H245_SendTerminalCapabilitySet_specificRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_capabilityTableEntryNumbers.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
  m_capabilityDescriptorNumbers.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_SendTerminalCapabilitySet_specificRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "multiplexCapability = " << setprecision(indent) << m_multiplexCapability << '\n';
  if (HasOptionalField(e_capabilityTableEntryNumbers))
    strm << setw(indent+30) << "capabilityTableEntryNumbers = " << setprecision(indent) << m_capabilityTableEntryNumbers << '\n';
  if (HasOptionalField(e_capabilityDescriptorNumbers))
    strm << setw(indent+30) << "capabilityDescriptorNumbers = " << setprecision(indent) << m_capabilityDescriptorNumbers << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_SendTerminalCapabilitySet_specificRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_SendTerminalCapabilitySet_specificRequest::Class()), PInvalidCast);
#endif
  const H245_SendTerminalCapabilitySet_specificRequest & other = (const H245_SendTerminalCapabilitySet_specificRequest &)obj;

  Comparison result;

  if ((result = m_multiplexCapability.Compare(other.m_multiplexCapability)) != EqualTo)
    return result;
  if ((result = m_capabilityTableEntryNumbers.Compare(other.m_capabilityTableEntryNumbers)) != EqualTo)
    return result;
  if ((result = m_capabilityDescriptorNumbers.Compare(other.m_capabilityDescriptorNumbers)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_SendTerminalCapabilitySet_specificRequest::GetDataLength() const
{
  return m_multiplexCapability.GetObjectLength() +
         m_capabilityTableEntryNumbers.GetObjectLength() +
         m_capabilityDescriptorNumbers.GetObjectLength();
}


BOOL H245_SendTerminalCapabilitySet_specificRequest::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_multiplexCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_capabilityTableEntryNumbers ) && !m_capabilityTableEntryNumbers.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_capabilityDescriptorNumbers ) && !m_capabilityDescriptorNumbers.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_SendTerminalCapabilitySet_specificRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_multiplexCapability.Encode(strm);
  if (HasOptionalField(e_capabilityTableEntryNumbers))
    m_capabilityTableEntryNumbers.Encode(strm);
  if (HasOptionalField(e_capabilityDescriptorNumbers))
    m_capabilityDescriptorNumbers.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_multiplexCapability.Encode(strm);
  if (HasOptionalField(e_capabilityTableEntryNumbers))
    m_capabilityTableEntryNumbers.Encode(strm);
  if (HasOptionalField(e_capabilityDescriptorNumbers))
    m_capabilityDescriptorNumbers.Encode(strm);
}


PObject * H245_SendTerminalCapabilitySet_specificRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_SendTerminalCapabilitySet_specificRequest::Class()), PInvalidCast);
#endif
  return new H245_SendTerminalCapabilitySet_specificRequest(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_SendTerminalCapabilitySet_specificRequest::preShowEthereal( void )
{
  m_multiplexCapability.preShowEthereal( );
  if ( HasOptionalField( e_capabilityTableEntryNumbers ) ) 
      m_capabilityTableEntryNumbers.preShowEthereal( );
  if ( HasOptionalField( e_capabilityDescriptorNumbers ) ) 
      m_capabilityDescriptorNumbers.preShowEthereal( );
}

PString H245_SendTerminalCapabilitySet_specificRequest::getSummary( void ) 
{
  return PString( "SendTerminalCapabilitySet_specificRequest" );
}

void H245_SendTerminalCapabilitySet_specificRequest::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_SendTerminalCapabilitySet_specificRequest_multiplexCapability, tvb, offset + m_multiplexCapability.GetStartByte(), m_multiplexCapability.GetByteLength() , m_multiplexCapability.GetValue() );

  if ( HasOptionalField( e_capabilityTableEntryNumbers ) ) {
    proto_tree *capabilityTableEntryNumbers_tree = (proto_tree*) NULL;
    proto_item *capabilityTableEntryNumbers_ti = (proto_item*) NULL;
    capabilityTableEntryNumbers_ti = proto_tree_add_text( tree, tvb, offset + m_capabilityTableEntryNumbers.GetStartByte(), m_capabilityTableEntryNumbers.GetByteLength(), "capabilityTableEntryNumbers (CapabilityTableEntryNumber)" );
    capabilityTableEntryNumbers_tree = proto_item_add_subtree( capabilityTableEntryNumbers_ti, hCont->h245_2.ett_h245_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers );
    m_capabilityTableEntryNumbers.showEthereal( capabilityTableEntryNumbers_tree, tvb, offset );
  }

  if ( HasOptionalField( e_capabilityDescriptorNumbers ) ) {
    proto_tree *capabilityDescriptorNumbers_tree = (proto_tree*) NULL;
    proto_item *capabilityDescriptorNumbers_ti = (proto_item*) NULL;
    capabilityDescriptorNumbers_ti = proto_tree_add_text( tree, tvb, offset + m_capabilityDescriptorNumbers.GetStartByte(), m_capabilityDescriptorNumbers.GetByteLength(), "capabilityDescriptorNumbers (CapabilityDescriptorNumber)" );
    capabilityDescriptorNumbers_tree = proto_item_add_subtree( capabilityDescriptorNumbers_ti, hCont->h245_2.ett_h245_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers );
    m_capabilityDescriptorNumbers.showEthereal( capabilityDescriptorNumbers_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// EncryptionCommand_encryptionAlgorithmID
//

H245_EncryptionCommand_encryptionAlgorithmID::H245_EncryptionCommand_encryptionAlgorithmID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_EncryptionCommand_encryptionAlgorithmID::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+26) << "h233AlgorithmIdentifier = " << setprecision(indent) << m_h233AlgorithmIdentifier << '\n';
  strm << setw(indent+22) << "associatedAlgorithm = " << setprecision(indent) << m_associatedAlgorithm << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_EncryptionCommand_encryptionAlgorithmID::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_EncryptionCommand_encryptionAlgorithmID::Class()), PInvalidCast);
#endif
  const H245_EncryptionCommand_encryptionAlgorithmID & other = (const H245_EncryptionCommand_encryptionAlgorithmID &)obj;

  Comparison result;

  if ((result = m_h233AlgorithmIdentifier.Compare(other.m_h233AlgorithmIdentifier)) != EqualTo)
    return result;
  if ((result = m_associatedAlgorithm.Compare(other.m_associatedAlgorithm)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_EncryptionCommand_encryptionAlgorithmID::GetDataLength() const
{
  return m_h233AlgorithmIdentifier.GetObjectLength() +
         m_associatedAlgorithm.GetObjectLength();
}


BOOL H245_EncryptionCommand_encryptionAlgorithmID::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_h233AlgorithmIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_associatedAlgorithm.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_EncryptionCommand_encryptionAlgorithmID::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_h233AlgorithmIdentifier.Encode(strm);
  m_associatedAlgorithm.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_h233AlgorithmIdentifier.Encode(strm);
  m_associatedAlgorithm.Encode(strm);
}


PObject * H245_EncryptionCommand_encryptionAlgorithmID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EncryptionCommand_encryptionAlgorithmID::Class()), PInvalidCast);
#endif
  return new H245_EncryptionCommand_encryptionAlgorithmID(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_EncryptionCommand_encryptionAlgorithmID::preShowEthereal( void )
{
  m_h233AlgorithmIdentifier.preShowEthereal( );
  m_associatedAlgorithm.preShowEthereal( );
}

PString H245_EncryptionCommand_encryptionAlgorithmID::getSummary( void ) 
{
  return PString( "EncryptionCommand_encryptionAlgorithmID" );
}

void H245_EncryptionCommand_encryptionAlgorithmID::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_EncryptionCommand_encryptionAlgorithmID_h233AlgorithmIdentifier, tvb, offset + m_h233AlgorithmIdentifier.GetStartByte(), m_h233AlgorithmIdentifier.GetByteLength() , m_h233AlgorithmIdentifier.GetValue() );

  proto_tree *associatedAlgorithm_tree = (proto_tree*) NULL;
  proto_item *associatedAlgorithm_ti = (proto_item*) NULL;
  associatedAlgorithm_ti = proto_tree_add_text( tree, tvb, offset + m_associatedAlgorithm.GetStartByte(), m_associatedAlgorithm.GetByteLength(), "associatedAlgorithm (NonStandardParameter)" );
  associatedAlgorithm_tree = proto_item_add_subtree( associatedAlgorithm_ti, hCont->h245_2.ett_h245_EncryptionCommand_encryptionAlgorithmID_associatedAlgorithm );

  m_associatedAlgorithm.showEthereal( associatedAlgorithm_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// NewATMVCCommand_reverseParameters
//

H245_NewATMVCCommand_reverseParameters::H245_NewATMVCCommand_reverseParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_bitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H245_NewATMVCCommand_reverseParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "bitRate = " << setprecision(indent) << m_bitRate << '\n';
  strm << setw(indent+26) << "bitRateLockedToPCRClock = " << setprecision(indent) << m_bitRateLockedToPCRClock << '\n';
  strm << setw(indent+30) << "bitRateLockedToNetworkClock = " << setprecision(indent) << m_bitRateLockedToNetworkClock << '\n';
  strm << setw(indent+12) << "multiplex = " << setprecision(indent) << m_multiplex << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_NewATMVCCommand_reverseParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_NewATMVCCommand_reverseParameters::Class()), PInvalidCast);
#endif
  const H245_NewATMVCCommand_reverseParameters & other = (const H245_NewATMVCCommand_reverseParameters &)obj;

  Comparison result;

  if ((result = m_bitRate.Compare(other.m_bitRate)) != EqualTo)
    return result;
  if ((result = m_bitRateLockedToPCRClock.Compare(other.m_bitRateLockedToPCRClock)) != EqualTo)
    return result;
  if ((result = m_bitRateLockedToNetworkClock.Compare(other.m_bitRateLockedToNetworkClock)) != EqualTo)
    return result;
  if ((result = m_multiplex.Compare(other.m_multiplex)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NewATMVCCommand_reverseParameters::GetDataLength() const
{
  return m_bitRate.GetObjectLength() +
         m_bitRateLockedToPCRClock.GetObjectLength() +
         m_bitRateLockedToNetworkClock.GetObjectLength() +
         m_multiplex.GetObjectLength();
}


BOOL H245_NewATMVCCommand_reverseParameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bitRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bitRateLockedToPCRClock.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bitRateLockedToNetworkClock.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_multiplex.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_NewATMVCCommand_reverseParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_bitRate.Encode(strm);
  m_bitRateLockedToPCRClock.Encode(strm);
  m_bitRateLockedToNetworkClock.Encode(strm);
  m_multiplex.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_bitRate.Encode(strm);
  m_bitRateLockedToPCRClock.Encode(strm);
  m_bitRateLockedToNetworkClock.Encode(strm);
  m_multiplex.Encode(strm);
}


PObject * H245_NewATMVCCommand_reverseParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCCommand_reverseParameters::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCCommand_reverseParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NewATMVCCommand_reverseParameters::preShowEthereal( void )
{
  m_bitRate.preShowEthereal( );
  m_bitRateLockedToPCRClock.preShowEthereal( );
  m_bitRateLockedToNetworkClock.preShowEthereal( );
  m_multiplex.preShowEthereal( );
}

PString H245_NewATMVCCommand_reverseParameters::getSummary( void ) 
{
  return PString( "NewATMVCCommand_reverseParameters" );
}

void H245_NewATMVCCommand_reverseParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_NewATMVCCommand_reverseParameters_bitRate, tvb, offset + m_bitRate.GetStartByte(), m_bitRate.GetByteLength() , m_bitRate.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_NewATMVCCommand_reverseParameters_bitRateLockedToPCRClock, tvb, offset + m_bitRateLockedToPCRClock.GetStartByte(), m_bitRateLockedToPCRClock.GetByteLength() , m_bitRateLockedToPCRClock.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_NewATMVCCommand_reverseParameters_bitRateLockedToNetworkClock, tvb, offset + m_bitRateLockedToNetworkClock.GetStartByte(), m_bitRateLockedToNetworkClock.GetByteLength() , m_bitRateLockedToNetworkClock.GetValue() );

  proto_tree *multiplex_tree = (proto_tree*) NULL;
  proto_item *multiplex_ti = (proto_item*) NULL;
  multiplex_ti = proto_tree_add_text( tree, tvb, offset + m_multiplex.GetStartByte(), m_multiplex.GetByteLength(), "multiplex (%s)", ( const char* ) m_multiplex.GetTagName() );
  multiplex_tree = proto_item_add_subtree( multiplex_ti, hCont->h245_2.ett_h245_NewATMVCCommand_reverseParameters_multiplex );

  m_multiplex.showEthereal( multiplex_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// NewATMVCIndication_reverseParameters
//

H245_NewATMVCIndication_reverseParameters::H245_NewATMVCIndication_reverseParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_bitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H245_NewATMVCIndication_reverseParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "bitRate = " << setprecision(indent) << m_bitRate << '\n';
  strm << setw(indent+26) << "bitRateLockedToPCRClock = " << setprecision(indent) << m_bitRateLockedToPCRClock << '\n';
  strm << setw(indent+30) << "bitRateLockedToNetworkClock = " << setprecision(indent) << m_bitRateLockedToNetworkClock << '\n';
  strm << setw(indent+12) << "multiplex = " << setprecision(indent) << m_multiplex << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_NewATMVCIndication_reverseParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_NewATMVCIndication_reverseParameters::Class()), PInvalidCast);
#endif
  const H245_NewATMVCIndication_reverseParameters & other = (const H245_NewATMVCIndication_reverseParameters &)obj;

  Comparison result;

  if ((result = m_bitRate.Compare(other.m_bitRate)) != EqualTo)
    return result;
  if ((result = m_bitRateLockedToPCRClock.Compare(other.m_bitRateLockedToPCRClock)) != EqualTo)
    return result;
  if ((result = m_bitRateLockedToNetworkClock.Compare(other.m_bitRateLockedToNetworkClock)) != EqualTo)
    return result;
  if ((result = m_multiplex.Compare(other.m_multiplex)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NewATMVCIndication_reverseParameters::GetDataLength() const
{
  return m_bitRate.GetObjectLength() +
         m_bitRateLockedToPCRClock.GetObjectLength() +
         m_bitRateLockedToNetworkClock.GetObjectLength() +
         m_multiplex.GetObjectLength();
}


BOOL H245_NewATMVCIndication_reverseParameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bitRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bitRateLockedToPCRClock.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bitRateLockedToNetworkClock.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_multiplex.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_NewATMVCIndication_reverseParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_bitRate.Encode(strm);
  m_bitRateLockedToPCRClock.Encode(strm);
  m_bitRateLockedToNetworkClock.Encode(strm);
  m_multiplex.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_bitRate.Encode(strm);
  m_bitRateLockedToPCRClock.Encode(strm);
  m_bitRateLockedToNetworkClock.Encode(strm);
  m_multiplex.Encode(strm);
}


PObject * H245_NewATMVCIndication_reverseParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCIndication_reverseParameters::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCIndication_reverseParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NewATMVCIndication_reverseParameters::preShowEthereal( void )
{
  m_bitRate.preShowEthereal( );
  m_bitRateLockedToPCRClock.preShowEthereal( );
  m_bitRateLockedToNetworkClock.preShowEthereal( );
  m_multiplex.preShowEthereal( );
}

PString H245_NewATMVCIndication_reverseParameters::getSummary( void ) 
{
  return PString( "NewATMVCIndication_reverseParameters" );
}

void H245_NewATMVCIndication_reverseParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_NewATMVCIndication_reverseParameters_bitRate, tvb, offset + m_bitRate.GetStartByte(), m_bitRate.GetByteLength() , m_bitRate.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_NewATMVCIndication_reverseParameters_bitRateLockedToPCRClock, tvb, offset + m_bitRateLockedToPCRClock.GetStartByte(), m_bitRateLockedToPCRClock.GetByteLength() , m_bitRateLockedToPCRClock.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_NewATMVCIndication_reverseParameters_bitRateLockedToNetworkClock, tvb, offset + m_bitRateLockedToNetworkClock.GetStartByte(), m_bitRateLockedToNetworkClock.GetByteLength() , m_bitRateLockedToNetworkClock.GetValue() );

  proto_tree *multiplex_tree = (proto_tree*) NULL;
  proto_item *multiplex_ti = (proto_item*) NULL;
  multiplex_ti = proto_tree_add_text( tree, tvb, offset + m_multiplex.GetStartByte(), m_multiplex.GetByteLength(), "multiplex (%s)", ( const char* ) m_multiplex.GetTagName() );
  multiplex_tree = proto_item_add_subtree( multiplex_ti, hCont->h245_2.ett_h245_NewATMVCIndication_reverseParameters_multiplex );

  m_multiplex.showEthereal( multiplex_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// UserInputIndication_signal
//

H245_UserInputIndication_signal::H245_UserInputIndication_signal(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_signalType.SetConstraints(PASN_Object::FixedConstraint, 1, 1);
  m_signalType.SetCharacterSet(PASN_Object::FixedConstraint, "0123456789#*ABCD!");
  m_duration.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H245_UserInputIndication_signal::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "signalType = " << setprecision(indent) << m_signalType << '\n';
  if (HasOptionalField(e_duration))
    strm << setw(indent+11) << "duration = " << setprecision(indent) << m_duration << '\n';
  if (HasOptionalField(e_rtp))
    strm << setw(indent+6) << "rtp = " << setprecision(indent) << m_rtp << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_UserInputIndication_signal::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_UserInputIndication_signal::Class()), PInvalidCast);
#endif
  const H245_UserInputIndication_signal & other = (const H245_UserInputIndication_signal &)obj;

  Comparison result;

  if ((result = m_signalType.Compare(other.m_signalType)) != EqualTo)
    return result;
  if ((result = m_duration.Compare(other.m_duration)) != EqualTo)
    return result;
  if ((result = m_rtp.Compare(other.m_rtp)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_UserInputIndication_signal::GetDataLength() const
{
  return m_signalType.GetObjectLength() +
         m_duration.GetObjectLength() +
         m_rtp.GetObjectLength();
}


BOOL H245_UserInputIndication_signal::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_signalType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_duration ) && !m_duration.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_rtp ) && !m_rtp.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_UserInputIndication_signal::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_signalType.Encode(strm);
  if (HasOptionalField(e_duration))
    m_duration.Encode(strm);
  if (HasOptionalField(e_rtp))
    m_rtp.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_signalType.Encode(strm);
  if (HasOptionalField(e_duration))
    m_duration.Encode(strm);
  if (HasOptionalField(e_rtp))
    m_rtp.Encode(strm);
}


PObject * H245_UserInputIndication_signal::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UserInputIndication_signal::Class()), PInvalidCast);
#endif
  return new H245_UserInputIndication_signal(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_UserInputIndication_signal::preShowEthereal( void )
{
  m_signalType.preShowEthereal( );
  if ( HasOptionalField( e_duration ) ) 
      m_duration.preShowEthereal( );
  if ( HasOptionalField( e_rtp ) ) 
      m_rtp.preShowEthereal( );
}

PString H245_UserInputIndication_signal::getSummary( void ) 
{
  return PString( "UserInputIndication_signal" );
}

void H245_UserInputIndication_signal::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* psignalType = m_signalType.getValue();
  proto_tree_add_string( tree, hCont->h245_2.hf_h245_UserInputIndication_signal_signalType, tvb, offset + m_signalType.GetStartByte(), m_signalType.GetByteLength() , psignalType );
  delete[] psignalType;

  if ( HasOptionalField( e_duration ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_UserInputIndication_signal_duration, tvb, offset + m_duration.GetStartByte(), m_duration.GetByteLength() , m_duration.GetValue() );
  }

  if ( HasOptionalField( e_rtp ) ) {
    proto_tree *rtp_tree = (proto_tree*) NULL;
    proto_item *rtp_ti = (proto_item*) NULL;
    rtp_ti = proto_tree_add_text( tree, tvb, offset + m_rtp.GetStartByte(), m_rtp.GetByteLength(), "rtp (UserInputIndication-signal-rtp)" );
    rtp_tree = proto_item_add_subtree( rtp_ti, hCont->h245_2.ett_h245_UserInputIndication_signal_rtp );
    m_rtp.showEthereal( rtp_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// UserInputIndication_signalUpdate
//

H245_UserInputIndication_signalUpdate::H245_UserInputIndication_signalUpdate(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_duration.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H245_UserInputIndication_signalUpdate::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "duration = " << setprecision(indent) << m_duration << '\n';
  if (HasOptionalField(e_rtp))
    strm << setw(indent+6) << "rtp = " << setprecision(indent) << m_rtp << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_UserInputIndication_signalUpdate::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_UserInputIndication_signalUpdate::Class()), PInvalidCast);
#endif
  const H245_UserInputIndication_signalUpdate & other = (const H245_UserInputIndication_signalUpdate &)obj;

  Comparison result;

  if ((result = m_duration.Compare(other.m_duration)) != EqualTo)
    return result;
  if ((result = m_rtp.Compare(other.m_rtp)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_UserInputIndication_signalUpdate::GetDataLength() const
{
  return m_duration.GetObjectLength() +
         m_rtp.GetObjectLength();
}


BOOL H245_UserInputIndication_signalUpdate::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_duration.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_rtp ) && !m_rtp.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_UserInputIndication_signalUpdate::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_duration.Encode(strm);
  if (HasOptionalField(e_rtp))
    m_rtp.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_duration.Encode(strm);
  if (HasOptionalField(e_rtp))
    m_rtp.Encode(strm);
}


PObject * H245_UserInputIndication_signalUpdate::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UserInputIndication_signalUpdate::Class()), PInvalidCast);
#endif
  return new H245_UserInputIndication_signalUpdate(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_UserInputIndication_signalUpdate::preShowEthereal( void )
{
  m_duration.preShowEthereal( );
  if ( HasOptionalField( e_rtp ) ) 
      m_rtp.preShowEthereal( );
}

PString H245_UserInputIndication_signalUpdate::getSummary( void ) 
{
  return PString( "UserInputIndication_signalUpdate" );
}

void H245_UserInputIndication_signalUpdate::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_UserInputIndication_signalUpdate_duration, tvb, offset + m_duration.GetStartByte(), m_duration.GetByteLength() , m_duration.GetValue() );

  if ( HasOptionalField( e_rtp ) ) {
    proto_tree *rtp_tree = (proto_tree*) NULL;
    proto_item *rtp_ti = (proto_item*) NULL;
    rtp_ti = proto_tree_add_text( tree, tvb, offset + m_rtp.GetStartByte(), m_rtp.GetByteLength(), "rtp (UserInputIndication-signalUpdate-rtp)" );
    rtp_tree = proto_item_add_subtree( rtp_ti, hCont->h245_2.ett_h245_UserInputIndication_signalUpdate_rtp );
    m_rtp.showEthereal( rtp_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// V76LogicalChannelParameters_mode_eRM
//

H245_V76LogicalChannelParameters_mode_eRM::H245_V76LogicalChannelParameters_mode_eRM(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_windowSize.SetConstraints(PASN_Object::FixedConstraint, 1, 127);
}


#ifndef PASN_NOPRINTON
void H245_V76LogicalChannelParameters_mode_eRM::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "windowSize = " << setprecision(indent) << m_windowSize << '\n';
  strm << setw(indent+11) << "recovery = " << setprecision(indent) << m_recovery << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_V76LogicalChannelParameters_mode_eRM::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_V76LogicalChannelParameters_mode_eRM::Class()), PInvalidCast);
#endif
  const H245_V76LogicalChannelParameters_mode_eRM & other = (const H245_V76LogicalChannelParameters_mode_eRM &)obj;

  Comparison result;

  if ((result = m_windowSize.Compare(other.m_windowSize)) != EqualTo)
    return result;
  if ((result = m_recovery.Compare(other.m_recovery)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_V76LogicalChannelParameters_mode_eRM::GetDataLength() const
{
  return m_windowSize.GetObjectLength() +
         m_recovery.GetObjectLength();
}


BOOL H245_V76LogicalChannelParameters_mode_eRM::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_windowSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_recovery.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_V76LogicalChannelParameters_mode_eRM::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_windowSize.Encode(strm);
  m_recovery.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_windowSize.Encode(strm);
  m_recovery.Encode(strm);
}


PObject * H245_V76LogicalChannelParameters_mode_eRM::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_V76LogicalChannelParameters_mode_eRM::Class()), PInvalidCast);
#endif
  return new H245_V76LogicalChannelParameters_mode_eRM(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_V76LogicalChannelParameters_mode_eRM::preShowEthereal( void )
{
  m_windowSize.preShowEthereal( );
  m_recovery.preShowEthereal( );
}

PString H245_V76LogicalChannelParameters_mode_eRM::getSummary( void ) 
{
  return PString( "V76LogicalChannelParameters_mode_eRM" );
}

void H245_V76LogicalChannelParameters_mode_eRM::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_V76LogicalChannelParameters_mode_eRM_windowSize, tvb, offset + m_windowSize.GetStartByte(), m_windowSize.GetByteLength() , m_windowSize.GetValue() );

  proto_tree *recovery_tree = (proto_tree*) NULL;
  proto_item *recovery_ti = (proto_item*) NULL;
  recovery_ti = proto_tree_add_text( tree, tvb, offset + m_recovery.GetStartByte(), m_recovery.GetByteLength(), "recovery (%s)", ( const char* ) m_recovery.GetTagName() );
  recovery_tree = proto_item_add_subtree( recovery_ti, hCont->h245_2.ett_h245_V76LogicalChannelParameters_mode_eRM_recovery );

  m_recovery.showEthereal( recovery_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// MiscellaneousCommand_type_progressiveRefinementStart
//

H245_MiscellaneousCommand_type_progressiveRefinementStart::H245_MiscellaneousCommand_type_progressiveRefinementStart(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MiscellaneousCommand_type_progressiveRefinementStart::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "repeatCount = " << setprecision(indent) << m_repeatCount << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_MiscellaneousCommand_type_progressiveRefinementStart::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_MiscellaneousCommand_type_progressiveRefinementStart::Class()), PInvalidCast);
#endif
  const H245_MiscellaneousCommand_type_progressiveRefinementStart & other = (const H245_MiscellaneousCommand_type_progressiveRefinementStart &)obj;

  Comparison result;

  if ((result = m_repeatCount.Compare(other.m_repeatCount)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MiscellaneousCommand_type_progressiveRefinementStart::GetDataLength() const
{
  return m_repeatCount.GetObjectLength();
}


BOOL H245_MiscellaneousCommand_type_progressiveRefinementStart::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_repeatCount.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_MiscellaneousCommand_type_progressiveRefinementStart::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_repeatCount.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_repeatCount.Encode(strm);
}


PObject * H245_MiscellaneousCommand_type_progressiveRefinementStart::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MiscellaneousCommand_type_progressiveRefinementStart::Class()), PInvalidCast);
#endif
  return new H245_MiscellaneousCommand_type_progressiveRefinementStart(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_MiscellaneousCommand_type_progressiveRefinementStart::preShowEthereal( void )
{
  m_repeatCount.preShowEthereal( );
}

PString H245_MiscellaneousCommand_type_progressiveRefinementStart::getSummary( void ) 
{
  return PString( "MiscellaneousCommand_type_progressiveRefinementStart" );
}

void H245_MiscellaneousCommand_type_progressiveRefinementStart::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *repeatCount_tree = (proto_tree*) NULL;
  proto_item *repeatCount_ti = (proto_item*) NULL;
  repeatCount_ti = proto_tree_add_text( tree, tvb, offset + m_repeatCount.GetStartByte(), m_repeatCount.GetByteLength(), "repeatCount (%s)", ( const char* ) m_repeatCount.GetTagName() );
  repeatCount_tree = proto_item_add_subtree( repeatCount_ti, hCont->h245_2.ett_h245_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount );

  m_repeatCount.showEthereal( repeatCount_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// NewATMVCCommand_aal_aal1
//

H245_NewATMVCCommand_aal_aal1::H245_NewATMVCCommand_aal_aal1(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_NewATMVCCommand_aal_aal1::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "clockRecovery = " << setprecision(indent) << m_clockRecovery << '\n';
  strm << setw(indent+18) << "errorCorrection = " << setprecision(indent) << m_errorCorrection << '\n';
  strm << setw(indent+25) << "structuredDataTransfer = " << setprecision(indent) << m_structuredDataTransfer << '\n';
  strm << setw(indent+23) << "partiallyFilledCells = " << setprecision(indent) << m_partiallyFilledCells << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_NewATMVCCommand_aal_aal1::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_NewATMVCCommand_aal_aal1::Class()), PInvalidCast);
#endif
  const H245_NewATMVCCommand_aal_aal1 & other = (const H245_NewATMVCCommand_aal_aal1 &)obj;

  Comparison result;

  if ((result = m_clockRecovery.Compare(other.m_clockRecovery)) != EqualTo)
    return result;
  if ((result = m_errorCorrection.Compare(other.m_errorCorrection)) != EqualTo)
    return result;
  if ((result = m_structuredDataTransfer.Compare(other.m_structuredDataTransfer)) != EqualTo)
    return result;
  if ((result = m_partiallyFilledCells.Compare(other.m_partiallyFilledCells)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NewATMVCCommand_aal_aal1::GetDataLength() const
{
  return m_clockRecovery.GetObjectLength() +
         m_errorCorrection.GetObjectLength() +
         m_structuredDataTransfer.GetObjectLength() +
         m_partiallyFilledCells.GetObjectLength();
}


BOOL H245_NewATMVCCommand_aal_aal1::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_clockRecovery.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_errorCorrection.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_structuredDataTransfer.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_partiallyFilledCells.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_NewATMVCCommand_aal_aal1::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_clockRecovery.Encode(strm);
  m_errorCorrection.Encode(strm);
  m_structuredDataTransfer.Encode(strm);
  m_partiallyFilledCells.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_clockRecovery.Encode(strm);
  m_errorCorrection.Encode(strm);
  m_structuredDataTransfer.Encode(strm);
  m_partiallyFilledCells.Encode(strm);
}


PObject * H245_NewATMVCCommand_aal_aal1::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCCommand_aal_aal1::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCCommand_aal_aal1(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NewATMVCCommand_aal_aal1::preShowEthereal( void )
{
  m_clockRecovery.preShowEthereal( );
  m_errorCorrection.preShowEthereal( );
  m_structuredDataTransfer.preShowEthereal( );
  m_partiallyFilledCells.preShowEthereal( );
}

PString H245_NewATMVCCommand_aal_aal1::getSummary( void ) 
{
  return PString( "NewATMVCCommand_aal_aal1" );
}

void H245_NewATMVCCommand_aal_aal1::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *clockRecovery_tree = (proto_tree*) NULL;
  proto_item *clockRecovery_ti = (proto_item*) NULL;
  clockRecovery_ti = proto_tree_add_text( tree, tvb, offset + m_clockRecovery.GetStartByte(), m_clockRecovery.GetByteLength(), "clockRecovery (%s)", ( const char* ) m_clockRecovery.GetTagName() );
  clockRecovery_tree = proto_item_add_subtree( clockRecovery_ti, hCont->h245_2.ett_h245_NewATMVCCommand_aal_aal1_clockRecovery );

  m_clockRecovery.showEthereal( clockRecovery_tree, tvb, offset );

  proto_tree *errorCorrection_tree = (proto_tree*) NULL;
  proto_item *errorCorrection_ti = (proto_item*) NULL;
  errorCorrection_ti = proto_tree_add_text( tree, tvb, offset + m_errorCorrection.GetStartByte(), m_errorCorrection.GetByteLength(), "errorCorrection (%s)", ( const char* ) m_errorCorrection.GetTagName() );
  errorCorrection_tree = proto_item_add_subtree( errorCorrection_ti, hCont->h245_2.ett_h245_NewATMVCCommand_aal_aal1_errorCorrection );

  m_errorCorrection.showEthereal( errorCorrection_tree, tvb, offset );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_NewATMVCCommand_aal_aal1_structuredDataTransfer, tvb, offset + m_structuredDataTransfer.GetStartByte(), m_structuredDataTransfer.GetByteLength() , m_structuredDataTransfer.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_NewATMVCCommand_aal_aal1_partiallyFilledCells, tvb, offset + m_partiallyFilledCells.GetStartByte(), m_partiallyFilledCells.GetByteLength() , m_partiallyFilledCells.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// NewATMVCIndication_aal_aal1
//

H245_NewATMVCIndication_aal_aal1::H245_NewATMVCIndication_aal_aal1(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_NewATMVCIndication_aal_aal1::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "clockRecovery = " << setprecision(indent) << m_clockRecovery << '\n';
  strm << setw(indent+18) << "errorCorrection = " << setprecision(indent) << m_errorCorrection << '\n';
  strm << setw(indent+25) << "structuredDataTransfer = " << setprecision(indent) << m_structuredDataTransfer << '\n';
  strm << setw(indent+23) << "partiallyFilledCells = " << setprecision(indent) << m_partiallyFilledCells << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_NewATMVCIndication_aal_aal1::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_NewATMVCIndication_aal_aal1::Class()), PInvalidCast);
#endif
  const H245_NewATMVCIndication_aal_aal1 & other = (const H245_NewATMVCIndication_aal_aal1 &)obj;

  Comparison result;

  if ((result = m_clockRecovery.Compare(other.m_clockRecovery)) != EqualTo)
    return result;
  if ((result = m_errorCorrection.Compare(other.m_errorCorrection)) != EqualTo)
    return result;
  if ((result = m_structuredDataTransfer.Compare(other.m_structuredDataTransfer)) != EqualTo)
    return result;
  if ((result = m_partiallyFilledCells.Compare(other.m_partiallyFilledCells)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NewATMVCIndication_aal_aal1::GetDataLength() const
{
  return m_clockRecovery.GetObjectLength() +
         m_errorCorrection.GetObjectLength() +
         m_structuredDataTransfer.GetObjectLength() +
         m_partiallyFilledCells.GetObjectLength();
}


BOOL H245_NewATMVCIndication_aal_aal1::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_clockRecovery.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_errorCorrection.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_structuredDataTransfer.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_partiallyFilledCells.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_NewATMVCIndication_aal_aal1::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_clockRecovery.Encode(strm);
  m_errorCorrection.Encode(strm);
  m_structuredDataTransfer.Encode(strm);
  m_partiallyFilledCells.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_clockRecovery.Encode(strm);
  m_errorCorrection.Encode(strm);
  m_structuredDataTransfer.Encode(strm);
  m_partiallyFilledCells.Encode(strm);
}


PObject * H245_NewATMVCIndication_aal_aal1::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCIndication_aal_aal1::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCIndication_aal_aal1(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NewATMVCIndication_aal_aal1::preShowEthereal( void )
{
  m_clockRecovery.preShowEthereal( );
  m_errorCorrection.preShowEthereal( );
  m_structuredDataTransfer.preShowEthereal( );
  m_partiallyFilledCells.preShowEthereal( );
}

PString H245_NewATMVCIndication_aal_aal1::getSummary( void ) 
{
  return PString( "NewATMVCIndication_aal_aal1" );
}

void H245_NewATMVCIndication_aal_aal1::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *clockRecovery_tree = (proto_tree*) NULL;
  proto_item *clockRecovery_ti = (proto_item*) NULL;
  clockRecovery_ti = proto_tree_add_text( tree, tvb, offset + m_clockRecovery.GetStartByte(), m_clockRecovery.GetByteLength(), "clockRecovery (%s)", ( const char* ) m_clockRecovery.GetTagName() );
  clockRecovery_tree = proto_item_add_subtree( clockRecovery_ti, hCont->h245_2.ett_h245_NewATMVCIndication_aal_aal1_clockRecovery );

  m_clockRecovery.showEthereal( clockRecovery_tree, tvb, offset );

  proto_tree *errorCorrection_tree = (proto_tree*) NULL;
  proto_item *errorCorrection_ti = (proto_item*) NULL;
  errorCorrection_ti = proto_tree_add_text( tree, tvb, offset + m_errorCorrection.GetStartByte(), m_errorCorrection.GetByteLength(), "errorCorrection (%s)", ( const char* ) m_errorCorrection.GetTagName() );
  errorCorrection_tree = proto_item_add_subtree( errorCorrection_ti, hCont->h245_2.ett_h245_NewATMVCIndication_aal_aal1_errorCorrection );

  m_errorCorrection.showEthereal( errorCorrection_tree, tvb, offset );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_NewATMVCIndication_aal_aal1_structuredDataTransfer, tvb, offset + m_structuredDataTransfer.GetStartByte(), m_structuredDataTransfer.GetByteLength() , m_structuredDataTransfer.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_NewATMVCIndication_aal_aal1_partiallyFilledCells, tvb, offset + m_partiallyFilledCells.GetStartByte(), m_partiallyFilledCells.GetByteLength() , m_partiallyFilledCells.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// NonStandardMessage
//

H245_NonStandardMessage::H245_NonStandardMessage(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_NonStandardMessage::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_NonStandardMessage::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_NonStandardMessage::Class()), PInvalidCast);
#endif
  const H245_NonStandardMessage & other = (const H245_NonStandardMessage &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NonStandardMessage::GetDataLength() const
{
  return m_nonStandardData.GetObjectLength();
}


BOOL H245_NonStandardMessage::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_NonStandardMessage::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nonStandardData.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_nonStandardData.Encode(strm);
}


PObject * H245_NonStandardMessage::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NonStandardMessage::Class()), PInvalidCast);
#endif
  return new H245_NonStandardMessage(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NonStandardMessage::preShowEthereal( void )
{
  m_nonStandardData.preShowEthereal( );
}

PString H245_NonStandardMessage::getSummary( void ) 
{
  return PString( "NonStandardMessage" );
}

void H245_NonStandardMessage::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *nonStandardData_tree = (proto_tree*) NULL;
  proto_item *nonStandardData_ti = (proto_item*) NULL;
  nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
  nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h245_2.ett_h245_NonStandardMessage_nonStandardData );

  m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// VCCapability
//

H245_VCCapability::H245_VCCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void H245_VCCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_aal1))
    strm << setw(indent+7) << "aal1 = " << setprecision(indent) << m_aal1 << '\n';
  if (HasOptionalField(e_aal5))
    strm << setw(indent+7) << "aal5 = " << setprecision(indent) << m_aal5 << '\n';
  strm << setw(indent+18) << "transportStream = " << setprecision(indent) << m_transportStream << '\n';
  strm << setw(indent+16) << "programStream = " << setprecision(indent) << m_programStream << '\n';
  strm << setw(indent+20) << "availableBitRates = " << setprecision(indent) << m_availableBitRates << '\n';
  if (HasOptionalField(e_aal1ViaGateway))
    strm << setw(indent+17) << "aal1ViaGateway = " << setprecision(indent) << m_aal1ViaGateway << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_VCCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_VCCapability::Class()), PInvalidCast);
#endif
  const H245_VCCapability & other = (const H245_VCCapability &)obj;

  Comparison result;

  if ((result = m_aal1.Compare(other.m_aal1)) != EqualTo)
    return result;
  if ((result = m_aal5.Compare(other.m_aal5)) != EqualTo)
    return result;
  if ((result = m_transportStream.Compare(other.m_transportStream)) != EqualTo)
    return result;
  if ((result = m_programStream.Compare(other.m_programStream)) != EqualTo)
    return result;
  if ((result = m_availableBitRates.Compare(other.m_availableBitRates)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_VCCapability::GetDataLength() const
{
  return m_aal1.GetObjectLength() +
         m_aal5.GetObjectLength() +
         m_transportStream.GetObjectLength() +
         m_programStream.GetObjectLength() +
         m_availableBitRates.GetObjectLength();
}


BOOL H245_VCCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_aal1 ) && !m_aal1.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_aal5 ) && !m_aal5.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_transportStream.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_programStream.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_availableBitRates.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_aal1ViaGateway, m_aal1ViaGateway ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_VCCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_aal1))
    m_aal1.Encode(strm);
  if (HasOptionalField(e_aal5))
    m_aal5.Encode(strm);
  m_transportStream.Encode(strm);
  m_programStream.Encode(strm);
  m_availableBitRates.Encode(strm);
  KnownExtensionEncode(strm, e_aal1ViaGateway, m_aal1ViaGateway);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_aal1))
    m_aal1.Encode(strm);
  if (HasOptionalField(e_aal5))
    m_aal5.Encode(strm);
  m_transportStream.Encode(strm);
  m_programStream.Encode(strm);
  m_availableBitRates.Encode(strm);
}


PObject * H245_VCCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_VCCapability::Class()), PInvalidCast);
#endif
  return new H245_VCCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_VCCapability::preShowEthereal( void )
{
  if ( HasOptionalField( e_aal1 ) ) 
      m_aal1.preShowEthereal( );
  if ( HasOptionalField( e_aal5 ) ) 
      m_aal5.preShowEthereal( );
  m_transportStream.preShowEthereal( );
  m_programStream.preShowEthereal( );
  m_availableBitRates.preShowEthereal( );
  if ( HasOptionalField( e_aal1ViaGateway ) ) 
      m_aal1ViaGateway.preShowEthereal( );
}

PString H245_VCCapability::getSummary( void ) 
{
  return PString( "VCCapability" );
}

void H245_VCCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_aal1 ) ) {
    proto_tree *aal1_tree = (proto_tree*) NULL;
    proto_item *aal1_ti = (proto_item*) NULL;
    aal1_ti = proto_tree_add_text( tree, tvb, offset + m_aal1.GetStartByte(), m_aal1.GetByteLength(), "aal1 (VCCapability-aal1)" );
    aal1_tree = proto_item_add_subtree( aal1_ti, hCont->h245_2.ett_h245_VCCapability_aal1 );
    m_aal1.showEthereal( aal1_tree, tvb, offset );
  }

  if ( HasOptionalField( e_aal5 ) ) {
    proto_tree *aal5_tree = (proto_tree*) NULL;
    proto_item *aal5_ti = (proto_item*) NULL;
    aal5_ti = proto_tree_add_text( tree, tvb, offset + m_aal5.GetStartByte(), m_aal5.GetByteLength(), "aal5 (VCCapability-aal5)" );
    aal5_tree = proto_item_add_subtree( aal5_ti, hCont->h245_2.ett_h245_VCCapability_aal5 );
    m_aal5.showEthereal( aal5_tree, tvb, offset );
  }

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_VCCapability_transportStream, tvb, offset + m_transportStream.GetStartByte(), m_transportStream.GetByteLength() , m_transportStream.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_VCCapability_programStream, tvb, offset + m_programStream.GetStartByte(), m_programStream.GetByteLength() , m_programStream.GetValue() );

  proto_tree *availableBitRates_tree = (proto_tree*) NULL;
  proto_item *availableBitRates_ti = (proto_item*) NULL;
  availableBitRates_ti = proto_tree_add_text( tree, tvb, offset + m_availableBitRates.GetStartByte(), m_availableBitRates.GetByteLength(), "availableBitRates (VCCapability-availableBitRates)" );
  availableBitRates_tree = proto_item_add_subtree( availableBitRates_ti, hCont->h245_2.ett_h245_VCCapability_availableBitRates );

  m_availableBitRates.showEthereal( availableBitRates_tree, tvb, offset );

  if ( HasOptionalField( e_aal1ViaGateway ) ) {
    proto_tree *aal1ViaGateway_tree = (proto_tree*) NULL;
    proto_item *aal1ViaGateway_ti = (proto_item*) NULL;
    aal1ViaGateway_ti = proto_tree_add_text( tree, tvb, offset + m_aal1ViaGateway.GetStartByte(), m_aal1ViaGateway.GetByteLength(), "aal1ViaGateway (VCCapability-aal1ViaGateway)" );
    aal1ViaGateway_tree = proto_item_add_subtree( aal1ViaGateway_ti, hCont->h245_2.ett_h245_VCCapability_aal1ViaGateway );
    m_aal1ViaGateway.showEthereal( aal1ViaGateway_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// H2250Capability
//

H245_H2250Capability::H245_H2250Capability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 4)
{
  m_maximumAudioDelayJitter.SetConstraints(PASN_Object::FixedConstraint, 0, 1023);
  m_redundancyEncodingCapability.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
  IncludeOptionalField(e_logicalChannelSwitchingCapability);
  IncludeOptionalField(e_t120DynamicPortCapability);
}


#ifndef PASN_NOPRINTON
void H245_H2250Capability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+26) << "maximumAudioDelayJitter = " << setprecision(indent) << m_maximumAudioDelayJitter << '\n';
  strm << setw(indent+30) << "receiveMultipointCapability = " << setprecision(indent) << m_receiveMultipointCapability << '\n';
  strm << setw(indent+31) << "transmitMultipointCapability = " << setprecision(indent) << m_transmitMultipointCapability << '\n';
  strm << setw(indent+41) << "receiveAndTransmitMultipointCapability = " << setprecision(indent) << m_receiveAndTransmitMultipointCapability << '\n';
  strm << setw(indent+15) << "mcCapability = " << setprecision(indent) << m_mcCapability << '\n';
  strm << setw(indent+29) << "rtcpVideoControlCapability = " << setprecision(indent) << m_rtcpVideoControlCapability << '\n';
  strm << setw(indent+31) << "mediaPacketizationCapability = " << setprecision(indent) << m_mediaPacketizationCapability << '\n';
  if (HasOptionalField(e_transportCapability))
    strm << setw(indent+22) << "transportCapability = " << setprecision(indent) << m_transportCapability << '\n';
  if (HasOptionalField(e_redundancyEncodingCapability))
    strm << setw(indent+31) << "redundancyEncodingCapability = " << setprecision(indent) << m_redundancyEncodingCapability << '\n';
  if (HasOptionalField(e_logicalChannelSwitchingCapability))
    strm << setw(indent+36) << "logicalChannelSwitchingCapability = " << setprecision(indent) << m_logicalChannelSwitchingCapability << '\n';
  if (HasOptionalField(e_t120DynamicPortCapability))
    strm << setw(indent+28) << "t120DynamicPortCapability = " << setprecision(indent) << m_t120DynamicPortCapability << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H2250Capability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H2250Capability::Class()), PInvalidCast);
#endif
  const H245_H2250Capability & other = (const H245_H2250Capability &)obj;

  Comparison result;

  if ((result = m_maximumAudioDelayJitter.Compare(other.m_maximumAudioDelayJitter)) != EqualTo)
    return result;
  if ((result = m_receiveMultipointCapability.Compare(other.m_receiveMultipointCapability)) != EqualTo)
    return result;
  if ((result = m_transmitMultipointCapability.Compare(other.m_transmitMultipointCapability)) != EqualTo)
    return result;
  if ((result = m_receiveAndTransmitMultipointCapability.Compare(other.m_receiveAndTransmitMultipointCapability)) != EqualTo)
    return result;
  if ((result = m_mcCapability.Compare(other.m_mcCapability)) != EqualTo)
    return result;
  if ((result = m_rtcpVideoControlCapability.Compare(other.m_rtcpVideoControlCapability)) != EqualTo)
    return result;
  if ((result = m_mediaPacketizationCapability.Compare(other.m_mediaPacketizationCapability)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H2250Capability::GetDataLength() const
{
  return m_maximumAudioDelayJitter.GetObjectLength() +
         m_receiveMultipointCapability.GetObjectLength() +
         m_transmitMultipointCapability.GetObjectLength() +
         m_receiveAndTransmitMultipointCapability.GetObjectLength() +
         m_mcCapability.GetObjectLength() +
         m_rtcpVideoControlCapability.GetObjectLength() +
         m_mediaPacketizationCapability.GetObjectLength();
}


BOOL H245_H2250Capability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maximumAudioDelayJitter.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_receiveMultipointCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_transmitMultipointCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_receiveAndTransmitMultipointCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_mcCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_rtcpVideoControlCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_mediaPacketizationCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_transportCapability, m_transportCapability ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_redundancyEncodingCapability, m_redundancyEncodingCapability ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_logicalChannelSwitchingCapability, m_logicalChannelSwitchingCapability ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_t120DynamicPortCapability, m_t120DynamicPortCapability ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H2250Capability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_maximumAudioDelayJitter.Encode(strm);
  m_receiveMultipointCapability.Encode(strm);
  m_transmitMultipointCapability.Encode(strm);
  m_receiveAndTransmitMultipointCapability.Encode(strm);
  m_mcCapability.Encode(strm);
  m_rtcpVideoControlCapability.Encode(strm);
  m_mediaPacketizationCapability.Encode(strm);
  KnownExtensionEncode(strm, e_transportCapability, m_transportCapability);
  KnownExtensionEncode(strm, e_redundancyEncodingCapability, m_redundancyEncodingCapability);
  KnownExtensionEncode(strm, e_logicalChannelSwitchingCapability, m_logicalChannelSwitchingCapability);
  KnownExtensionEncode(strm, e_t120DynamicPortCapability, m_t120DynamicPortCapability);

  UnknownExtensionsEncode(strm);
  m_maximumAudioDelayJitter.Encode(strm);
  m_receiveMultipointCapability.Encode(strm);
  m_transmitMultipointCapability.Encode(strm);
  m_receiveAndTransmitMultipointCapability.Encode(strm);
  m_mcCapability.Encode(strm);
  m_rtcpVideoControlCapability.Encode(strm);
  m_mediaPacketizationCapability.Encode(strm);
}


PObject * H245_H2250Capability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H2250Capability::Class()), PInvalidCast);
#endif
  return new H245_H2250Capability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H2250Capability::preShowEthereal( void )
{
  m_maximumAudioDelayJitter.preShowEthereal( );
  m_receiveMultipointCapability.preShowEthereal( );
  m_transmitMultipointCapability.preShowEthereal( );
  m_receiveAndTransmitMultipointCapability.preShowEthereal( );
  m_mcCapability.preShowEthereal( );
  m_rtcpVideoControlCapability.preShowEthereal( );
  m_mediaPacketizationCapability.preShowEthereal( );
  if ( HasOptionalField( e_transportCapability ) ) 
      m_transportCapability.preShowEthereal( );
  if ( HasOptionalField( e_redundancyEncodingCapability ) ) 
      m_redundancyEncodingCapability.preShowEthereal( );
  if ( HasOptionalField( e_logicalChannelSwitchingCapability ) ) 
      m_logicalChannelSwitchingCapability.preShowEthereal( );
  if ( HasOptionalField( e_t120DynamicPortCapability ) ) 
      m_t120DynamicPortCapability.preShowEthereal( );
}

PString H245_H2250Capability::getSummary( void ) 
{
  return PString( "H2250Capability" );
}

void H245_H2250Capability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_H2250Capability_maximumAudioDelayJitter, tvb, offset + m_maximumAudioDelayJitter.GetStartByte(), m_maximumAudioDelayJitter.GetByteLength() , m_maximumAudioDelayJitter.GetValue() );

  proto_tree *receiveMultipointCapability_tree = (proto_tree*) NULL;
  proto_item *receiveMultipointCapability_ti = (proto_item*) NULL;
  receiveMultipointCapability_ti = proto_tree_add_text( tree, tvb, offset + m_receiveMultipointCapability.GetStartByte(), m_receiveMultipointCapability.GetByteLength(), "receiveMultipointCapability (MultipointCapability)" );
  receiveMultipointCapability_tree = proto_item_add_subtree( receiveMultipointCapability_ti, hCont->h245_2.ett_h245_H2250Capability_receiveMultipointCapability );

  m_receiveMultipointCapability.showEthereal( receiveMultipointCapability_tree, tvb, offset );

  proto_tree *transmitMultipointCapability_tree = (proto_tree*) NULL;
  proto_item *transmitMultipointCapability_ti = (proto_item*) NULL;
  transmitMultipointCapability_ti = proto_tree_add_text( tree, tvb, offset + m_transmitMultipointCapability.GetStartByte(), m_transmitMultipointCapability.GetByteLength(), "transmitMultipointCapability (MultipointCapability)" );
  transmitMultipointCapability_tree = proto_item_add_subtree( transmitMultipointCapability_ti, hCont->h245_2.ett_h245_H2250Capability_transmitMultipointCapability );

  m_transmitMultipointCapability.showEthereal( transmitMultipointCapability_tree, tvb, offset );

  proto_tree *receiveAndTransmitMultipointCapability_tree = (proto_tree*) NULL;
  proto_item *receiveAndTransmitMultipointCapability_ti = (proto_item*) NULL;
  receiveAndTransmitMultipointCapability_ti = proto_tree_add_text( tree, tvb, offset + m_receiveAndTransmitMultipointCapability.GetStartByte(), m_receiveAndTransmitMultipointCapability.GetByteLength(), "receiveAndTransmitMultipointCapability (MultipointCapability)" );
  receiveAndTransmitMultipointCapability_tree = proto_item_add_subtree( receiveAndTransmitMultipointCapability_ti, hCont->h245_2.ett_h245_H2250Capability_receiveAndTransmitMultipointCapability );

  m_receiveAndTransmitMultipointCapability.showEthereal( receiveAndTransmitMultipointCapability_tree, tvb, offset );

  proto_tree *mcCapability_tree = (proto_tree*) NULL;
  proto_item *mcCapability_ti = (proto_item*) NULL;
  mcCapability_ti = proto_tree_add_text( tree, tvb, offset + m_mcCapability.GetStartByte(), m_mcCapability.GetByteLength(), "mcCapability (H2250Capability-mcCapability)" );
  mcCapability_tree = proto_item_add_subtree( mcCapability_ti, hCont->h245_2.ett_h245_H2250Capability_mcCapability );

  m_mcCapability.showEthereal( mcCapability_tree, tvb, offset );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H2250Capability_rtcpVideoControlCapability, tvb, offset + m_rtcpVideoControlCapability.GetStartByte(), m_rtcpVideoControlCapability.GetByteLength() , m_rtcpVideoControlCapability.GetValue() );

  proto_tree *mediaPacketizationCapability_tree = (proto_tree*) NULL;
  proto_item *mediaPacketizationCapability_ti = (proto_item*) NULL;
  mediaPacketizationCapability_ti = proto_tree_add_text( tree, tvb, offset + m_mediaPacketizationCapability.GetStartByte(), m_mediaPacketizationCapability.GetByteLength(), "mediaPacketizationCapability (MediaPacketizationCapability)" );
  mediaPacketizationCapability_tree = proto_item_add_subtree( mediaPacketizationCapability_ti, hCont->h245_2.ett_h245_H2250Capability_mediaPacketizationCapability );

  m_mediaPacketizationCapability.showEthereal( mediaPacketizationCapability_tree, tvb, offset );

  if ( HasOptionalField( e_transportCapability ) ) {
    proto_tree *transportCapability_tree = (proto_tree*) NULL;
    proto_item *transportCapability_ti = (proto_item*) NULL;
    transportCapability_ti = proto_tree_add_text( tree, tvb, offset + m_transportCapability.GetStartByte(), m_transportCapability.GetByteLength(), "transportCapability (TransportCapability)" );
    transportCapability_tree = proto_item_add_subtree( transportCapability_ti, hCont->h245_2.ett_h245_H2250Capability_transportCapability );
    m_transportCapability.showEthereal( transportCapability_tree, tvb, offset );
  }

  if ( HasOptionalField( e_redundancyEncodingCapability ) ) {
    proto_tree *redundancyEncodingCapability_tree = (proto_tree*) NULL;
    proto_item *redundancyEncodingCapability_ti = (proto_item*) NULL;
    redundancyEncodingCapability_ti = proto_tree_add_text( tree, tvb, offset + m_redundancyEncodingCapability.GetStartByte(), m_redundancyEncodingCapability.GetByteLength(), "redundancyEncodingCapability (RedundancyEncodingCapability)" );
    redundancyEncodingCapability_tree = proto_item_add_subtree( redundancyEncodingCapability_ti, hCont->h245_2.ett_h245_H2250Capability_redundancyEncodingCapability );
    m_redundancyEncodingCapability.showEthereal( redundancyEncodingCapability_tree, tvb, offset );
  }

  if ( HasOptionalField( e_logicalChannelSwitchingCapability ) ) {
    proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H2250Capability_logicalChannelSwitchingCapability, tvb, offset + m_logicalChannelSwitchingCapability.GetStartByte(), m_logicalChannelSwitchingCapability.GetByteLength() , m_logicalChannelSwitchingCapability.GetValue() );
  }

  if ( HasOptionalField( e_t120DynamicPortCapability ) ) {
    proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H2250Capability_t120DynamicPortCapability, tvb, offset + m_t120DynamicPortCapability.GetStartByte(), m_t120DynamicPortCapability.GetByteLength() , m_t120DynamicPortCapability.GetValue() );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// H263Options
//

H245_H263Options::H245_H263Options(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 5, TRUE, 0)
{
  m_customPictureClockFrequency.SetConstraints(PASN_Object::FixedConstraint, 1, 16);
  m_customPictureFormat.SetConstraints(PASN_Object::FixedConstraint, 1, 16);
  m_modeCombos.SetConstraints(PASN_Object::FixedConstraint, 1, 16);
}


#ifndef PASN_NOPRINTON
void H245_H263Options::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+26) << "advancedIntraCodingMode = " << setprecision(indent) << m_advancedIntraCodingMode << '\n';
  strm << setw(indent+23) << "deblockingFilterMode = " << setprecision(indent) << m_deblockingFilterMode << '\n';
  strm << setw(indent+23) << "improvedPBFramesMode = " << setprecision(indent) << m_improvedPBFramesMode << '\n';
  strm << setw(indent+25) << "unlimitedMotionVectors = " << setprecision(indent) << m_unlimitedMotionVectors << '\n';
  strm << setw(indent+20) << "fullPictureFreeze = " << setprecision(indent) << m_fullPictureFreeze << '\n';
  strm << setw(indent+33) << "partialPictureFreezeAndRelease = " << setprecision(indent) << m_partialPictureFreezeAndRelease << '\n';
  strm << setw(indent+34) << "resizingPartPicFreezeAndRelease = " << setprecision(indent) << m_resizingPartPicFreezeAndRelease << '\n';
  strm << setw(indent+22) << "fullPictureSnapshot = " << setprecision(indent) << m_fullPictureSnapshot << '\n';
  strm << setw(indent+25) << "partialPictureSnapshot = " << setprecision(indent) << m_partialPictureSnapshot << '\n';
  strm << setw(indent+22) << "videoSegmentTagging = " << setprecision(indent) << m_videoSegmentTagging << '\n';
  strm << setw(indent+24) << "progressiveRefinement = " << setprecision(indent) << m_progressiveRefinement << '\n';
  strm << setw(indent+31) << "dynamicPictureResizingByFour = " << setprecision(indent) << m_dynamicPictureResizingByFour << '\n';
  strm << setw(indent+37) << "dynamicPictureResizingSixteenthPel = " << setprecision(indent) << m_dynamicPictureResizingSixteenthPel << '\n';
  strm << setw(indent+24) << "dynamicWarpingHalfPel = " << setprecision(indent) << m_dynamicWarpingHalfPel << '\n';
  strm << setw(indent+29) << "dynamicWarpingSixteenthPel = " << setprecision(indent) << m_dynamicWarpingSixteenthPel << '\n';
  strm << setw(indent+29) << "independentSegmentDecoding = " << setprecision(indent) << m_independentSegmentDecoding << '\n';
  strm << setw(indent+24) << "slicesInOrder_NonRect = " << setprecision(indent) << m_slicesInOrder_NonRect << '\n';
  strm << setw(indent+21) << "slicesInOrder_Rect = " << setprecision(indent) << m_slicesInOrder_Rect << '\n';
  strm << setw(indent+24) << "slicesNoOrder_NonRect = " << setprecision(indent) << m_slicesNoOrder_NonRect << '\n';
  strm << setw(indent+21) << "slicesNoOrder_Rect = " << setprecision(indent) << m_slicesNoOrder_Rect << '\n';
  strm << setw(indent+24) << "alternateInterVLCMode = " << setprecision(indent) << m_alternateInterVLCMode << '\n';
  strm << setw(indent+27) << "modifiedQuantizationMode = " << setprecision(indent) << m_modifiedQuantizationMode << '\n';
  strm << setw(indent+26) << "reducedResolutionUpdate = " << setprecision(indent) << m_reducedResolutionUpdate << '\n';
  if (HasOptionalField(e_transparencyParameters))
    strm << setw(indent+25) << "transparencyParameters = " << setprecision(indent) << m_transparencyParameters << '\n';
  strm << setw(indent+27) << "separateVideoBackChannel = " << setprecision(indent) << m_separateVideoBackChannel << '\n';
  if (HasOptionalField(e_refPictureSelection))
    strm << setw(indent+22) << "refPictureSelection = " << setprecision(indent) << m_refPictureSelection << '\n';
  if (HasOptionalField(e_customPictureClockFrequency))
    strm << setw(indent+30) << "customPictureClockFrequency = " << setprecision(indent) << m_customPictureClockFrequency << '\n';
  if (HasOptionalField(e_customPictureFormat))
    strm << setw(indent+22) << "customPictureFormat = " << setprecision(indent) << m_customPictureFormat << '\n';
  if (HasOptionalField(e_modeCombos))
    strm << setw(indent+13) << "modeCombos = " << setprecision(indent) << m_modeCombos << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H263Options::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H263Options::Class()), PInvalidCast);
#endif
  const H245_H263Options & other = (const H245_H263Options &)obj;

  Comparison result;

  if ((result = m_advancedIntraCodingMode.Compare(other.m_advancedIntraCodingMode)) != EqualTo)
    return result;
  if ((result = m_deblockingFilterMode.Compare(other.m_deblockingFilterMode)) != EqualTo)
    return result;
  if ((result = m_improvedPBFramesMode.Compare(other.m_improvedPBFramesMode)) != EqualTo)
    return result;
  if ((result = m_unlimitedMotionVectors.Compare(other.m_unlimitedMotionVectors)) != EqualTo)
    return result;
  if ((result = m_fullPictureFreeze.Compare(other.m_fullPictureFreeze)) != EqualTo)
    return result;
  if ((result = m_partialPictureFreezeAndRelease.Compare(other.m_partialPictureFreezeAndRelease)) != EqualTo)
    return result;
  if ((result = m_resizingPartPicFreezeAndRelease.Compare(other.m_resizingPartPicFreezeAndRelease)) != EqualTo)
    return result;
  if ((result = m_fullPictureSnapshot.Compare(other.m_fullPictureSnapshot)) != EqualTo)
    return result;
  if ((result = m_partialPictureSnapshot.Compare(other.m_partialPictureSnapshot)) != EqualTo)
    return result;
  if ((result = m_videoSegmentTagging.Compare(other.m_videoSegmentTagging)) != EqualTo)
    return result;
  if ((result = m_progressiveRefinement.Compare(other.m_progressiveRefinement)) != EqualTo)
    return result;
  if ((result = m_dynamicPictureResizingByFour.Compare(other.m_dynamicPictureResizingByFour)) != EqualTo)
    return result;
  if ((result = m_dynamicPictureResizingSixteenthPel.Compare(other.m_dynamicPictureResizingSixteenthPel)) != EqualTo)
    return result;
  if ((result = m_dynamicWarpingHalfPel.Compare(other.m_dynamicWarpingHalfPel)) != EqualTo)
    return result;
  if ((result = m_dynamicWarpingSixteenthPel.Compare(other.m_dynamicWarpingSixteenthPel)) != EqualTo)
    return result;
  if ((result = m_independentSegmentDecoding.Compare(other.m_independentSegmentDecoding)) != EqualTo)
    return result;
  if ((result = m_slicesInOrder_NonRect.Compare(other.m_slicesInOrder_NonRect)) != EqualTo)
    return result;
  if ((result = m_slicesInOrder_Rect.Compare(other.m_slicesInOrder_Rect)) != EqualTo)
    return result;
  if ((result = m_slicesNoOrder_NonRect.Compare(other.m_slicesNoOrder_NonRect)) != EqualTo)
    return result;
  if ((result = m_slicesNoOrder_Rect.Compare(other.m_slicesNoOrder_Rect)) != EqualTo)
    return result;
  if ((result = m_alternateInterVLCMode.Compare(other.m_alternateInterVLCMode)) != EqualTo)
    return result;
  if ((result = m_modifiedQuantizationMode.Compare(other.m_modifiedQuantizationMode)) != EqualTo)
    return result;
  if ((result = m_reducedResolutionUpdate.Compare(other.m_reducedResolutionUpdate)) != EqualTo)
    return result;
  if ((result = m_transparencyParameters.Compare(other.m_transparencyParameters)) != EqualTo)
    return result;
  if ((result = m_separateVideoBackChannel.Compare(other.m_separateVideoBackChannel)) != EqualTo)
    return result;
  if ((result = m_refPictureSelection.Compare(other.m_refPictureSelection)) != EqualTo)
    return result;
  if ((result = m_customPictureClockFrequency.Compare(other.m_customPictureClockFrequency)) != EqualTo)
    return result;
  if ((result = m_customPictureFormat.Compare(other.m_customPictureFormat)) != EqualTo)
    return result;
  if ((result = m_modeCombos.Compare(other.m_modeCombos)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H263Options::GetDataLength() const
{
  return m_advancedIntraCodingMode.GetObjectLength() +
         m_deblockingFilterMode.GetObjectLength() +
         m_improvedPBFramesMode.GetObjectLength() +
         m_unlimitedMotionVectors.GetObjectLength() +
         m_fullPictureFreeze.GetObjectLength() +
         m_partialPictureFreezeAndRelease.GetObjectLength() +
         m_resizingPartPicFreezeAndRelease.GetObjectLength() +
         m_fullPictureSnapshot.GetObjectLength() +
         m_partialPictureSnapshot.GetObjectLength() +
         m_videoSegmentTagging.GetObjectLength() +
         m_progressiveRefinement.GetObjectLength() +
         m_dynamicPictureResizingByFour.GetObjectLength() +
         m_dynamicPictureResizingSixteenthPel.GetObjectLength() +
         m_dynamicWarpingHalfPel.GetObjectLength() +
         m_dynamicWarpingSixteenthPel.GetObjectLength() +
         m_independentSegmentDecoding.GetObjectLength() +
         m_slicesInOrder_NonRect.GetObjectLength() +
         m_slicesInOrder_Rect.GetObjectLength() +
         m_slicesNoOrder_NonRect.GetObjectLength() +
         m_slicesNoOrder_Rect.GetObjectLength() +
         m_alternateInterVLCMode.GetObjectLength() +
         m_modifiedQuantizationMode.GetObjectLength() +
         m_reducedResolutionUpdate.GetObjectLength() +
         m_transparencyParameters.GetObjectLength() +
         m_separateVideoBackChannel.GetObjectLength() +
         m_refPictureSelection.GetObjectLength() +
         m_customPictureClockFrequency.GetObjectLength() +
         m_customPictureFormat.GetObjectLength() +
         m_modeCombos.GetObjectLength();
}


BOOL H245_H263Options::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_advancedIntraCodingMode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_deblockingFilterMode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_improvedPBFramesMode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_unlimitedMotionVectors.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_fullPictureFreeze.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_partialPictureFreezeAndRelease.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_resizingPartPicFreezeAndRelease.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_fullPictureSnapshot.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_partialPictureSnapshot.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_videoSegmentTagging.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_progressiveRefinement.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_dynamicPictureResizingByFour.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_dynamicPictureResizingSixteenthPel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_dynamicWarpingHalfPel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_dynamicWarpingSixteenthPel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_independentSegmentDecoding.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_slicesInOrder_NonRect.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_slicesInOrder_Rect.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_slicesNoOrder_NonRect.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_slicesNoOrder_Rect.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_alternateInterVLCMode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_modifiedQuantizationMode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_reducedResolutionUpdate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_transparencyParameters ) && !m_transparencyParameters.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_separateVideoBackChannel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_refPictureSelection ) && !m_refPictureSelection.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_customPictureClockFrequency ) && !m_customPictureClockFrequency.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_customPictureFormat ) && !m_customPictureFormat.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_modeCombos ) && !m_modeCombos.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H263Options::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_advancedIntraCodingMode.Encode(strm);
  m_deblockingFilterMode.Encode(strm);
  m_improvedPBFramesMode.Encode(strm);
  m_unlimitedMotionVectors.Encode(strm);
  m_fullPictureFreeze.Encode(strm);
  m_partialPictureFreezeAndRelease.Encode(strm);
  m_resizingPartPicFreezeAndRelease.Encode(strm);
  m_fullPictureSnapshot.Encode(strm);
  m_partialPictureSnapshot.Encode(strm);
  m_videoSegmentTagging.Encode(strm);
  m_progressiveRefinement.Encode(strm);
  m_dynamicPictureResizingByFour.Encode(strm);
  m_dynamicPictureResizingSixteenthPel.Encode(strm);
  m_dynamicWarpingHalfPel.Encode(strm);
  m_dynamicWarpingSixteenthPel.Encode(strm);
  m_independentSegmentDecoding.Encode(strm);
  m_slicesInOrder_NonRect.Encode(strm);
  m_slicesInOrder_Rect.Encode(strm);
  m_slicesNoOrder_NonRect.Encode(strm);
  m_slicesNoOrder_Rect.Encode(strm);
  m_alternateInterVLCMode.Encode(strm);
  m_modifiedQuantizationMode.Encode(strm);
  m_reducedResolutionUpdate.Encode(strm);
  if (HasOptionalField(e_transparencyParameters))
    m_transparencyParameters.Encode(strm);
  m_separateVideoBackChannel.Encode(strm);
  if (HasOptionalField(e_refPictureSelection))
    m_refPictureSelection.Encode(strm);
  if (HasOptionalField(e_customPictureClockFrequency))
    m_customPictureClockFrequency.Encode(strm);
  if (HasOptionalField(e_customPictureFormat))
    m_customPictureFormat.Encode(strm);
  if (HasOptionalField(e_modeCombos))
    m_modeCombos.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_advancedIntraCodingMode.Encode(strm);
  m_deblockingFilterMode.Encode(strm);
  m_improvedPBFramesMode.Encode(strm);
  m_unlimitedMotionVectors.Encode(strm);
  m_fullPictureFreeze.Encode(strm);
  m_partialPictureFreezeAndRelease.Encode(strm);
  m_resizingPartPicFreezeAndRelease.Encode(strm);
  m_fullPictureSnapshot.Encode(strm);
  m_partialPictureSnapshot.Encode(strm);
  m_videoSegmentTagging.Encode(strm);
  m_progressiveRefinement.Encode(strm);
  m_dynamicPictureResizingByFour.Encode(strm);
  m_dynamicPictureResizingSixteenthPel.Encode(strm);
  m_dynamicWarpingHalfPel.Encode(strm);
  m_dynamicWarpingSixteenthPel.Encode(strm);
  m_independentSegmentDecoding.Encode(strm);
  m_slicesInOrder_NonRect.Encode(strm);
  m_slicesInOrder_Rect.Encode(strm);
  m_slicesNoOrder_NonRect.Encode(strm);
  m_slicesNoOrder_Rect.Encode(strm);
  m_alternateInterVLCMode.Encode(strm);
  m_modifiedQuantizationMode.Encode(strm);
  m_reducedResolutionUpdate.Encode(strm);
  if (HasOptionalField(e_transparencyParameters))
    m_transparencyParameters.Encode(strm);
  m_separateVideoBackChannel.Encode(strm);
  if (HasOptionalField(e_refPictureSelection))
    m_refPictureSelection.Encode(strm);
  if (HasOptionalField(e_customPictureClockFrequency))
    m_customPictureClockFrequency.Encode(strm);
  if (HasOptionalField(e_customPictureFormat))
    m_customPictureFormat.Encode(strm);
  if (HasOptionalField(e_modeCombos))
    m_modeCombos.Encode(strm);
}


PObject * H245_H263Options::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H263Options::Class()), PInvalidCast);
#endif
  return new H245_H263Options(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H263Options::preShowEthereal( void )
{
  m_advancedIntraCodingMode.preShowEthereal( );
  m_deblockingFilterMode.preShowEthereal( );
  m_improvedPBFramesMode.preShowEthereal( );
  m_unlimitedMotionVectors.preShowEthereal( );
  m_fullPictureFreeze.preShowEthereal( );
  m_partialPictureFreezeAndRelease.preShowEthereal( );
  m_resizingPartPicFreezeAndRelease.preShowEthereal( );
  m_fullPictureSnapshot.preShowEthereal( );
  m_partialPictureSnapshot.preShowEthereal( );
  m_videoSegmentTagging.preShowEthereal( );
  m_progressiveRefinement.preShowEthereal( );
  m_dynamicPictureResizingByFour.preShowEthereal( );
  m_dynamicPictureResizingSixteenthPel.preShowEthereal( );
  m_dynamicWarpingHalfPel.preShowEthereal( );
  m_dynamicWarpingSixteenthPel.preShowEthereal( );
  m_independentSegmentDecoding.preShowEthereal( );
  m_slicesInOrder_NonRect.preShowEthereal( );
  m_slicesInOrder_Rect.preShowEthereal( );
  m_slicesNoOrder_NonRect.preShowEthereal( );
  m_slicesNoOrder_Rect.preShowEthereal( );
  m_alternateInterVLCMode.preShowEthereal( );
  m_modifiedQuantizationMode.preShowEthereal( );
  m_reducedResolutionUpdate.preShowEthereal( );
  if ( HasOptionalField( e_transparencyParameters ) ) 
      m_transparencyParameters.preShowEthereal( );
  m_separateVideoBackChannel.preShowEthereal( );
  if ( HasOptionalField( e_refPictureSelection ) ) 
      m_refPictureSelection.preShowEthereal( );
  if ( HasOptionalField( e_customPictureClockFrequency ) ) 
      m_customPictureClockFrequency.preShowEthereal( );
  if ( HasOptionalField( e_customPictureFormat ) ) 
      m_customPictureFormat.preShowEthereal( );
  if ( HasOptionalField( e_modeCombos ) ) 
      m_modeCombos.preShowEthereal( );
}

PString H245_H263Options::getSummary( void ) 
{
  return PString( "H263Options" );
}

void H245_H263Options::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_advancedIntraCodingMode, tvb, offset + m_advancedIntraCodingMode.GetStartByte(), m_advancedIntraCodingMode.GetByteLength() , m_advancedIntraCodingMode.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_deblockingFilterMode, tvb, offset + m_deblockingFilterMode.GetStartByte(), m_deblockingFilterMode.GetByteLength() , m_deblockingFilterMode.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_improvedPBFramesMode, tvb, offset + m_improvedPBFramesMode.GetStartByte(), m_improvedPBFramesMode.GetByteLength() , m_improvedPBFramesMode.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_unlimitedMotionVectors, tvb, offset + m_unlimitedMotionVectors.GetStartByte(), m_unlimitedMotionVectors.GetByteLength() , m_unlimitedMotionVectors.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_fullPictureFreeze, tvb, offset + m_fullPictureFreeze.GetStartByte(), m_fullPictureFreeze.GetByteLength() , m_fullPictureFreeze.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_partialPictureFreezeAndRelease, tvb, offset + m_partialPictureFreezeAndRelease.GetStartByte(), m_partialPictureFreezeAndRelease.GetByteLength() , m_partialPictureFreezeAndRelease.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_resizingPartPicFreezeAndRelease, tvb, offset + m_resizingPartPicFreezeAndRelease.GetStartByte(), m_resizingPartPicFreezeAndRelease.GetByteLength() , m_resizingPartPicFreezeAndRelease.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_fullPictureSnapshot, tvb, offset + m_fullPictureSnapshot.GetStartByte(), m_fullPictureSnapshot.GetByteLength() , m_fullPictureSnapshot.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_partialPictureSnapshot, tvb, offset + m_partialPictureSnapshot.GetStartByte(), m_partialPictureSnapshot.GetByteLength() , m_partialPictureSnapshot.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_videoSegmentTagging, tvb, offset + m_videoSegmentTagging.GetStartByte(), m_videoSegmentTagging.GetByteLength() , m_videoSegmentTagging.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_progressiveRefinement, tvb, offset + m_progressiveRefinement.GetStartByte(), m_progressiveRefinement.GetByteLength() , m_progressiveRefinement.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_dynamicPictureResizingByFour, tvb, offset + m_dynamicPictureResizingByFour.GetStartByte(), m_dynamicPictureResizingByFour.GetByteLength() , m_dynamicPictureResizingByFour.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_dynamicPictureResizingSixteenthPel, tvb, offset + m_dynamicPictureResizingSixteenthPel.GetStartByte(), m_dynamicPictureResizingSixteenthPel.GetByteLength() , m_dynamicPictureResizingSixteenthPel.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_dynamicWarpingHalfPel, tvb, offset + m_dynamicWarpingHalfPel.GetStartByte(), m_dynamicWarpingHalfPel.GetByteLength() , m_dynamicWarpingHalfPel.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_dynamicWarpingSixteenthPel, tvb, offset + m_dynamicWarpingSixteenthPel.GetStartByte(), m_dynamicWarpingSixteenthPel.GetByteLength() , m_dynamicWarpingSixteenthPel.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_independentSegmentDecoding, tvb, offset + m_independentSegmentDecoding.GetStartByte(), m_independentSegmentDecoding.GetByteLength() , m_independentSegmentDecoding.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_slicesInOrder_NonRect, tvb, offset + m_slicesInOrder_NonRect.GetStartByte(), m_slicesInOrder_NonRect.GetByteLength() , m_slicesInOrder_NonRect.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_slicesInOrder_Rect, tvb, offset + m_slicesInOrder_Rect.GetStartByte(), m_slicesInOrder_Rect.GetByteLength() , m_slicesInOrder_Rect.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_slicesNoOrder_NonRect, tvb, offset + m_slicesNoOrder_NonRect.GetStartByte(), m_slicesNoOrder_NonRect.GetByteLength() , m_slicesNoOrder_NonRect.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_slicesNoOrder_Rect, tvb, offset + m_slicesNoOrder_Rect.GetStartByte(), m_slicesNoOrder_Rect.GetByteLength() , m_slicesNoOrder_Rect.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_alternateInterVLCMode, tvb, offset + m_alternateInterVLCMode.GetStartByte(), m_alternateInterVLCMode.GetByteLength() , m_alternateInterVLCMode.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_modifiedQuantizationMode, tvb, offset + m_modifiedQuantizationMode.GetStartByte(), m_modifiedQuantizationMode.GetByteLength() , m_modifiedQuantizationMode.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_reducedResolutionUpdate, tvb, offset + m_reducedResolutionUpdate.GetStartByte(), m_reducedResolutionUpdate.GetByteLength() , m_reducedResolutionUpdate.GetValue() );

  if ( HasOptionalField( e_transparencyParameters ) ) {
    proto_tree *transparencyParameters_tree = (proto_tree*) NULL;
    proto_item *transparencyParameters_ti = (proto_item*) NULL;
    transparencyParameters_ti = proto_tree_add_text( tree, tvb, offset + m_transparencyParameters.GetStartByte(), m_transparencyParameters.GetByteLength(), "transparencyParameters (TransparencyParameters)" );
    transparencyParameters_tree = proto_item_add_subtree( transparencyParameters_ti, hCont->h245_2.ett_h245_H263Options_transparencyParameters );
    m_transparencyParameters.showEthereal( transparencyParameters_tree, tvb, offset );
  }

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263Options_separateVideoBackChannel, tvb, offset + m_separateVideoBackChannel.GetStartByte(), m_separateVideoBackChannel.GetByteLength() , m_separateVideoBackChannel.GetValue() );

  if ( HasOptionalField( e_refPictureSelection ) ) {
    proto_tree *refPictureSelection_tree = (proto_tree*) NULL;
    proto_item *refPictureSelection_ti = (proto_item*) NULL;
    refPictureSelection_ti = proto_tree_add_text( tree, tvb, offset + m_refPictureSelection.GetStartByte(), m_refPictureSelection.GetByteLength(), "refPictureSelection (RefPictureSelection)" );
    refPictureSelection_tree = proto_item_add_subtree( refPictureSelection_ti, hCont->h245_2.ett_h245_H263Options_refPictureSelection );
    m_refPictureSelection.showEthereal( refPictureSelection_tree, tvb, offset );
  }

  if ( HasOptionalField( e_customPictureClockFrequency ) ) {
    proto_tree *customPictureClockFrequency_tree = (proto_tree*) NULL;
    proto_item *customPictureClockFrequency_ti = (proto_item*) NULL;
    customPictureClockFrequency_ti = proto_tree_add_text( tree, tvb, offset + m_customPictureClockFrequency.GetStartByte(), m_customPictureClockFrequency.GetByteLength(), "customPictureClockFrequency (CustomPictureClockFrequency)" );
    customPictureClockFrequency_tree = proto_item_add_subtree( customPictureClockFrequency_ti, hCont->h245_2.ett_h245_H263Options_customPictureClockFrequency );
    m_customPictureClockFrequency.showEthereal( customPictureClockFrequency_tree, tvb, offset );
  }

  if ( HasOptionalField( e_customPictureFormat ) ) {
    proto_tree *customPictureFormat_tree = (proto_tree*) NULL;
    proto_item *customPictureFormat_ti = (proto_item*) NULL;
    customPictureFormat_ti = proto_tree_add_text( tree, tvb, offset + m_customPictureFormat.GetStartByte(), m_customPictureFormat.GetByteLength(), "customPictureFormat (CustomPictureFormat)" );
    customPictureFormat_tree = proto_item_add_subtree( customPictureFormat_ti, hCont->h245_2.ett_h245_H263Options_customPictureFormat );
    m_customPictureFormat.showEthereal( customPictureFormat_tree, tvb, offset );
  }

  if ( HasOptionalField( e_modeCombos ) ) {
    proto_tree *modeCombos_tree = (proto_tree*) NULL;
    proto_item *modeCombos_ti = (proto_item*) NULL;
    modeCombos_ti = proto_tree_add_text( tree, tvb, offset + m_modeCombos.GetStartByte(), m_modeCombos.GetByteLength(), "modeCombos (H263VideoModeCombos)" );
    modeCombos_tree = proto_item_add_subtree( modeCombos_ti, hCont->h245_2.ett_h245_H263Options_modeCombos );
    m_modeCombos.showEthereal( modeCombos_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CustomPictureFormat
//

H245_CustomPictureFormat::H245_CustomPictureFormat(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_maxCustomPictureWidth.SetConstraints(PASN_Object::FixedConstraint, 1, 2048);
  m_maxCustomPictureHeight.SetConstraints(PASN_Object::FixedConstraint, 1, 2048);
  m_minCustomPictureWidth.SetConstraints(PASN_Object::FixedConstraint, 1, 2048);
  m_minCustomPictureHeight.SetConstraints(PASN_Object::FixedConstraint, 1, 2048);
}


#ifndef PASN_NOPRINTON
void H245_CustomPictureFormat::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "maxCustomPictureWidth = " << setprecision(indent) << m_maxCustomPictureWidth << '\n';
  strm << setw(indent+25) << "maxCustomPictureHeight = " << setprecision(indent) << m_maxCustomPictureHeight << '\n';
  strm << setw(indent+24) << "minCustomPictureWidth = " << setprecision(indent) << m_minCustomPictureWidth << '\n';
  strm << setw(indent+25) << "minCustomPictureHeight = " << setprecision(indent) << m_minCustomPictureHeight << '\n';
  strm << setw(indent+6) << "mPI = " << setprecision(indent) << m_mPI << '\n';
  strm << setw(indent+25) << "pixelAspectInformation = " << setprecision(indent) << m_pixelAspectInformation << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_CustomPictureFormat::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_CustomPictureFormat::Class()), PInvalidCast);
#endif
  const H245_CustomPictureFormat & other = (const H245_CustomPictureFormat &)obj;

  Comparison result;

  if ((result = m_maxCustomPictureWidth.Compare(other.m_maxCustomPictureWidth)) != EqualTo)
    return result;
  if ((result = m_maxCustomPictureHeight.Compare(other.m_maxCustomPictureHeight)) != EqualTo)
    return result;
  if ((result = m_minCustomPictureWidth.Compare(other.m_minCustomPictureWidth)) != EqualTo)
    return result;
  if ((result = m_minCustomPictureHeight.Compare(other.m_minCustomPictureHeight)) != EqualTo)
    return result;
  if ((result = m_mPI.Compare(other.m_mPI)) != EqualTo)
    return result;
  if ((result = m_pixelAspectInformation.Compare(other.m_pixelAspectInformation)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_CustomPictureFormat::GetDataLength() const
{
  return m_maxCustomPictureWidth.GetObjectLength() +
         m_maxCustomPictureHeight.GetObjectLength() +
         m_minCustomPictureWidth.GetObjectLength() +
         m_minCustomPictureHeight.GetObjectLength() +
         m_mPI.GetObjectLength() +
         m_pixelAspectInformation.GetObjectLength();
}


BOOL H245_CustomPictureFormat::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maxCustomPictureWidth.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maxCustomPictureHeight.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_minCustomPictureWidth.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_minCustomPictureHeight.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_mPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_pixelAspectInformation.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_CustomPictureFormat::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_maxCustomPictureWidth.Encode(strm);
  m_maxCustomPictureHeight.Encode(strm);
  m_minCustomPictureWidth.Encode(strm);
  m_minCustomPictureHeight.Encode(strm);
  m_mPI.Encode(strm);
  m_pixelAspectInformation.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_maxCustomPictureWidth.Encode(strm);
  m_maxCustomPictureHeight.Encode(strm);
  m_minCustomPictureWidth.Encode(strm);
  m_minCustomPictureHeight.Encode(strm);
  m_mPI.Encode(strm);
  m_pixelAspectInformation.Encode(strm);
}


PObject * H245_CustomPictureFormat::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CustomPictureFormat::Class()), PInvalidCast);
#endif
  return new H245_CustomPictureFormat(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CustomPictureFormat::preShowEthereal( void )
{
  m_maxCustomPictureWidth.preShowEthereal( );
  m_maxCustomPictureHeight.preShowEthereal( );
  m_minCustomPictureWidth.preShowEthereal( );
  m_minCustomPictureHeight.preShowEthereal( );
  m_mPI.preShowEthereal( );
  m_pixelAspectInformation.preShowEthereal( );
}

PString H245_CustomPictureFormat::getSummary( void ) 
{
  return PString( "CustomPictureFormat" );
}

void H245_CustomPictureFormat::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_CustomPictureFormat_maxCustomPictureWidth, tvb, offset + m_maxCustomPictureWidth.GetStartByte(), m_maxCustomPictureWidth.GetByteLength() , m_maxCustomPictureWidth.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_CustomPictureFormat_maxCustomPictureHeight, tvb, offset + m_maxCustomPictureHeight.GetStartByte(), m_maxCustomPictureHeight.GetByteLength() , m_maxCustomPictureHeight.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_CustomPictureFormat_minCustomPictureWidth, tvb, offset + m_minCustomPictureWidth.GetStartByte(), m_minCustomPictureWidth.GetByteLength() , m_minCustomPictureWidth.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_CustomPictureFormat_minCustomPictureHeight, tvb, offset + m_minCustomPictureHeight.GetStartByte(), m_minCustomPictureHeight.GetByteLength() , m_minCustomPictureHeight.GetValue() );

  proto_tree *mPI_tree = (proto_tree*) NULL;
  proto_item *mPI_ti = (proto_item*) NULL;
  mPI_ti = proto_tree_add_text( tree, tvb, offset + m_mPI.GetStartByte(), m_mPI.GetByteLength(), "mPI (CustomPictureFormat-mPI)" );
  mPI_tree = proto_item_add_subtree( mPI_ti, hCont->h245_2.ett_h245_CustomPictureFormat_mPI );

  m_mPI.showEthereal( mPI_tree, tvb, offset );

  proto_tree *pixelAspectInformation_tree = (proto_tree*) NULL;
  proto_item *pixelAspectInformation_ti = (proto_item*) NULL;
  pixelAspectInformation_ti = proto_tree_add_text( tree, tvb, offset + m_pixelAspectInformation.GetStartByte(), m_pixelAspectInformation.GetByteLength(), "pixelAspectInformation (%s)", ( const char* ) m_pixelAspectInformation.GetTagName() );
  pixelAspectInformation_tree = proto_item_add_subtree( pixelAspectInformation_ti, hCont->h245_2.ett_h245_CustomPictureFormat_pixelAspectInformation );

  m_pixelAspectInformation.showEthereal( pixelAspectInformation_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// EncryptionAuthenticationAndIntegrity
//

H245_EncryptionAuthenticationAndIntegrity::H245_EncryptionAuthenticationAndIntegrity(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_EncryptionAuthenticationAndIntegrity::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_encryptionCapability))
    strm << setw(indent+23) << "encryptionCapability = " << setprecision(indent) << m_encryptionCapability << '\n';
  if (HasOptionalField(e_authenticationCapability))
    strm << setw(indent+27) << "authenticationCapability = " << setprecision(indent) << m_authenticationCapability << '\n';
  if (HasOptionalField(e_integrityCapability))
    strm << setw(indent+22) << "integrityCapability = " << setprecision(indent) << m_integrityCapability << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_EncryptionAuthenticationAndIntegrity::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_EncryptionAuthenticationAndIntegrity::Class()), PInvalidCast);
#endif
  const H245_EncryptionAuthenticationAndIntegrity & other = (const H245_EncryptionAuthenticationAndIntegrity &)obj;

  Comparison result;

  if ((result = m_encryptionCapability.Compare(other.m_encryptionCapability)) != EqualTo)
    return result;
  if ((result = m_authenticationCapability.Compare(other.m_authenticationCapability)) != EqualTo)
    return result;
  if ((result = m_integrityCapability.Compare(other.m_integrityCapability)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_EncryptionAuthenticationAndIntegrity::GetDataLength() const
{
  return m_encryptionCapability.GetObjectLength() +
         m_authenticationCapability.GetObjectLength() +
         m_integrityCapability.GetObjectLength();
}


BOOL H245_EncryptionAuthenticationAndIntegrity::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_encryptionCapability ) && !m_encryptionCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_authenticationCapability ) && !m_authenticationCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_integrityCapability ) && !m_integrityCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_EncryptionAuthenticationAndIntegrity::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_encryptionCapability))
    m_encryptionCapability.Encode(strm);
  if (HasOptionalField(e_authenticationCapability))
    m_authenticationCapability.Encode(strm);
  if (HasOptionalField(e_integrityCapability))
    m_integrityCapability.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_encryptionCapability))
    m_encryptionCapability.Encode(strm);
  if (HasOptionalField(e_authenticationCapability))
    m_authenticationCapability.Encode(strm);
  if (HasOptionalField(e_integrityCapability))
    m_integrityCapability.Encode(strm);
}


PObject * H245_EncryptionAuthenticationAndIntegrity::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EncryptionAuthenticationAndIntegrity::Class()), PInvalidCast);
#endif
  return new H245_EncryptionAuthenticationAndIntegrity(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_EncryptionAuthenticationAndIntegrity::preShowEthereal( void )
{
  if ( HasOptionalField( e_encryptionCapability ) ) 
      m_encryptionCapability.preShowEthereal( );
  if ( HasOptionalField( e_authenticationCapability ) ) 
      m_authenticationCapability.preShowEthereal( );
  if ( HasOptionalField( e_integrityCapability ) ) 
      m_integrityCapability.preShowEthereal( );
}

PString H245_EncryptionAuthenticationAndIntegrity::getSummary( void ) 
{
  return PString( "EncryptionAuthenticationAndIntegrity" );
}

void H245_EncryptionAuthenticationAndIntegrity::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_encryptionCapability ) ) {
    proto_tree *encryptionCapability_tree = (proto_tree*) NULL;
    proto_item *encryptionCapability_ti = (proto_item*) NULL;
    encryptionCapability_ti = proto_tree_add_text( tree, tvb, offset + m_encryptionCapability.GetStartByte(), m_encryptionCapability.GetByteLength(), "encryptionCapability (EncryptionCapability)" );
    encryptionCapability_tree = proto_item_add_subtree( encryptionCapability_ti, hCont->h245_2.ett_h245_EncryptionAuthenticationAndIntegrity_encryptionCapability );
    m_encryptionCapability.showEthereal( encryptionCapability_tree, tvb, offset );
  }

  if ( HasOptionalField( e_authenticationCapability ) ) {
    proto_tree *authenticationCapability_tree = (proto_tree*) NULL;
    proto_item *authenticationCapability_ti = (proto_item*) NULL;
    authenticationCapability_ti = proto_tree_add_text( tree, tvb, offset + m_authenticationCapability.GetStartByte(), m_authenticationCapability.GetByteLength(), "authenticationCapability (AuthenticationCapability)" );
    authenticationCapability_tree = proto_item_add_subtree( authenticationCapability_ti, hCont->h245_2.ett_h245_EncryptionAuthenticationAndIntegrity_authenticationCapability );
    m_authenticationCapability.showEthereal( authenticationCapability_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCapability ) ) {
    proto_tree *integrityCapability_tree = (proto_tree*) NULL;
    proto_item *integrityCapability_ti = (proto_item*) NULL;
    integrityCapability_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCapability.GetStartByte(), m_integrityCapability.GetByteLength(), "integrityCapability (IntegrityCapability)" );
    integrityCapability_tree = proto_item_add_subtree( integrityCapability_ti, hCont->h245_2.ett_h245_EncryptionAuthenticationAndIntegrity_integrityCapability );
    m_integrityCapability.showEthereal( integrityCapability_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// OpenLogicalChannel
//

H245_OpenLogicalChannel::H245_OpenLogicalChannel(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 2)
{
}


#ifndef PASN_NOPRINTON
void H245_OpenLogicalChannel::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+30) << "forwardLogicalChannelNumber = " << setprecision(indent) << m_forwardLogicalChannelNumber << '\n';
  strm << setw(indent+34) << "forwardLogicalChannelParameters = " << setprecision(indent) << m_forwardLogicalChannelParameters << '\n';
  if (HasOptionalField(e_reverseLogicalChannelParameters))
    strm << setw(indent+34) << "reverseLogicalChannelParameters = " << setprecision(indent) << m_reverseLogicalChannelParameters << '\n';
  if (HasOptionalField(e_separateStack))
    strm << setw(indent+16) << "separateStack = " << setprecision(indent) << m_separateStack << '\n';
  if (HasOptionalField(e_encryptionSync))
    strm << setw(indent+17) << "encryptionSync = " << setprecision(indent) << m_encryptionSync << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_OpenLogicalChannel::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_OpenLogicalChannel::Class()), PInvalidCast);
#endif
  const H245_OpenLogicalChannel & other = (const H245_OpenLogicalChannel &)obj;

  Comparison result;

  if ((result = m_forwardLogicalChannelNumber.Compare(other.m_forwardLogicalChannelNumber)) != EqualTo)
    return result;
  if ((result = m_forwardLogicalChannelParameters.Compare(other.m_forwardLogicalChannelParameters)) != EqualTo)
    return result;
  if ((result = m_reverseLogicalChannelParameters.Compare(other.m_reverseLogicalChannelParameters)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_OpenLogicalChannel::GetDataLength() const
{
  return m_forwardLogicalChannelNumber.GetObjectLength() +
         m_forwardLogicalChannelParameters.GetObjectLength() +
         m_reverseLogicalChannelParameters.GetObjectLength();
}


BOOL H245_OpenLogicalChannel::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_forwardLogicalChannelNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_forwardLogicalChannelParameters.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_reverseLogicalChannelParameters ) && !m_reverseLogicalChannelParameters.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_separateStack, m_separateStack ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_encryptionSync, m_encryptionSync ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_OpenLogicalChannel::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardLogicalChannelNumber.Encode(strm);
  m_forwardLogicalChannelParameters.Encode(strm);
  if (HasOptionalField(e_reverseLogicalChannelParameters))
    m_reverseLogicalChannelParameters.Encode(strm);
  KnownExtensionEncode(strm, e_separateStack, m_separateStack);
  KnownExtensionEncode(strm, e_encryptionSync, m_encryptionSync);

  UnknownExtensionsEncode(strm);
  m_forwardLogicalChannelNumber.Encode(strm);
  m_forwardLogicalChannelParameters.Encode(strm);
  if (HasOptionalField(e_reverseLogicalChannelParameters))
    m_reverseLogicalChannelParameters.Encode(strm);
}


PObject * H245_OpenLogicalChannel::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannel::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannel(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_OpenLogicalChannel::preShowEthereal( void )
{
  m_forwardLogicalChannelNumber.preShowEthereal( );
  m_forwardLogicalChannelParameters.preShowEthereal( );
  if ( HasOptionalField( e_reverseLogicalChannelParameters ) ) 
      m_reverseLogicalChannelParameters.preShowEthereal( );
  if ( HasOptionalField( e_separateStack ) ) 
      m_separateStack.preShowEthereal( );
  if ( HasOptionalField( e_encryptionSync ) ) 
      m_encryptionSync.preShowEthereal( );
}

PString H245_OpenLogicalChannel::getSummary( void ) 
{
  return PString( "OpenLogicalChannel" );
}

void H245_OpenLogicalChannel::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_OpenLogicalChannel_forwardLogicalChannelNumber, tvb, offset + m_forwardLogicalChannelNumber.GetStartByte(), m_forwardLogicalChannelNumber.GetByteLength() , m_forwardLogicalChannelNumber.GetValue() );

  proto_tree *forwardLogicalChannelParameters_tree = (proto_tree*) NULL;
  proto_item *forwardLogicalChannelParameters_ti = (proto_item*) NULL;
  forwardLogicalChannelParameters_ti = proto_tree_add_text( tree, tvb, offset + m_forwardLogicalChannelParameters.GetStartByte(), m_forwardLogicalChannelParameters.GetByteLength(), "forwardLogicalChannelParameters (OpenLogicalChannel-forwardLogicalChannelParameters)" );
  forwardLogicalChannelParameters_tree = proto_item_add_subtree( forwardLogicalChannelParameters_ti, hCont->h245_2.ett_h245_OpenLogicalChannel_forwardLogicalChannelParameters );

  m_forwardLogicalChannelParameters.showEthereal( forwardLogicalChannelParameters_tree, tvb, offset );

  if ( HasOptionalField( e_reverseLogicalChannelParameters ) ) {
    proto_tree *reverseLogicalChannelParameters_tree = (proto_tree*) NULL;
    proto_item *reverseLogicalChannelParameters_ti = (proto_item*) NULL;
    reverseLogicalChannelParameters_ti = proto_tree_add_text( tree, tvb, offset + m_reverseLogicalChannelParameters.GetStartByte(), m_reverseLogicalChannelParameters.GetByteLength(), "reverseLogicalChannelParameters (OpenLogicalChannel-reverseLogicalChannelParameters)" );
    reverseLogicalChannelParameters_tree = proto_item_add_subtree( reverseLogicalChannelParameters_ti, hCont->h245_2.ett_h245_OpenLogicalChannel_reverseLogicalChannelParameters );
    m_reverseLogicalChannelParameters.showEthereal( reverseLogicalChannelParameters_tree, tvb, offset );
  }

  if ( HasOptionalField( e_separateStack ) ) {
    proto_tree *separateStack_tree = (proto_tree*) NULL;
    proto_item *separateStack_ti = (proto_item*) NULL;
    separateStack_ti = proto_tree_add_text( tree, tvb, offset + m_separateStack.GetStartByte(), m_separateStack.GetByteLength(), "separateStack (NetworkAccessParameters)" );
    separateStack_tree = proto_item_add_subtree( separateStack_ti, hCont->h245_2.ett_h245_OpenLogicalChannel_separateStack );
    m_separateStack.showEthereal( separateStack_tree, tvb, offset );
  }

  if ( HasOptionalField( e_encryptionSync ) ) {
    proto_tree *encryptionSync_tree = (proto_tree*) NULL;
    proto_item *encryptionSync_ti = (proto_item*) NULL;
    encryptionSync_ti = proto_tree_add_text( tree, tvb, offset + m_encryptionSync.GetStartByte(), m_encryptionSync.GetByteLength(), "encryptionSync (EncryptionSync)" );
    encryptionSync_tree = proto_item_add_subtree( encryptionSync_ti, hCont->h245_2.ett_h245_OpenLogicalChannel_encryptionSync );
    m_encryptionSync.showEthereal( encryptionSync_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// H235Media
//

H245_H235Media::H245_H235Media(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_H235Media::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+39) << "encryptionAuthenticationAndIntegrity = " << setprecision(indent) << m_encryptionAuthenticationAndIntegrity << '\n';
  strm << setw(indent+12) << "mediaType = " << setprecision(indent) << m_mediaType << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H235Media::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H235Media::Class()), PInvalidCast);
#endif
  const H245_H235Media & other = (const H245_H235Media &)obj;

  Comparison result;

  if ((result = m_encryptionAuthenticationAndIntegrity.Compare(other.m_encryptionAuthenticationAndIntegrity)) != EqualTo)
    return result;
  if ((result = m_mediaType.Compare(other.m_mediaType)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H235Media::GetDataLength() const
{
  return m_encryptionAuthenticationAndIntegrity.GetObjectLength() +
         m_mediaType.GetObjectLength();
}


BOOL H245_H235Media::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_encryptionAuthenticationAndIntegrity.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_mediaType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H235Media::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_encryptionAuthenticationAndIntegrity.Encode(strm);
  m_mediaType.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_encryptionAuthenticationAndIntegrity.Encode(strm);
  m_mediaType.Encode(strm);
}


PObject * H245_H235Media::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H235Media::Class()), PInvalidCast);
#endif
  return new H245_H235Media(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H235Media::preShowEthereal( void )
{
  m_encryptionAuthenticationAndIntegrity.preShowEthereal( );
  m_mediaType.preShowEthereal( );
}

PString H245_H235Media::getSummary( void ) 
{
  return PString( "H235Media" );
}

void H245_H235Media::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *encryptionAuthenticationAndIntegrity_tree = (proto_tree*) NULL;
  proto_item *encryptionAuthenticationAndIntegrity_ti = (proto_item*) NULL;
  encryptionAuthenticationAndIntegrity_ti = proto_tree_add_text( tree, tvb, offset + m_encryptionAuthenticationAndIntegrity.GetStartByte(), m_encryptionAuthenticationAndIntegrity.GetByteLength(), "encryptionAuthenticationAndIntegrity (EncryptionAuthenticationAndIntegrity)" );
  encryptionAuthenticationAndIntegrity_tree = proto_item_add_subtree( encryptionAuthenticationAndIntegrity_ti, hCont->h245_2.ett_h245_H235Media_encryptionAuthenticationAndIntegrity );

  m_encryptionAuthenticationAndIntegrity.showEthereal( encryptionAuthenticationAndIntegrity_tree, tvb, offset );

  proto_tree *mediaType_tree = (proto_tree*) NULL;
  proto_item *mediaType_ti = (proto_item*) NULL;
  mediaType_ti = proto_tree_add_text( tree, tvb, offset + m_mediaType.GetStartByte(), m_mediaType.GetByteLength(), "mediaType (%s)", ( const char* ) m_mediaType.GetTagName() );
  mediaType_tree = proto_item_add_subtree( mediaType_ti, hCont->h245_2.ett_h245_H235Media_mediaType );

  m_mediaType.showEthereal( mediaType_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// V76LogicalChannelParameters
//

H245_V76LogicalChannelParameters::H245_V76LogicalChannelParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_V76LogicalChannelParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "hdlcParameters = " << setprecision(indent) << m_hdlcParameters << '\n';
  strm << setw(indent+16) << "suspendResume = " << setprecision(indent) << m_suspendResume << '\n';
  strm << setw(indent+6) << "uIH = " << setprecision(indent) << m_uIH << '\n';
  strm << setw(indent+7) << "mode = " << setprecision(indent) << m_mode << '\n';
  strm << setw(indent+16) << "v75Parameters = " << setprecision(indent) << m_v75Parameters << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_V76LogicalChannelParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_V76LogicalChannelParameters::Class()), PInvalidCast);
#endif
  const H245_V76LogicalChannelParameters & other = (const H245_V76LogicalChannelParameters &)obj;

  Comparison result;

  if ((result = m_hdlcParameters.Compare(other.m_hdlcParameters)) != EqualTo)
    return result;
  if ((result = m_suspendResume.Compare(other.m_suspendResume)) != EqualTo)
    return result;
  if ((result = m_uIH.Compare(other.m_uIH)) != EqualTo)
    return result;
  if ((result = m_mode.Compare(other.m_mode)) != EqualTo)
    return result;
  if ((result = m_v75Parameters.Compare(other.m_v75Parameters)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_V76LogicalChannelParameters::GetDataLength() const
{
  return m_hdlcParameters.GetObjectLength() +
         m_suspendResume.GetObjectLength() +
         m_uIH.GetObjectLength() +
         m_mode.GetObjectLength() +
         m_v75Parameters.GetObjectLength();
}


BOOL H245_V76LogicalChannelParameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_hdlcParameters.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_suspendResume.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_uIH.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_mode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_v75Parameters.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_V76LogicalChannelParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_hdlcParameters.Encode(strm);
  m_suspendResume.Encode(strm);
  m_uIH.Encode(strm);
  m_mode.Encode(strm);
  m_v75Parameters.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_hdlcParameters.Encode(strm);
  m_suspendResume.Encode(strm);
  m_uIH.Encode(strm);
  m_mode.Encode(strm);
  m_v75Parameters.Encode(strm);
}


PObject * H245_V76LogicalChannelParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_V76LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return new H245_V76LogicalChannelParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_V76LogicalChannelParameters::preShowEthereal( void )
{
  m_hdlcParameters.preShowEthereal( );
  m_suspendResume.preShowEthereal( );
  m_uIH.preShowEthereal( );
  m_mode.preShowEthereal( );
  m_v75Parameters.preShowEthereal( );
}

PString H245_V76LogicalChannelParameters::getSummary( void ) 
{
  return PString( "V76LogicalChannelParameters" );
}

void H245_V76LogicalChannelParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *hdlcParameters_tree = (proto_tree*) NULL;
  proto_item *hdlcParameters_ti = (proto_item*) NULL;
  hdlcParameters_ti = proto_tree_add_text( tree, tvb, offset + m_hdlcParameters.GetStartByte(), m_hdlcParameters.GetByteLength(), "hdlcParameters (V76HDLCParameters)" );
  hdlcParameters_tree = proto_item_add_subtree( hdlcParameters_ti, hCont->h245_2.ett_h245_V76LogicalChannelParameters_hdlcParameters );

  m_hdlcParameters.showEthereal( hdlcParameters_tree, tvb, offset );

  proto_tree *suspendResume_tree = (proto_tree*) NULL;
  proto_item *suspendResume_ti = (proto_item*) NULL;
  suspendResume_ti = proto_tree_add_text( tree, tvb, offset + m_suspendResume.GetStartByte(), m_suspendResume.GetByteLength(), "suspendResume (%s)", ( const char* ) m_suspendResume.GetTagName() );
  suspendResume_tree = proto_item_add_subtree( suspendResume_ti, hCont->h245_2.ett_h245_V76LogicalChannelParameters_suspendResume );

  m_suspendResume.showEthereal( suspendResume_tree, tvb, offset );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_V76LogicalChannelParameters_uIH, tvb, offset + m_uIH.GetStartByte(), m_uIH.GetByteLength() , m_uIH.GetValue() );

  proto_tree *mode_tree = (proto_tree*) NULL;
  proto_item *mode_ti = (proto_item*) NULL;
  mode_ti = proto_tree_add_text( tree, tvb, offset + m_mode.GetStartByte(), m_mode.GetByteLength(), "mode (%s)", ( const char* ) m_mode.GetTagName() );
  mode_tree = proto_item_add_subtree( mode_ti, hCont->h245_2.ett_h245_V76LogicalChannelParameters_mode );

  m_mode.showEthereal( mode_tree, tvb, offset );

  proto_tree *v75Parameters_tree = (proto_tree*) NULL;
  proto_item *v75Parameters_ti = (proto_item*) NULL;
  v75Parameters_ti = proto_tree_add_text( tree, tvb, offset + m_v75Parameters.GetStartByte(), m_v75Parameters.GetByteLength(), "v75Parameters (V75Parameters)" );
  v75Parameters_tree = proto_item_add_subtree( v75Parameters_ti, hCont->h245_2.ett_h245_V76LogicalChannelParameters_v75Parameters );

  m_v75Parameters.showEthereal( v75Parameters_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// H2250LogicalChannelParameters
//

H245_H2250LogicalChannelParameters::H245_H2250LogicalChannelParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 10, TRUE, 3)
{
  m_sessionID.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
  m_associatedSessionID.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
  m_dynamicRTPPayloadType.SetConstraints(PASN_Object::FixedConstraint, 96, 127);
}


#ifndef PASN_NOPRINTON
void H245_H2250LogicalChannelParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandard))
    strm << setw(indent+14) << "nonStandard = " << setprecision(indent) << m_nonStandard << '\n';
  strm << setw(indent+12) << "sessionID = " << setprecision(indent) << m_sessionID << '\n';
  if (HasOptionalField(e_associatedSessionID))
    strm << setw(indent+22) << "associatedSessionID = " << setprecision(indent) << m_associatedSessionID << '\n';
  if (HasOptionalField(e_mediaChannel))
    strm << setw(indent+15) << "mediaChannel = " << setprecision(indent) << m_mediaChannel << '\n';
  if (HasOptionalField(e_mediaGuaranteedDelivery))
    strm << setw(indent+26) << "mediaGuaranteedDelivery = " << setprecision(indent) << m_mediaGuaranteedDelivery << '\n';
  if (HasOptionalField(e_mediaControlChannel))
    strm << setw(indent+22) << "mediaControlChannel = " << setprecision(indent) << m_mediaControlChannel << '\n';
  if (HasOptionalField(e_mediaControlGuaranteedDelivery))
    strm << setw(indent+33) << "mediaControlGuaranteedDelivery = " << setprecision(indent) << m_mediaControlGuaranteedDelivery << '\n';
  if (HasOptionalField(e_silenceSuppression))
    strm << setw(indent+21) << "silenceSuppression = " << setprecision(indent) << m_silenceSuppression << '\n';
  if (HasOptionalField(e_destination))
    strm << setw(indent+14) << "destination = " << setprecision(indent) << m_destination << '\n';
  if (HasOptionalField(e_dynamicRTPPayloadType))
    strm << setw(indent+24) << "dynamicRTPPayloadType = " << setprecision(indent) << m_dynamicRTPPayloadType << '\n';
  if (HasOptionalField(e_mediaPacketization))
    strm << setw(indent+21) << "mediaPacketization = " << setprecision(indent) << m_mediaPacketization << '\n';
  if (HasOptionalField(e_transportCapability))
    strm << setw(indent+22) << "transportCapability = " << setprecision(indent) << m_transportCapability << '\n';
  if (HasOptionalField(e_redundancyEncoding))
    strm << setw(indent+21) << "redundancyEncoding = " << setprecision(indent) << m_redundancyEncoding << '\n';
  if (HasOptionalField(e_source))
    strm << setw(indent+9) << "source = " << setprecision(indent) << m_source << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H2250LogicalChannelParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H2250LogicalChannelParameters::Class()), PInvalidCast);
#endif
  const H245_H2250LogicalChannelParameters & other = (const H245_H2250LogicalChannelParameters &)obj;

  Comparison result;

  if ((result = m_nonStandard.Compare(other.m_nonStandard)) != EqualTo)
    return result;
  if ((result = m_sessionID.Compare(other.m_sessionID)) != EqualTo)
    return result;
  if ((result = m_associatedSessionID.Compare(other.m_associatedSessionID)) != EqualTo)
    return result;
  if ((result = m_mediaChannel.Compare(other.m_mediaChannel)) != EqualTo)
    return result;
  if ((result = m_mediaGuaranteedDelivery.Compare(other.m_mediaGuaranteedDelivery)) != EqualTo)
    return result;
  if ((result = m_mediaControlChannel.Compare(other.m_mediaControlChannel)) != EqualTo)
    return result;
  if ((result = m_mediaControlGuaranteedDelivery.Compare(other.m_mediaControlGuaranteedDelivery)) != EqualTo)
    return result;
  if ((result = m_silenceSuppression.Compare(other.m_silenceSuppression)) != EqualTo)
    return result;
  if ((result = m_destination.Compare(other.m_destination)) != EqualTo)
    return result;
  if ((result = m_dynamicRTPPayloadType.Compare(other.m_dynamicRTPPayloadType)) != EqualTo)
    return result;
  if ((result = m_mediaPacketization.Compare(other.m_mediaPacketization)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H2250LogicalChannelParameters::GetDataLength() const
{
  return m_nonStandard.GetObjectLength() +
         m_sessionID.GetObjectLength() +
         m_associatedSessionID.GetObjectLength() +
         m_mediaChannel.GetObjectLength() +
         m_mediaGuaranteedDelivery.GetObjectLength() +
         m_mediaControlChannel.GetObjectLength() +
         m_mediaControlGuaranteedDelivery.GetObjectLength() +
         m_silenceSuppression.GetObjectLength() +
         m_destination.GetObjectLength() +
         m_dynamicRTPPayloadType.GetObjectLength() +
         m_mediaPacketization.GetObjectLength();
}


BOOL H245_H2250LogicalChannelParameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandard ) && !m_nonStandard.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sessionID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_associatedSessionID ) && !m_associatedSessionID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_mediaChannel ) && !m_mediaChannel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_mediaGuaranteedDelivery ) && !m_mediaGuaranteedDelivery.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_mediaControlChannel ) && !m_mediaControlChannel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_mediaControlGuaranteedDelivery ) && !m_mediaControlGuaranteedDelivery.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_silenceSuppression ) && !m_silenceSuppression.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_destination ) && !m_destination.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_dynamicRTPPayloadType ) && !m_dynamicRTPPayloadType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_mediaPacketization ) && !m_mediaPacketization.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_transportCapability, m_transportCapability ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_redundancyEncoding, m_redundancyEncoding ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_source, m_source ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H2250LogicalChannelParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
  m_sessionID.Encode(strm);
  if (HasOptionalField(e_associatedSessionID))
    m_associatedSessionID.Encode(strm);
  if (HasOptionalField(e_mediaChannel))
    m_mediaChannel.Encode(strm);
  if (HasOptionalField(e_mediaGuaranteedDelivery))
    m_mediaGuaranteedDelivery.Encode(strm);
  if (HasOptionalField(e_mediaControlChannel))
    m_mediaControlChannel.Encode(strm);
  if (HasOptionalField(e_mediaControlGuaranteedDelivery))
    m_mediaControlGuaranteedDelivery.Encode(strm);
  if (HasOptionalField(e_silenceSuppression))
    m_silenceSuppression.Encode(strm);
  if (HasOptionalField(e_destination))
    m_destination.Encode(strm);
  if (HasOptionalField(e_dynamicRTPPayloadType))
    m_dynamicRTPPayloadType.Encode(strm);
  if (HasOptionalField(e_mediaPacketization))
    m_mediaPacketization.Encode(strm);
  KnownExtensionEncode(strm, e_transportCapability, m_transportCapability);
  KnownExtensionEncode(strm, e_redundancyEncoding, m_redundancyEncoding);
  KnownExtensionEncode(strm, e_source, m_source);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
  m_sessionID.Encode(strm);
  if (HasOptionalField(e_associatedSessionID))
    m_associatedSessionID.Encode(strm);
  if (HasOptionalField(e_mediaChannel))
    m_mediaChannel.Encode(strm);
  if (HasOptionalField(e_mediaGuaranteedDelivery))
    m_mediaGuaranteedDelivery.Encode(strm);
  if (HasOptionalField(e_mediaControlChannel))
    m_mediaControlChannel.Encode(strm);
  if (HasOptionalField(e_mediaControlGuaranteedDelivery))
    m_mediaControlGuaranteedDelivery.Encode(strm);
  if (HasOptionalField(e_silenceSuppression))
    m_silenceSuppression.Encode(strm);
  if (HasOptionalField(e_destination))
    m_destination.Encode(strm);
  if (HasOptionalField(e_dynamicRTPPayloadType))
    m_dynamicRTPPayloadType.Encode(strm);
  if (HasOptionalField(e_mediaPacketization))
    m_mediaPacketization.Encode(strm);
}


PObject * H245_H2250LogicalChannelParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H2250LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return new H245_H2250LogicalChannelParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H2250LogicalChannelParameters::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandard ) ) 
      m_nonStandard.preShowEthereal( );
  m_sessionID.preShowEthereal( );
  if ( HasOptionalField( e_associatedSessionID ) ) 
      m_associatedSessionID.preShowEthereal( );

  if ( HasOptionalField( e_mediaChannel ) ) {
     m_mediaChannel.preShowEthereal( );
	  if ( m_mediaChannel.GetTagName() == "unicastAddress" ) {
			H245_UnicastAddress tmp_unicast = (H245_UnicastAddress) m_mediaChannel;
			if ( tmp_unicast.GetTagName() == "iPAddress" ) {
				H245_UnicastAddress_iPAddress tmpAddr = (H245_UnicastAddress_iPAddress) tmp_unicast;
				//rtp_add_address( (unsigned char*) tmpAddr.m_network.GetPointer(), tmpAddr.m_tsapIdentifier );
        address src_addr;
        conversation_t* pconv = ( conversation_t* ) NULL;
        
        src_addr.type = AT_IPv4;
        src_addr.len = 4;
        src_addr.data = (unsigned char*) tmpAddr.m_network.GetPointer();
        
        pconv = conversation_new( &src_addr, &src_addr, PT_UDP, tmpAddr.m_tsapIdentifier, 0, NO_ADDR2 + NO_PORT2 );
        
        conversation_set_dissector( pconv, find_dissector( "rtp" ) );
			}
		}
	}

  if ( HasOptionalField( e_mediaGuaranteedDelivery ) ) 
      m_mediaGuaranteedDelivery.preShowEthereal( );

  if ( HasOptionalField( e_mediaControlChannel ) ) {
     m_mediaControlChannel.preShowEthereal( );
	  if ( m_mediaControlChannel.GetTagName() == "unicastAddress" ) {
			H245_UnicastAddress tmp_unicast = (H245_UnicastAddress) m_mediaControlChannel;
			if ( tmp_unicast.GetTagName() == "iPAddress" ) {
				H245_UnicastAddress_iPAddress tmpAddr = (H245_UnicastAddress_iPAddress) tmp_unicast;
				//rtcp_add_address( (unsigned char*) tmpAddr.m_network.GetPointer(), tmpAddr.m_tsapIdentifier );
        address src_addr;
        conversation_t* pconv = ( conversation_t* ) NULL;
        
        src_addr.type = AT_IPv4;
        src_addr.len = 4;
        src_addr.data = (unsigned char*) tmpAddr.m_network.GetPointer();
        
        pconv = conversation_new( &src_addr, &src_addr, PT_UDP, tmpAddr.m_tsapIdentifier, 0, NO_ADDR2 + NO_PORT2 );
        
        conversation_set_dissector( pconv, find_dissector( "rtcp" ) );
			}
		}
	}
  if ( HasOptionalField( e_mediaControlGuaranteedDelivery ) ) 
      m_mediaControlGuaranteedDelivery.preShowEthereal( );
  if ( HasOptionalField( e_silenceSuppression ) ) 
      m_silenceSuppression.preShowEthereal( );
  if ( HasOptionalField( e_destination ) ) 
      m_destination.preShowEthereal( );
  if ( HasOptionalField( e_dynamicRTPPayloadType ) ) 
      m_dynamicRTPPayloadType.preShowEthereal( );
  if ( HasOptionalField( e_mediaPacketization ) ) 
      m_mediaPacketization.preShowEthereal( );
  if ( HasOptionalField( e_transportCapability ) ) 
      m_transportCapability.preShowEthereal( );
  if ( HasOptionalField( e_redundancyEncoding ) ) 
      m_redundancyEncoding.preShowEthereal( );
  if ( HasOptionalField( e_source ) ) 
      m_source.preShowEthereal( );
}

PString H245_H2250LogicalChannelParameters::getSummary( void ) 
{
  return PString( "H2250LogicalChannelParameters" );
}

void H245_H2250LogicalChannelParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandard ) ) {
    proto_tree *nonStandard_tree = (proto_tree*) NULL;
    proto_item *nonStandard_ti = (proto_item*) NULL;
    nonStandard_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandard.GetStartByte(), m_nonStandard.GetByteLength(), "nonStandard (NonStandardParameter)" );
    nonStandard_tree = proto_item_add_subtree( nonStandard_ti, hCont->h245_2.ett_h245_H2250LogicalChannelParameters_nonStandard );
    m_nonStandard.showEthereal( nonStandard_tree, tvb, offset );
  }

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_H2250LogicalChannelParameters_sessionID, tvb, offset + m_sessionID.GetStartByte(), m_sessionID.GetByteLength() , m_sessionID.GetValue() );

  if ( HasOptionalField( e_associatedSessionID ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_H2250LogicalChannelParameters_associatedSessionID, tvb, offset + m_associatedSessionID.GetStartByte(), m_associatedSessionID.GetByteLength() , m_associatedSessionID.GetValue() );
  }

  if ( HasOptionalField( e_mediaChannel ) ) {
    proto_tree *mediaChannel_tree = (proto_tree*) NULL;
    proto_item *mediaChannel_ti = (proto_item*) NULL;
    mediaChannel_ti = proto_tree_add_text( tree, tvb, offset + m_mediaChannel.GetStartByte(), m_mediaChannel.GetByteLength(), "mediaChannel (%s)", ( const char* ) m_mediaChannel.GetTagName() );
    mediaChannel_tree = proto_item_add_subtree( mediaChannel_ti, hCont->h245_2.ett_h245_H2250LogicalChannelParameters_mediaChannel );
    m_mediaChannel.showEthereal( mediaChannel_tree, tvb, offset );
  }

  if ( HasOptionalField( e_mediaGuaranteedDelivery ) ) {
    proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H2250LogicalChannelParameters_mediaGuaranteedDelivery, tvb, offset + m_mediaGuaranteedDelivery.GetStartByte(), m_mediaGuaranteedDelivery.GetByteLength() , m_mediaGuaranteedDelivery.GetValue() );
  }

  if ( HasOptionalField( e_mediaControlChannel ) ) {
    proto_tree *mediaControlChannel_tree = (proto_tree*) NULL;
    proto_item *mediaControlChannel_ti = (proto_item*) NULL;
    mediaControlChannel_ti = proto_tree_add_text( tree, tvb, offset + m_mediaControlChannel.GetStartByte(), m_mediaControlChannel.GetByteLength(), "mediaControlChannel (%s)", ( const char* ) m_mediaControlChannel.GetTagName() );
    mediaControlChannel_tree = proto_item_add_subtree( mediaControlChannel_ti, hCont->h245_2.ett_h245_H2250LogicalChannelParameters_mediaControlChannel );
    m_mediaControlChannel.showEthereal( mediaControlChannel_tree, tvb, offset );
  }

  if ( HasOptionalField( e_mediaControlGuaranteedDelivery ) ) {
    proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H2250LogicalChannelParameters_mediaControlGuaranteedDelivery, tvb, offset + m_mediaControlGuaranteedDelivery.GetStartByte(), m_mediaControlGuaranteedDelivery.GetByteLength() , m_mediaControlGuaranteedDelivery.GetValue() );
  }

  if ( HasOptionalField( e_silenceSuppression ) ) {
    proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H2250LogicalChannelParameters_silenceSuppression, tvb, offset + m_silenceSuppression.GetStartByte(), m_silenceSuppression.GetByteLength() , m_silenceSuppression.GetValue() );
  }

  if ( HasOptionalField( e_destination ) ) {
    proto_tree *destination_tree = (proto_tree*) NULL;
    proto_item *destination_ti = (proto_item*) NULL;
    destination_ti = proto_tree_add_text( tree, tvb, offset + m_destination.GetStartByte(), m_destination.GetByteLength(), "destination (TerminalLabel)" );
    destination_tree = proto_item_add_subtree( destination_ti, hCont->h245_2.ett_h245_H2250LogicalChannelParameters_destination );
    m_destination.showEthereal( destination_tree, tvb, offset );
  }

  if ( HasOptionalField( e_dynamicRTPPayloadType ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_H2250LogicalChannelParameters_dynamicRTPPayloadType, tvb, offset + m_dynamicRTPPayloadType.GetStartByte(), m_dynamicRTPPayloadType.GetByteLength() , m_dynamicRTPPayloadType.GetValue() );
  }

  if ( HasOptionalField( e_mediaPacketization ) ) {
    proto_tree *mediaPacketization_tree = (proto_tree*) NULL;
    proto_item *mediaPacketization_ti = (proto_item*) NULL;
    mediaPacketization_ti = proto_tree_add_text( tree, tvb, offset + m_mediaPacketization.GetStartByte(), m_mediaPacketization.GetByteLength(), "mediaPacketization (%s)", ( const char* ) m_mediaPacketization.GetTagName() );
    mediaPacketization_tree = proto_item_add_subtree( mediaPacketization_ti, hCont->h245_2.ett_h245_H2250LogicalChannelParameters_mediaPacketization );
    m_mediaPacketization.showEthereal( mediaPacketization_tree, tvb, offset );
  }

  if ( HasOptionalField( e_transportCapability ) ) {
    proto_tree *transportCapability_tree = (proto_tree*) NULL;
    proto_item *transportCapability_ti = (proto_item*) NULL;
    transportCapability_ti = proto_tree_add_text( tree, tvb, offset + m_transportCapability.GetStartByte(), m_transportCapability.GetByteLength(), "transportCapability (TransportCapability)" );
    transportCapability_tree = proto_item_add_subtree( transportCapability_ti, hCont->h245_2.ett_h245_H2250LogicalChannelParameters_transportCapability );
    m_transportCapability.showEthereal( transportCapability_tree, tvb, offset );
  }

  if ( HasOptionalField( e_redundancyEncoding ) ) {
    proto_tree *redundancyEncoding_tree = (proto_tree*) NULL;
    proto_item *redundancyEncoding_ti = (proto_item*) NULL;
    redundancyEncoding_ti = proto_tree_add_text( tree, tvb, offset + m_redundancyEncoding.GetStartByte(), m_redundancyEncoding.GetByteLength(), "redundancyEncoding (RedundancyEncoding)" );
    redundancyEncoding_tree = proto_item_add_subtree( redundancyEncoding_ti, hCont->h245_2.ett_h245_H2250LogicalChannelParameters_redundancyEncoding );
    m_redundancyEncoding.showEthereal( redundancyEncoding_tree, tvb, offset );
  }

  if ( HasOptionalField( e_source ) ) {
    proto_tree *source_tree = (proto_tree*) NULL;
    proto_item *source_ti = (proto_item*) NULL;
    source_ti = proto_tree_add_text( tree, tvb, offset + m_source.GetStartByte(), m_source.GetByteLength(), "source (TerminalLabel)" );
    source_tree = proto_item_add_subtree( source_ti, hCont->h245_2.ett_h245_H2250LogicalChannelParameters_source );
    m_source.showEthereal( source_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// OpenLogicalChannelAck
//

H245_OpenLogicalChannelAck::H245_OpenLogicalChannelAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 3)
{
}


#ifndef PASN_NOPRINTON
void H245_OpenLogicalChannelAck::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+30) << "forwardLogicalChannelNumber = " << setprecision(indent) << m_forwardLogicalChannelNumber << '\n';
  if (HasOptionalField(e_reverseLogicalChannelParameters))
    strm << setw(indent+34) << "reverseLogicalChannelParameters = " << setprecision(indent) << m_reverseLogicalChannelParameters << '\n';
  if (HasOptionalField(e_separateStack))
    strm << setw(indent+16) << "separateStack = " << setprecision(indent) << m_separateStack << '\n';
  if (HasOptionalField(e_forwardMultiplexAckParameters))
    strm << setw(indent+32) << "forwardMultiplexAckParameters = " << setprecision(indent) << m_forwardMultiplexAckParameters << '\n';
  if (HasOptionalField(e_encryptionSync))
    strm << setw(indent+17) << "encryptionSync = " << setprecision(indent) << m_encryptionSync << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_OpenLogicalChannelAck::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_OpenLogicalChannelAck::Class()), PInvalidCast);
#endif
  const H245_OpenLogicalChannelAck & other = (const H245_OpenLogicalChannelAck &)obj;

  Comparison result;

  if ((result = m_forwardLogicalChannelNumber.Compare(other.m_forwardLogicalChannelNumber)) != EqualTo)
    return result;
  if ((result = m_reverseLogicalChannelParameters.Compare(other.m_reverseLogicalChannelParameters)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_OpenLogicalChannelAck::GetDataLength() const
{
  return m_forwardLogicalChannelNumber.GetObjectLength() +
         m_reverseLogicalChannelParameters.GetObjectLength();
}


BOOL H245_OpenLogicalChannelAck::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_forwardLogicalChannelNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_reverseLogicalChannelParameters ) && !m_reverseLogicalChannelParameters.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_separateStack, m_separateStack ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_forwardMultiplexAckParameters, m_forwardMultiplexAckParameters ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_encryptionSync, m_encryptionSync ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_OpenLogicalChannelAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardLogicalChannelNumber.Encode(strm);
  if (HasOptionalField(e_reverseLogicalChannelParameters))
    m_reverseLogicalChannelParameters.Encode(strm);
  KnownExtensionEncode(strm, e_separateStack, m_separateStack);
  KnownExtensionEncode(strm, e_forwardMultiplexAckParameters, m_forwardMultiplexAckParameters);
  KnownExtensionEncode(strm, e_encryptionSync, m_encryptionSync);

  UnknownExtensionsEncode(strm);
  m_forwardLogicalChannelNumber.Encode(strm);
  if (HasOptionalField(e_reverseLogicalChannelParameters))
    m_reverseLogicalChannelParameters.Encode(strm);
}


PObject * H245_OpenLogicalChannelAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannelAck::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannelAck(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_OpenLogicalChannelAck::preShowEthereal( void )
{
  m_forwardLogicalChannelNumber.preShowEthereal( );
  if ( HasOptionalField( e_reverseLogicalChannelParameters ) ) 
      m_reverseLogicalChannelParameters.preShowEthereal( );
  if ( HasOptionalField( e_separateStack ) ) 
      m_separateStack.preShowEthereal( );
  if ( HasOptionalField( e_forwardMultiplexAckParameters ) ) 
      m_forwardMultiplexAckParameters.preShowEthereal( );
  if ( HasOptionalField( e_encryptionSync ) ) 
      m_encryptionSync.preShowEthereal( );
}

PString H245_OpenLogicalChannelAck::getSummary( void ) 
{
  return PString( "OpenLogicalChannelAck" );
}

void H245_OpenLogicalChannelAck::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_OpenLogicalChannelAck_forwardLogicalChannelNumber, tvb, offset + m_forwardLogicalChannelNumber.GetStartByte(), m_forwardLogicalChannelNumber.GetByteLength() , m_forwardLogicalChannelNumber.GetValue() );

  if ( HasOptionalField( e_reverseLogicalChannelParameters ) ) {
    proto_tree *reverseLogicalChannelParameters_tree = (proto_tree*) NULL;
    proto_item *reverseLogicalChannelParameters_ti = (proto_item*) NULL;
    reverseLogicalChannelParameters_ti = proto_tree_add_text( tree, tvb, offset + m_reverseLogicalChannelParameters.GetStartByte(), m_reverseLogicalChannelParameters.GetByteLength(), "reverseLogicalChannelParameters (OpenLogicalChannelAck-reverseLogicalChannelParameters)" );
    reverseLogicalChannelParameters_tree = proto_item_add_subtree( reverseLogicalChannelParameters_ti, hCont->h245_2.ett_h245_OpenLogicalChannelAck_reverseLogicalChannelParameters );
    m_reverseLogicalChannelParameters.showEthereal( reverseLogicalChannelParameters_tree, tvb, offset );
  }

  if ( HasOptionalField( e_separateStack ) ) {
    proto_tree *separateStack_tree = (proto_tree*) NULL;
    proto_item *separateStack_ti = (proto_item*) NULL;
    separateStack_ti = proto_tree_add_text( tree, tvb, offset + m_separateStack.GetStartByte(), m_separateStack.GetByteLength(), "separateStack (NetworkAccessParameters)" );
    separateStack_tree = proto_item_add_subtree( separateStack_ti, hCont->h245_2.ett_h245_OpenLogicalChannelAck_separateStack );
    m_separateStack.showEthereal( separateStack_tree, tvb, offset );
  }

  if ( HasOptionalField( e_forwardMultiplexAckParameters ) ) {
    proto_tree *forwardMultiplexAckParameters_tree = (proto_tree*) NULL;
    proto_item *forwardMultiplexAckParameters_ti = (proto_item*) NULL;
    forwardMultiplexAckParameters_ti = proto_tree_add_text( tree, tvb, offset + m_forwardMultiplexAckParameters.GetStartByte(), m_forwardMultiplexAckParameters.GetByteLength(), "forwardMultiplexAckParameters (%s)", ( const char* ) m_forwardMultiplexAckParameters.GetTagName() );
    forwardMultiplexAckParameters_tree = proto_item_add_subtree( forwardMultiplexAckParameters_ti, hCont->h245_2.ett_h245_OpenLogicalChannelAck_forwardMultiplexAckParameters );
    m_forwardMultiplexAckParameters.showEthereal( forwardMultiplexAckParameters_tree, tvb, offset );
  }

  if ( HasOptionalField( e_encryptionSync ) ) {
    proto_tree *encryptionSync_tree = (proto_tree*) NULL;
    proto_item *encryptionSync_ti = (proto_item*) NULL;
    encryptionSync_ti = proto_tree_add_text( tree, tvb, offset + m_encryptionSync.GetStartByte(), m_encryptionSync.GetByteLength(), "encryptionSync (EncryptionSync)" );
    encryptionSync_tree = proto_item_add_subtree( encryptionSync_ti, hCont->h245_2.ett_h245_OpenLogicalChannelAck_encryptionSync );
    m_encryptionSync.showEthereal( encryptionSync_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// H235Mode
//

H245_H235Mode::H245_H235Mode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_H235Mode::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+39) << "encryptionAuthenticationAndIntegrity = " << setprecision(indent) << m_encryptionAuthenticationAndIntegrity << '\n';
  strm << setw(indent+12) << "mediaMode = " << setprecision(indent) << m_mediaMode << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H235Mode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H235Mode::Class()), PInvalidCast);
#endif
  const H245_H235Mode & other = (const H245_H235Mode &)obj;

  Comparison result;

  if ((result = m_encryptionAuthenticationAndIntegrity.Compare(other.m_encryptionAuthenticationAndIntegrity)) != EqualTo)
    return result;
  if ((result = m_mediaMode.Compare(other.m_mediaMode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H235Mode::GetDataLength() const
{
  return m_encryptionAuthenticationAndIntegrity.GetObjectLength() +
         m_mediaMode.GetObjectLength();
}


BOOL H245_H235Mode::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_encryptionAuthenticationAndIntegrity.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_mediaMode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H235Mode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_encryptionAuthenticationAndIntegrity.Encode(strm);
  m_mediaMode.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_encryptionAuthenticationAndIntegrity.Encode(strm);
  m_mediaMode.Encode(strm);
}


PObject * H245_H235Mode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H235Mode::Class()), PInvalidCast);
#endif
  return new H245_H235Mode(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H235Mode::preShowEthereal( void )
{
  m_encryptionAuthenticationAndIntegrity.preShowEthereal( );
  m_mediaMode.preShowEthereal( );
}

PString H245_H235Mode::getSummary( void ) 
{
  return PString( "H235Mode" );
}

void H245_H235Mode::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *encryptionAuthenticationAndIntegrity_tree = (proto_tree*) NULL;
  proto_item *encryptionAuthenticationAndIntegrity_ti = (proto_item*) NULL;
  encryptionAuthenticationAndIntegrity_ti = proto_tree_add_text( tree, tvb, offset + m_encryptionAuthenticationAndIntegrity.GetStartByte(), m_encryptionAuthenticationAndIntegrity.GetByteLength(), "encryptionAuthenticationAndIntegrity (EncryptionAuthenticationAndIntegrity)" );
  encryptionAuthenticationAndIntegrity_tree = proto_item_add_subtree( encryptionAuthenticationAndIntegrity_ti, hCont->h245_2.ett_h245_H235Mode_encryptionAuthenticationAndIntegrity );

  m_encryptionAuthenticationAndIntegrity.showEthereal( encryptionAuthenticationAndIntegrity_tree, tvb, offset );

  proto_tree *mediaMode_tree = (proto_tree*) NULL;
  proto_item *mediaMode_ti = (proto_item*) NULL;
  mediaMode_ti = proto_tree_add_text( tree, tvb, offset + m_mediaMode.GetStartByte(), m_mediaMode.GetByteLength(), "mediaMode (%s)", ( const char* ) m_mediaMode.GetTagName() );
  mediaMode_tree = proto_item_add_subtree( mediaMode_ti, hCont->h245_2.ett_h245_H235Mode_mediaMode );

  m_mediaMode.showEthereal( mediaMode_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// H2250ModeParameters
//

H245_H2250ModeParameters::H245_H2250ModeParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_H2250ModeParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_redundancyEncodingMode))
    strm << setw(indent+25) << "redundancyEncodingMode = " << setprecision(indent) << m_redundancyEncodingMode << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H2250ModeParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H2250ModeParameters::Class()), PInvalidCast);
#endif
  const H245_H2250ModeParameters & other = (const H245_H2250ModeParameters &)obj;

  Comparison result;

  if ((result = m_redundancyEncodingMode.Compare(other.m_redundancyEncodingMode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H2250ModeParameters::GetDataLength() const
{
  return m_redundancyEncodingMode.GetObjectLength();
}


BOOL H245_H2250ModeParameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_redundancyEncodingMode ) && !m_redundancyEncodingMode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H2250ModeParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_redundancyEncodingMode))
    m_redundancyEncodingMode.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_redundancyEncodingMode))
    m_redundancyEncodingMode.Encode(strm);
}


PObject * H245_H2250ModeParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H2250ModeParameters::Class()), PInvalidCast);
#endif
  return new H245_H2250ModeParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H2250ModeParameters::preShowEthereal( void )
{
  if ( HasOptionalField( e_redundancyEncodingMode ) ) 
      m_redundancyEncodingMode.preShowEthereal( );
}

PString H245_H2250ModeParameters::getSummary( void ) 
{
  return PString( "H2250ModeParameters" );
}

void H245_H2250ModeParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_redundancyEncodingMode ) ) {
    proto_tree *redundancyEncodingMode_tree = (proto_tree*) NULL;
    proto_item *redundancyEncodingMode_ti = (proto_item*) NULL;
    redundancyEncodingMode_ti = proto_tree_add_text( tree, tvb, offset + m_redundancyEncodingMode.GetStartByte(), m_redundancyEncodingMode.GetByteLength(), "redundancyEncodingMode (RedundancyEncodingMode)" );
    redundancyEncodingMode_tree = proto_item_add_subtree( redundancyEncodingMode_ti, hCont->h245_2.ett_h245_H2250ModeParameters_redundancyEncodingMode );
    m_redundancyEncodingMode.showEthereal( redundancyEncodingMode_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// H263VideoMode
//

H245_H263VideoMode::H245_H263VideoMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 3)
{
  m_bitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 19200);
  IncludeOptionalField(e_errorCompensation);
}


#ifndef PASN_NOPRINTON
void H245_H263VideoMode::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "resolution = " << setprecision(indent) << m_resolution << '\n';
  strm << setw(indent+10) << "bitRate = " << setprecision(indent) << m_bitRate << '\n';
  strm << setw(indent+21) << "unrestrictedVector = " << setprecision(indent) << m_unrestrictedVector << '\n';
  strm << setw(indent+19) << "arithmeticCoding = " << setprecision(indent) << m_arithmeticCoding << '\n';
  strm << setw(indent+21) << "advancedPrediction = " << setprecision(indent) << m_advancedPrediction << '\n';
  strm << setw(indent+11) << "pbFrames = " << setprecision(indent) << m_pbFrames << '\n';
  if (HasOptionalField(e_errorCompensation))
    strm << setw(indent+20) << "errorCompensation = " << setprecision(indent) << m_errorCompensation << '\n';
  if (HasOptionalField(e_enhancementLayerInfo))
    strm << setw(indent+23) << "enhancementLayerInfo = " << setprecision(indent) << m_enhancementLayerInfo << '\n';
  if (HasOptionalField(e_h263Options))
    strm << setw(indent+14) << "h263Options = " << setprecision(indent) << m_h263Options << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H263VideoMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H263VideoMode::Class()), PInvalidCast);
#endif
  const H245_H263VideoMode & other = (const H245_H263VideoMode &)obj;

  Comparison result;

  if ((result = m_resolution.Compare(other.m_resolution)) != EqualTo)
    return result;
  if ((result = m_bitRate.Compare(other.m_bitRate)) != EqualTo)
    return result;
  if ((result = m_unrestrictedVector.Compare(other.m_unrestrictedVector)) != EqualTo)
    return result;
  if ((result = m_arithmeticCoding.Compare(other.m_arithmeticCoding)) != EqualTo)
    return result;
  if ((result = m_advancedPrediction.Compare(other.m_advancedPrediction)) != EqualTo)
    return result;
  if ((result = m_pbFrames.Compare(other.m_pbFrames)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H263VideoMode::GetDataLength() const
{
  return m_resolution.GetObjectLength() +
         m_bitRate.GetObjectLength() +
         m_unrestrictedVector.GetObjectLength() +
         m_arithmeticCoding.GetObjectLength() +
         m_advancedPrediction.GetObjectLength() +
         m_pbFrames.GetObjectLength();
}


BOOL H245_H263VideoMode::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_resolution.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bitRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_unrestrictedVector.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_arithmeticCoding.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_advancedPrediction.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_pbFrames.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_errorCompensation, m_errorCompensation ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_enhancementLayerInfo, m_enhancementLayerInfo ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_h263Options, m_h263Options ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H263VideoMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_resolution.Encode(strm);
  m_bitRate.Encode(strm);
  m_unrestrictedVector.Encode(strm);
  m_arithmeticCoding.Encode(strm);
  m_advancedPrediction.Encode(strm);
  m_pbFrames.Encode(strm);
  KnownExtensionEncode(strm, e_errorCompensation, m_errorCompensation);
  KnownExtensionEncode(strm, e_enhancementLayerInfo, m_enhancementLayerInfo);
  KnownExtensionEncode(strm, e_h263Options, m_h263Options);

  UnknownExtensionsEncode(strm);
  m_resolution.Encode(strm);
  m_bitRate.Encode(strm);
  m_unrestrictedVector.Encode(strm);
  m_arithmeticCoding.Encode(strm);
  m_advancedPrediction.Encode(strm);
  m_pbFrames.Encode(strm);
}


PObject * H245_H263VideoMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H263VideoMode::Class()), PInvalidCast);
#endif
  return new H245_H263VideoMode(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H263VideoMode::preShowEthereal( void )
{
  m_resolution.preShowEthereal( );
  m_bitRate.preShowEthereal( );
  m_unrestrictedVector.preShowEthereal( );
  m_arithmeticCoding.preShowEthereal( );
  m_advancedPrediction.preShowEthereal( );
  m_pbFrames.preShowEthereal( );
  if ( HasOptionalField( e_errorCompensation ) ) 
      m_errorCompensation.preShowEthereal( );
  if ( HasOptionalField( e_enhancementLayerInfo ) ) 
      m_enhancementLayerInfo.preShowEthereal( );
  if ( HasOptionalField( e_h263Options ) ) 
      m_h263Options.preShowEthereal( );
}

PString H245_H263VideoMode::getSummary( void ) 
{
  return PString( "H263VideoMode" );
}

void H245_H263VideoMode::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *resolution_tree = (proto_tree*) NULL;
  proto_item *resolution_ti = (proto_item*) NULL;
  resolution_ti = proto_tree_add_text( tree, tvb, offset + m_resolution.GetStartByte(), m_resolution.GetByteLength(), "resolution (%s)", ( const char* ) m_resolution.GetTagName() );
  resolution_tree = proto_item_add_subtree( resolution_ti, hCont->h245_2.ett_h245_H263VideoMode_resolution );

  m_resolution.showEthereal( resolution_tree, tvb, offset );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_H263VideoMode_bitRate, tvb, offset + m_bitRate.GetStartByte(), m_bitRate.GetByteLength() , m_bitRate.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263VideoMode_unrestrictedVector, tvb, offset + m_unrestrictedVector.GetStartByte(), m_unrestrictedVector.GetByteLength() , m_unrestrictedVector.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263VideoMode_arithmeticCoding, tvb, offset + m_arithmeticCoding.GetStartByte(), m_arithmeticCoding.GetByteLength() , m_arithmeticCoding.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263VideoMode_advancedPrediction, tvb, offset + m_advancedPrediction.GetStartByte(), m_advancedPrediction.GetByteLength() , m_advancedPrediction.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263VideoMode_pbFrames, tvb, offset + m_pbFrames.GetStartByte(), m_pbFrames.GetByteLength() , m_pbFrames.GetValue() );

  if ( HasOptionalField( e_errorCompensation ) ) {
    proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_H263VideoMode_errorCompensation, tvb, offset + m_errorCompensation.GetStartByte(), m_errorCompensation.GetByteLength() , m_errorCompensation.GetValue() );
  }

  if ( HasOptionalField( e_enhancementLayerInfo ) ) {
    proto_tree *enhancementLayerInfo_tree = (proto_tree*) NULL;
    proto_item *enhancementLayerInfo_ti = (proto_item*) NULL;
    enhancementLayerInfo_ti = proto_tree_add_text( tree, tvb, offset + m_enhancementLayerInfo.GetStartByte(), m_enhancementLayerInfo.GetByteLength(), "enhancementLayerInfo (EnhancementLayerInfo)" );
    enhancementLayerInfo_tree = proto_item_add_subtree( enhancementLayerInfo_ti, hCont->h245_2.ett_h245_H263VideoMode_enhancementLayerInfo );
    m_enhancementLayerInfo.showEthereal( enhancementLayerInfo_tree, tvb, offset );
  }

  if ( HasOptionalField( e_h263Options ) ) {
    proto_tree *h263Options_tree = (proto_tree*) NULL;
    proto_item *h263Options_ti = (proto_item*) NULL;
    h263Options_ti = proto_tree_add_text( tree, tvb, offset + m_h263Options.GetStartByte(), m_h263Options.GetByteLength(), "h263Options (H263Options)" );
    h263Options_tree = proto_item_add_subtree( h263Options_ti, hCont->h245_2.ett_h245_H263VideoMode_h263Options );
    m_h263Options.showEthereal( h263Options_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CommunicationModeTableEntry
//

H245_CommunicationModeTableEntry::H245_CommunicationModeTableEntry(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 7, TRUE, 3)
{
  m_sessionID.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
  m_associatedSessionID.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
  m_sessionDescription.SetConstraints(PASN_Object::FixedConstraint, 1, 128);
  m_sessionDependency.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
}


#ifndef PASN_NOPRINTON
void H245_CommunicationModeTableEntry::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandard))
    strm << setw(indent+14) << "nonStandard = " << setprecision(indent) << m_nonStandard << '\n';
  strm << setw(indent+12) << "sessionID = " << setprecision(indent) << m_sessionID << '\n';
  if (HasOptionalField(e_associatedSessionID))
    strm << setw(indent+22) << "associatedSessionID = " << setprecision(indent) << m_associatedSessionID << '\n';
  if (HasOptionalField(e_terminalLabel))
    strm << setw(indent+16) << "terminalLabel = " << setprecision(indent) << m_terminalLabel << '\n';
  strm << setw(indent+21) << "sessionDescription = " << setprecision(indent) << m_sessionDescription << '\n';
  strm << setw(indent+11) << "dataType = " << setprecision(indent) << m_dataType << '\n';
  if (HasOptionalField(e_mediaChannel))
    strm << setw(indent+15) << "mediaChannel = " << setprecision(indent) << m_mediaChannel << '\n';
  if (HasOptionalField(e_mediaGuaranteedDelivery))
    strm << setw(indent+26) << "mediaGuaranteedDelivery = " << setprecision(indent) << m_mediaGuaranteedDelivery << '\n';
  if (HasOptionalField(e_mediaControlChannel))
    strm << setw(indent+22) << "mediaControlChannel = " << setprecision(indent) << m_mediaControlChannel << '\n';
  if (HasOptionalField(e_mediaControlGuaranteedDelivery))
    strm << setw(indent+33) << "mediaControlGuaranteedDelivery = " << setprecision(indent) << m_mediaControlGuaranteedDelivery << '\n';
  if (HasOptionalField(e_redundancyEncoding))
    strm << setw(indent+21) << "redundancyEncoding = " << setprecision(indent) << m_redundancyEncoding << '\n';
  if (HasOptionalField(e_sessionDependency))
    strm << setw(indent+20) << "sessionDependency = " << setprecision(indent) << m_sessionDependency << '\n';
  if (HasOptionalField(e_destination))
    strm << setw(indent+14) << "destination = " << setprecision(indent) << m_destination << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_CommunicationModeTableEntry::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_CommunicationModeTableEntry::Class()), PInvalidCast);
#endif
  const H245_CommunicationModeTableEntry & other = (const H245_CommunicationModeTableEntry &)obj;

  Comparison result;

  if ((result = m_nonStandard.Compare(other.m_nonStandard)) != EqualTo)
    return result;
  if ((result = m_sessionID.Compare(other.m_sessionID)) != EqualTo)
    return result;
  if ((result = m_associatedSessionID.Compare(other.m_associatedSessionID)) != EqualTo)
    return result;
  if ((result = m_terminalLabel.Compare(other.m_terminalLabel)) != EqualTo)
    return result;
  if ((result = m_sessionDescription.Compare(other.m_sessionDescription)) != EqualTo)
    return result;
  if ((result = m_dataType.Compare(other.m_dataType)) != EqualTo)
    return result;
  if ((result = m_mediaChannel.Compare(other.m_mediaChannel)) != EqualTo)
    return result;
  if ((result = m_mediaGuaranteedDelivery.Compare(other.m_mediaGuaranteedDelivery)) != EqualTo)
    return result;
  if ((result = m_mediaControlChannel.Compare(other.m_mediaControlChannel)) != EqualTo)
    return result;
  if ((result = m_mediaControlGuaranteedDelivery.Compare(other.m_mediaControlGuaranteedDelivery)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_CommunicationModeTableEntry::GetDataLength() const
{
  return m_nonStandard.GetObjectLength() +
         m_sessionID.GetObjectLength() +
         m_associatedSessionID.GetObjectLength() +
         m_terminalLabel.GetObjectLength() +
         m_sessionDescription.GetObjectLength() +
         m_dataType.GetObjectLength() +
         m_mediaChannel.GetObjectLength() +
         m_mediaGuaranteedDelivery.GetObjectLength() +
         m_mediaControlChannel.GetObjectLength() +
         m_mediaControlGuaranteedDelivery.GetObjectLength();
}


BOOL H245_CommunicationModeTableEntry::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandard ) && !m_nonStandard.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sessionID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_associatedSessionID ) && !m_associatedSessionID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_terminalLabel ) && !m_terminalLabel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sessionDescription.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_dataType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_mediaChannel ) && !m_mediaChannel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_mediaGuaranteedDelivery ) && !m_mediaGuaranteedDelivery.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_mediaControlChannel ) && !m_mediaControlChannel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_mediaControlGuaranteedDelivery ) && !m_mediaControlGuaranteedDelivery.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_redundancyEncoding, m_redundancyEncoding ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_sessionDependency, m_sessionDependency ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_destination, m_destination ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_CommunicationModeTableEntry::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
  m_sessionID.Encode(strm);
  if (HasOptionalField(e_associatedSessionID))
    m_associatedSessionID.Encode(strm);
  if (HasOptionalField(e_terminalLabel))
    m_terminalLabel.Encode(strm);
  m_sessionDescription.Encode(strm);
  m_dataType.Encode(strm);
  if (HasOptionalField(e_mediaChannel))
    m_mediaChannel.Encode(strm);
  if (HasOptionalField(e_mediaGuaranteedDelivery))
    m_mediaGuaranteedDelivery.Encode(strm);
  if (HasOptionalField(e_mediaControlChannel))
    m_mediaControlChannel.Encode(strm);
  if (HasOptionalField(e_mediaControlGuaranteedDelivery))
    m_mediaControlGuaranteedDelivery.Encode(strm);
  KnownExtensionEncode(strm, e_redundancyEncoding, m_redundancyEncoding);
  KnownExtensionEncode(strm, e_sessionDependency, m_sessionDependency);
  KnownExtensionEncode(strm, e_destination, m_destination);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
  m_sessionID.Encode(strm);
  if (HasOptionalField(e_associatedSessionID))
    m_associatedSessionID.Encode(strm);
  if (HasOptionalField(e_terminalLabel))
    m_terminalLabel.Encode(strm);
  m_sessionDescription.Encode(strm);
  m_dataType.Encode(strm);
  if (HasOptionalField(e_mediaChannel))
    m_mediaChannel.Encode(strm);
  if (HasOptionalField(e_mediaGuaranteedDelivery))
    m_mediaGuaranteedDelivery.Encode(strm);
  if (HasOptionalField(e_mediaControlChannel))
    m_mediaControlChannel.Encode(strm);
  if (HasOptionalField(e_mediaControlGuaranteedDelivery))
    m_mediaControlGuaranteedDelivery.Encode(strm);
}


PObject * H245_CommunicationModeTableEntry::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CommunicationModeTableEntry::Class()), PInvalidCast);
#endif
  return new H245_CommunicationModeTableEntry(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_CommunicationModeTableEntry::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandard ) ) 
      m_nonStandard.preShowEthereal( );
  m_sessionID.preShowEthereal( );
  if ( HasOptionalField( e_associatedSessionID ) ) 
      m_associatedSessionID.preShowEthereal( );
  if ( HasOptionalField( e_terminalLabel ) ) 
      m_terminalLabel.preShowEthereal( );
  m_sessionDescription.preShowEthereal( );
  m_dataType.preShowEthereal( );

  if ( HasOptionalField( e_mediaChannel ) ) {
     m_mediaChannel.preShowEthereal( );
	  if ( m_mediaChannel.GetTagName() == "unicastAddress" ) {
			H245_UnicastAddress tmp_unicast = (H245_UnicastAddress) m_mediaChannel;
			if ( tmp_unicast.GetTagName() == "iPAddress" ) {
				H245_UnicastAddress_iPAddress tmpAddr = (H245_UnicastAddress_iPAddress) tmp_unicast;
				//rtp_add_address( (unsigned char*) tmpAddr.m_network.GetPointer(), tmpAddr.m_tsapIdentifier );
        address src_addr;
        conversation_t* pconv = ( conversation_t* ) NULL;
        
        src_addr.type = AT_IPv4;
        src_addr.len = 4;
        src_addr.data = (unsigned char*) tmpAddr.m_network.GetPointer();
        
        pconv = conversation_new( &src_addr, &src_addr, PT_UDP, tmpAddr.m_tsapIdentifier, 0, NO_ADDR2 + NO_PORT2 );
        
        conversation_set_dissector( pconv, find_dissector( "rtp" ) );
			}
		}
	}

  if ( HasOptionalField( e_mediaGuaranteedDelivery ) ) 
      m_mediaGuaranteedDelivery.preShowEthereal( );

  if ( HasOptionalField( e_mediaControlChannel ) ) {
     m_mediaControlChannel.preShowEthereal( );
	  if ( m_mediaControlChannel.GetTagName() == "unicastAddress" ) {
			H245_UnicastAddress tmp_unicast = (H245_UnicastAddress) m_mediaControlChannel;
			if ( tmp_unicast.GetTagName() == "iPAddress" ) {
				H245_UnicastAddress_iPAddress tmpAddr = (H245_UnicastAddress_iPAddress) tmp_unicast;
				//rtcp_add_address( (unsigned char*) tmpAddr.m_network.GetPointer(), tmpAddr.m_tsapIdentifier );
        address src_addr;
        conversation_t* pconv = ( conversation_t* ) NULL;
        
        src_addr.type = AT_IPv4;
        src_addr.len = 4;
        src_addr.data = (unsigned char*) tmpAddr.m_network.GetPointer();
        
        pconv = conversation_new( &src_addr, &src_addr, PT_UDP, tmpAddr.m_tsapIdentifier, 0, NO_ADDR2 + NO_PORT2 );
        
        conversation_set_dissector( pconv, find_dissector( "rtcp" ) );
			}
		}
	}
  if ( HasOptionalField( e_mediaControlGuaranteedDelivery ) ) 
      m_mediaControlGuaranteedDelivery.preShowEthereal( );
  if ( HasOptionalField( e_redundancyEncoding ) ) 
      m_redundancyEncoding.preShowEthereal( );
  if ( HasOptionalField( e_sessionDependency ) ) 
      m_sessionDependency.preShowEthereal( );
  if ( HasOptionalField( e_destination ) ) 
      m_destination.preShowEthereal( );
}

PString H245_CommunicationModeTableEntry::getSummary( void ) 
{
  return PString( "CommunicationModeTableEntry" );
}

void H245_CommunicationModeTableEntry::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandard ) ) {
    proto_tree *nonStandard_tree = (proto_tree*) NULL;
    proto_item *nonStandard_ti = (proto_item*) NULL;
    nonStandard_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandard.GetStartByte(), m_nonStandard.GetByteLength(), "nonStandard (NonStandardParameter)" );
    nonStandard_tree = proto_item_add_subtree( nonStandard_ti, hCont->h245_2.ett_h245_CommunicationModeTableEntry_nonStandard );
    m_nonStandard.showEthereal( nonStandard_tree, tvb, offset );
  }

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_CommunicationModeTableEntry_sessionID, tvb, offset + m_sessionID.GetStartByte(), m_sessionID.GetByteLength() , m_sessionID.GetValue() );

  if ( HasOptionalField( e_associatedSessionID ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_CommunicationModeTableEntry_associatedSessionID, tvb, offset + m_associatedSessionID.GetStartByte(), m_associatedSessionID.GetByteLength() , m_associatedSessionID.GetValue() );
  }

  if ( HasOptionalField( e_terminalLabel ) ) {
    proto_tree *terminalLabel_tree = (proto_tree*) NULL;
    proto_item *terminalLabel_ti = (proto_item*) NULL;
    terminalLabel_ti = proto_tree_add_text( tree, tvb, offset + m_terminalLabel.GetStartByte(), m_terminalLabel.GetByteLength(), "terminalLabel (TerminalLabel)" );
    terminalLabel_tree = proto_item_add_subtree( terminalLabel_ti, hCont->h245_2.ett_h245_CommunicationModeTableEntry_terminalLabel );
    m_terminalLabel.showEthereal( terminalLabel_tree, tvb, offset );
  }

  char* psessionDescription = m_sessionDescription.getValue();
  proto_tree_add_string( tree, hCont->h245_2.hf_h245_CommunicationModeTableEntry_sessionDescription, tvb, offset + m_sessionDescription.GetStartByte(), m_sessionDescription.GetByteLength() , psessionDescription );
  delete[] psessionDescription;

  proto_tree *dataType_tree = (proto_tree*) NULL;
  proto_item *dataType_ti = (proto_item*) NULL;
  dataType_ti = proto_tree_add_text( tree, tvb, offset + m_dataType.GetStartByte(), m_dataType.GetByteLength(), "dataType (%s)", ( const char* ) m_dataType.GetTagName() );
  dataType_tree = proto_item_add_subtree( dataType_ti, hCont->h245_2.ett_h245_CommunicationModeTableEntry_dataType );

  m_dataType.showEthereal( dataType_tree, tvb, offset );

  if ( HasOptionalField( e_mediaChannel ) ) {
    proto_tree *mediaChannel_tree = (proto_tree*) NULL;
    proto_item *mediaChannel_ti = (proto_item*) NULL;
    mediaChannel_ti = proto_tree_add_text( tree, tvb, offset + m_mediaChannel.GetStartByte(), m_mediaChannel.GetByteLength(), "mediaChannel (%s)", ( const char* ) m_mediaChannel.GetTagName() );
    mediaChannel_tree = proto_item_add_subtree( mediaChannel_ti, hCont->h245_2.ett_h245_CommunicationModeTableEntry_mediaChannel );
    m_mediaChannel.showEthereal( mediaChannel_tree, tvb, offset );
  }

  if ( HasOptionalField( e_mediaGuaranteedDelivery ) ) {
    proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_CommunicationModeTableEntry_mediaGuaranteedDelivery, tvb, offset + m_mediaGuaranteedDelivery.GetStartByte(), m_mediaGuaranteedDelivery.GetByteLength() , m_mediaGuaranteedDelivery.GetValue() );
  }

  if ( HasOptionalField( e_mediaControlChannel ) ) {
    proto_tree *mediaControlChannel_tree = (proto_tree*) NULL;
    proto_item *mediaControlChannel_ti = (proto_item*) NULL;
    mediaControlChannel_ti = proto_tree_add_text( tree, tvb, offset + m_mediaControlChannel.GetStartByte(), m_mediaControlChannel.GetByteLength(), "mediaControlChannel (%s)", ( const char* ) m_mediaControlChannel.GetTagName() );
    mediaControlChannel_tree = proto_item_add_subtree( mediaControlChannel_ti, hCont->h245_2.ett_h245_CommunicationModeTableEntry_mediaControlChannel );
    m_mediaControlChannel.showEthereal( mediaControlChannel_tree, tvb, offset );
  }

  if ( HasOptionalField( e_mediaControlGuaranteedDelivery ) ) {
    proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_CommunicationModeTableEntry_mediaControlGuaranteedDelivery, tvb, offset + m_mediaControlGuaranteedDelivery.GetStartByte(), m_mediaControlGuaranteedDelivery.GetByteLength() , m_mediaControlGuaranteedDelivery.GetValue() );
  }

  if ( HasOptionalField( e_redundancyEncoding ) ) {
    proto_tree *redundancyEncoding_tree = (proto_tree*) NULL;
    proto_item *redundancyEncoding_ti = (proto_item*) NULL;
    redundancyEncoding_ti = proto_tree_add_text( tree, tvb, offset + m_redundancyEncoding.GetStartByte(), m_redundancyEncoding.GetByteLength(), "redundancyEncoding (RedundancyEncoding)" );
    redundancyEncoding_tree = proto_item_add_subtree( redundancyEncoding_ti, hCont->h245_2.ett_h245_CommunicationModeTableEntry_redundancyEncoding );
    m_redundancyEncoding.showEthereal( redundancyEncoding_tree, tvb, offset );
  }

  if ( HasOptionalField( e_sessionDependency ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_CommunicationModeTableEntry_sessionDependency, tvb, offset + m_sessionDependency.GetStartByte(), m_sessionDependency.GetByteLength() , m_sessionDependency.GetValue() );
  }

  if ( HasOptionalField( e_destination ) ) {
    proto_tree *destination_tree = (proto_tree*) NULL;
    proto_item *destination_ti = (proto_item*) NULL;
    destination_ti = proto_tree_add_text( tree, tvb, offset + m_destination.GetStartByte(), m_destination.GetByteLength(), "destination (TerminalLabel)" );
    destination_tree = proto_item_add_subtree( destination_ti, hCont->h245_2.ett_h245_CommunicationModeTableEntry_destination );
    m_destination.showEthereal( destination_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// NewATMVCCommand
//

H245_NewATMVCCommand::H245_NewATMVCCommand(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_resourceID.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_bitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H245_NewATMVCCommand::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "resourceID = " << setprecision(indent) << m_resourceID << '\n';
  strm << setw(indent+10) << "bitRate = " << setprecision(indent) << m_bitRate << '\n';
  strm << setw(indent+26) << "bitRateLockedToPCRClock = " << setprecision(indent) << m_bitRateLockedToPCRClock << '\n';
  strm << setw(indent+30) << "bitRateLockedToNetworkClock = " << setprecision(indent) << m_bitRateLockedToNetworkClock << '\n';
  strm << setw(indent+6) << "aal = " << setprecision(indent) << m_aal << '\n';
  strm << setw(indent+12) << "multiplex = " << setprecision(indent) << m_multiplex << '\n';
  strm << setw(indent+20) << "reverseParameters = " << setprecision(indent) << m_reverseParameters << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_NewATMVCCommand::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_NewATMVCCommand::Class()), PInvalidCast);
#endif
  const H245_NewATMVCCommand & other = (const H245_NewATMVCCommand &)obj;

  Comparison result;

  if ((result = m_resourceID.Compare(other.m_resourceID)) != EqualTo)
    return result;
  if ((result = m_bitRate.Compare(other.m_bitRate)) != EqualTo)
    return result;
  if ((result = m_bitRateLockedToPCRClock.Compare(other.m_bitRateLockedToPCRClock)) != EqualTo)
    return result;
  if ((result = m_bitRateLockedToNetworkClock.Compare(other.m_bitRateLockedToNetworkClock)) != EqualTo)
    return result;
  if ((result = m_aal.Compare(other.m_aal)) != EqualTo)
    return result;
  if ((result = m_multiplex.Compare(other.m_multiplex)) != EqualTo)
    return result;
  if ((result = m_reverseParameters.Compare(other.m_reverseParameters)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NewATMVCCommand::GetDataLength() const
{
  return m_resourceID.GetObjectLength() +
         m_bitRate.GetObjectLength() +
         m_bitRateLockedToPCRClock.GetObjectLength() +
         m_bitRateLockedToNetworkClock.GetObjectLength() +
         m_aal.GetObjectLength() +
         m_multiplex.GetObjectLength() +
         m_reverseParameters.GetObjectLength();
}


BOOL H245_NewATMVCCommand::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_resourceID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bitRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bitRateLockedToPCRClock.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bitRateLockedToNetworkClock.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_aal.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_multiplex.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_reverseParameters.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_NewATMVCCommand::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_resourceID.Encode(strm);
  m_bitRate.Encode(strm);
  m_bitRateLockedToPCRClock.Encode(strm);
  m_bitRateLockedToNetworkClock.Encode(strm);
  m_aal.Encode(strm);
  m_multiplex.Encode(strm);
  m_reverseParameters.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_resourceID.Encode(strm);
  m_bitRate.Encode(strm);
  m_bitRateLockedToPCRClock.Encode(strm);
  m_bitRateLockedToNetworkClock.Encode(strm);
  m_aal.Encode(strm);
  m_multiplex.Encode(strm);
  m_reverseParameters.Encode(strm);
}


PObject * H245_NewATMVCCommand::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCCommand::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCCommand(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NewATMVCCommand::preShowEthereal( void )
{
  m_resourceID.preShowEthereal( );
  m_bitRate.preShowEthereal( );
  m_bitRateLockedToPCRClock.preShowEthereal( );
  m_bitRateLockedToNetworkClock.preShowEthereal( );
  m_aal.preShowEthereal( );
  m_multiplex.preShowEthereal( );
  m_reverseParameters.preShowEthereal( );
}

PString H245_NewATMVCCommand::getSummary( void ) 
{
  return PString( "NewATMVCCommand" );
}

void H245_NewATMVCCommand::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_NewATMVCCommand_resourceID, tvb, offset + m_resourceID.GetStartByte(), m_resourceID.GetByteLength() , m_resourceID.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_NewATMVCCommand_bitRate, tvb, offset + m_bitRate.GetStartByte(), m_bitRate.GetByteLength() , m_bitRate.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_NewATMVCCommand_bitRateLockedToPCRClock, tvb, offset + m_bitRateLockedToPCRClock.GetStartByte(), m_bitRateLockedToPCRClock.GetByteLength() , m_bitRateLockedToPCRClock.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_NewATMVCCommand_bitRateLockedToNetworkClock, tvb, offset + m_bitRateLockedToNetworkClock.GetStartByte(), m_bitRateLockedToNetworkClock.GetByteLength() , m_bitRateLockedToNetworkClock.GetValue() );

  proto_tree *aal_tree = (proto_tree*) NULL;
  proto_item *aal_ti = (proto_item*) NULL;
  aal_ti = proto_tree_add_text( tree, tvb, offset + m_aal.GetStartByte(), m_aal.GetByteLength(), "aal (%s)", ( const char* ) m_aal.GetTagName() );
  aal_tree = proto_item_add_subtree( aal_ti, hCont->h245_2.ett_h245_NewATMVCCommand_aal );

  m_aal.showEthereal( aal_tree, tvb, offset );

  proto_tree *multiplex_tree = (proto_tree*) NULL;
  proto_item *multiplex_ti = (proto_item*) NULL;
  multiplex_ti = proto_tree_add_text( tree, tvb, offset + m_multiplex.GetStartByte(), m_multiplex.GetByteLength(), "multiplex (%s)", ( const char* ) m_multiplex.GetTagName() );
  multiplex_tree = proto_item_add_subtree( multiplex_ti, hCont->h245_2.ett_h245_NewATMVCCommand_multiplex );

  m_multiplex.showEthereal( multiplex_tree, tvb, offset );

  proto_tree *reverseParameters_tree = (proto_tree*) NULL;
  proto_item *reverseParameters_ti = (proto_item*) NULL;
  reverseParameters_ti = proto_tree_add_text( tree, tvb, offset + m_reverseParameters.GetStartByte(), m_reverseParameters.GetByteLength(), "reverseParameters (NewATMVCCommand-reverseParameters)" );
  reverseParameters_tree = proto_item_add_subtree( reverseParameters_ti, hCont->h245_2.ett_h245_NewATMVCCommand_reverseParameters );

  m_reverseParameters.showEthereal( reverseParameters_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// NewATMVCIndication
//

H245_NewATMVCIndication::H245_NewATMVCIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 1)
{
  m_resourceID.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_bitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
  IncludeOptionalField(e_reverseParameters);
}


#ifndef PASN_NOPRINTON
void H245_NewATMVCIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "resourceID = " << setprecision(indent) << m_resourceID << '\n';
  strm << setw(indent+10) << "bitRate = " << setprecision(indent) << m_bitRate << '\n';
  strm << setw(indent+26) << "bitRateLockedToPCRClock = " << setprecision(indent) << m_bitRateLockedToPCRClock << '\n';
  strm << setw(indent+30) << "bitRateLockedToNetworkClock = " << setprecision(indent) << m_bitRateLockedToNetworkClock << '\n';
  strm << setw(indent+6) << "aal = " << setprecision(indent) << m_aal << '\n';
  strm << setw(indent+12) << "multiplex = " << setprecision(indent) << m_multiplex << '\n';
  if (HasOptionalField(e_reverseParameters))
    strm << setw(indent+20) << "reverseParameters = " << setprecision(indent) << m_reverseParameters << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_NewATMVCIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_NewATMVCIndication::Class()), PInvalidCast);
#endif
  const H245_NewATMVCIndication & other = (const H245_NewATMVCIndication &)obj;

  Comparison result;

  if ((result = m_resourceID.Compare(other.m_resourceID)) != EqualTo)
    return result;
  if ((result = m_bitRate.Compare(other.m_bitRate)) != EqualTo)
    return result;
  if ((result = m_bitRateLockedToPCRClock.Compare(other.m_bitRateLockedToPCRClock)) != EqualTo)
    return result;
  if ((result = m_bitRateLockedToNetworkClock.Compare(other.m_bitRateLockedToNetworkClock)) != EqualTo)
    return result;
  if ((result = m_aal.Compare(other.m_aal)) != EqualTo)
    return result;
  if ((result = m_multiplex.Compare(other.m_multiplex)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NewATMVCIndication::GetDataLength() const
{
  return m_resourceID.GetObjectLength() +
         m_bitRate.GetObjectLength() +
         m_bitRateLockedToPCRClock.GetObjectLength() +
         m_bitRateLockedToNetworkClock.GetObjectLength() +
         m_aal.GetObjectLength() +
         m_multiplex.GetObjectLength();
}


BOOL H245_NewATMVCIndication::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_resourceID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bitRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bitRateLockedToPCRClock.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bitRateLockedToNetworkClock.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_aal.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_multiplex.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_reverseParameters, m_reverseParameters ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_NewATMVCIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_resourceID.Encode(strm);
  m_bitRate.Encode(strm);
  m_bitRateLockedToPCRClock.Encode(strm);
  m_bitRateLockedToNetworkClock.Encode(strm);
  m_aal.Encode(strm);
  m_multiplex.Encode(strm);
  KnownExtensionEncode(strm, e_reverseParameters, m_reverseParameters);

  UnknownExtensionsEncode(strm);
  m_resourceID.Encode(strm);
  m_bitRate.Encode(strm);
  m_bitRateLockedToPCRClock.Encode(strm);
  m_bitRateLockedToNetworkClock.Encode(strm);
  m_aal.Encode(strm);
  m_multiplex.Encode(strm);
}


PObject * H245_NewATMVCIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCIndication::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCIndication(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_NewATMVCIndication::preShowEthereal( void )
{
  m_resourceID.preShowEthereal( );
  m_bitRate.preShowEthereal( );
  m_bitRateLockedToPCRClock.preShowEthereal( );
  m_bitRateLockedToNetworkClock.preShowEthereal( );
  m_aal.preShowEthereal( );
  m_multiplex.preShowEthereal( );
  if ( HasOptionalField( e_reverseParameters ) ) 
      m_reverseParameters.preShowEthereal( );
}

PString H245_NewATMVCIndication::getSummary( void ) 
{
  return PString( "NewATMVCIndication" );
}

void H245_NewATMVCIndication::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_NewATMVCIndication_resourceID, tvb, offset + m_resourceID.GetStartByte(), m_resourceID.GetByteLength() , m_resourceID.GetValue() );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_NewATMVCIndication_bitRate, tvb, offset + m_bitRate.GetStartByte(), m_bitRate.GetByteLength() , m_bitRate.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_NewATMVCIndication_bitRateLockedToPCRClock, tvb, offset + m_bitRateLockedToPCRClock.GetStartByte(), m_bitRateLockedToPCRClock.GetByteLength() , m_bitRateLockedToPCRClock.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_2.hf_h245_NewATMVCIndication_bitRateLockedToNetworkClock, tvb, offset + m_bitRateLockedToNetworkClock.GetStartByte(), m_bitRateLockedToNetworkClock.GetByteLength() , m_bitRateLockedToNetworkClock.GetValue() );

  proto_tree *aal_tree = (proto_tree*) NULL;
  proto_item *aal_ti = (proto_item*) NULL;
  aal_ti = proto_tree_add_text( tree, tvb, offset + m_aal.GetStartByte(), m_aal.GetByteLength(), "aal (%s)", ( const char* ) m_aal.GetTagName() );
  aal_tree = proto_item_add_subtree( aal_ti, hCont->h245_2.ett_h245_NewATMVCIndication_aal );

  m_aal.showEthereal( aal_tree, tvb, offset );

  proto_tree *multiplex_tree = (proto_tree*) NULL;
  proto_item *multiplex_ti = (proto_item*) NULL;
  multiplex_ti = proto_tree_add_text( tree, tvb, offset + m_multiplex.GetStartByte(), m_multiplex.GetByteLength(), "multiplex (%s)", ( const char* ) m_multiplex.GetTagName() );
  multiplex_tree = proto_item_add_subtree( multiplex_ti, hCont->h245_2.ett_h245_NewATMVCIndication_multiplex );

  m_multiplex.showEthereal( multiplex_tree, tvb, offset );

  if ( HasOptionalField( e_reverseParameters ) ) {
    proto_tree *reverseParameters_tree = (proto_tree*) NULL;
    proto_item *reverseParameters_ti = (proto_item*) NULL;
    reverseParameters_ti = proto_tree_add_text( tree, tvb, offset + m_reverseParameters.GetStartByte(), m_reverseParameters.GetByteLength(), "reverseParameters (NewATMVCIndication-reverseParameters)" );
    reverseParameters_tree = proto_item_add_subtree( reverseParameters_ti, hCont->h245_2.ett_h245_NewATMVCIndication_reverseParameters );
    m_reverseParameters.showEthereal( reverseParameters_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// H235SecurityCapability
//

H245_H235SecurityCapability::H245_H235SecurityCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_H235SecurityCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+39) << "encryptionAuthenticationAndIntegrity = " << setprecision(indent) << m_encryptionAuthenticationAndIntegrity << '\n';
  strm << setw(indent+18) << "mediaCapability = " << setprecision(indent) << m_mediaCapability << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H235SecurityCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H235SecurityCapability::Class()), PInvalidCast);
#endif
  const H245_H235SecurityCapability & other = (const H245_H235SecurityCapability &)obj;

  Comparison result;

  if ((result = m_encryptionAuthenticationAndIntegrity.Compare(other.m_encryptionAuthenticationAndIntegrity)) != EqualTo)
    return result;
  if ((result = m_mediaCapability.Compare(other.m_mediaCapability)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H235SecurityCapability::GetDataLength() const
{
  return m_encryptionAuthenticationAndIntegrity.GetObjectLength() +
         m_mediaCapability.GetObjectLength();
}


BOOL H245_H235SecurityCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_encryptionAuthenticationAndIntegrity.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_mediaCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H235SecurityCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_encryptionAuthenticationAndIntegrity.Encode(strm);
  m_mediaCapability.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_encryptionAuthenticationAndIntegrity.Encode(strm);
  m_mediaCapability.Encode(strm);
}


PObject * H245_H235SecurityCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H235SecurityCapability::Class()), PInvalidCast);
#endif
  return new H245_H235SecurityCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H235SecurityCapability::preShowEthereal( void )
{
  m_encryptionAuthenticationAndIntegrity.preShowEthereal( );
  m_mediaCapability.preShowEthereal( );
}

PString H245_H235SecurityCapability::getSummary( void ) 
{
  return PString( "H235SecurityCapability" );
}

void H245_H235SecurityCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *encryptionAuthenticationAndIntegrity_tree = (proto_tree*) NULL;
  proto_item *encryptionAuthenticationAndIntegrity_ti = (proto_item*) NULL;
  encryptionAuthenticationAndIntegrity_ti = proto_tree_add_text( tree, tvb, offset + m_encryptionAuthenticationAndIntegrity.GetStartByte(), m_encryptionAuthenticationAndIntegrity.GetByteLength(), "encryptionAuthenticationAndIntegrity (EncryptionAuthenticationAndIntegrity)" );
  encryptionAuthenticationAndIntegrity_tree = proto_item_add_subtree( encryptionAuthenticationAndIntegrity_ti, hCont->h245_2.ett_h245_H235SecurityCapability_encryptionAuthenticationAndIntegrity );

  m_encryptionAuthenticationAndIntegrity.showEthereal( encryptionAuthenticationAndIntegrity_tree, tvb, offset );

  proto_tree_add_uint( tree, hCont->h245_2.hf_h245_H235SecurityCapability_mediaCapability, tvb, offset + m_mediaCapability.GetStartByte(), m_mediaCapability.GetByteLength() , m_mediaCapability.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// H263VideoCapability
//

H245_H263VideoCapability::H245_H263VideoCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 7, TRUE, 8)
{
  m_sqcifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  m_qcifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  m_cifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  m_cif4MPI.SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  m_cif16MPI.SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  m_maxBitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 192400);
  m_hrd_B.SetConstraints(PASN_Object::FixedConstraint, 0, 524287);
  m_bppMaxKb.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_slowSqcifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 3600);
  m_slowQcifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 3600);
  m_slowCifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 3600);
  m_slowCif4MPI.SetConstraints(PASN_Object::FixedConstraint, 1, 3600);
  m_slowCif16MPI.SetConstraints(PASN_Object::FixedConstraint, 1, 3600);
  IncludeOptionalField(e_errorCompensation);
}


#ifndef PASN_NOPRINTON
void H245_H263VideoCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_sqcifMPI))
    strm << setw(indent+11) << "sqcifMPI = " << setprecision(indent) << m_sqcifMPI << '\n';
  if (HasOptionalField(e_qcifMPI))
    strm << setw(indent+10) << "qcifMPI = " << setprecision(indent) << m_qcifMPI << '\n';
  if (HasOptionalField(e_cifMPI))
    strm << setw(indent+9) << "cifMPI = " << setprecision(indent) << m_cifMPI << '\n';
  if (HasOptionalField(e_cif4MPI))
    strm << setw(indent+10) << "cif4MPI = " << setprecision(indent) << m_cif4MPI << '\n';
  if (HasOptionalField(e_cif16MPI))
    strm << setw(indent+11) << "cif16MPI = " << setprecision(indent) << m_cif16MPI << '\n';
  strm << setw(indent+13) << "maxBitRate = " << setprecision(indent) << m_maxBitRate << '\n';
  strm << setw(indent+21) << "unrestrictedVector = " << setprecision(indent) << m_unrestrictedVector << '\n';
  strm << setw(indent+19) << "arithmeticCoding = " << setprecision(indent) << m_arithmeticCoding << '\n';
  strm << setw(indent+21) << "advancedPrediction = " << setprecision(indent) << m_advancedPrediction << '\n';
  strm << setw(indent+11) << "pbFrames = " << setprecision(indent) << m_pbFrames << '\n';
  strm << setw(indent+36) << "temporalSpatialTradeOffCapability = " << setprecision(indent) << m_temporalSpatialTradeOffCapability << '\n';
  if (HasOptionalField(e_hrd_B))
    strm << setw(indent+8) << "hrd_B = " << setprecision(indent) << m_hrd_B << '\n';
  if (HasOptionalField(e_bppMaxKb))
    strm << setw(indent+11) << "bppMaxKb = " << setprecision(indent) << m_bppMaxKb << '\n';
  if (HasOptionalField(e_slowSqcifMPI))
    strm << setw(indent+15) << "slowSqcifMPI = " << setprecision(indent) << m_slowSqcifMPI << '\n';
  if (HasOptionalField(e_slowQcifMPI))
    strm << setw(indent+14) << "slowQcifMPI = " << setprecision(indent) << m_slowQcifMPI << '\n';
  if (HasOptionalField(e_slowCifMPI))
    strm << setw(indent+13) << "slowCifMPI = " << setprecision(indent) << m_slowCifMPI << '\n';
  if (HasOptionalField(e_slowCif4MPI))
    strm << setw(indent+14) << "slowCif4MPI = " << setprecision(indent) << m_slowCif4MPI << '\n';
  if (HasOptionalField(e_slowCif16MPI))
    strm << setw(indent+15) << "slowCif16MPI = " << setprecision(indent) << m_slowCif16MPI << '\n';
  if (HasOptionalField(e_errorCompensation))
    strm << setw(indent+20) << "errorCompensation = " << setprecision(indent) << m_errorCompensation << '\n';
  if (HasOptionalField(e_enhancementLayerInfo))
    strm << setw(indent+23) << "enhancementLayerInfo = " << setprecision(indent) << m_enhancementLayerInfo << '\n';
  if (HasOptionalField(e_h263Options))
    strm << setw(indent+14) << "h263Options = " << setprecision(indent) << m_h263Options << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_H263VideoCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_H263VideoCapability::Class()), PInvalidCast);
#endif
  const H245_H263VideoCapability & other = (const H245_H263VideoCapability &)obj;

  Comparison result;

  if ((result = m_sqcifMPI.Compare(other.m_sqcifMPI)) != EqualTo)
    return result;
  if ((result = m_qcifMPI.Compare(other.m_qcifMPI)) != EqualTo)
    return result;
  if ((result = m_cifMPI.Compare(other.m_cifMPI)) != EqualTo)
    return result;
  if ((result = m_cif4MPI.Compare(other.m_cif4MPI)) != EqualTo)
    return result;
  if ((result = m_cif16MPI.Compare(other.m_cif16MPI)) != EqualTo)
    return result;
  if ((result = m_maxBitRate.Compare(other.m_maxBitRate)) != EqualTo)
    return result;
  if ((result = m_unrestrictedVector.Compare(other.m_unrestrictedVector)) != EqualTo)
    return result;
  if ((result = m_arithmeticCoding.Compare(other.m_arithmeticCoding)) != EqualTo)
    return result;
  if ((result = m_advancedPrediction.Compare(other.m_advancedPrediction)) != EqualTo)
    return result;
  if ((result = m_pbFrames.Compare(other.m_pbFrames)) != EqualTo)
    return result;
  if ((result = m_temporalSpatialTradeOffCapability.Compare(other.m_temporalSpatialTradeOffCapability)) != EqualTo)
    return result;
  if ((result = m_hrd_B.Compare(other.m_hrd_B)) != EqualTo)
    return result;
  if ((result = m_bppMaxKb.Compare(other.m_bppMaxKb)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H263VideoCapability::GetDataLength() const
{
  return m_sqcifMPI.GetObjectLength() +
         m_qcifMPI.GetObjectLength() +
         m_cifMPI.GetObjectLength() +
         m_cif4MPI.GetObjectLength() +
         m_cif16MPI.GetObjectLength() +
         m_maxBitRate.GetObjectLength() +
         m_unrestrictedVector.GetObjectLength() +
         m_arithmeticCoding.GetObjectLength() +
         m_advancedPrediction.GetObjectLength() +
         m_pbFrames.GetObjectLength() +
         m_temporalSpatialTradeOffCapability.GetObjectLength() +
         m_hrd_B.GetObjectLength() +
         m_bppMaxKb.GetObjectLength();
}


BOOL H245_H263VideoCapability::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_sqcifMPI ) && !m_sqcifMPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_qcifMPI ) && !m_qcifMPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_cifMPI ) && !m_cifMPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_cif4MPI ) && !m_cif4MPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_cif16MPI ) && !m_cif16MPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maxBitRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_unrestrictedVector.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_arithmeticCoding.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_advancedPrediction.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_pbFrames.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_temporalSpatialTradeOffCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_hrd_B ) && !m_hrd_B.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_bppMaxKb ) && !m_bppMaxKb.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_slowSqcifMPI, m_slowSqcifMPI ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_slowQcifMPI, m_slowQcifMPI ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_slowCifMPI, m_slowCifMPI ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_slowCif4MPI, m_slowCif4MPI ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_slowCif16MPI, m_slowCif16MPI ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_errorCompensation, m_errorCompensation ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_enhancementLayerInfo, m_enhancementLayerInfo ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_h263Options, m_h263Options ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_H263VideoCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_sqcifMPI))
    m_sqcifMPI.Encode(strm);
  if (HasOptionalField(e_qcifMPI))
    m_qcifMPI.Encode(strm);
  if (HasOptionalField(e_cifMPI))
    m_cifMPI.Encode(strm);
  if (HasOptionalField(e_cif4MPI))
    m_cif4MPI.Encode(strm);
  if (HasOptionalField(e_cif16MPI))
    m_cif16MPI.Encode(strm);
  m_maxBitRate.Encode(strm);
  m_unrestrictedVector.Encode(strm);
  m_arithmeticCoding.Encode(strm);
  m_advancedPrediction.Encode(strm);
  m_pbFrames.Encode(strm);
  m_temporalSpatialTradeOffCapability.Encode(strm);
  if (HasOptionalField(e_hrd_B))
    m_hrd_B.Encode(strm);
  if (HasOptionalField(e_bppMaxKb))
    m_bppMaxKb.Encode(strm);
  KnownExtensionEncode(strm, e_slowSqcifMPI, m_slowSqcifMPI);
  KnownExtensionEncode(strm, e_slowQcifMPI, m_slowQcifMPI);
  KnownExtensionEncode(strm, e_slowCifMPI, m_slowCifMPI);
  KnownExtensionEncode(strm, e_slowCif4MPI, m_slowCif4MPI);
  KnownExtensionEncode(strm, e_slowCif16MPI, m_slowCif16MPI);
  KnownExtensionEncode(strm, e_errorCompensation, m_errorCompensation);
  KnownExtensionEncode(strm, e_enhancementLayerInfo, m_enhancementLayerInfo);
  KnownExtensionEncode(strm, e_h263Options, m_h263Options);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_sqcifMPI))
    m_sqcifMPI.Encode(strm);
  if (HasOptionalField(e_qcifMPI))
    m_qcifMPI.Encode(strm);
  if (HasOptionalField(e_cifMPI))
    m_cifMPI.Encode(strm);
  if (HasOptionalField(e_cif4MPI))
    m_cif4MPI.Encode(strm);
  if (HasOptionalField(e_cif16MPI))
    m_cif16MPI.Encode(strm);
  m_maxBitRate.Encode(strm);
  m_unrestrictedVector.Encode(strm);
  m_arithmeticCoding.Encode(strm);
  m_advancedPrediction.Encode(strm);
  m_pbFrames.Encode(strm);
  m_temporalSpatialTradeOffCapability.Encode(strm);
  if (HasOptionalField(e_hrd_B))
    m_hrd_B.Encode(strm);
  if (HasOptionalField(e_bppMaxKb))
    m_bppMaxKb.Encode(strm);
}


PObject * H245_H263VideoCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H263VideoCapability::Class()), PInvalidCast);
#endif
  return new H245_H263VideoCapability(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_H263VideoCapability::preShowEthereal( void )
{
  if ( HasOptionalField( e_sqcifMPI ) ) 
      m_sqcifMPI.preShowEthereal( );
  if ( HasOptionalField( e_qcifMPI ) ) 
      m_qcifMPI.preShowEthereal( );
  if ( HasOptionalField( e_cifMPI ) ) 
      m_cifMPI.preShowEthereal( );
  if ( HasOptionalField( e_cif4MPI ) ) 
      m_cif4MPI.preShowEthereal( );
  if ( HasOptionalField( e_cif16MPI ) ) 
      m_cif16MPI.preShowEthereal( );
  m_maxBitRate.preShowEthereal( );
  m_unrestrictedVector.preShowEthereal( );
  m_arithmeticCoding.preShowEthereal( );
  m_advancedPrediction.preShowEthereal( );
  m_pbFrames.preShowEthereal( );
  m_temporalSpatialTradeOffCapability.preShowEthereal( );
  if ( HasOptionalField( e_hrd_B ) ) 
      m_hrd_B.preShowEthereal( );
  if ( HasOptionalField( e_bppMaxKb ) ) 
      m_bppMaxKb.preShowEthereal( );
  if ( HasOptionalField( e_slowSqcifMPI ) ) 
      m_slowSqcifMPI.preShowEthereal( );
  if ( HasOptionalField( e_slowQcifMPI ) ) 
      m_slowQcifMPI.preShowEthereal( );
  if ( HasOptionalField( e_slowCifMPI ) ) 
      m_slowCifMPI.preShowEthereal( );
  if ( HasOptionalField( e_slowCif4MPI ) ) 
      m_slowCif4MPI.preShowEthereal( );
  if ( HasOptionalField( e_slowCif16MPI ) ) 
      m_slowCif16MPI.preShowEthereal( );
  if ( HasOptionalField( e_errorCompensation ) ) 
      m_errorCompensation.preShowEthereal( );
  if ( HasOptionalField( e_enhancementLayerInfo ) ) 
      m_enhancementLayerInfo.preShowEthereal( );
  if ( HasOptionalField( e_h263Options ) ) 
      m_h263Options.preShowEthereal( );
}

PString H245_H263VideoCapability::getSummary( void ) 
{
  return PString( "H263VideoCapability" );
}

void H245_H263VideoCapability::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_sqcifMPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_2.hf_h245_H263VideoCapability_sqcifMPI, tvb, offset + m_sqcifMPI.GetStartByte(), m_sqcifMPI.GetByteLength() , m_sqcifMPI.GetValue() );
  }

  if ( HasOptionalField( e_qcifMPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_3.hf_h245_H263VideoCapability_qcifMPI, tvb, offset + m_qcifMPI.GetStartByte(), m_qcifMPI.GetByteLength() , m_qcifMPI.GetValue() );
  }

  if ( HasOptionalField( e_cifMPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_3.hf_h245_H263VideoCapability_cifMPI, tvb, offset + m_cifMPI.GetStartByte(), m_cifMPI.GetByteLength() , m_cifMPI.GetValue() );
  }

  if ( HasOptionalField( e_cif4MPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_3.hf_h245_H263VideoCapability_cif4MPI, tvb, offset + m_cif4MPI.GetStartByte(), m_cif4MPI.GetByteLength() , m_cif4MPI.GetValue() );
  }

  if ( HasOptionalField( e_cif16MPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_3.hf_h245_H263VideoCapability_cif16MPI, tvb, offset + m_cif16MPI.GetStartByte(), m_cif16MPI.GetByteLength() , m_cif16MPI.GetValue() );
  }

  proto_tree_add_uint( tree, hCont->h245_3.hf_h245_H263VideoCapability_maxBitRate, tvb, offset + m_maxBitRate.GetStartByte(), m_maxBitRate.GetByteLength() , m_maxBitRate.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_3.hf_h245_H263VideoCapability_unrestrictedVector, tvb, offset + m_unrestrictedVector.GetStartByte(), m_unrestrictedVector.GetByteLength() , m_unrestrictedVector.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_3.hf_h245_H263VideoCapability_arithmeticCoding, tvb, offset + m_arithmeticCoding.GetStartByte(), m_arithmeticCoding.GetByteLength() , m_arithmeticCoding.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_3.hf_h245_H263VideoCapability_advancedPrediction, tvb, offset + m_advancedPrediction.GetStartByte(), m_advancedPrediction.GetByteLength() , m_advancedPrediction.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_3.hf_h245_H263VideoCapability_pbFrames, tvb, offset + m_pbFrames.GetStartByte(), m_pbFrames.GetByteLength() , m_pbFrames.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_3.hf_h245_H263VideoCapability_temporalSpatialTradeOffCapability, tvb, offset + m_temporalSpatialTradeOffCapability.GetStartByte(), m_temporalSpatialTradeOffCapability.GetByteLength() , m_temporalSpatialTradeOffCapability.GetValue() );

  if ( HasOptionalField( e_hrd_B ) ) {
    proto_tree_add_uint( tree, hCont->h245_3.hf_h245_H263VideoCapability_hrd_B, tvb, offset + m_hrd_B.GetStartByte(), m_hrd_B.GetByteLength() , m_hrd_B.GetValue() );
  }

  if ( HasOptionalField( e_bppMaxKb ) ) {
    proto_tree_add_uint( tree, hCont->h245_3.hf_h245_H263VideoCapability_bppMaxKb, tvb, offset + m_bppMaxKb.GetStartByte(), m_bppMaxKb.GetByteLength() , m_bppMaxKb.GetValue() );
  }

  if ( HasOptionalField( e_slowSqcifMPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_3.hf_h245_H263VideoCapability_slowSqcifMPI, tvb, offset + m_slowSqcifMPI.GetStartByte(), m_slowSqcifMPI.GetByteLength() , m_slowSqcifMPI.GetValue() );
  }

  if ( HasOptionalField( e_slowQcifMPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_3.hf_h245_H263VideoCapability_slowQcifMPI, tvb, offset + m_slowQcifMPI.GetStartByte(), m_slowQcifMPI.GetByteLength() , m_slowQcifMPI.GetValue() );
  }

  if ( HasOptionalField( e_slowCifMPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_3.hf_h245_H263VideoCapability_slowCifMPI, tvb, offset + m_slowCifMPI.GetStartByte(), m_slowCifMPI.GetByteLength() , m_slowCifMPI.GetValue() );
  }

  if ( HasOptionalField( e_slowCif4MPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_3.hf_h245_H263VideoCapability_slowCif4MPI, tvb, offset + m_slowCif4MPI.GetStartByte(), m_slowCif4MPI.GetByteLength() , m_slowCif4MPI.GetValue() );
  }

  if ( HasOptionalField( e_slowCif16MPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_3.hf_h245_H263VideoCapability_slowCif16MPI, tvb, offset + m_slowCif16MPI.GetStartByte(), m_slowCif16MPI.GetByteLength() , m_slowCif16MPI.GetValue() );
  }

  if ( HasOptionalField( e_errorCompensation ) ) {
    proto_tree_add_boolean( tree, hCont->h245_3.hf_h245_H263VideoCapability_errorCompensation, tvb, offset + m_errorCompensation.GetStartByte(), m_errorCompensation.GetByteLength() , m_errorCompensation.GetValue() );
  }

  if ( HasOptionalField( e_enhancementLayerInfo ) ) {
    proto_tree *enhancementLayerInfo_tree = (proto_tree*) NULL;
    proto_item *enhancementLayerInfo_ti = (proto_item*) NULL;
    enhancementLayerInfo_ti = proto_tree_add_text( tree, tvb, offset + m_enhancementLayerInfo.GetStartByte(), m_enhancementLayerInfo.GetByteLength(), "enhancementLayerInfo (EnhancementLayerInfo)" );
    enhancementLayerInfo_tree = proto_item_add_subtree( enhancementLayerInfo_ti, hCont->h245_3.ett_h245_H263VideoCapability_enhancementLayerInfo );
    m_enhancementLayerInfo.showEthereal( enhancementLayerInfo_tree, tvb, offset );
  }

  if ( HasOptionalField( e_h263Options ) ) {
    proto_tree *h263Options_tree = (proto_tree*) NULL;
    proto_item *h263Options_ti = (proto_item*) NULL;
    h263Options_ti = proto_tree_add_text( tree, tvb, offset + m_h263Options.GetStartByte(), m_h263Options.GetByteLength(), "h263Options (H263Options)" );
    h263Options_tree = proto_item_add_subtree( h263Options_ti, hCont->h245_3.ett_h245_H263VideoCapability_h263Options );
    m_h263Options.showEthereal( h263Options_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// EnhancementOptions
//

H245_EnhancementOptions::H245_EnhancementOptions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 11, TRUE, 0)
{
  m_sqcifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  m_qcifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  m_cifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  m_cif4MPI.SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  m_cif16MPI.SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  m_maxBitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 192400);
  m_slowSqcifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 3600);
  m_slowQcifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 3600);
  m_slowCifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 3600);
  m_slowCif4MPI.SetConstraints(PASN_Object::FixedConstraint, 1, 3600);
  m_slowCif16MPI.SetConstraints(PASN_Object::FixedConstraint, 1, 3600);
}


#ifndef PASN_NOPRINTON
void H245_EnhancementOptions::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_sqcifMPI))
    strm << setw(indent+11) << "sqcifMPI = " << setprecision(indent) << m_sqcifMPI << '\n';
  if (HasOptionalField(e_qcifMPI))
    strm << setw(indent+10) << "qcifMPI = " << setprecision(indent) << m_qcifMPI << '\n';
  if (HasOptionalField(e_cifMPI))
    strm << setw(indent+9) << "cifMPI = " << setprecision(indent) << m_cifMPI << '\n';
  if (HasOptionalField(e_cif4MPI))
    strm << setw(indent+10) << "cif4MPI = " << setprecision(indent) << m_cif4MPI << '\n';
  if (HasOptionalField(e_cif16MPI))
    strm << setw(indent+11) << "cif16MPI = " << setprecision(indent) << m_cif16MPI << '\n';
  strm << setw(indent+13) << "maxBitRate = " << setprecision(indent) << m_maxBitRate << '\n';
  strm << setw(indent+21) << "unrestrictedVector = " << setprecision(indent) << m_unrestrictedVector << '\n';
  strm << setw(indent+19) << "arithmeticCoding = " << setprecision(indent) << m_arithmeticCoding << '\n';
  strm << setw(indent+36) << "temporalSpatialTradeOffCapability = " << setprecision(indent) << m_temporalSpatialTradeOffCapability << '\n';
  if (HasOptionalField(e_slowSqcifMPI))
    strm << setw(indent+15) << "slowSqcifMPI = " << setprecision(indent) << m_slowSqcifMPI << '\n';
  if (HasOptionalField(e_slowQcifMPI))
    strm << setw(indent+14) << "slowQcifMPI = " << setprecision(indent) << m_slowQcifMPI << '\n';
  if (HasOptionalField(e_slowCifMPI))
    strm << setw(indent+13) << "slowCifMPI = " << setprecision(indent) << m_slowCifMPI << '\n';
  if (HasOptionalField(e_slowCif4MPI))
    strm << setw(indent+14) << "slowCif4MPI = " << setprecision(indent) << m_slowCif4MPI << '\n';
  if (HasOptionalField(e_slowCif16MPI))
    strm << setw(indent+15) << "slowCif16MPI = " << setprecision(indent) << m_slowCif16MPI << '\n';
  strm << setw(indent+20) << "errorCompensation = " << setprecision(indent) << m_errorCompensation << '\n';
  if (HasOptionalField(e_h263Options))
    strm << setw(indent+14) << "h263Options = " << setprecision(indent) << m_h263Options << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_EnhancementOptions::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_EnhancementOptions::Class()), PInvalidCast);
#endif
  const H245_EnhancementOptions & other = (const H245_EnhancementOptions &)obj;

  Comparison result;

  if ((result = m_sqcifMPI.Compare(other.m_sqcifMPI)) != EqualTo)
    return result;
  if ((result = m_qcifMPI.Compare(other.m_qcifMPI)) != EqualTo)
    return result;
  if ((result = m_cifMPI.Compare(other.m_cifMPI)) != EqualTo)
    return result;
  if ((result = m_cif4MPI.Compare(other.m_cif4MPI)) != EqualTo)
    return result;
  if ((result = m_cif16MPI.Compare(other.m_cif16MPI)) != EqualTo)
    return result;
  if ((result = m_maxBitRate.Compare(other.m_maxBitRate)) != EqualTo)
    return result;
  if ((result = m_unrestrictedVector.Compare(other.m_unrestrictedVector)) != EqualTo)
    return result;
  if ((result = m_arithmeticCoding.Compare(other.m_arithmeticCoding)) != EqualTo)
    return result;
  if ((result = m_temporalSpatialTradeOffCapability.Compare(other.m_temporalSpatialTradeOffCapability)) != EqualTo)
    return result;
  if ((result = m_slowSqcifMPI.Compare(other.m_slowSqcifMPI)) != EqualTo)
    return result;
  if ((result = m_slowQcifMPI.Compare(other.m_slowQcifMPI)) != EqualTo)
    return result;
  if ((result = m_slowCifMPI.Compare(other.m_slowCifMPI)) != EqualTo)
    return result;
  if ((result = m_slowCif4MPI.Compare(other.m_slowCif4MPI)) != EqualTo)
    return result;
  if ((result = m_slowCif16MPI.Compare(other.m_slowCif16MPI)) != EqualTo)
    return result;
  if ((result = m_errorCompensation.Compare(other.m_errorCompensation)) != EqualTo)
    return result;
  if ((result = m_h263Options.Compare(other.m_h263Options)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_EnhancementOptions::GetDataLength() const
{
  return m_sqcifMPI.GetObjectLength() +
         m_qcifMPI.GetObjectLength() +
         m_cifMPI.GetObjectLength() +
         m_cif4MPI.GetObjectLength() +
         m_cif16MPI.GetObjectLength() +
         m_maxBitRate.GetObjectLength() +
         m_unrestrictedVector.GetObjectLength() +
         m_arithmeticCoding.GetObjectLength() +
         m_temporalSpatialTradeOffCapability.GetObjectLength() +
         m_slowSqcifMPI.GetObjectLength() +
         m_slowQcifMPI.GetObjectLength() +
         m_slowCifMPI.GetObjectLength() +
         m_slowCif4MPI.GetObjectLength() +
         m_slowCif16MPI.GetObjectLength() +
         m_errorCompensation.GetObjectLength() +
         m_h263Options.GetObjectLength();
}


BOOL H245_EnhancementOptions::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_sqcifMPI ) && !m_sqcifMPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_qcifMPI ) && !m_qcifMPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_cifMPI ) && !m_cifMPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_cif4MPI ) && !m_cif4MPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_cif16MPI ) && !m_cif16MPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_maxBitRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_unrestrictedVector.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_arithmeticCoding.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_temporalSpatialTradeOffCapability.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_slowSqcifMPI ) && !m_slowSqcifMPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_slowQcifMPI ) && !m_slowQcifMPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_slowCifMPI ) && !m_slowCifMPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_slowCif4MPI ) && !m_slowCif4MPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_slowCif16MPI ) && !m_slowCif16MPI.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_errorCompensation.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_h263Options ) && !m_h263Options.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_EnhancementOptions::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_sqcifMPI))
    m_sqcifMPI.Encode(strm);
  if (HasOptionalField(e_qcifMPI))
    m_qcifMPI.Encode(strm);
  if (HasOptionalField(e_cifMPI))
    m_cifMPI.Encode(strm);
  if (HasOptionalField(e_cif4MPI))
    m_cif4MPI.Encode(strm);
  if (HasOptionalField(e_cif16MPI))
    m_cif16MPI.Encode(strm);
  m_maxBitRate.Encode(strm);
  m_unrestrictedVector.Encode(strm);
  m_arithmeticCoding.Encode(strm);
  m_temporalSpatialTradeOffCapability.Encode(strm);
  if (HasOptionalField(e_slowSqcifMPI))
    m_slowSqcifMPI.Encode(strm);
  if (HasOptionalField(e_slowQcifMPI))
    m_slowQcifMPI.Encode(strm);
  if (HasOptionalField(e_slowCifMPI))
    m_slowCifMPI.Encode(strm);
  if (HasOptionalField(e_slowCif4MPI))
    m_slowCif4MPI.Encode(strm);
  if (HasOptionalField(e_slowCif16MPI))
    m_slowCif16MPI.Encode(strm);
  m_errorCompensation.Encode(strm);
  if (HasOptionalField(e_h263Options))
    m_h263Options.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_sqcifMPI))
    m_sqcifMPI.Encode(strm);
  if (HasOptionalField(e_qcifMPI))
    m_qcifMPI.Encode(strm);
  if (HasOptionalField(e_cifMPI))
    m_cifMPI.Encode(strm);
  if (HasOptionalField(e_cif4MPI))
    m_cif4MPI.Encode(strm);
  if (HasOptionalField(e_cif16MPI))
    m_cif16MPI.Encode(strm);
  m_maxBitRate.Encode(strm);
  m_unrestrictedVector.Encode(strm);
  m_arithmeticCoding.Encode(strm);
  m_temporalSpatialTradeOffCapability.Encode(strm);
  if (HasOptionalField(e_slowSqcifMPI))
    m_slowSqcifMPI.Encode(strm);
  if (HasOptionalField(e_slowQcifMPI))
    m_slowQcifMPI.Encode(strm);
  if (HasOptionalField(e_slowCifMPI))
    m_slowCifMPI.Encode(strm);
  if (HasOptionalField(e_slowCif4MPI))
    m_slowCif4MPI.Encode(strm);
  if (HasOptionalField(e_slowCif16MPI))
    m_slowCif16MPI.Encode(strm);
  m_errorCompensation.Encode(strm);
  if (HasOptionalField(e_h263Options))
    m_h263Options.Encode(strm);
}


PObject * H245_EnhancementOptions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EnhancementOptions::Class()), PInvalidCast);
#endif
  return new H245_EnhancementOptions(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_EnhancementOptions::preShowEthereal( void )
{
  if ( HasOptionalField( e_sqcifMPI ) ) 
      m_sqcifMPI.preShowEthereal( );
  if ( HasOptionalField( e_qcifMPI ) ) 
      m_qcifMPI.preShowEthereal( );
  if ( HasOptionalField( e_cifMPI ) ) 
      m_cifMPI.preShowEthereal( );
  if ( HasOptionalField( e_cif4MPI ) ) 
      m_cif4MPI.preShowEthereal( );
  if ( HasOptionalField( e_cif16MPI ) ) 
      m_cif16MPI.preShowEthereal( );
  m_maxBitRate.preShowEthereal( );
  m_unrestrictedVector.preShowEthereal( );
  m_arithmeticCoding.preShowEthereal( );
  m_temporalSpatialTradeOffCapability.preShowEthereal( );
  if ( HasOptionalField( e_slowSqcifMPI ) ) 
      m_slowSqcifMPI.preShowEthereal( );
  if ( HasOptionalField( e_slowQcifMPI ) ) 
      m_slowQcifMPI.preShowEthereal( );
  if ( HasOptionalField( e_slowCifMPI ) ) 
      m_slowCifMPI.preShowEthereal( );
  if ( HasOptionalField( e_slowCif4MPI ) ) 
      m_slowCif4MPI.preShowEthereal( );
  if ( HasOptionalField( e_slowCif16MPI ) ) 
      m_slowCif16MPI.preShowEthereal( );
  m_errorCompensation.preShowEthereal( );
  if ( HasOptionalField( e_h263Options ) ) 
      m_h263Options.preShowEthereal( );
}

PString H245_EnhancementOptions::getSummary( void ) 
{
  return PString( "EnhancementOptions" );
}

void H245_EnhancementOptions::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_sqcifMPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_3.hf_h245_EnhancementOptions_sqcifMPI, tvb, offset + m_sqcifMPI.GetStartByte(), m_sqcifMPI.GetByteLength() , m_sqcifMPI.GetValue() );
  }

  if ( HasOptionalField( e_qcifMPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_3.hf_h245_EnhancementOptions_qcifMPI, tvb, offset + m_qcifMPI.GetStartByte(), m_qcifMPI.GetByteLength() , m_qcifMPI.GetValue() );
  }

  if ( HasOptionalField( e_cifMPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_3.hf_h245_EnhancementOptions_cifMPI, tvb, offset + m_cifMPI.GetStartByte(), m_cifMPI.GetByteLength() , m_cifMPI.GetValue() );
  }

  if ( HasOptionalField( e_cif4MPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_3.hf_h245_EnhancementOptions_cif4MPI, tvb, offset + m_cif4MPI.GetStartByte(), m_cif4MPI.GetByteLength() , m_cif4MPI.GetValue() );
  }

  if ( HasOptionalField( e_cif16MPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_3.hf_h245_EnhancementOptions_cif16MPI, tvb, offset + m_cif16MPI.GetStartByte(), m_cif16MPI.GetByteLength() , m_cif16MPI.GetValue() );
  }

  proto_tree_add_uint( tree, hCont->h245_3.hf_h245_EnhancementOptions_maxBitRate, tvb, offset + m_maxBitRate.GetStartByte(), m_maxBitRate.GetByteLength() , m_maxBitRate.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_3.hf_h245_EnhancementOptions_unrestrictedVector, tvb, offset + m_unrestrictedVector.GetStartByte(), m_unrestrictedVector.GetByteLength() , m_unrestrictedVector.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_3.hf_h245_EnhancementOptions_arithmeticCoding, tvb, offset + m_arithmeticCoding.GetStartByte(), m_arithmeticCoding.GetByteLength() , m_arithmeticCoding.GetValue() );

  proto_tree_add_boolean( tree, hCont->h245_3.hf_h245_EnhancementOptions_temporalSpatialTradeOffCapability, tvb, offset + m_temporalSpatialTradeOffCapability.GetStartByte(), m_temporalSpatialTradeOffCapability.GetByteLength() , m_temporalSpatialTradeOffCapability.GetValue() );

  if ( HasOptionalField( e_slowSqcifMPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_3.hf_h245_EnhancementOptions_slowSqcifMPI, tvb, offset + m_slowSqcifMPI.GetStartByte(), m_slowSqcifMPI.GetByteLength() , m_slowSqcifMPI.GetValue() );
  }

  if ( HasOptionalField( e_slowQcifMPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_3.hf_h245_EnhancementOptions_slowQcifMPI, tvb, offset + m_slowQcifMPI.GetStartByte(), m_slowQcifMPI.GetByteLength() , m_slowQcifMPI.GetValue() );
  }

  if ( HasOptionalField( e_slowCifMPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_3.hf_h245_EnhancementOptions_slowCifMPI, tvb, offset + m_slowCifMPI.GetStartByte(), m_slowCifMPI.GetByteLength() , m_slowCifMPI.GetValue() );
  }

  if ( HasOptionalField( e_slowCif4MPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_3.hf_h245_EnhancementOptions_slowCif4MPI, tvb, offset + m_slowCif4MPI.GetStartByte(), m_slowCif4MPI.GetByteLength() , m_slowCif4MPI.GetValue() );
  }

  if ( HasOptionalField( e_slowCif16MPI ) ) {
    proto_tree_add_uint( tree, hCont->h245_3.hf_h245_EnhancementOptions_slowCif16MPI, tvb, offset + m_slowCif16MPI.GetStartByte(), m_slowCif16MPI.GetByteLength() , m_slowCif16MPI.GetValue() );
  }

  proto_tree_add_boolean( tree, hCont->h245_3.hf_h245_EnhancementOptions_errorCompensation, tvb, offset + m_errorCompensation.GetStartByte(), m_errorCompensation.GetByteLength() , m_errorCompensation.GetValue() );

  if ( HasOptionalField( e_h263Options ) ) {
    proto_tree *h263Options_tree = (proto_tree*) NULL;
    proto_item *h263Options_ti = (proto_item*) NULL;
    h263Options_ti = proto_tree_add_text( tree, tvb, offset + m_h263Options.GetStartByte(), m_h263Options.GetByteLength(), "h263Options (H263Options)" );
    h263Options_tree = proto_item_add_subtree( h263Options_ti, hCont->h245_3.ett_h245_EnhancementOptions_h263Options );
    m_h263Options.showEthereal( h263Options_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// ModeElement
//

H245_ModeElement::H245_ModeElement(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 2)
{
}


#ifndef PASN_NOPRINTON
void H245_ModeElement::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "type = " << setprecision(indent) << m_type << '\n';
  if (HasOptionalField(e_h223ModeParameters))
    strm << setw(indent+21) << "h223ModeParameters = " << setprecision(indent) << m_h223ModeParameters << '\n';
  if (HasOptionalField(e_v76ModeParameters))
    strm << setw(indent+20) << "v76ModeParameters = " << setprecision(indent) << m_v76ModeParameters << '\n';
  if (HasOptionalField(e_h2250ModeParameters))
    strm << setw(indent+22) << "h2250ModeParameters = " << setprecision(indent) << m_h2250ModeParameters << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_ModeElement::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_ModeElement::Class()), PInvalidCast);
#endif
  const H245_ModeElement & other = (const H245_ModeElement &)obj;

  Comparison result;

  if ((result = m_type.Compare(other.m_type)) != EqualTo)
    return result;
  if ((result = m_h223ModeParameters.Compare(other.m_h223ModeParameters)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ModeElement::GetDataLength() const
{
  return m_type.GetObjectLength() +
         m_h223ModeParameters.GetObjectLength();
}


BOOL H245_ModeElement::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_type.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_h223ModeParameters ) && !m_h223ModeParameters.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_v76ModeParameters, m_v76ModeParameters ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_h2250ModeParameters, m_h2250ModeParameters ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_ModeElement::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_type.Encode(strm);
  if (HasOptionalField(e_h223ModeParameters))
    m_h223ModeParameters.Encode(strm);
  KnownExtensionEncode(strm, e_v76ModeParameters, m_v76ModeParameters);
  KnownExtensionEncode(strm, e_h2250ModeParameters, m_h2250ModeParameters);

  UnknownExtensionsEncode(strm);
  m_type.Encode(strm);
  if (HasOptionalField(e_h223ModeParameters))
    m_h223ModeParameters.Encode(strm);
}


PObject * H245_ModeElement::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ModeElement::Class()), PInvalidCast);
#endif
  return new H245_ModeElement(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_ModeElement::preShowEthereal( void )
{
  m_type.preShowEthereal( );
  if ( HasOptionalField( e_h223ModeParameters ) ) 
      m_h223ModeParameters.preShowEthereal( );
  if ( HasOptionalField( e_v76ModeParameters ) ) 
      m_v76ModeParameters.preShowEthereal( );
  if ( HasOptionalField( e_h2250ModeParameters ) ) 
      m_h2250ModeParameters.preShowEthereal( );
}

PString H245_ModeElement::getSummary( void ) 
{
  return PString( "ModeElement" );
}

void H245_ModeElement::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *type_tree = (proto_tree*) NULL;
  proto_item *type_ti = (proto_item*) NULL;
  type_ti = proto_tree_add_text( tree, tvb, offset + m_type.GetStartByte(), m_type.GetByteLength(), "type (%s)", ( const char* ) m_type.GetTagName() );
  type_tree = proto_item_add_subtree( type_ti, hCont->h245_3.ett_h245_ModeElement_type );

  m_type.showEthereal( type_tree, tvb, offset );

  if ( HasOptionalField( e_h223ModeParameters ) ) {
    proto_tree *h223ModeParameters_tree = (proto_tree*) NULL;
    proto_item *h223ModeParameters_ti = (proto_item*) NULL;
    h223ModeParameters_ti = proto_tree_add_text( tree, tvb, offset + m_h223ModeParameters.GetStartByte(), m_h223ModeParameters.GetByteLength(), "h223ModeParameters (H223ModeParameters)" );
    h223ModeParameters_tree = proto_item_add_subtree( h223ModeParameters_ti, hCont->h245_3.ett_h245_ModeElement_h223ModeParameters );
    m_h223ModeParameters.showEthereal( h223ModeParameters_tree, tvb, offset );
  }

  if ( HasOptionalField( e_v76ModeParameters ) ) {
    proto_tree *v76ModeParameters_tree = (proto_tree*) NULL;
    proto_item *v76ModeParameters_ti = (proto_item*) NULL;
    v76ModeParameters_ti = proto_tree_add_text( tree, tvb, offset + m_v76ModeParameters.GetStartByte(), m_v76ModeParameters.GetByteLength(), "v76ModeParameters (%s)", ( const char* ) m_v76ModeParameters.GetTagName() );
    v76ModeParameters_tree = proto_item_add_subtree( v76ModeParameters_ti, hCont->h245_3.ett_h245_ModeElement_v76ModeParameters );
    m_v76ModeParameters.showEthereal( v76ModeParameters_tree, tvb, offset );
  }

  if ( HasOptionalField( e_h2250ModeParameters ) ) {
    proto_tree *h2250ModeParameters_tree = (proto_tree*) NULL;
    proto_item *h2250ModeParameters_ti = (proto_item*) NULL;
    h2250ModeParameters_ti = proto_tree_add_text( tree, tvb, offset + m_h2250ModeParameters.GetStartByte(), m_h2250ModeParameters.GetByteLength(), "h2250ModeParameters (H2250ModeParameters)" );
    h2250ModeParameters_tree = proto_item_add_subtree( h2250ModeParameters_ti, hCont->h245_3.ett_h245_ModeElement_h2250ModeParameters );
    m_h2250ModeParameters.showEthereal( h2250ModeParameters_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// BEnhancementParameters
//

H245_BEnhancementParameters::H245_BEnhancementParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_numberOfBPictures.SetConstraints(PASN_Object::FixedConstraint, 1, 64);
}


#ifndef PASN_NOPRINTON
void H245_BEnhancementParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "enhancementOptions = " << setprecision(indent) << m_enhancementOptions << '\n';
  strm << setw(indent+20) << "numberOfBPictures = " << setprecision(indent) << m_numberOfBPictures << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H245_BEnhancementParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H245_BEnhancementParameters::Class()), PInvalidCast);
#endif
  const H245_BEnhancementParameters & other = (const H245_BEnhancementParameters &)obj;

  Comparison result;

  if ((result = m_enhancementOptions.Compare(other.m_enhancementOptions)) != EqualTo)
    return result;
  if ((result = m_numberOfBPictures.Compare(other.m_numberOfBPictures)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_BEnhancementParameters::GetDataLength() const
{
  return m_enhancementOptions.GetObjectLength() +
         m_numberOfBPictures.GetObjectLength();
}


BOOL H245_BEnhancementParameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_enhancementOptions.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_numberOfBPictures.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H245_BEnhancementParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_enhancementOptions.Encode(strm);
  m_numberOfBPictures.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_enhancementOptions.Encode(strm);
  m_numberOfBPictures.Encode(strm);
}


PObject * H245_BEnhancementParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_BEnhancementParameters::Class()), PInvalidCast);
#endif
  return new H245_BEnhancementParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H245_BEnhancementParameters::preShowEthereal( void )
{
  m_enhancementOptions.preShowEthereal( );
  m_numberOfBPictures.preShowEthereal( );
}

PString H245_BEnhancementParameters::getSummary( void ) 
{
  return PString( "BEnhancementParameters" );
}

void H245_BEnhancementParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *enhancementOptions_tree = (proto_tree*) NULL;
  proto_item *enhancementOptions_ti = (proto_item*) NULL;
  enhancementOptions_ti = proto_tree_add_text( tree, tvb, offset + m_enhancementOptions.GetStartByte(), m_enhancementOptions.GetByteLength(), "enhancementOptions (EnhancementOptions)" );
  enhancementOptions_tree = proto_item_add_subtree( enhancementOptions_ti, hCont->h245_3.ett_h245_BEnhancementParameters_enhancementOptions );

  m_enhancementOptions.showEthereal( enhancementOptions_tree, tvb, offset );

  proto_tree_add_uint( tree, hCont->h245_3.hf_h245_BEnhancementParameters_numberOfBPictures, tvb, offset + m_numberOfBPictures.GetStartByte(), m_numberOfBPictures.GetByteLength() , m_numberOfBPictures.GetValue() );

}
#endif  //USE_FOR_ETHEREAL


// End of h245.cxx
