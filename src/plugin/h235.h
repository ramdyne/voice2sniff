/* 
 * h235.h
 *
 * The header file which is used in decoding H.235 messages
 *
 * H.323 for Ethereal
 *
 * Copyright (c) 2002 Koninklijke Philips NV
 *
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.0 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is H.323 for Ethereal.
 *
 * The Initial Developer of the Original Code is Koninklijke Philips NV.
 *
 * All Rights Reserved.
 *
 * Contributor(s): ______________________________________.
 *
 *
 */

//
// h235.h
//
// Code automatically generated by asnparse.
//

#ifndef __H235_H
#define __H235_H

#ifdef __GNUC__
#pragma interface
#endif

#include "mini_ptlib/include/ptlib/asner.h"

#ifdef USE_FOR_ETHEREAL
//extern "C" {
// use these only if the dissector is meant to be a plug-in!
//  //#include "plugins/plugin_api.h"
//}
#  include "h235_container.h"
#endif //USE_FOR_ETHEREAL

void setH235Container( H235_Integer_Container* cont );

//
// ChallengeString
//

class H235_ChallengeString : public PASN_OctetString
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_ChallengeString, PASN_OctetString);
#endif
  public:
    H235_ChallengeString(unsigned tag = UniversalOctetString, TagClass tagClass = UniversalTagClass);

    H235_ChallengeString & operator=(const char * v);
    H235_ChallengeString & operator=(const PString & v);
    H235_ChallengeString & operator=(const PBYTEArray & v);
    PObject * Clone() const;
};


//
// TimeStamp
//

class H235_TimeStamp : public PASN_Integer
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_TimeStamp, PASN_Integer);
#endif
  public:
    H235_TimeStamp(unsigned tag = UniversalInteger, TagClass tagClass = UniversalTagClass);

    H235_TimeStamp & operator=(int v);
    H235_TimeStamp & operator=(unsigned v);
    PObject * Clone() const;
};


//
// RandomVal
//

class H235_RandomVal : public PASN_Integer
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_RandomVal, PASN_Integer);
#endif
  public:
    H235_RandomVal(unsigned tag = UniversalInteger, TagClass tagClass = UniversalTagClass);

    H235_RandomVal & operator=(int v);
    H235_RandomVal & operator=(unsigned v);
    PObject * Clone() const;
};


//
// Password
//

class H235_Password : public PASN_BMPString
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_Password, PASN_BMPString);
#endif
  public:
    H235_Password(unsigned tag = UniversalBMPString, TagClass tagClass = UniversalTagClass);

    H235_Password & operator=(const char * v);
    H235_Password & operator=(const PString & v);
    PObject * Clone() const;
};


//
// Identifier
//

class H235_Identifier : public PASN_BMPString
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_Identifier, PASN_BMPString);
#endif
  public:
    H235_Identifier(unsigned tag = UniversalBMPString, TagClass tagClass = UniversalTagClass);

    H235_Identifier & operator=(const char * v);
    H235_Identifier & operator=(const PString & v);
    PObject * Clone() const;
};


//
// KeyMaterial
//

class H235_KeyMaterial : public PASN_BitString
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_KeyMaterial, PASN_BitString);
#endif
  public:
    H235_KeyMaterial(unsigned tag = UniversalBitString, TagClass tagClass = UniversalTagClass);

    PObject * Clone() const;
};


//
// NonStandardParameter
//

class H235_NonStandardParameter : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_NonStandardParameter, PASN_Sequence);
#endif
  public:
    H235_NonStandardParameter(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_ObjectId m_nonStandardIdentifier;
    PASN_OctetString m_data;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// DHset
//

class H235_DHset : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_DHset, PASN_Sequence);
#endif
  public:
    H235_DHset(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_BitString m_halfkey;
    PASN_BitString m_modSize;
    PASN_BitString m_generator;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// TypedCertificate
//

class H235_TypedCertificate : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_TypedCertificate, PASN_Sequence);
#endif
  public:
    H235_TypedCertificate(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_ObjectId m_type;
    PASN_OctetString m_certificate;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// AuthenticationMechanism
//

class H235_NonStandardParameter;

class H235_AuthenticationMechanism : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_AuthenticationMechanism, PASN_Choice);
#endif
  public:
    H235_AuthenticationMechanism(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_dhExch,
      e_pwdSymEnc,
      e_pwdHash,
      e_certSign,
      e_ipsec,
      e_tls,
      e_nonStandard
    };

#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H235_NonStandardParameter &() const;
#else
    operator H235_NonStandardParameter &();
    operator const H235_NonStandardParameter &() const;
#endif

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ClearToken
//

class H235_ClearToken : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_ClearToken, PASN_Sequence);
#endif
  public:
    H235_ClearToken(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_timeStamp,
      e_password,
      e_dhkey,
      e_challenge,
      e_random,
      e_certificate,
      e_generalID,
      e_nonStandard
    };

    PASN_ObjectId m_tokenOID;
    H235_TimeStamp m_timeStamp;
    H235_Password m_password;
    H235_DHset m_dhkey;
    H235_ChallengeString m_challenge;
    H235_RandomVal m_random;
    H235_TypedCertificate m_certificate;
    H235_Identifier m_generalID;
    H235_NonStandardParameter m_nonStandard;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// IV8
//

class H235_IV8 : public PASN_OctetString
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_IV8, PASN_OctetString);
#endif
  public:
    H235_IV8(unsigned tag = UniversalOctetString, TagClass tagClass = UniversalTagClass);

    H235_IV8 & operator=(const char * v);
    H235_IV8 & operator=(const PString & v);
    H235_IV8 & operator=(const PBYTEArray & v);
    PObject * Clone() const;
};


//
// Params
//

class H235_Params : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_Params, PASN_Sequence);
#endif
  public:
    H235_Params(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_ranInt,
      e_iv8
    };

    PASN_Integer m_ranInt;
    H235_IV8 m_iv8;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// EncodedGeneralToken
//

typedef H235_ClearToken H235_EncodedGeneralToken;


//
// PwdCertToken
//

class H235_PwdCertToken : public H235_ClearToken
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_PwdCertToken, H235_ClearToken);
#endif
  public:
    H235_PwdCertToken(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PObject * Clone() const;
};


//
// EncodedPwdCertToken
//

typedef H235_PwdCertToken H235_EncodedPwdCertToken;


//
// KeySyncMaterial
//

class H235_KeySyncMaterial : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_KeySyncMaterial, PASN_Sequence);
#endif
  public:
    H235_KeySyncMaterial(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    H235_Identifier m_generalID;
    H235_KeyMaterial m_keyMaterial;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// EncodedKeySyncMaterial
//

typedef H235_KeySyncMaterial H235_EncodedKeySyncMaterial;


//
// ReturnSig
//

class H235_ReturnSig : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_ReturnSig, PASN_Sequence);
#endif
  public:
    H235_ReturnSig(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_requestRandom,
      e_certificate
    };

    H235_Identifier m_generalId;
    H235_RandomVal m_responseRandom;
    H235_RandomVal m_requestRandom;
    H235_TypedCertificate m_certificate;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// EncodedReturnSig
//

typedef H235_ReturnSig H235_EncodedReturnSig;


//
// SIGNED
//

template <class ToBeSigned>
class H235_SIGNED : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_SIGNED, PASN_Sequence);
#endif
  public:
    H235_SIGNED(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    ToBeSigned m_toBeSigned;
    PASN_ObjectId m_algorithmOID;
    H235_Params m_paramS;
    PASN_BitString m_signature;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;
    PObject * Clone() const;
};


//
// ENCRYPTED
//

template <class ToBeEncrypted>
class H235_ENCRYPTED : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_ENCRYPTED, PASN_Sequence);
#endif
  public:
    H235_ENCRYPTED(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_ObjectId m_algorithmOID;
    H235_Params m_paramS;
    PASN_OctetString m_encryptedData;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;
    PObject * Clone() const;
};


//
// HASHED
//

template <class ToBeHashed>
class H235_HASHED : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_HASHED, PASN_Sequence);
#endif
  public:
    H235_HASHED(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_ObjectId m_algorithmOID;
    H235_Params m_paramS;
    PASN_BitString m_hash;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;
    PObject * Clone() const;
};


//
// CryptoToken
//

class H235_CryptoToken_cryptoEncryptedToken;
class H235_CryptoToken_cryptoSignedToken;
class H235_CryptoToken_cryptoHashedToken;

class H235_CryptoToken : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_CryptoToken, PASN_Choice);
#endif
  public:
    H235_CryptoToken(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_cryptoEncryptedToken,
      e_cryptoSignedToken,
      e_cryptoHashedToken,
      e_cryptoPwdEncr
    };

#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H235_CryptoToken_cryptoEncryptedToken &() const;
#else
    operator H235_CryptoToken_cryptoEncryptedToken &();
    operator const H235_CryptoToken_cryptoEncryptedToken &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H235_CryptoToken_cryptoSignedToken &() const;
#else
    operator H235_CryptoToken_cryptoSignedToken &();
    operator const H235_CryptoToken_cryptoSignedToken &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H235_CryptoToken_cryptoHashedToken &() const;
#else
    operator H235_CryptoToken_cryptoHashedToken &();
    operator const H235_CryptoToken_cryptoHashedToken &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H235_ENCRYPTED<H235_EncodedPwdCertToken> &() const;
#else
    operator H235_ENCRYPTED<H235_EncodedPwdCertToken> &();
    operator const H235_ENCRYPTED<H235_EncodedPwdCertToken> &() const;
#endif

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// KeySignedMaterial
//

class H235_KeySignedMaterial : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_KeySignedMaterial, PASN_Sequence);
#endif
  public:
    H235_KeySignedMaterial(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_srandom,
      e_timeStamp
    };

    H235_Identifier m_generalId;
    H235_RandomVal m_mrandom;
    H235_RandomVal m_srandom;
    H235_TimeStamp m_timeStamp;
    H235_ENCRYPTED<H235_EncodedKeySyncMaterial> m_encrptval;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// EncodedKeySignedMaterial
//

typedef H235_KeySignedMaterial H235_EncodedKeySignedMaterial;


//
// H235CertificateSignature
//

class H235_H235CertificateSignature : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_H235CertificateSignature, PASN_Sequence);
#endif
  public:
    H235_H235CertificateSignature(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_requesterRandom
    };

    H235_TypedCertificate m_certificate;
    H235_RandomVal m_responseRandom;
    H235_RandomVal m_requesterRandom;
    H235_SIGNED<H235_EncodedReturnSig> m_signature;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// CryptoToken_cryptoEncryptedToken
//

class H235_CryptoToken_cryptoEncryptedToken : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_CryptoToken_cryptoEncryptedToken, PASN_Sequence);
#endif
  public:
    H235_CryptoToken_cryptoEncryptedToken(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_ObjectId m_tokenOID;
    H235_ENCRYPTED<H235_EncodedGeneralToken> m_token;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// CryptoToken_cryptoSignedToken
//

class H235_CryptoToken_cryptoSignedToken : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_CryptoToken_cryptoSignedToken, PASN_Sequence);
#endif
  public:
    H235_CryptoToken_cryptoSignedToken(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_ObjectId m_tokenOID;
    H235_SIGNED<H235_EncodedGeneralToken> m_token;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// CryptoToken_cryptoHashedToken
//

class H235_CryptoToken_cryptoHashedToken : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_CryptoToken_cryptoHashedToken, PASN_Sequence);
#endif
  public:
    H235_CryptoToken_cryptoHashedToken(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_ObjectId m_tokenOID;
    H235_ClearToken m_hashedVals;
    H235_HASHED<H235_EncodedGeneralToken> m_token;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// H235Key
//

class H235_KeyMaterial;

class H235_H235Key : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H235_H235Key, PASN_Choice);
#endif
  public:
    H235_H235Key(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_secureChannel,
      e_sharedSecret,
      e_certProtectedKey
    };

#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H235_KeyMaterial &() const;
#else
    operator H235_KeyMaterial &();
    operator const H235_KeyMaterial &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H235_ENCRYPTED<H235_EncodedKeySyncMaterial> &() const;
#else
    operator H235_ENCRYPTED<H235_EncodedKeySyncMaterial> &();
    operator const H235_ENCRYPTED<H235_EncodedKeySyncMaterial> &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H235_SIGNED<H235_EncodedKeySignedMaterial> &() const;
#else
    operator H235_SIGNED<H235_EncodedKeySignedMaterial> &();
    operator const H235_SIGNED<H235_EncodedKeySignedMaterial> &() const;
#endif

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


#endif // __H235_H


// End of h235.h
