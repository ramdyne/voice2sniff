/* 
 * h235.cxx
 *
 * Source for decding H.235
 *
 * H.323 for Ethereal
 *
 * Copyright (c) 2002 Koninklijke Philips NV
 *
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.0 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is H.323 for Ethereal.
 *
 * The Initial Developer of the Original Code is Koninklijke Philips NV.
 *
 * All Rights Reserved.
 *
 * Contributor(s): ______________________________________.
 *
 *
 */


//
// h235.cxx
//
// Code automatically generated by asnparse.
//

#ifdef __GNUC__
#pragma implementation "h235.h"
#endif


#ifdef USE_FOR_ETHEREAL

extern "C" {

#  ifdef HAVE_CONFIG_H
#    include "config.h"
#  endif

#  include "plugins/plugin_api.h"

#  include "moduleinfo.h"

#  ifdef HAVE_SYS_TYPES_H
#    include <sys/types.h>
#  endif

#  include <string.h>
#  include <ctype.h>
#  include <time.h>

#  include <gmodule.h>
#  ifdef HAVE_NETINET_IN_H
#    include <netinet/in.h>
#  endif
#  include <epan/packet.h>
#  include "packet-h225.h"

//#  include "plugins/plugin_api_defs.h"
}

extern "C++" {
#  include <stdio.h>
#  include <string.h>
#  include "h235_container.h"
#  include "mini_ptlib/include/mini_ptlib.h"
#  include "h235.h"
#include "h235_t.cxx"
}
#endif//USE_FOR_ETHEREAL

#ifndef USE_FOR_ETHEREAL
#  include <ptlib.h>
#  include "h235.h"
#include "h235_t.cxx"
#endif //USE_FOR_ETHEREAL

#define new PNEW
static H235_Integer_Container* hCont;

void setH235Container( H235_Integer_Container* cont )
{
  hCont = cont;
}

//
// ChallengeString
//

H235_ChallengeString::H235_ChallengeString(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_OctetString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 8, 128);
}


H235_ChallengeString & H235_ChallengeString::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H235_ChallengeString & H235_ChallengeString::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H235_ChallengeString & H235_ChallengeString::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H235_ChallengeString::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H235_ChallengeString::Class()), PInvalidCast);
#endif
  return new H235_ChallengeString(*this);
}


//
// TimeStamp
//

H235_TimeStamp::H235_TimeStamp(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
}


H235_TimeStamp & H235_TimeStamp::operator=(int v)
{
  SetValue(v);
  return *this;
}


H235_TimeStamp & H235_TimeStamp::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H235_TimeStamp::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H235_TimeStamp::Class()), PInvalidCast);
#endif
  return new H235_TimeStamp(*this);
}


//
// RandomVal
//

H235_RandomVal::H235_RandomVal(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
}


H235_RandomVal & H235_RandomVal::operator=(int v)
{
  SetValue(v);
  return *this;
}


H235_RandomVal & H235_RandomVal::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H235_RandomVal::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H235_RandomVal::Class()), PInvalidCast);
#endif
  return new H235_RandomVal(*this);
}


//
// Password
//

H235_Password::H235_Password(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_BMPString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 128);
}


H235_Password & H235_Password::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H235_Password & H235_Password::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


PObject * H235_Password::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H235_Password::Class()), PInvalidCast);
#endif
  return new H235_Password(*this);
}


//
// Identifier
//

H235_Identifier::H235_Identifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_BMPString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 128);
}


H235_Identifier & H235_Identifier::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H235_Identifier & H235_Identifier::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


PObject * H235_Identifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H235_Identifier::Class()), PInvalidCast);
#endif
  return new H235_Identifier(*this);
}


//
// KeyMaterial
//

H235_KeyMaterial::H235_KeyMaterial(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_BitString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 2048);
}


PObject * H235_KeyMaterial::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H235_KeyMaterial::Class()), PInvalidCast);
#endif
  return new H235_KeyMaterial(*this);
}


//
// NonStandardParameter
//

H235_NonStandardParameter::H235_NonStandardParameter(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H235_NonStandardParameter::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "nonStandardIdentifier = " << setprecision(indent) << m_nonStandardIdentifier << '\n';
  strm << setw(indent+7) << "data = " << setprecision(indent) << m_data << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H235_NonStandardParameter::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H235_NonStandardParameter::Class()), PInvalidCast);
#endif
  const H235_NonStandardParameter & other = (const H235_NonStandardParameter &)obj;

  Comparison result;

  if ((result = m_nonStandardIdentifier.Compare(other.m_nonStandardIdentifier)) != EqualTo)
    return result;
  if ((result = m_data.Compare(other.m_data)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H235_NonStandardParameter::GetDataLength() const
{
  return m_nonStandardIdentifier.GetObjectLength() +
         m_data.GetObjectLength();
}


BOOL H235_NonStandardParameter::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_nonStandardIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_data.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H235_NonStandardParameter::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nonStandardIdentifier.Encode(strm);
  m_data.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_nonStandardIdentifier.Encode(strm);
  m_data.Encode(strm);
}


PObject * H235_NonStandardParameter::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H235_NonStandardParameter::Class()), PInvalidCast);
#endif
  return new H235_NonStandardParameter(*this);
}


#ifdef USE_FOR_ETHEREAL
void H235_NonStandardParameter::preShowEthereal( void )
{
  m_nonStandardIdentifier.preShowEthereal( );
  m_data.preShowEthereal( );
}

PString H235_NonStandardParameter::getSummary( void ) 
{
  return PString( "NonStandardParameter" );
}

void H235_NonStandardParameter::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pnonStandardIdentifier = m_nonStandardIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h235_0.hf_h235_NonStandardParameter_nonStandardIdentifier, tvb, offset + m_nonStandardIdentifier.GetStartByte(), m_nonStandardIdentifier.GetByteLength() , pnonStandardIdentifier );
  delete[] pnonStandardIdentifier;

  char* pdata = m_data.getValue();
  proto_tree_add_string( tree, hCont->h235_0.hf_h235_NonStandardParameter_data, tvb, offset + m_data.GetStartByte(), m_data.GetByteLength() , pdata );
  delete[] pdata;

}
#endif  //USE_FOR_ETHEREAL

//
// DHset
//

H235_DHset::H235_DHset(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_halfkey.SetConstraints(PASN_Object::FixedConstraint, 0, 2048);
  m_modSize.SetConstraints(PASN_Object::FixedConstraint, 0, 2048);
  m_generator.SetConstraints(PASN_Object::FixedConstraint, 0, 2048);
}


#ifndef PASN_NOPRINTON
void H235_DHset::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "halfkey = " << setprecision(indent) << m_halfkey << '\n';
  strm << setw(indent+10) << "modSize = " << setprecision(indent) << m_modSize << '\n';
  strm << setw(indent+12) << "generator = " << setprecision(indent) << m_generator << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H235_DHset::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H235_DHset::Class()), PInvalidCast);
#endif
  const H235_DHset & other = (const H235_DHset &)obj;

  Comparison result;

  if ((result = m_halfkey.Compare(other.m_halfkey)) != EqualTo)
    return result;
  if ((result = m_modSize.Compare(other.m_modSize)) != EqualTo)
    return result;
  if ((result = m_generator.Compare(other.m_generator)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H235_DHset::GetDataLength() const
{
  return m_halfkey.GetObjectLength() +
         m_modSize.GetObjectLength() +
         m_generator.GetObjectLength();
}


BOOL H235_DHset::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_halfkey.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_modSize.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_generator.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H235_DHset::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_halfkey.Encode(strm);
  m_modSize.Encode(strm);
  m_generator.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_halfkey.Encode(strm);
  m_modSize.Encode(strm);
  m_generator.Encode(strm);
}


PObject * H235_DHset::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H235_DHset::Class()), PInvalidCast);
#endif
  return new H235_DHset(*this);
}


#ifdef USE_FOR_ETHEREAL
void H235_DHset::preShowEthereal( void )
{
  m_halfkey.preShowEthereal( );
  m_modSize.preShowEthereal( );
  m_generator.preShowEthereal( );
}

PString H235_DHset::getSummary( void ) 
{
  return PString( "DHset" );
}

void H235_DHset::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* phalfkey = m_halfkey.getValue();
  proto_tree_add_string( tree, hCont->h235_0.hf_h235_DHset_halfkey, tvb, offset + m_halfkey.GetStartByte(), m_halfkey.GetByteLength() , phalfkey );
  delete[] phalfkey;

  char* pmodSize = m_modSize.getValue();
  proto_tree_add_string( tree, hCont->h235_0.hf_h235_DHset_modSize, tvb, offset + m_modSize.GetStartByte(), m_modSize.GetByteLength() , pmodSize );
  delete[] pmodSize;

  char* pgenerator = m_generator.getValue();
  proto_tree_add_string( tree, hCont->h235_0.hf_h235_DHset_generator, tvb, offset + m_generator.GetStartByte(), m_generator.GetByteLength() , pgenerator );
  delete[] pgenerator;

}
#endif  //USE_FOR_ETHEREAL

//
// TypedCertificate
//

H235_TypedCertificate::H235_TypedCertificate(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H235_TypedCertificate::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "type = " << setprecision(indent) << m_type << '\n';
  strm << setw(indent+14) << "certificate = " << setprecision(indent) << m_certificate << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H235_TypedCertificate::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H235_TypedCertificate::Class()), PInvalidCast);
#endif
  const H235_TypedCertificate & other = (const H235_TypedCertificate &)obj;

  Comparison result;

  if ((result = m_type.Compare(other.m_type)) != EqualTo)
    return result;
  if ((result = m_certificate.Compare(other.m_certificate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H235_TypedCertificate::GetDataLength() const
{
  return m_type.GetObjectLength() +
         m_certificate.GetObjectLength();
}


BOOL H235_TypedCertificate::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_type.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_certificate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H235_TypedCertificate::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_type.Encode(strm);
  m_certificate.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_type.Encode(strm);
  m_certificate.Encode(strm);
}


PObject * H235_TypedCertificate::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H235_TypedCertificate::Class()), PInvalidCast);
#endif
  return new H235_TypedCertificate(*this);
}


#ifdef USE_FOR_ETHEREAL
void H235_TypedCertificate::preShowEthereal( void )
{
  m_type.preShowEthereal( );
  m_certificate.preShowEthereal( );
}

PString H235_TypedCertificate::getSummary( void ) 
{
  return PString( "TypedCertificate" );
}

void H235_TypedCertificate::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* ptype = m_type.getValue();
  proto_tree_add_string( tree, hCont->h235_0.hf_h235_TypedCertificate_type, tvb, offset + m_type.GetStartByte(), m_type.GetByteLength() , ptype );
  delete[] ptype;

  char* pcertificate = m_certificate.getValue();
  proto_tree_add_string( tree, hCont->h235_0.hf_h235_TypedCertificate_certificate, tvb, offset + m_certificate.GetStartByte(), m_certificate.GetByteLength() , pcertificate );
  delete[] pcertificate;

}
#endif  //USE_FOR_ETHEREAL

//
// AuthenticationMechanism
//

H235_AuthenticationMechanism::H235_AuthenticationMechanism(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 7, TRUE
#ifndef PASN_NOPRINTON
      , "dhExch "
        "pwdSymEnc "
        "pwdHash "
        "certSign "
        "ipsec "
        "tls "
        "nonStandard "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H235_AuthenticationMechanism::operator H235_NonStandardParameter &() const
#else
H235_AuthenticationMechanism::operator H235_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H235_NonStandardParameter *)choice;
}


H235_AuthenticationMechanism::operator const H235_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H235_NonStandardParameter *)choice;
}


BOOL H235_AuthenticationMechanism::CreateObject()
{
  switch (tag) {
    case e_dhExch :
    case e_pwdSymEnc :
    case e_pwdHash :
    case e_certSign :
    case e_ipsec :
    case e_tls :
      choice = new PASN_Null();
      return TRUE;
    case e_nonStandard :
      choice = new H235_NonStandardParameter();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H235_AuthenticationMechanism::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H235_AuthenticationMechanism::Class()), PInvalidCast);
#endif
  return new H235_AuthenticationMechanism(*this);
}


#ifdef USE_FOR_ETHEREAL
void H235_AuthenticationMechanism::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_dhExch :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_pwdSymEnc :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_pwdHash :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_certSign :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_ipsec :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_tls :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_nonStandard :
        ( ( H235_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H235_AuthenticationMechanism::getSummary( void ) 
{
  return PString( "AuthenticationMechanism" );
}

void H235_AuthenticationMechanism::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "dhExch" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h235_0.hf_h235_AuthenticationMechanism_dhExch, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "pwdSymEnc" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h235_0.hf_h235_AuthenticationMechanism_pwdSymEnc, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "pwdHash" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h235_0.hf_h235_AuthenticationMechanism_pwdHash, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "certSign" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h235_0.hf_h235_AuthenticationMechanism_certSign, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "ipsec" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h235_0.hf_h235_AuthenticationMechanism_ipsec, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "tls" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h235_0.hf_h235_AuthenticationMechanism_tls, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h235_0.ett_h235_AuthenticationMechanism_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ClearToken
//

H235_ClearToken::H235_ClearToken(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 8, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H235_ClearToken::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "tokenOID = " << setprecision(indent) << m_tokenOID << '\n';
  if (HasOptionalField(e_timeStamp))
    strm << setw(indent+12) << "timeStamp = " << setprecision(indent) << m_timeStamp << '\n';
  if (HasOptionalField(e_password))
    strm << setw(indent+11) << "password = " << setprecision(indent) << m_password << '\n';
  if (HasOptionalField(e_dhkey))
    strm << setw(indent+8) << "dhkey = " << setprecision(indent) << m_dhkey << '\n';
  if (HasOptionalField(e_challenge))
    strm << setw(indent+12) << "challenge = " << setprecision(indent) << m_challenge << '\n';
  if (HasOptionalField(e_random))
    strm << setw(indent+9) << "random = " << setprecision(indent) << m_random << '\n';
  if (HasOptionalField(e_certificate))
    strm << setw(indent+14) << "certificate = " << setprecision(indent) << m_certificate << '\n';
  if (HasOptionalField(e_generalID))
    strm << setw(indent+12) << "generalID = " << setprecision(indent) << m_generalID << '\n';
  if (HasOptionalField(e_nonStandard))
    strm << setw(indent+14) << "nonStandard = " << setprecision(indent) << m_nonStandard << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H235_ClearToken::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H235_ClearToken::Class()), PInvalidCast);
#endif
  const H235_ClearToken & other = (const H235_ClearToken &)obj;

  Comparison result;

  if ((result = m_tokenOID.Compare(other.m_tokenOID)) != EqualTo)
    return result;
  if ((result = m_timeStamp.Compare(other.m_timeStamp)) != EqualTo)
    return result;
  if ((result = m_password.Compare(other.m_password)) != EqualTo)
    return result;
  if ((result = m_dhkey.Compare(other.m_dhkey)) != EqualTo)
    return result;
  if ((result = m_challenge.Compare(other.m_challenge)) != EqualTo)
    return result;
  if ((result = m_random.Compare(other.m_random)) != EqualTo)
    return result;
  if ((result = m_certificate.Compare(other.m_certificate)) != EqualTo)
    return result;
  if ((result = m_generalID.Compare(other.m_generalID)) != EqualTo)
    return result;
  if ((result = m_nonStandard.Compare(other.m_nonStandard)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H235_ClearToken::GetDataLength() const
{
  return m_tokenOID.GetObjectLength() +
         m_timeStamp.GetObjectLength() +
         m_password.GetObjectLength() +
         m_dhkey.GetObjectLength() +
         m_challenge.GetObjectLength() +
         m_random.GetObjectLength() +
         m_certificate.GetObjectLength() +
         m_generalID.GetObjectLength() +
         m_nonStandard.GetObjectLength();
}


BOOL H235_ClearToken::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_tokenOID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_timeStamp ) && !m_timeStamp.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_password ) && !m_password.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_dhkey ) && !m_dhkey.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_challenge ) && !m_challenge.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_random ) && !m_random.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_certificate ) && !m_certificate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_generalID ) && !m_generalID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandard ) && !m_nonStandard.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H235_ClearToken::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_tokenOID.Encode(strm);
  if (HasOptionalField(e_timeStamp))
    m_timeStamp.Encode(strm);
  if (HasOptionalField(e_password))
    m_password.Encode(strm);
  if (HasOptionalField(e_dhkey))
    m_dhkey.Encode(strm);
  if (HasOptionalField(e_challenge))
    m_challenge.Encode(strm);
  if (HasOptionalField(e_random))
    m_random.Encode(strm);
  if (HasOptionalField(e_certificate))
    m_certificate.Encode(strm);
  if (HasOptionalField(e_generalID))
    m_generalID.Encode(strm);
  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_tokenOID.Encode(strm);
  if (HasOptionalField(e_timeStamp))
    m_timeStamp.Encode(strm);
  if (HasOptionalField(e_password))
    m_password.Encode(strm);
  if (HasOptionalField(e_dhkey))
    m_dhkey.Encode(strm);
  if (HasOptionalField(e_challenge))
    m_challenge.Encode(strm);
  if (HasOptionalField(e_random))
    m_random.Encode(strm);
  if (HasOptionalField(e_certificate))
    m_certificate.Encode(strm);
  if (HasOptionalField(e_generalID))
    m_generalID.Encode(strm);
  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
}


PObject * H235_ClearToken::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H235_ClearToken::Class()), PInvalidCast);
#endif
  return new H235_ClearToken(*this);
}


#ifdef USE_FOR_ETHEREAL
void H235_ClearToken::preShowEthereal( void )
{
  m_tokenOID.preShowEthereal( );
  if ( HasOptionalField( e_timeStamp ) ) 
      m_timeStamp.preShowEthereal( );
  if ( HasOptionalField( e_password ) ) 
      m_password.preShowEthereal( );
  if ( HasOptionalField( e_dhkey ) ) 
      m_dhkey.preShowEthereal( );
  if ( HasOptionalField( e_challenge ) ) 
      m_challenge.preShowEthereal( );
  if ( HasOptionalField( e_random ) ) 
      m_random.preShowEthereal( );
  if ( HasOptionalField( e_certificate ) ) 
      m_certificate.preShowEthereal( );
  if ( HasOptionalField( e_generalID ) ) 
      m_generalID.preShowEthereal( );
  if ( HasOptionalField( e_nonStandard ) ) 
      m_nonStandard.preShowEthereal( );
}

PString H235_ClearToken::getSummary( void ) 
{
  return PString( "ClearToken" );
}

void H235_ClearToken::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* ptokenOID = m_tokenOID.getValue();
  proto_tree_add_string( tree, hCont->h235_0.hf_h235_ClearToken_tokenOID, tvb, offset + m_tokenOID.GetStartByte(), m_tokenOID.GetByteLength() , ptokenOID );
  delete[] ptokenOID;

  if ( HasOptionalField( e_timeStamp ) ) {
    proto_tree_add_uint( tree, hCont->h235_0.hf_h235_ClearToken_timeStamp, tvb, offset + m_timeStamp.GetStartByte(), m_timeStamp.GetByteLength() , m_timeStamp.GetValue() );
  }

  if ( HasOptionalField( e_password ) ) {
    char* ppassword = m_password.getValue();
    proto_tree_add_string( tree, hCont->h235_0.hf_h235_ClearToken_password, tvb, offset + m_password.GetStartByte(), m_password.GetByteLength() , ppassword );
    delete[] ppassword;
  }

  if ( HasOptionalField( e_dhkey ) ) {
    proto_tree *dhkey_tree = (proto_tree*) NULL;
    proto_item *dhkey_ti = (proto_item*) NULL;
    dhkey_ti = proto_tree_add_text( tree, tvb, offset + m_dhkey.GetStartByte(), m_dhkey.GetByteLength(), "dhkey (DHset)" );
    dhkey_tree = proto_item_add_subtree( dhkey_ti, hCont->h235_0.ett_h235_ClearToken_dhkey );
    m_dhkey.showEthereal( dhkey_tree, tvb, offset );
  }

  if ( HasOptionalField( e_challenge ) ) {
    char* pchallenge = m_challenge.getValue();
    proto_tree_add_string( tree, hCont->h235_0.hf_h235_ClearToken_challenge, tvb, offset + m_challenge.GetStartByte(), m_challenge.GetByteLength() , pchallenge );
    delete[] pchallenge;
  }

  if ( HasOptionalField( e_random ) ) {
    proto_tree_add_uint( tree, hCont->h235_0.hf_h235_ClearToken_random, tvb, offset + m_random.GetStartByte(), m_random.GetByteLength() , m_random.GetValue() );
  }

  if ( HasOptionalField( e_certificate ) ) {
    proto_tree *certificate_tree = (proto_tree*) NULL;
    proto_item *certificate_ti = (proto_item*) NULL;
    certificate_ti = proto_tree_add_text( tree, tvb, offset + m_certificate.GetStartByte(), m_certificate.GetByteLength(), "certificate (TypedCertificate)" );
    certificate_tree = proto_item_add_subtree( certificate_ti, hCont->h235_0.ett_h235_ClearToken_certificate );
    m_certificate.showEthereal( certificate_tree, tvb, offset );
  }

  if ( HasOptionalField( e_generalID ) ) {
    char* pgeneralID = m_generalID.getValue();
    proto_tree_add_string( tree, hCont->h235_0.hf_h235_ClearToken_generalID, tvb, offset + m_generalID.GetStartByte(), m_generalID.GetByteLength() , pgeneralID );
    delete[] pgeneralID;
  }

  if ( HasOptionalField( e_nonStandard ) ) {
    proto_tree *nonStandard_tree = (proto_tree*) NULL;
    proto_item *nonStandard_ti = (proto_item*) NULL;
    nonStandard_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandard.GetStartByte(), m_nonStandard.GetByteLength(), "nonStandard (NonStandardParameter)" );
    nonStandard_tree = proto_item_add_subtree( nonStandard_ti, hCont->h235_0.ett_h235_ClearToken_nonStandard );
    m_nonStandard.showEthereal( nonStandard_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// IV8
//

H235_IV8::H235_IV8(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_OctetString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 8, 8);
}


H235_IV8 & H235_IV8::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H235_IV8 & H235_IV8::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H235_IV8 & H235_IV8::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H235_IV8::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H235_IV8::Class()), PInvalidCast);
#endif
  return new H235_IV8(*this);
}


//
// Params
//

H235_Params::H235_Params(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H235_Params::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_ranInt))
    strm << setw(indent+9) << "ranInt = " << setprecision(indent) << m_ranInt << '\n';
  if (HasOptionalField(e_iv8))
    strm << setw(indent+6) << "iv8 = " << setprecision(indent) << m_iv8 << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H235_Params::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H235_Params::Class()), PInvalidCast);
#endif
  const H235_Params & other = (const H235_Params &)obj;

  Comparison result;

  if ((result = m_ranInt.Compare(other.m_ranInt)) != EqualTo)
    return result;
  if ((result = m_iv8.Compare(other.m_iv8)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H235_Params::GetDataLength() const
{
  return m_ranInt.GetObjectLength() +
         m_iv8.GetObjectLength();
}


BOOL H235_Params::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_ranInt ) && !m_ranInt.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_iv8 ) && !m_iv8.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H235_Params::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_ranInt))
    m_ranInt.Encode(strm);
  if (HasOptionalField(e_iv8))
    m_iv8.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_ranInt))
    m_ranInt.Encode(strm);
  if (HasOptionalField(e_iv8))
    m_iv8.Encode(strm);
}


PObject * H235_Params::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H235_Params::Class()), PInvalidCast);
#endif
  return new H235_Params(*this);
}


#ifdef USE_FOR_ETHEREAL
void H235_Params::preShowEthereal( void )
{
  if ( HasOptionalField( e_ranInt ) ) 
      m_ranInt.preShowEthereal( );
  if ( HasOptionalField( e_iv8 ) ) 
      m_iv8.preShowEthereal( );
}

PString H235_Params::getSummary( void ) 
{
  return PString( "Params" );
}

void H235_Params::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_ranInt ) ) {
    proto_tree_add_uint( tree, hCont->h235_0.hf_h235_Params_ranInt, tvb, offset + m_ranInt.GetStartByte(), m_ranInt.GetByteLength() , m_ranInt.GetValue() );
  }

  if ( HasOptionalField( e_iv8 ) ) {
    char* piv8 = m_iv8.getValue();
    proto_tree_add_string( tree, hCont->h235_0.hf_h235_Params_iv8, tvb, offset + m_iv8.GetStartByte(), m_iv8.GetByteLength() , piv8 );
    delete[] piv8;
  }

}
#endif  //USE_FOR_ETHEREAL

//
// PwdCertToken
//

H235_PwdCertToken::H235_PwdCertToken(unsigned tag, PASN_Object::TagClass tagClass)
  : H235_ClearToken(tag, tagClass)
{
  IncludeOptionalField(e_generalID);
  IncludeOptionalField(e_timeStamp);
}


PObject * H235_PwdCertToken::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H235_PwdCertToken::Class()), PInvalidCast);
#endif
  return new H235_PwdCertToken(*this);
}


//
// KeySyncMaterial
//

H235_KeySyncMaterial::H235_KeySyncMaterial(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H235_KeySyncMaterial::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "generalID = " << setprecision(indent) << m_generalID << '\n';
  strm << setw(indent+14) << "keyMaterial = " << setprecision(indent) << m_keyMaterial << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H235_KeySyncMaterial::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H235_KeySyncMaterial::Class()), PInvalidCast);
#endif
  const H235_KeySyncMaterial & other = (const H235_KeySyncMaterial &)obj;

  Comparison result;

  if ((result = m_generalID.Compare(other.m_generalID)) != EqualTo)
    return result;
  if ((result = m_keyMaterial.Compare(other.m_keyMaterial)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H235_KeySyncMaterial::GetDataLength() const
{
  return m_generalID.GetObjectLength() +
         m_keyMaterial.GetObjectLength();
}


BOOL H235_KeySyncMaterial::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_generalID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_keyMaterial.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H235_KeySyncMaterial::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_generalID.Encode(strm);
  m_keyMaterial.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_generalID.Encode(strm);
  m_keyMaterial.Encode(strm);
}


PObject * H235_KeySyncMaterial::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H235_KeySyncMaterial::Class()), PInvalidCast);
#endif
  return new H235_KeySyncMaterial(*this);
}


#ifdef USE_FOR_ETHEREAL
void H235_KeySyncMaterial::preShowEthereal( void )
{
  m_generalID.preShowEthereal( );
  m_keyMaterial.preShowEthereal( );
}

PString H235_KeySyncMaterial::getSummary( void ) 
{
  return PString( "KeySyncMaterial" );
}

void H235_KeySyncMaterial::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pgeneralID = m_generalID.getValue();
  proto_tree_add_string( tree, hCont->h235_0.hf_h235_KeySyncMaterial_generalID, tvb, offset + m_generalID.GetStartByte(), m_generalID.GetByteLength() , pgeneralID );
  delete[] pgeneralID;

  char* pkeyMaterial = m_keyMaterial.getValue();
  proto_tree_add_string( tree, hCont->h235_0.hf_h235_KeySyncMaterial_keyMaterial, tvb, offset + m_keyMaterial.GetStartByte(), m_keyMaterial.GetByteLength() , pkeyMaterial );
  delete[] pkeyMaterial;

}
#endif  //USE_FOR_ETHEREAL

//
// ReturnSig
//

H235_ReturnSig::H235_ReturnSig(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H235_ReturnSig::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "generalId = " << setprecision(indent) << m_generalId << '\n';
  strm << setw(indent+17) << "responseRandom = " << setprecision(indent) << m_responseRandom << '\n';
  if (HasOptionalField(e_requestRandom))
    strm << setw(indent+16) << "requestRandom = " << setprecision(indent) << m_requestRandom << '\n';
  if (HasOptionalField(e_certificate))
    strm << setw(indent+14) << "certificate = " << setprecision(indent) << m_certificate << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H235_ReturnSig::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H235_ReturnSig::Class()), PInvalidCast);
#endif
  const H235_ReturnSig & other = (const H235_ReturnSig &)obj;

  Comparison result;

  if ((result = m_generalId.Compare(other.m_generalId)) != EqualTo)
    return result;
  if ((result = m_responseRandom.Compare(other.m_responseRandom)) != EqualTo)
    return result;
  if ((result = m_requestRandom.Compare(other.m_requestRandom)) != EqualTo)
    return result;
  if ((result = m_certificate.Compare(other.m_certificate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H235_ReturnSig::GetDataLength() const
{
  return m_generalId.GetObjectLength() +
         m_responseRandom.GetObjectLength() +
         m_requestRandom.GetObjectLength() +
         m_certificate.GetObjectLength();
}


BOOL H235_ReturnSig::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_generalId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_responseRandom.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_requestRandom ) && !m_requestRandom.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_certificate ) && !m_certificate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H235_ReturnSig::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_generalId.Encode(strm);
  m_responseRandom.Encode(strm);
  if (HasOptionalField(e_requestRandom))
    m_requestRandom.Encode(strm);
  if (HasOptionalField(e_certificate))
    m_certificate.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_generalId.Encode(strm);
  m_responseRandom.Encode(strm);
  if (HasOptionalField(e_requestRandom))
    m_requestRandom.Encode(strm);
  if (HasOptionalField(e_certificate))
    m_certificate.Encode(strm);
}


PObject * H235_ReturnSig::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H235_ReturnSig::Class()), PInvalidCast);
#endif
  return new H235_ReturnSig(*this);
}


#ifdef USE_FOR_ETHEREAL
void H235_ReturnSig::preShowEthereal( void )
{
  m_generalId.preShowEthereal( );
  m_responseRandom.preShowEthereal( );
  if ( HasOptionalField( e_requestRandom ) ) 
      m_requestRandom.preShowEthereal( );
  if ( HasOptionalField( e_certificate ) ) 
      m_certificate.preShowEthereal( );
}

PString H235_ReturnSig::getSummary( void ) 
{
  return PString( "ReturnSig" );
}

void H235_ReturnSig::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pgeneralId = m_generalId.getValue();
  proto_tree_add_string( tree, hCont->h235_0.hf_h235_ReturnSig_generalId, tvb, offset + m_generalId.GetStartByte(), m_generalId.GetByteLength() , pgeneralId );
  delete[] pgeneralId;

  proto_tree_add_uint( tree, hCont->h235_0.hf_h235_ReturnSig_responseRandom, tvb, offset + m_responseRandom.GetStartByte(), m_responseRandom.GetByteLength() , m_responseRandom.GetValue() );

  if ( HasOptionalField( e_requestRandom ) ) {
    proto_tree_add_uint( tree, hCont->h235_0.hf_h235_ReturnSig_requestRandom, tvb, offset + m_requestRandom.GetStartByte(), m_requestRandom.GetByteLength() , m_requestRandom.GetValue() );
  }

  if ( HasOptionalField( e_certificate ) ) {
    proto_tree *certificate_tree = (proto_tree*) NULL;
    proto_item *certificate_ti = (proto_item*) NULL;
    certificate_ti = proto_tree_add_text( tree, tvb, offset + m_certificate.GetStartByte(), m_certificate.GetByteLength(), "certificate (TypedCertificate)" );
    certificate_tree = proto_item_add_subtree( certificate_ti, hCont->h235_0.ett_h235_ReturnSig_certificate );
    m_certificate.showEthereal( certificate_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CryptoToken
//

H235_CryptoToken::H235_CryptoToken(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "cryptoEncryptedToken "
        "cryptoSignedToken "
        "cryptoHashedToken "
        "cryptoPwdEncr "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H235_CryptoToken::operator H235_CryptoToken_cryptoEncryptedToken &() const
#else
H235_CryptoToken::operator H235_CryptoToken_cryptoEncryptedToken &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_CryptoToken_cryptoEncryptedToken::Class()), PInvalidCast);
#endif
  return *(H235_CryptoToken_cryptoEncryptedToken *)choice;
}


H235_CryptoToken::operator const H235_CryptoToken_cryptoEncryptedToken &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_CryptoToken_cryptoEncryptedToken::Class()), PInvalidCast);
#endif
  return *(H235_CryptoToken_cryptoEncryptedToken *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H235_CryptoToken::operator H235_CryptoToken_cryptoSignedToken &() const
#else
H235_CryptoToken::operator H235_CryptoToken_cryptoSignedToken &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_CryptoToken_cryptoSignedToken::Class()), PInvalidCast);
#endif
  return *(H235_CryptoToken_cryptoSignedToken *)choice;
}


H235_CryptoToken::operator const H235_CryptoToken_cryptoSignedToken &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_CryptoToken_cryptoSignedToken::Class()), PInvalidCast);
#endif
  return *(H235_CryptoToken_cryptoSignedToken *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H235_CryptoToken::operator H235_CryptoToken_cryptoHashedToken &() const
#else
H235_CryptoToken::operator H235_CryptoToken_cryptoHashedToken &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_CryptoToken_cryptoHashedToken::Class()), PInvalidCast);
#endif
  return *(H235_CryptoToken_cryptoHashedToken *)choice;
}


H235_CryptoToken::operator const H235_CryptoToken_cryptoHashedToken &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_CryptoToken_cryptoHashedToken::Class()), PInvalidCast);
#endif
  return *(H235_CryptoToken_cryptoHashedToken *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H235_CryptoToken::operator H235_ENCRYPTED<H235_EncodedPwdCertToken> &() const
#else
H235_CryptoToken::operator H235_ENCRYPTED<H235_EncodedPwdCertToken> &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_ENCRYPTED<H235_EncodedPwdCertToken>::Class()), PInvalidCast);
#endif
  return *(H235_ENCRYPTED<H235_EncodedPwdCertToken> *)choice;
}


H235_CryptoToken::operator const H235_ENCRYPTED<H235_EncodedPwdCertToken> &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_ENCRYPTED<H235_EncodedPwdCertToken>::Class()), PInvalidCast);
#endif
  return *(H235_ENCRYPTED<H235_EncodedPwdCertToken> *)choice;
}


BOOL H235_CryptoToken::CreateObject()
{
  switch (tag) {
    case e_cryptoEncryptedToken :
      choice = new H235_CryptoToken_cryptoEncryptedToken();
      return TRUE;
    case e_cryptoSignedToken :
      choice = new H235_CryptoToken_cryptoSignedToken();
      return TRUE;
    case e_cryptoHashedToken :
      choice = new H235_CryptoToken_cryptoHashedToken();
      return TRUE;
    case e_cryptoPwdEncr :
      choice = new H235_ENCRYPTED<H235_EncodedPwdCertToken>();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H235_CryptoToken::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H235_CryptoToken::Class()), PInvalidCast);
#endif
  return new H235_CryptoToken(*this);
}


#ifdef USE_FOR_ETHEREAL
void H235_CryptoToken::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_cryptoEncryptedToken :
        ( ( H235_CryptoToken_cryptoEncryptedToken * ) choice )->preShowEthereal();
        break;
      case e_cryptoSignedToken :
        ( ( H235_CryptoToken_cryptoSignedToken * ) choice )->preShowEthereal();
        break;
      case e_cryptoHashedToken :
        ( ( H235_CryptoToken_cryptoHashedToken * ) choice )->preShowEthereal();
        break;
      case e_cryptoPwdEncr :
        ( ( H235_ENCRYPTED<H235_EncodedPwdCertToken> * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H235_CryptoToken::getSummary( void ) 
{
  return PString( "CryptoToken" );
}

void H235_CryptoToken::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h235_0.ett_h235_CryptoToken_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// KeySignedMaterial
//

H235_KeySignedMaterial::H235_KeySignedMaterial(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H235_KeySignedMaterial::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "generalId = " << setprecision(indent) << m_generalId << '\n';
  strm << setw(indent+10) << "mrandom = " << setprecision(indent) << m_mrandom << '\n';
  if (HasOptionalField(e_srandom))
    strm << setw(indent+10) << "srandom = " << setprecision(indent) << m_srandom << '\n';
  if (HasOptionalField(e_timeStamp))
    strm << setw(indent+12) << "timeStamp = " << setprecision(indent) << m_timeStamp << '\n';
  strm << setw(indent+12) << "encrptval = " << setprecision(indent) << m_encrptval << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H235_KeySignedMaterial::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H235_KeySignedMaterial::Class()), PInvalidCast);
#endif
  const H235_KeySignedMaterial & other = (const H235_KeySignedMaterial &)obj;

  Comparison result;

  if ((result = m_generalId.Compare(other.m_generalId)) != EqualTo)
    return result;
  if ((result = m_mrandom.Compare(other.m_mrandom)) != EqualTo)
    return result;
  if ((result = m_srandom.Compare(other.m_srandom)) != EqualTo)
    return result;
  if ((result = m_timeStamp.Compare(other.m_timeStamp)) != EqualTo)
    return result;
  if ((result = m_encrptval.Compare(other.m_encrptval)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H235_KeySignedMaterial::GetDataLength() const
{
  return m_generalId.GetObjectLength() +
         m_mrandom.GetObjectLength() +
         m_srandom.GetObjectLength() +
         m_timeStamp.GetObjectLength() +
         m_encrptval.GetObjectLength();
}


BOOL H235_KeySignedMaterial::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_generalId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_mrandom.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_srandom ) && !m_srandom.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_timeStamp ) && !m_timeStamp.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_encrptval.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H235_KeySignedMaterial::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_generalId.Encode(strm);
  m_mrandom.Encode(strm);
  if (HasOptionalField(e_srandom))
    m_srandom.Encode(strm);
  if (HasOptionalField(e_timeStamp))
    m_timeStamp.Encode(strm);
  m_encrptval.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_generalId.Encode(strm);
  m_mrandom.Encode(strm);
  if (HasOptionalField(e_srandom))
    m_srandom.Encode(strm);
  if (HasOptionalField(e_timeStamp))
    m_timeStamp.Encode(strm);
  m_encrptval.Encode(strm);
}


PObject * H235_KeySignedMaterial::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H235_KeySignedMaterial::Class()), PInvalidCast);
#endif
  return new H235_KeySignedMaterial(*this);
}


#ifdef USE_FOR_ETHEREAL
void H235_KeySignedMaterial::preShowEthereal( void )
{
  m_generalId.preShowEthereal( );
  m_mrandom.preShowEthereal( );
  if ( HasOptionalField( e_srandom ) ) 
      m_srandom.preShowEthereal( );
  if ( HasOptionalField( e_timeStamp ) ) 
      m_timeStamp.preShowEthereal( );
  m_encrptval.preShowEthereal( );
}

PString H235_KeySignedMaterial::getSummary( void ) 
{
  return PString( "KeySignedMaterial" );
}

void H235_KeySignedMaterial::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pgeneralId = m_generalId.getValue();
  proto_tree_add_string( tree, hCont->h235_0.hf_h235_KeySignedMaterial_generalId, tvb, offset + m_generalId.GetStartByte(), m_generalId.GetByteLength() , pgeneralId );
  delete[] pgeneralId;

  proto_tree_add_uint( tree, hCont->h235_0.hf_h235_KeySignedMaterial_mrandom, tvb, offset + m_mrandom.GetStartByte(), m_mrandom.GetByteLength() , m_mrandom.GetValue() );

  if ( HasOptionalField( e_srandom ) ) {
    proto_tree_add_uint( tree, hCont->h235_0.hf_h235_KeySignedMaterial_srandom, tvb, offset + m_srandom.GetStartByte(), m_srandom.GetByteLength() , m_srandom.GetValue() );
  }

  if ( HasOptionalField( e_timeStamp ) ) {
    proto_tree_add_uint( tree, hCont->h235_0.hf_h235_KeySignedMaterial_timeStamp, tvb, offset + m_timeStamp.GetStartByte(), m_timeStamp.GetByteLength() , m_timeStamp.GetValue() );
  }

  proto_tree *encrptval_tree = (proto_tree*) NULL;
  proto_item *encrptval_ti = (proto_item*) NULL;
  encrptval_ti = proto_tree_add_text( tree, tvb, offset + m_encrptval.GetStartByte(), m_encrptval.GetByteLength(), "encrptval (ENCRYPTED<H235-EncodedKeySyncMaterial>)" );
  encrptval_tree = proto_item_add_subtree( encrptval_ti, hCont->h235_0.ett_h235_KeySignedMaterial_encrptval );

  m_encrptval.showEthereal( encrptval_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// H235CertificateSignature
//

H235_H235CertificateSignature::H235_H235CertificateSignature(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H235_H235CertificateSignature::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "certificate = " << setprecision(indent) << m_certificate << '\n';
  strm << setw(indent+17) << "responseRandom = " << setprecision(indent) << m_responseRandom << '\n';
  if (HasOptionalField(e_requesterRandom))
    strm << setw(indent+18) << "requesterRandom = " << setprecision(indent) << m_requesterRandom << '\n';
  strm << setw(indent+12) << "signature = " << setprecision(indent) << m_signature << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H235_H235CertificateSignature::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H235_H235CertificateSignature::Class()), PInvalidCast);
#endif
  const H235_H235CertificateSignature & other = (const H235_H235CertificateSignature &)obj;

  Comparison result;

  if ((result = m_certificate.Compare(other.m_certificate)) != EqualTo)
    return result;
  if ((result = m_responseRandom.Compare(other.m_responseRandom)) != EqualTo)
    return result;
  if ((result = m_requesterRandom.Compare(other.m_requesterRandom)) != EqualTo)
    return result;
  if ((result = m_signature.Compare(other.m_signature)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H235_H235CertificateSignature::GetDataLength() const
{
  return m_certificate.GetObjectLength() +
         m_responseRandom.GetObjectLength() +
         m_requesterRandom.GetObjectLength() +
         m_signature.GetObjectLength();
}


BOOL H235_H235CertificateSignature::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_certificate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_responseRandom.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_requesterRandom ) && !m_requesterRandom.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_signature.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H235_H235CertificateSignature::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_certificate.Encode(strm);
  m_responseRandom.Encode(strm);
  if (HasOptionalField(e_requesterRandom))
    m_requesterRandom.Encode(strm);
  m_signature.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_certificate.Encode(strm);
  m_responseRandom.Encode(strm);
  if (HasOptionalField(e_requesterRandom))
    m_requesterRandom.Encode(strm);
  m_signature.Encode(strm);
}


PObject * H235_H235CertificateSignature::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H235_H235CertificateSignature::Class()), PInvalidCast);
#endif
  return new H235_H235CertificateSignature(*this);
}


#ifdef USE_FOR_ETHEREAL
void H235_H235CertificateSignature::preShowEthereal( void )
{
  m_certificate.preShowEthereal( );
  m_responseRandom.preShowEthereal( );
  if ( HasOptionalField( e_requesterRandom ) ) 
      m_requesterRandom.preShowEthereal( );
  m_signature.preShowEthereal( );
}

PString H235_H235CertificateSignature::getSummary( void ) 
{
  return PString( "H235CertificateSignature" );
}

void H235_H235CertificateSignature::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *certificate_tree = (proto_tree*) NULL;
  proto_item *certificate_ti = (proto_item*) NULL;
  certificate_ti = proto_tree_add_text( tree, tvb, offset + m_certificate.GetStartByte(), m_certificate.GetByteLength(), "certificate (TypedCertificate)" );
  certificate_tree = proto_item_add_subtree( certificate_ti, hCont->h235_0.ett_h235_H235CertificateSignature_certificate );

  m_certificate.showEthereal( certificate_tree, tvb, offset );

  proto_tree_add_uint( tree, hCont->h235_0.hf_h235_H235CertificateSignature_responseRandom, tvb, offset + m_responseRandom.GetStartByte(), m_responseRandom.GetByteLength() , m_responseRandom.GetValue() );

  if ( HasOptionalField( e_requesterRandom ) ) {
    proto_tree_add_uint( tree, hCont->h235_0.hf_h235_H235CertificateSignature_requesterRandom, tvb, offset + m_requesterRandom.GetStartByte(), m_requesterRandom.GetByteLength() , m_requesterRandom.GetValue() );
  }

  proto_tree *signature_tree = (proto_tree*) NULL;
  proto_item *signature_ti = (proto_item*) NULL;
  signature_ti = proto_tree_add_text( tree, tvb, offset + m_signature.GetStartByte(), m_signature.GetByteLength(), "signature (SIGNED<H235-EncodedReturnSig>)" );
  signature_tree = proto_item_add_subtree( signature_ti, hCont->h235_0.ett_h235_H235CertificateSignature_signature );

  m_signature.showEthereal( signature_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// CryptoToken_cryptoEncryptedToken
//

H235_CryptoToken_cryptoEncryptedToken::H235_CryptoToken_cryptoEncryptedToken(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H235_CryptoToken_cryptoEncryptedToken::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "tokenOID = " << setprecision(indent) << m_tokenOID << '\n';
  strm << setw(indent+8) << "token = " << setprecision(indent) << m_token << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H235_CryptoToken_cryptoEncryptedToken::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H235_CryptoToken_cryptoEncryptedToken::Class()), PInvalidCast);
#endif
  const H235_CryptoToken_cryptoEncryptedToken & other = (const H235_CryptoToken_cryptoEncryptedToken &)obj;

  Comparison result;

  if ((result = m_tokenOID.Compare(other.m_tokenOID)) != EqualTo)
    return result;
  if ((result = m_token.Compare(other.m_token)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H235_CryptoToken_cryptoEncryptedToken::GetDataLength() const
{
  return m_tokenOID.GetObjectLength() +
         m_token.GetObjectLength();
}


BOOL H235_CryptoToken_cryptoEncryptedToken::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_tokenOID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_token.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H235_CryptoToken_cryptoEncryptedToken::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_tokenOID.Encode(strm);
  m_token.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_tokenOID.Encode(strm);
  m_token.Encode(strm);
}


PObject * H235_CryptoToken_cryptoEncryptedToken::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H235_CryptoToken_cryptoEncryptedToken::Class()), PInvalidCast);
#endif
  return new H235_CryptoToken_cryptoEncryptedToken(*this);
}


#ifdef USE_FOR_ETHEREAL
void H235_CryptoToken_cryptoEncryptedToken::preShowEthereal( void )
{
  m_tokenOID.preShowEthereal( );
  m_token.preShowEthereal( );
}

PString H235_CryptoToken_cryptoEncryptedToken::getSummary( void ) 
{
  return PString( "CryptoToken_cryptoEncryptedToken" );
}

void H235_CryptoToken_cryptoEncryptedToken::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* ptokenOID = m_tokenOID.getValue();
  proto_tree_add_string( tree, hCont->h235_0.hf_h235_CryptoToken_cryptoEncryptedToken_tokenOID, tvb, offset + m_tokenOID.GetStartByte(), m_tokenOID.GetByteLength() , ptokenOID );
  delete[] ptokenOID;

  proto_tree *token_tree = (proto_tree*) NULL;
  proto_item *token_ti = (proto_item*) NULL;
  token_ti = proto_tree_add_text( tree, tvb, offset + m_token.GetStartByte(), m_token.GetByteLength(), "token (ENCRYPTED<H235-EncodedGeneralToken>)" );
  token_tree = proto_item_add_subtree( token_ti, hCont->h235_0.ett_h235_CryptoToken_cryptoEncryptedToken_token );

  m_token.showEthereal( token_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// CryptoToken_cryptoSignedToken
//

H235_CryptoToken_cryptoSignedToken::H235_CryptoToken_cryptoSignedToken(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H235_CryptoToken_cryptoSignedToken::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "tokenOID = " << setprecision(indent) << m_tokenOID << '\n';
  strm << setw(indent+8) << "token = " << setprecision(indent) << m_token << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H235_CryptoToken_cryptoSignedToken::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H235_CryptoToken_cryptoSignedToken::Class()), PInvalidCast);
#endif
  const H235_CryptoToken_cryptoSignedToken & other = (const H235_CryptoToken_cryptoSignedToken &)obj;

  Comparison result;

  if ((result = m_tokenOID.Compare(other.m_tokenOID)) != EqualTo)
    return result;
  if ((result = m_token.Compare(other.m_token)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H235_CryptoToken_cryptoSignedToken::GetDataLength() const
{
  return m_tokenOID.GetObjectLength() +
         m_token.GetObjectLength();
}


BOOL H235_CryptoToken_cryptoSignedToken::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_tokenOID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_token.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H235_CryptoToken_cryptoSignedToken::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_tokenOID.Encode(strm);
  m_token.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_tokenOID.Encode(strm);
  m_token.Encode(strm);
}


PObject * H235_CryptoToken_cryptoSignedToken::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H235_CryptoToken_cryptoSignedToken::Class()), PInvalidCast);
#endif
  return new H235_CryptoToken_cryptoSignedToken(*this);
}


#ifdef USE_FOR_ETHEREAL
void H235_CryptoToken_cryptoSignedToken::preShowEthereal( void )
{
  m_tokenOID.preShowEthereal( );
  m_token.preShowEthereal( );
}

PString H235_CryptoToken_cryptoSignedToken::getSummary( void ) 
{
  return PString( "CryptoToken_cryptoSignedToken" );
}

void H235_CryptoToken_cryptoSignedToken::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* ptokenOID = m_tokenOID.getValue();
  proto_tree_add_string( tree, hCont->h235_0.hf_h235_CryptoToken_cryptoSignedToken_tokenOID, tvb, offset + m_tokenOID.GetStartByte(), m_tokenOID.GetByteLength() , ptokenOID );
  delete[] ptokenOID;

  proto_tree *token_tree = (proto_tree*) NULL;
  proto_item *token_ti = (proto_item*) NULL;
  token_ti = proto_tree_add_text( tree, tvb, offset + m_token.GetStartByte(), m_token.GetByteLength(), "token (SIGNED<H235-EncodedGeneralToken>)" );
  token_tree = proto_item_add_subtree( token_ti, hCont->h235_0.ett_h235_CryptoToken_cryptoSignedToken_token );

  m_token.showEthereal( token_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// CryptoToken_cryptoHashedToken
//

H235_CryptoToken_cryptoHashedToken::H235_CryptoToken_cryptoHashedToken(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H235_CryptoToken_cryptoHashedToken::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "tokenOID = " << setprecision(indent) << m_tokenOID << '\n';
  strm << setw(indent+13) << "hashedVals = " << setprecision(indent) << m_hashedVals << '\n';
  strm << setw(indent+8) << "token = " << setprecision(indent) << m_token << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H235_CryptoToken_cryptoHashedToken::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H235_CryptoToken_cryptoHashedToken::Class()), PInvalidCast);
#endif
  const H235_CryptoToken_cryptoHashedToken & other = (const H235_CryptoToken_cryptoHashedToken &)obj;

  Comparison result;

  if ((result = m_tokenOID.Compare(other.m_tokenOID)) != EqualTo)
    return result;
  if ((result = m_hashedVals.Compare(other.m_hashedVals)) != EqualTo)
    return result;
  if ((result = m_token.Compare(other.m_token)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H235_CryptoToken_cryptoHashedToken::GetDataLength() const
{
  return m_tokenOID.GetObjectLength() +
         m_hashedVals.GetObjectLength() +
         m_token.GetObjectLength();
}


BOOL H235_CryptoToken_cryptoHashedToken::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_tokenOID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_hashedVals.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_token.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H235_CryptoToken_cryptoHashedToken::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_tokenOID.Encode(strm);
  m_hashedVals.Encode(strm);
  m_token.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_tokenOID.Encode(strm);
  m_hashedVals.Encode(strm);
  m_token.Encode(strm);
}


PObject * H235_CryptoToken_cryptoHashedToken::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H235_CryptoToken_cryptoHashedToken::Class()), PInvalidCast);
#endif
  return new H235_CryptoToken_cryptoHashedToken(*this);
}


#ifdef USE_FOR_ETHEREAL
void H235_CryptoToken_cryptoHashedToken::preShowEthereal( void )
{
  m_tokenOID.preShowEthereal( );
  m_hashedVals.preShowEthereal( );
  m_token.preShowEthereal( );
}

PString H235_CryptoToken_cryptoHashedToken::getSummary( void ) 
{
  return PString( "CryptoToken_cryptoHashedToken" );
}

void H235_CryptoToken_cryptoHashedToken::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* ptokenOID = m_tokenOID.getValue();
  proto_tree_add_string( tree, hCont->h235_0.hf_h235_CryptoToken_cryptoHashedToken_tokenOID, tvb, offset + m_tokenOID.GetStartByte(), m_tokenOID.GetByteLength() , ptokenOID );
  delete[] ptokenOID;

  proto_tree *hashedVals_tree = (proto_tree*) NULL;
  proto_item *hashedVals_ti = (proto_item*) NULL;
  hashedVals_ti = proto_tree_add_text( tree, tvb, offset + m_hashedVals.GetStartByte(), m_hashedVals.GetByteLength(), "hashedVals (ClearToken)" );
  hashedVals_tree = proto_item_add_subtree( hashedVals_ti, hCont->h235_0.ett_h235_CryptoToken_cryptoHashedToken_hashedVals );

  m_hashedVals.showEthereal( hashedVals_tree, tvb, offset );

  proto_tree *token_tree = (proto_tree*) NULL;
  proto_item *token_ti = (proto_item*) NULL;
  token_ti = proto_tree_add_text( tree, tvb, offset + m_token.GetStartByte(), m_token.GetByteLength(), "token (HASHED<H235-EncodedGeneralToken>)" );
  token_tree = proto_item_add_subtree( token_ti, hCont->h235_0.ett_h235_CryptoToken_cryptoHashedToken_token );

  m_token.showEthereal( token_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// H235Key
//

H235_H235Key::H235_H235Key(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "secureChannel "
        "sharedSecret "
        "certProtectedKey "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H235_H235Key::operator H235_KeyMaterial &() const
#else
H235_H235Key::operator H235_KeyMaterial &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_KeyMaterial::Class()), PInvalidCast);
#endif
  return *(H235_KeyMaterial *)choice;
}


H235_H235Key::operator const H235_KeyMaterial &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_KeyMaterial::Class()), PInvalidCast);
#endif
  return *(H235_KeyMaterial *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H235_H235Key::operator H235_ENCRYPTED<H235_EncodedKeySyncMaterial> &() const
#else
H235_H235Key::operator H235_ENCRYPTED<H235_EncodedKeySyncMaterial> &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_ENCRYPTED<H235_EncodedKeySyncMaterial>::Class()), PInvalidCast);
#endif
  return *(H235_ENCRYPTED<H235_EncodedKeySyncMaterial> *)choice;
}


H235_H235Key::operator const H235_ENCRYPTED<H235_EncodedKeySyncMaterial> &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_ENCRYPTED<H235_EncodedKeySyncMaterial>::Class()), PInvalidCast);
#endif
  return *(H235_ENCRYPTED<H235_EncodedKeySyncMaterial> *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H235_H235Key::operator H235_SIGNED<H235_EncodedKeySignedMaterial> &() const
#else
H235_H235Key::operator H235_SIGNED<H235_EncodedKeySignedMaterial> &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_SIGNED<H235_EncodedKeySignedMaterial>::Class()), PInvalidCast);
#endif
  return *(H235_SIGNED<H235_EncodedKeySignedMaterial> *)choice;
}


H235_H235Key::operator const H235_SIGNED<H235_EncodedKeySignedMaterial> &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_SIGNED<H235_EncodedKeySignedMaterial>::Class()), PInvalidCast);
#endif
  return *(H235_SIGNED<H235_EncodedKeySignedMaterial> *)choice;
}


BOOL H235_H235Key::CreateObject()
{
  switch (tag) {
    case e_secureChannel :
      choice = new H235_KeyMaterial();
      return TRUE;
    case e_sharedSecret :
      choice = new H235_ENCRYPTED<H235_EncodedKeySyncMaterial>();
      return TRUE;
    case e_certProtectedKey :
      choice = new H235_SIGNED<H235_EncodedKeySignedMaterial>();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H235_H235Key::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H235_H235Key::Class()), PInvalidCast);
#endif
  return new H235_H235Key(*this);
}


#ifdef USE_FOR_ETHEREAL
void H235_H235Key::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_secureChannel :
        ( ( H235_KeyMaterial * ) choice )->preShowEthereal();
        break;
      case e_sharedSecret :
        ( ( H235_ENCRYPTED<H235_EncodedKeySyncMaterial> * ) choice )->preShowEthereal();
        break;
      case e_certProtectedKey :
        ( ( H235_SIGNED<H235_EncodedKeySignedMaterial> * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H235_H235Key::getSummary( void ) 
{
  return PString( "H235Key" );
}

void H235_H235Key::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "secureChannel" ) == 0 ) {
      char* pstring = ( ( H235_KeyMaterial* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h235_0.hf_h235_H235Key_secureChannel, tvb, offset + ( ( H235_KeyMaterial* ) choice) ->GetStartByte(), ( ( H235_KeyMaterial* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h235_0.ett_h235_H235Key_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL


// End of h235.cxx
