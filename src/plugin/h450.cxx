/* 
 * h450.cxx
 *
 * Sources for decoding the H.450 protocol
 *
 * H.323 for Ethereal
 *
 * Copyright (c) 2002 Koninklijke Philips NV
 *
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.0 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is H.323 for Ethereal.
 *
 * The Initial Developer of the Original Code is Koninklijke Philips NV.
 *
 * All Rights Reserved.
 *
 * Contributor(s): ______________________________________.
 *
 *
 */

//
// h450.cxx
//
// Code automatically generated by asnparse.
//

#ifdef __GNUC__
#pragma implementation "h450.h"
#endif

#ifdef USE_FOR_ETHEREAL

extern "C" {

#  ifdef HAVE_CONFIG_H
#    include "config.h"
#  endif

#  include "plugins/plugin_api.h"

#  include "moduleinfo.h"

#  ifdef HAVE_SYS_TYPES_H
#    include <sys/types.h>
#  endif

#  include <string.h>
#  include <ctype.h>
#  include <time.h>

#  include <gmodule.h>
#  ifdef HAVE_NETINET_IN_H
#    include <netinet/in.h>
#  endif
#  include <epan/packet.h>
#include "packet-h450.h"
}

extern "C++" {
#  include <stdio.h>
#  include <string.h>
#  include "h450_container.h"
#  include "mini_ptlib/include/mini_ptlib.h"
#  include "h450.h"
}
#endif//USE_FOR_ETHEREAL

#ifndef USE_FOR_ETHEREAL
#  include <ptlib.h>
#  include "h450.h"
#endif //USE_FOR_ETHEREAL

#define new PNEW
static H450_Integer_Container* hCont;



void setH450Container( H450_Integer_Container* cont )
{
  hCont = cont;
}

//
// ROS
//

H450_ROS::H450_ROS(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, FALSE
#ifndef PASN_NOPRINTON
      , "invoke "
        "returnResult "
        "returnError "
        "reject "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_ROS::operator H450_Invoke &() const
#else
H450_ROS::operator H450_Invoke &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_Invoke::Class()), PInvalidCast);
#endif
  return *(H450_Invoke *)choice;
}


H450_ROS::operator const H450_Invoke &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_Invoke::Class()), PInvalidCast);
#endif
  return *(H450_Invoke *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_ROS::operator H450_ReturnResult &() const
#else
H450_ROS::operator H450_ReturnResult &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ReturnResult::Class()), PInvalidCast);
#endif
  return *(H450_ReturnResult *)choice;
}


H450_ROS::operator const H450_ReturnResult &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ReturnResult::Class()), PInvalidCast);
#endif
  return *(H450_ReturnResult *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_ROS::operator H450_ReturnError &() const
#else
H450_ROS::operator H450_ReturnError &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ReturnError::Class()), PInvalidCast);
#endif
  return *(H450_ReturnError *)choice;
}


H450_ROS::operator const H450_ReturnError &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ReturnError::Class()), PInvalidCast);
#endif
  return *(H450_ReturnError *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_ROS::operator H450_Reject &() const
#else
H450_ROS::operator H450_Reject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_Reject::Class()), PInvalidCast);
#endif
  return *(H450_Reject *)choice;
}


H450_ROS::operator const H450_Reject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_Reject::Class()), PInvalidCast);
#endif
  return *(H450_Reject *)choice;
}


BOOL H450_ROS::CreateObject()
{
  switch (tag) {
    case e_invoke :
      choice = new H450_Invoke(1, ContextSpecificTagClass);
      return TRUE;
    case e_returnResult :
      choice = new H450_ReturnResult(2, ContextSpecificTagClass);
      return TRUE;
    case e_returnError :
      choice = new H450_ReturnError(3, ContextSpecificTagClass);
      return TRUE;
    case e_reject :
      choice = new H450_Reject(4, ContextSpecificTagClass);
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_ROS::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_ROS::Class()), PInvalidCast);
#endif
  return new H450_ROS(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_ROS::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_invoke :
        ( ( H450_Invoke * ) choice )->preShowEthereal();
        break;
      case e_returnResult :
        ( ( H450_ReturnResult * ) choice )->preShowEthereal();
        break;
      case e_returnError :
        ( ( H450_ReturnError * ) choice )->preShowEthereal();
        break;
      case e_reject :
        ( ( H450_Reject * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_ROS::getSummary( void ) 
{
  return PString( "ROS" );
}

void H450_ROS::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h450_1.ett_h450_ROS_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// GeneralProblem
//

H450_GeneralProblem::H450_GeneralProblem(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
}


H450_GeneralProblem & H450_GeneralProblem::operator=(int v)
{
  SetValue(v);
  return *this;
}


H450_GeneralProblem & H450_GeneralProblem::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_GeneralProblem::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_GeneralProblem::Class()), PInvalidCast);
#endif
  return new H450_GeneralProblem(*this);
}


//
// InvokeProblem
//

H450_InvokeProblem::H450_InvokeProblem(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
}


H450_InvokeProblem & H450_InvokeProblem::operator=(int v)
{
  SetValue(v);
  return *this;
}


H450_InvokeProblem & H450_InvokeProblem::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_InvokeProblem::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_InvokeProblem::Class()), PInvalidCast);
#endif
  return new H450_InvokeProblem(*this);
}


//
// ReturnResultProblem
//

H450_ReturnResultProblem::H450_ReturnResultProblem(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
}


H450_ReturnResultProblem & H450_ReturnResultProblem::operator=(int v)
{
  SetValue(v);
  return *this;
}


H450_ReturnResultProblem & H450_ReturnResultProblem::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_ReturnResultProblem::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_ReturnResultProblem::Class()), PInvalidCast);
#endif
  return new H450_ReturnResultProblem(*this);
}


//
// ReturnErrorProblem
//

H450_ReturnErrorProblem::H450_ReturnErrorProblem(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
}


H450_ReturnErrorProblem & H450_ReturnErrorProblem::operator=(int v)
{
  SetValue(v);
  return *this;
}


H450_ReturnErrorProblem & H450_ReturnErrorProblem::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_ReturnErrorProblem::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_ReturnErrorProblem::Class()), PInvalidCast);
#endif
  return new H450_ReturnErrorProblem(*this);
}


//
// RejectProblem
//

H450_RejectProblem::H450_RejectProblem(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
}


H450_RejectProblem & H450_RejectProblem::operator=(int v)
{
  SetValue(v);
  return *this;
}


H450_RejectProblem & H450_RejectProblem::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_RejectProblem::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_RejectProblem::Class()), PInvalidCast);
#endif
  return new H450_RejectProblem(*this);
}


//
// InvokeId
//

H450_InvokeId::H450_InvokeId(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


H450_InvokeId & H450_InvokeId::operator=(int v)
{
  SetValue(v);
  return *this;
}


H450_InvokeId & H450_InvokeId::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_InvokeId::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_InvokeId::Class()), PInvalidCast);
#endif
  return new H450_InvokeId(*this);
}


//
// Code
//

H450_Code::H450_Code(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
      , "local "
        "global "
#endif
    )
{
}


BOOL H450_Code::CreateObject()
{
  switch (tag) {
    case e_local :
      choice = new PASN_Integer();
      return TRUE;
    case e_global :
      choice = new PASN_ObjectId();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_Code::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_Code::Class()), PInvalidCast);
#endif
  return new H450_Code(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_Code::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_local :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_global :
        ( ( PASN_ObjectId * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_Code::getSummary( void ) 
{
  return PString( "Code" );
}

void H450_Code::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "local" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h450_1.hf_h450_Code_local, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "global" ) == 0 ) {
      char* pstring = ( ( PASN_ObjectId* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_Code_global, tvb, offset + ( ( PASN_ObjectId* ) choice) ->GetStartByte(), ( ( PASN_ObjectId* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// EntityType
//

H450_EntityType::H450_EntityType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "endpoint "
        "anyEntity "
#endif
    )
{
}


BOOL H450_EntityType::CreateObject()
{
  switch (tag) {
    case e_endpoint :
    case e_anyEntity :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_EntityType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_EntityType::Class()), PInvalidCast);
#endif
  return new H450_EntityType(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_EntityType::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_endpoint :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_anyEntity :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_EntityType::getSummary( void ) 
{
  return PString( "EntityType" );
}

void H450_EntityType::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "endpoint" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_EntityType_endpoint, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "anyEntity" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_EntityType_anyEntity, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// AddressInformation
//

H450_AddressInformation::H450_AddressInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : H225_AliasAddress(tag, tagClass)
{
}


PObject * H450_AddressInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_AddressInformation::Class()), PInvalidCast);
#endif
  return new H450_AddressInformation(*this);
}


//
// InterpretationApdu
//

H450_InterpretationApdu::H450_InterpretationApdu(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "discardAnyUnrecognizedInvokePdu "
        "clearCallIfAnyInvokePduNotRecognized "
        "rejectAnyUnrecognizedInvokePdu "
#endif
    )
{
}


BOOL H450_InterpretationApdu::CreateObject()
{
  switch (tag) {
    case e_discardAnyUnrecognizedInvokePdu :
    case e_clearCallIfAnyInvokePduNotRecognized :
    case e_rejectAnyUnrecognizedInvokePdu :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_InterpretationApdu::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_InterpretationApdu::Class()), PInvalidCast);
#endif
  return new H450_InterpretationApdu(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_InterpretationApdu::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_discardAnyUnrecognizedInvokePdu :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_clearCallIfAnyInvokePduNotRecognized :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_rejectAnyUnrecognizedInvokePdu :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_InterpretationApdu::getSummary( void ) 
{
  return PString( "InterpretationApdu" );
}

void H450_InterpretationApdu::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "discardAnyUnrecognizedInvokePdu" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_InterpretationApdu_discardAnyUnrecognizedInvokePdu, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "clearCallIfAnyInvokePduNotRecognized" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_InterpretationApdu_clearCallIfAnyInvokePduNotRecognized, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "rejectAnyUnrecognizedInvokePdu" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_InterpretationApdu_rejectAnyUnrecognizedInvokePdu, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ServiceApdus
//

H450_ServiceApdus::H450_ServiceApdus(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
      , "rosApdus "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_ServiceApdus::operator H450_ArrayOf_ROS &() const
#else
H450_ServiceApdus::operator H450_ArrayOf_ROS &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ArrayOf_ROS::Class()), PInvalidCast);
#endif
  return *(H450_ArrayOf_ROS *)choice;
}


H450_ServiceApdus::operator const H450_ArrayOf_ROS &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ArrayOf_ROS::Class()), PInvalidCast);
#endif
  return *(H450_ArrayOf_ROS *)choice;
}


BOOL H450_ServiceApdus::CreateObject()
{
  switch (tag) {
    case e_rosApdus :
      choice = new H450_ArrayOf_ROS();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, MaximumValue);
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_ServiceApdus::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_ServiceApdus::Class()), PInvalidCast);
#endif
  return new H450_ServiceApdus(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_ServiceApdus::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_rosApdus :
        ( ( H450_ArrayOf_ROS * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_ServiceApdus::getSummary( void ) 
{
  return PString( "ServiceApdus" );
}

void H450_ServiceApdus::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h450_1.ett_h450_ServiceApdus_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// InvokeIdSet
//

H450_InvokeIdSet::H450_InvokeIdSet(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
}


H450_InvokeIdSet & H450_InvokeIdSet::operator=(int v)
{
  SetValue(v);
  return *this;
}


H450_InvokeIdSet & H450_InvokeIdSet::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_InvokeIdSet::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_InvokeIdSet::Class()), PInvalidCast);
#endif
  return new H450_InvokeIdSet(*this);
}


//
// InvokeIDs
//

H450_InvokeIDs::H450_InvokeIDs(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


H450_InvokeIDs & H450_InvokeIDs::operator=(int v)
{
  SetValue(v);
  return *this;
}


H450_InvokeIDs & H450_InvokeIDs::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_InvokeIDs::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_InvokeIDs::Class()), PInvalidCast);
#endif
  return new H450_InvokeIDs(*this);
}


//
// PresentedAddressScreened
//

H450_PresentedAddressScreened::H450_PresentedAddressScreened(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "presentationAllowedAddress "
        "presentationRestricted "
        "numberNotAvailableDueToInterworking "
        "presentationRestrictedAddress "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_PresentedAddressScreened::operator H450_AddressScreened &() const
#else
H450_PresentedAddressScreened::operator H450_AddressScreened &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_AddressScreened::Class()), PInvalidCast);
#endif
  return *(H450_AddressScreened *)choice;
}


H450_PresentedAddressScreened::operator const H450_AddressScreened &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_AddressScreened::Class()), PInvalidCast);
#endif
  return *(H450_AddressScreened *)choice;
}


BOOL H450_PresentedAddressScreened::CreateObject()
{
  switch (tag) {
    case e_presentationAllowedAddress :
    case e_presentationRestrictedAddress :
      choice = new H450_AddressScreened();
      return TRUE;
    case e_presentationRestricted :
    case e_numberNotAvailableDueToInterworking :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_PresentedAddressScreened::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_PresentedAddressScreened::Class()), PInvalidCast);
#endif
  return new H450_PresentedAddressScreened(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_PresentedAddressScreened::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_presentationAllowedAddress :
        ( ( H450_AddressScreened * ) choice )->preShowEthereal();
        break;
      case e_presentationRestricted :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_numberNotAvailableDueToInterworking :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_presentationRestrictedAddress :
        ( ( H450_AddressScreened * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_PresentedAddressScreened::getSummary( void ) 
{
  return PString( "PresentedAddressScreened" );
}

void H450_PresentedAddressScreened::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "presentationRestricted" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_PresentedAddressScreened_presentationRestricted, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "numberNotAvailableDueToInterworking" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_PresentedAddressScreened_numberNotAvailableDueToInterworking, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h450_1.ett_h450_PresentedAddressScreened_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// PresentedAddressUnscreened
//

H450_PresentedAddressUnscreened::H450_PresentedAddressUnscreened(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "presentationAllowedAddress "
        "presentationRestricted "
        "numberNotAvailableDueToInterworking "
        "presentationRestrictedAddress "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_PresentedAddressUnscreened::operator H450_Address &() const
#else
H450_PresentedAddressUnscreened::operator H450_Address &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_Address::Class()), PInvalidCast);
#endif
  return *(H450_Address *)choice;
}


H450_PresentedAddressUnscreened::operator const H450_Address &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_Address::Class()), PInvalidCast);
#endif
  return *(H450_Address *)choice;
}


BOOL H450_PresentedAddressUnscreened::CreateObject()
{
  switch (tag) {
    case e_presentationAllowedAddress :
    case e_presentationRestrictedAddress :
      choice = new H450_Address();
      return TRUE;
    case e_presentationRestricted :
    case e_numberNotAvailableDueToInterworking :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_PresentedAddressUnscreened::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_PresentedAddressUnscreened::Class()), PInvalidCast);
#endif
  return new H450_PresentedAddressUnscreened(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_PresentedAddressUnscreened::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_presentationAllowedAddress :
        ( ( H450_Address * ) choice )->preShowEthereal();
        break;
      case e_presentationRestricted :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_numberNotAvailableDueToInterworking :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_presentationRestrictedAddress :
        ( ( H450_Address * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_PresentedAddressUnscreened::getSummary( void ) 
{
  return PString( "PresentedAddressUnscreened" );
}

void H450_PresentedAddressUnscreened::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "presentationRestricted" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_PresentedAddressUnscreened_presentationRestricted, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "numberNotAvailableDueToInterworking" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_PresentedAddressUnscreened_numberNotAvailableDueToInterworking, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h450_1.ett_h450_PresentedAddressUnscreened_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// PresentedNumberScreened
//

H450_PresentedNumberScreened::H450_PresentedNumberScreened(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "presentationAllowedAddress "
        "presentationRestricted "
        "numberNotAvailableDueToInterworking "
        "presentationRestrictedAddress "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_PresentedNumberScreened::operator H450_NumberScreened &() const
#else
H450_PresentedNumberScreened::operator H450_NumberScreened &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_NumberScreened::Class()), PInvalidCast);
#endif
  return *(H450_NumberScreened *)choice;
}


H450_PresentedNumberScreened::operator const H450_NumberScreened &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_NumberScreened::Class()), PInvalidCast);
#endif
  return *(H450_NumberScreened *)choice;
}


BOOL H450_PresentedNumberScreened::CreateObject()
{
  switch (tag) {
    case e_presentationAllowedAddress :
    case e_presentationRestrictedAddress :
      choice = new H450_NumberScreened();
      return TRUE;
    case e_presentationRestricted :
    case e_numberNotAvailableDueToInterworking :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_PresentedNumberScreened::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_PresentedNumberScreened::Class()), PInvalidCast);
#endif
  return new H450_PresentedNumberScreened(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_PresentedNumberScreened::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_presentationAllowedAddress :
        ( ( H450_NumberScreened * ) choice )->preShowEthereal();
        break;
      case e_presentationRestricted :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_numberNotAvailableDueToInterworking :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_presentationRestrictedAddress :
        ( ( H450_NumberScreened * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_PresentedNumberScreened::getSummary( void ) 
{
  return PString( "PresentedNumberScreened" );
}

void H450_PresentedNumberScreened::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "presentationRestricted" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_PresentedNumberScreened_presentationRestricted, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "numberNotAvailableDueToInterworking" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_PresentedNumberScreened_numberNotAvailableDueToInterworking, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h450_1.ett_h450_PresentedNumberScreened_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// PresentedNumberUnscreened
//

H450_PresentedNumberUnscreened::H450_PresentedNumberUnscreened(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "presentationAllowedAddress "
        "presentationRestricted "
        "numberNotAvailableDueToInterworking "
        "presentationRestrictedAddress "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_PresentedNumberUnscreened::operator H225_PartyNumber &() const
#else
H450_PresentedNumberUnscreened::operator H225_PartyNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_PartyNumber::Class()), PInvalidCast);
#endif
  return *(H225_PartyNumber *)choice;
}


H450_PresentedNumberUnscreened::operator const H225_PartyNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_PartyNumber::Class()), PInvalidCast);
#endif
  return *(H225_PartyNumber *)choice;
}


BOOL H450_PresentedNumberUnscreened::CreateObject()
{
  switch (tag) {
    case e_presentationAllowedAddress :
    case e_presentationRestrictedAddress :
      choice = new H225_PartyNumber();
      return TRUE;
    case e_presentationRestricted :
    case e_numberNotAvailableDueToInterworking :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_PresentedNumberUnscreened::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_PresentedNumberUnscreened::Class()), PInvalidCast);
#endif
  return new H450_PresentedNumberUnscreened(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_PresentedNumberUnscreened::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_presentationAllowedAddress :
        ( ( H225_PartyNumber * ) choice )->preShowEthereal();
        break;
      case e_presentationRestricted :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_numberNotAvailableDueToInterworking :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_presentationRestrictedAddress :
        ( ( H225_PartyNumber * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_PresentedNumberUnscreened::getSummary( void ) 
{
  return PString( "PresentedNumberUnscreened" );
}

void H450_PresentedNumberUnscreened::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* The class H225_PartyNumber of which the choice type
     * presentationAllowedAddress is an instantation of, is defined
     * outside the current ASN.1 file, therefore it's not
     * known what type it is. A non-terminal is presumed
     */
    if ( strcmp( GetTagName(), "presentationRestricted" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_PresentedNumberUnscreened_presentationRestricted, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "numberNotAvailableDueToInterworking" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_PresentedNumberUnscreened_numberNotAvailableDueToInterworking, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* The class H225_PartyNumber of which the choice type
     * presentationRestrictedAddress is an instantation of, is defined
     * outside the current ASN.1 file, therefore it's not
     * known what type it is. A non-terminal is presumed
     */
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h450_1.ett_h450_PresentedNumberUnscreened_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// PartySubaddress
//

H450_PartySubaddress::H450_PartySubaddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "userSpecifiedSubaddress "
        "nsapSubaddress "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_PartySubaddress::operator H450_UserSpecifiedSubaddress &() const
#else
H450_PartySubaddress::operator H450_UserSpecifiedSubaddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_UserSpecifiedSubaddress::Class()), PInvalidCast);
#endif
  return *(H450_UserSpecifiedSubaddress *)choice;
}


H450_PartySubaddress::operator const H450_UserSpecifiedSubaddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_UserSpecifiedSubaddress::Class()), PInvalidCast);
#endif
  return *(H450_UserSpecifiedSubaddress *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_PartySubaddress::operator H450_NSAPSubaddress &() const
#else
H450_PartySubaddress::operator H450_NSAPSubaddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_NSAPSubaddress::Class()), PInvalidCast);
#endif
  return *(H450_NSAPSubaddress *)choice;
}


H450_PartySubaddress::operator const H450_NSAPSubaddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_NSAPSubaddress::Class()), PInvalidCast);
#endif
  return *(H450_NSAPSubaddress *)choice;
}


BOOL H450_PartySubaddress::CreateObject()
{
  switch (tag) {
    case e_userSpecifiedSubaddress :
      choice = new H450_UserSpecifiedSubaddress();
      return TRUE;
    case e_nsapSubaddress :
      choice = new H450_NSAPSubaddress();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_PartySubaddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_PartySubaddress::Class()), PInvalidCast);
#endif
  return new H450_PartySubaddress(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_PartySubaddress::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_userSpecifiedSubaddress :
        ( ( H450_UserSpecifiedSubaddress * ) choice )->preShowEthereal();
        break;
      case e_nsapSubaddress :
        ( ( H450_NSAPSubaddress * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_PartySubaddress::getSummary( void ) 
{
  return PString( "PartySubaddress" );
}

void H450_PartySubaddress::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "nsapSubaddress" ) == 0 ) {
      char* pstring = ( ( H450_NSAPSubaddress* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_PartySubaddress_nsapSubaddress, tvb, offset + ( ( H450_NSAPSubaddress* ) choice) ->GetStartByte(), ( ( H450_NSAPSubaddress* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h450_1.ett_h450_PartySubaddress_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// NSAPSubaddress
//

H450_NSAPSubaddress::H450_NSAPSubaddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_OctetString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 20);
}


H450_NSAPSubaddress & H450_NSAPSubaddress::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H450_NSAPSubaddress & H450_NSAPSubaddress::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H450_NSAPSubaddress & H450_NSAPSubaddress::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H450_NSAPSubaddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_NSAPSubaddress::Class()), PInvalidCast);
#endif
  return new H450_NSAPSubaddress(*this);
}


//
// SubaddressInformation
//

H450_SubaddressInformation::H450_SubaddressInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_OctetString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 20);
}


H450_SubaddressInformation & H450_SubaddressInformation::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H450_SubaddressInformation & H450_SubaddressInformation::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H450_SubaddressInformation & H450_SubaddressInformation::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H450_SubaddressInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_SubaddressInformation::Class()), PInvalidCast);
#endif
  return new H450_SubaddressInformation(*this);
}


//
// ScreeningIndicator
//

H450_ScreeningIndicator::H450_ScreeningIndicator(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "userProvidedNotScreened "
        "userProvidedVerifiedAndPassed "
        "userProvidedVerifiedAndFailed "
        "networkProvided "
#endif
    )
{
}


H450_ScreeningIndicator & H450_ScreeningIndicator::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_ScreeningIndicator::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_ScreeningIndicator::Class()), PInvalidCast);
#endif
  return new H450_ScreeningIndicator(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_ScreeningIndicator::preShowEthereal( void )
{
}

PString H450_ScreeningIndicator::getSummary( void ) 
{
  return PString( "ScreeningIndicator" );
}

void H450_ScreeningIndicator::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  switch( GetValue() ) {
  case e_userProvidedNotScreened:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_ScreeningIndicator_enum, tvb, offset + GetStartByte(), GetByteLength() , "userProvidedNotScreened");
    break;
  case e_userProvidedVerifiedAndPassed:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_ScreeningIndicator_enum, tvb, offset + GetStartByte(), GetByteLength() , "userProvidedVerifiedAndPassed");
    break;
  case e_userProvidedVerifiedAndFailed:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_ScreeningIndicator_enum, tvb, offset + GetStartByte(), GetByteLength() , "userProvidedVerifiedAndFailed");
    break;
  case e_networkProvided:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_ScreeningIndicator_enum, tvb, offset + GetStartByte(), GetByteLength() , "networkProvided");
    break;
  default:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_ScreeningIndicator_enum, tvb, offset + GetStartByte(), GetByteLength() , "default switch case");
    break;
  }
}
#endif  //USE_FOR_ETHEREAL

//
// PresentationAllowedIndicator
//

H450_PresentationAllowedIndicator::H450_PresentationAllowedIndicator(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Boolean(tag, tagClass)
{
}


H450_PresentationAllowedIndicator & H450_PresentationAllowedIndicator::operator=(BOOL v)
{
  SetValue(v);
  return *this;
}


PObject * H450_PresentationAllowedIndicator::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_PresentationAllowedIndicator::Class()), PInvalidCast);
#endif
  return new H450_PresentationAllowedIndicator(*this);
}


//
// GeneralErrorList
//

H450_GeneralErrorList::H450_GeneralErrorList(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 43, FALSE
#ifndef PASN_NOPRINTON
      , "userNotSubscribed "
        "rejectedByNetwork "
        "rejectedByUser "
        "notAvailable "
        "insufficientInformation=5 "
        "invalidServedUserNumber "
        "invalidCallState "
        "basicServiceNotProvided "
        "notIncomingCall "
        "supplementaryServiceInteractionNotAllowed "
        "resourceUnavailable "
        "callFailure=25 "
        "proceduralError=43 "
#endif
    )
{
}


H450_GeneralErrorList & H450_GeneralErrorList::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_GeneralErrorList::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_GeneralErrorList::Class()), PInvalidCast);
#endif
  return new H450_GeneralErrorList(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_GeneralErrorList::preShowEthereal( void )
{
}

PString H450_GeneralErrorList::getSummary( void ) 
{
  return PString( "GeneralErrorList" );
}

void H450_GeneralErrorList::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  switch( GetValue() ) {
  case e_userNotSubscribed:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_GeneralErrorList_enum, tvb, offset + GetStartByte(), GetByteLength() , "userNotSubscribed");
    break;
  case e_rejectedByNetwork:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_GeneralErrorList_enum, tvb, offset + GetStartByte(), GetByteLength() , "rejectedByNetwork");
    break;
  case e_rejectedByUser:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_GeneralErrorList_enum, tvb, offset + GetStartByte(), GetByteLength() , "rejectedByUser");
    break;
  case e_notAvailable:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_GeneralErrorList_enum, tvb, offset + GetStartByte(), GetByteLength() , "notAvailable");
    break;
  case e_insufficientInformation:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_GeneralErrorList_enum, tvb, offset + GetStartByte(), GetByteLength() , "insufficientInformation");
    break;
  case e_invalidServedUserNumber:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_GeneralErrorList_enum, tvb, offset + GetStartByte(), GetByteLength() , "invalidServedUserNumber");
    break;
  case e_invalidCallState:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_GeneralErrorList_enum, tvb, offset + GetStartByte(), GetByteLength() , "invalidCallState");
    break;
  case e_basicServiceNotProvided:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_GeneralErrorList_enum, tvb, offset + GetStartByte(), GetByteLength() , "basicServiceNotProvided");
    break;
  case e_notIncomingCall:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_GeneralErrorList_enum, tvb, offset + GetStartByte(), GetByteLength() , "notIncomingCall");
    break;
  case e_supplementaryServiceInteractionNotAllowed:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_GeneralErrorList_enum, tvb, offset + GetStartByte(), GetByteLength() , "supplementaryServiceInteractionNotAllowed");
    break;
  case e_resourceUnavailable:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_GeneralErrorList_enum, tvb, offset + GetStartByte(), GetByteLength() , "resourceUnavailable");
    break;
  case e_callFailure:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_GeneralErrorList_enum, tvb, offset + GetStartByte(), GetByteLength() , "callFailure");
    break;
  case e_proceduralError:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_GeneralErrorList_enum, tvb, offset + GetStartByte(), GetByteLength() , "proceduralError");
    break;
  default:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_GeneralErrorList_enum, tvb, offset + GetStartByte(), GetByteLength() , "default switch case");
    break;
  }
}
#endif  //USE_FOR_ETHEREAL

//
// H225InformationElement
//

H450_H225InformationElement::H450_H225InformationElement(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_OctetString(tag, tagClass)
{
}


H450_H225InformationElement & H450_H225InformationElement::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H450_H225InformationElement & H450_H225InformationElement::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H450_H225InformationElement & H450_H225InformationElement::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H450_H225InformationElement::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_H225InformationElement::Class()), PInvalidCast);
#endif
  return new H450_H225InformationElement(*this);
}


//
// Extension
//

H450_Extension::H450_Extension(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H450_Extension::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "extensionId = " << setprecision(indent) << m_extensionId << '\n';
  strm << setw(indent+20) << "extensionArgument = " << setprecision(indent) << m_extensionArgument << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_Extension::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_Extension::Class()), PInvalidCast);
#endif
  const H450_Extension & other = (const H450_Extension &)obj;

  Comparison result;

  if ((result = m_extensionId.Compare(other.m_extensionId)) != EqualTo)
    return result;
  if ((result = m_extensionArgument.Compare(other.m_extensionArgument)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_Extension::GetDataLength() const
{
  PINDEX length = 0;
  length += m_extensionId.GetObjectLength();
  length += m_extensionArgument.GetObjectLength();
  return length;
}


BOOL H450_Extension::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_extensionId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_extensionArgument.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_Extension::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_extensionId.Encode(strm);
  m_extensionArgument.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_extensionId.Encode(strm);
  m_extensionArgument.Encode(strm);
}


PObject * H450_Extension::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_Extension::Class()), PInvalidCast);
#endif
  return new H450_Extension(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_Extension::preShowEthereal( void )
{
  m_extensionId.preShowEthereal( );
  m_extensionArgument.preShowEthereal( );
}

PString H450_Extension::getSummary( void ) 
{
  return PString( "Extension" );
}

void H450_Extension::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *extensionId_tree = (proto_tree*) NULL;
  proto_item *extensionId_ti = (proto_item*) NULL;
  extensionId_ti = proto_tree_add_text( tree, tvb, offset + m_extensionId.GetStartByte(), m_extensionId.GetByteLength(), "extensionId (%s)", ( const char* ) m_extensionId.GetTagName() );
  extensionId_tree = proto_item_add_subtree( extensionId_ti, hCont->h450_1.ett_h450_Extension_extensionId );

  m_extensionId.showEthereal( extensionId_tree, tvb, offset );

  char* pextensionArgument = m_extensionArgument.getValue();
  proto_tree_add_string( tree, hCont->h450_1.hf_h450_Extension_extensionArgument, tvb, offset + m_extensionArgument.GetStartByte(), m_extensionArgument.GetByteLength() , pextensionArgument );
  delete[] pextensionArgument;

}
#endif  //USE_FOR_ETHEREAL

//
// OperationName
//

H450_OperationName::H450_OperationName(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 104, FALSE
#ifndef PASN_NOPRINTON
      , "holdNotific=101 "
        "retrieveNotific "
        "remoteHold "
        "remoteRetrieve "
#endif
    )
{
}


H450_OperationName & H450_OperationName::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_OperationName::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_OperationName::Class()), PInvalidCast);
#endif
  return new H450_OperationName(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_OperationName::preShowEthereal( void )
{
}

PString H450_OperationName::getSummary( void ) 
{
  return PString( "OperationName" );
}

void H450_OperationName::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  switch( GetValue() ) {
  case e_holdNotific:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_OperationName_enum, tvb, offset + GetStartByte(), GetByteLength() , "holdNotific");
    break;
  case e_retrieveNotific:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_OperationName_enum, tvb, offset + GetStartByte(), GetByteLength() , "retrieveNotific");
    break;
  case e_remoteHold:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_OperationName_enum, tvb, offset + GetStartByte(), GetByteLength() , "remoteHold");
    break;
  case e_remoteRetrieve:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_OperationName_enum, tvb, offset + GetStartByte(), GetByteLength() , "remoteRetrieve");
    break;
  default:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_OperationName_enum, tvb, offset + GetStartByte(), GetByteLength() , "default switch case");
    break;
  }
}
#endif  //USE_FOR_ETHEREAL

//
// MixedExtension
//

H450_MixedExtension::H450_MixedExtension(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
      , "extension "
        "nonStandardData "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_MixedExtension::operator H450_Extension &() const
#else
H450_MixedExtension::operator H450_Extension &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_Extension::Class()), PInvalidCast);
#endif
  return *(H450_Extension *)choice;
}


H450_MixedExtension::operator const H450_Extension &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_Extension::Class()), PInvalidCast);
#endif
  return *(H450_Extension *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_MixedExtension::operator H225_NonStandardParameter &() const
#else
H450_MixedExtension::operator H225_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


H450_MixedExtension::operator const H225_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


BOOL H450_MixedExtension::CreateObject()
{
  switch (tag) {
    case e_extension :
      choice = new H450_Extension();
      return TRUE;
    case e_nonStandardData :
      choice = new H225_NonStandardParameter();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_MixedExtension::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_MixedExtension::Class()), PInvalidCast);
#endif
  return new H450_MixedExtension(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_MixedExtension::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_extension :
        ( ( H450_Extension * ) choice )->preShowEthereal();
        break;
      case e_nonStandardData :
        ( ( H225_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_MixedExtension::getSummary( void ) 
{
  return PString( "MixedExtension" );
}

void H450_MixedExtension::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* The class H225_NonStandardParameter of which the choice type
     * nonStandardData is an instantation of, is defined
     * outside the current ASN.1 file, therefore it's not
     * known what type it is. A non-terminal is presumed
     */
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h450_1.ett_h450_MixedExtension_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// CcArg
//

H450_CcArg::H450_CcArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "shortArg "
        "longArg "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_CcArg::operator H450_CcShortArg &() const
#else
H450_CcArg::operator H450_CcShortArg &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_CcShortArg::Class()), PInvalidCast);
#endif
  return *(H450_CcShortArg *)choice;
}


H450_CcArg::operator const H450_CcShortArg &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_CcShortArg::Class()), PInvalidCast);
#endif
  return *(H450_CcShortArg *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_CcArg::operator H450_CcLongArg &() const
#else
H450_CcArg::operator H450_CcLongArg &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_CcLongArg::Class()), PInvalidCast);
#endif
  return *(H450_CcLongArg *)choice;
}


H450_CcArg::operator const H450_CcLongArg &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_CcLongArg::Class()), PInvalidCast);
#endif
  return *(H450_CcLongArg *)choice;
}


BOOL H450_CcArg::CreateObject()
{
  switch (tag) {
    case e_shortArg :
      choice = new H450_CcShortArg();
      return TRUE;
    case e_longArg :
      choice = new H450_CcLongArg();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_CcArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CcArg::Class()), PInvalidCast);
#endif
  return new H450_CcArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CcArg::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_shortArg :
        ( ( H450_CcShortArg * ) choice )->preShowEthereal();
        break;
      case e_longArg :
        ( ( H450_CcLongArg * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_CcArg::getSummary( void ) 
{
  return PString( "CcArg" );
}

void H450_CcArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h450_1.ett_h450_CcArg_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// CallCompletionErrors
//

H450_CallCompletionErrors::H450_CallCompletionErrors(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 1013, FALSE
#ifndef PASN_NOPRINTON
      , "shortTermRejection=1010 "
        "longTermRejection "
        "remoteUserBusyAgain "
        "failureToMatch "
#endif
    )
{
}


H450_CallCompletionErrors & H450_CallCompletionErrors::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_CallCompletionErrors::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CallCompletionErrors::Class()), PInvalidCast);
#endif
  return new H450_CallCompletionErrors(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CallCompletionErrors::preShowEthereal( void )
{
}

PString H450_CallCompletionErrors::getSummary( void ) 
{
  return PString( "CallCompletionErrors" );
}

void H450_CallCompletionErrors::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  switch( GetValue() ) {
  case e_shortTermRejection:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallCompletionErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "shortTermRejection");
    break;
  case e_longTermRejection:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallCompletionErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "longTermRejection");
    break;
  case e_remoteUserBusyAgain:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallCompletionErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "remoteUserBusyAgain");
    break;
  case e_failureToMatch:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallCompletionErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "failureToMatch");
    break;
  default:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallCompletionErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "default switch case");
    break;
  }
}
#endif  //USE_FOR_ETHEREAL

//
// Name
//

H450_Name::H450_Name(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "namePresentationAllowed "
        "namePresentationRestricted "
        "nameNotAvailable "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_Name::operator H450_NamePresentationAllowed &() const
#else
H450_Name::operator H450_NamePresentationAllowed &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_NamePresentationAllowed::Class()), PInvalidCast);
#endif
  return *(H450_NamePresentationAllowed *)choice;
}


H450_Name::operator const H450_NamePresentationAllowed &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_NamePresentationAllowed::Class()), PInvalidCast);
#endif
  return *(H450_NamePresentationAllowed *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_Name::operator H450_NamePresentationRestricted &() const
#else
H450_Name::operator H450_NamePresentationRestricted &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_NamePresentationRestricted::Class()), PInvalidCast);
#endif
  return *(H450_NamePresentationRestricted *)choice;
}


H450_Name::operator const H450_NamePresentationRestricted &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_NamePresentationRestricted::Class()), PInvalidCast);
#endif
  return *(H450_NamePresentationRestricted *)choice;
}


BOOL H450_Name::CreateObject()
{
  switch (tag) {
    case e_namePresentationAllowed :
      choice = new H450_NamePresentationAllowed();
      return TRUE;
    case e_namePresentationRestricted :
      choice = new H450_NamePresentationRestricted();
      return TRUE;
    case e_nameNotAvailable :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_Name::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_Name::Class()), PInvalidCast);
#endif
  return new H450_Name(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_Name::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_namePresentationAllowed :
        ( ( H450_NamePresentationAllowed * ) choice )->preShowEthereal();
        break;
      case e_namePresentationRestricted :
        ( ( H450_NamePresentationRestricted * ) choice )->preShowEthereal();
        break;
      case e_nameNotAvailable :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_Name::getSummary( void ) 
{
  return PString( "Name" );
}

void H450_Name::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "nameNotAvailable" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_Name_nameNotAvailable, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h450_1.ett_h450_Name_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// NamePresentationAllowed
//

H450_NamePresentationAllowed::H450_NamePresentationAllowed(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "simpleName "
        "extendedName "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_NamePresentationAllowed::operator H450_SimpleName &() const
#else
H450_NamePresentationAllowed::operator H450_SimpleName &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_SimpleName::Class()), PInvalidCast);
#endif
  return *(H450_SimpleName *)choice;
}


H450_NamePresentationAllowed::operator const H450_SimpleName &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_SimpleName::Class()), PInvalidCast);
#endif
  return *(H450_SimpleName *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_NamePresentationAllowed::operator H450_ExtendedName &() const
#else
H450_NamePresentationAllowed::operator H450_ExtendedName &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ExtendedName::Class()), PInvalidCast);
#endif
  return *(H450_ExtendedName *)choice;
}


H450_NamePresentationAllowed::operator const H450_ExtendedName &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ExtendedName::Class()), PInvalidCast);
#endif
  return *(H450_ExtendedName *)choice;
}


BOOL H450_NamePresentationAllowed::CreateObject()
{
  switch (tag) {
    case e_simpleName :
      choice = new H450_SimpleName();
      return TRUE;
    case e_extendedName :
      choice = new H450_ExtendedName();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_NamePresentationAllowed::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_NamePresentationAllowed::Class()), PInvalidCast);
#endif
  return new H450_NamePresentationAllowed(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_NamePresentationAllowed::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_simpleName :
        ( ( H450_SimpleName * ) choice )->preShowEthereal();
        break;
      case e_extendedName :
        ( ( H450_ExtendedName * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_NamePresentationAllowed::getSummary( void ) 
{
  return PString( "NamePresentationAllowed" );
}

void H450_NamePresentationAllowed::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "simpleName" ) == 0 ) {
      char* pstring = ( ( H450_SimpleName* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_NamePresentationAllowed_simpleName, tvb, offset + ( ( H450_SimpleName* ) choice) ->GetStartByte(), ( ( H450_SimpleName* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    if ( strcmp( GetTagName(), "extendedName" ) == 0 ) {
      char* pstring = ( ( H450_ExtendedName* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_NamePresentationAllowed_extendedName, tvb, offset + ( ( H450_ExtendedName* ) choice) ->GetStartByte(), ( ( H450_ExtendedName* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// NamePresentationRestricted
//

H450_NamePresentationRestricted::H450_NamePresentationRestricted(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "simpleName "
        "extendedName "
        "restrictedNull "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_NamePresentationRestricted::operator H450_SimpleName &() const
#else
H450_NamePresentationRestricted::operator H450_SimpleName &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_SimpleName::Class()), PInvalidCast);
#endif
  return *(H450_SimpleName *)choice;
}


H450_NamePresentationRestricted::operator const H450_SimpleName &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_SimpleName::Class()), PInvalidCast);
#endif
  return *(H450_SimpleName *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_NamePresentationRestricted::operator H450_ExtendedName &() const
#else
H450_NamePresentationRestricted::operator H450_ExtendedName &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ExtendedName::Class()), PInvalidCast);
#endif
  return *(H450_ExtendedName *)choice;
}


H450_NamePresentationRestricted::operator const H450_ExtendedName &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ExtendedName::Class()), PInvalidCast);
#endif
  return *(H450_ExtendedName *)choice;
}


BOOL H450_NamePresentationRestricted::CreateObject()
{
  switch (tag) {
    case e_simpleName :
      choice = new H450_SimpleName();
      return TRUE;
    case e_extendedName :
      choice = new H450_ExtendedName();
      return TRUE;
    case e_restrictedNull :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_NamePresentationRestricted::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_NamePresentationRestricted::Class()), PInvalidCast);
#endif
  return new H450_NamePresentationRestricted(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_NamePresentationRestricted::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_simpleName :
        ( ( H450_SimpleName * ) choice )->preShowEthereal();
        break;
      case e_extendedName :
        ( ( H450_ExtendedName * ) choice )->preShowEthereal();
        break;
      case e_restrictedNull :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_NamePresentationRestricted::getSummary( void ) 
{
  return PString( "NamePresentationRestricted" );
}

void H450_NamePresentationRestricted::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "simpleName" ) == 0 ) {
      char* pstring = ( ( H450_SimpleName* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_NamePresentationRestricted_simpleName, tvb, offset + ( ( H450_SimpleName* ) choice) ->GetStartByte(), ( ( H450_SimpleName* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    if ( strcmp( GetTagName(), "extendedName" ) == 0 ) {
      char* pstring = ( ( H450_ExtendedName* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_NamePresentationRestricted_extendedName, tvb, offset + ( ( H450_ExtendedName* ) choice) ->GetStartByte(), ( ( H450_ExtendedName* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    if ( strcmp( GetTagName(), "restrictedNull" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_NamePresentationRestricted_restrictedNull, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// SimpleName
//

H450_SimpleName::H450_SimpleName(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_OctetString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 50);
}


H450_SimpleName & H450_SimpleName::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H450_SimpleName & H450_SimpleName::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H450_SimpleName & H450_SimpleName::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H450_SimpleName::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_SimpleName::Class()), PInvalidCast);
#endif
  return new H450_SimpleName(*this);
}


//
// ExtendedName
//

H450_ExtendedName::H450_ExtendedName(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_BMPString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


H450_ExtendedName & H450_ExtendedName::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H450_ExtendedName & H450_ExtendedName::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H450_ExtendedName & H450_ExtendedName::operator=(const PWORDArray & v)
{
  SetValue(v);
  return *this;
}


H450_ExtendedName & H450_ExtendedName::operator=(const PASN_BMPString & v)
{
  SetValue(v);
  return *this;
}


PObject * H450_ExtendedName::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_ExtendedName::Class()), PInvalidCast);
#endif
  return new H450_ExtendedName(*this);
}


//
// DummyRes
//

H450_DummyRes::H450_DummyRes(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


PASN_Object * H450_DummyRes::CreateObject() const
{
  return new H450_MixedExtension;
}


H450_MixedExtension & H450_DummyRes::operator[](PINDEX i) const
{
  return (H450_MixedExtension &)array[i];
}


PObject * H450_DummyRes::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_DummyRes::Class()), PInvalidCast);
#endif
  return new H450_DummyRes(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_DummyRes::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H450_MixedExtension& ) array[i] ).preShowEthereal();
  }
}

PString H450_DummyRes::getSummary( void ) 
{
  return PString( "DummyRes" );
}

void H450_DummyRes::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *DummyRes_tree = (proto_tree*) NULL;
  proto_item *DummyRes_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    DummyRes_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (%s)", i, (const char*) ( ( PASN_Choice* ) &( array[i] ) )->GetTagName() );
    DummyRes_tree = proto_item_add_subtree( DummyRes_ti, hCont->h450_1.ett_h450_DummyRes );
    array[i].showEthereal( DummyRes_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// MWIInterrogateRes
//

H450_MWIInterrogateRes::H450_MWIInterrogateRes(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 64);
}


PASN_Object * H450_MWIInterrogateRes::CreateObject() const
{
  return new H450_MWIInterrogateResElt;
}


H450_MWIInterrogateResElt & H450_MWIInterrogateRes::operator[](PINDEX i) const
{
  return (H450_MWIInterrogateResElt &)array[i];
}


PObject * H450_MWIInterrogateRes::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_MWIInterrogateRes::Class()), PInvalidCast);
#endif
  return new H450_MWIInterrogateRes(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_MWIInterrogateRes::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H450_MWIInterrogateResElt& ) array[i] ).preShowEthereal();
  }
}

PString H450_MWIInterrogateRes::getSummary( void ) 
{
  return PString( "MWIInterrogateRes" );
}

void H450_MWIInterrogateRes::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *MWIInterrogateRes_tree = (proto_tree*) NULL;
  proto_item *MWIInterrogateRes_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    MWIInterrogateRes_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (MWIInterrogateResElt)", i );
    MWIInterrogateRes_tree = proto_item_add_subtree( MWIInterrogateRes_ti, hCont->h450_1.ett_h450_MWIInterrogateRes );
    array[i].showEthereal( MWIInterrogateRes_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// MsgCentreId
//

H450_MsgCentreId::H450_MsgCentreId(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
      , "integer "
        "partyNumber "
        "numericString "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_MsgCentreId::operator H450_EndpointAddress &() const
#else
H450_MsgCentreId::operator H450_EndpointAddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_EndpointAddress::Class()), PInvalidCast);
#endif
  return *(H450_EndpointAddress *)choice;
}


H450_MsgCentreId::operator const H450_EndpointAddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_EndpointAddress::Class()), PInvalidCast);
#endif
  return *(H450_EndpointAddress *)choice;
}


BOOL H450_MsgCentreId::CreateObject()
{
  switch (tag) {
    case e_integer :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
      return TRUE;
    case e_partyNumber :
      choice = new H450_EndpointAddress();
      return TRUE;
    case e_numericString :
      choice = new PASN_NumericString();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 10);
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_MsgCentreId::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_MsgCentreId::Class()), PInvalidCast);
#endif
  return new H450_MsgCentreId(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_MsgCentreId::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_integer :
        ( ( PASN_Integer * ) choice )->preShowEthereal();
        break;
      case e_partyNumber :
        ( ( H450_EndpointAddress * ) choice )->preShowEthereal();
        break;
      case e_numericString :
        ( ( PASN_NumericString * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_MsgCentreId::getSummary( void ) 
{
  return PString( "MsgCentreId" );
}

void H450_MsgCentreId::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "integer" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h450_1.hf_h450_MsgCentreId_integer, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "numericString" ) == 0 ) {
      char* pstring = ( ( PASN_NumericString* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_MsgCentreId_numericString, tvb, offset + ( ( PASN_NumericString* ) choice) ->GetStartByte(), ( ( PASN_NumericString* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h450_1.ett_h450_MsgCentreId_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// NbOfMessages
//

H450_NbOfMessages::H450_NbOfMessages(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


H450_NbOfMessages & H450_NbOfMessages::operator=(int v)
{
  SetValue(v);
  return *this;
}


H450_NbOfMessages & H450_NbOfMessages::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_NbOfMessages::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_NbOfMessages::Class()), PInvalidCast);
#endif
  return new H450_NbOfMessages(*this);
}


//
// TimeStamp
//

H450_TimeStamp::H450_TimeStamp(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_GeneralisedTime(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 12, 19);
}


PObject * H450_TimeStamp::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_TimeStamp::Class()), PInvalidCast);
#endif
  return new H450_TimeStamp(*this);
}


//
// MessageWaitingIndicationErrors
//

H450_MessageWaitingIndicationErrors::H450_MessageWaitingIndicationErrors(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 2002, FALSE
#ifndef PASN_NOPRINTON
      , "notActivated=31 "
        "undefined=2002 "
        "invalidMsgCentreId=1018 "
#endif
    )
{
}


H450_MessageWaitingIndicationErrors & H450_MessageWaitingIndicationErrors::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_MessageWaitingIndicationErrors::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_MessageWaitingIndicationErrors::Class()), PInvalidCast);
#endif
  return new H450_MessageWaitingIndicationErrors(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_MessageWaitingIndicationErrors::preShowEthereal( void )
{
}

PString H450_MessageWaitingIndicationErrors::getSummary( void ) 
{
  return PString( "MessageWaitingIndicationErrors" );
}

void H450_MessageWaitingIndicationErrors::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  switch( GetValue() ) {
  case e_notActivated:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_MessageWaitingIndicationErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "notActivated");
    break;
  case e_undefined:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_MessageWaitingIndicationErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "undefined");
    break;
  case e_invalidMsgCentreId:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_MessageWaitingIndicationErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "invalidMsgCentreId");
    break;
  default:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_MessageWaitingIndicationErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "default switch case");
    break;
  }
}
#endif  //USE_FOR_ETHEREAL

//
// BasicService
//

H450_BasicService::H450_BasicService(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 36, FALSE
#ifndef PASN_NOPRINTON
      , "allServices "
        "speech "
        "unrestrictedDigitalInformation "
        "audio3100Hz "
        "telephony=32 "
        "teletex "
        "telefaxGroup4Class1 "
        "videotexSyntaxBased "
        "videotelephony "
#endif
    )
{
}


H450_BasicService & H450_BasicService::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_BasicService::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_BasicService::Class()), PInvalidCast);
#endif
  return new H450_BasicService(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_BasicService::preShowEthereal( void )
{
}

PString H450_BasicService::getSummary( void ) 
{
  return PString( "BasicService" );
}

void H450_BasicService::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  switch( GetValue() ) {
  case e_allServices:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_BasicService_enum, tvb, offset + GetStartByte(), GetByteLength() , "allServices");
    break;
  case e_speech:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_BasicService_enum, tvb, offset + GetStartByte(), GetByteLength() , "speech");
    break;
  case e_unrestrictedDigitalInformation:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_BasicService_enum, tvb, offset + GetStartByte(), GetByteLength() , "unrestrictedDigitalInformation");
    break;
  case e_audio3100Hz:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_BasicService_enum, tvb, offset + GetStartByte(), GetByteLength() , "audio3100Hz");
    break;
  case e_telephony:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_BasicService_enum, tvb, offset + GetStartByte(), GetByteLength() , "telephony");
    break;
  case e_teletex:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_BasicService_enum, tvb, offset + GetStartByte(), GetByteLength() , "teletex");
    break;
  case e_telefaxGroup4Class1:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_BasicService_enum, tvb, offset + GetStartByte(), GetByteLength() , "telefaxGroup4Class1");
    break;
  case e_videotexSyntaxBased:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_BasicService_enum, tvb, offset + GetStartByte(), GetByteLength() , "videotexSyntaxBased");
    break;
  case e_videotelephony:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_BasicService_enum, tvb, offset + GetStartByte(), GetByteLength() , "videotelephony");
    break;
  default:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_BasicService_enum, tvb, offset + GetStartByte(), GetByteLength() , "default switch case");
    break;
  }
}
#endif  //USE_FOR_ETHEREAL

//
// ParkedToPosition
//

H450_ParkedToPosition::H450_ParkedToPosition(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


H450_ParkedToPosition & H450_ParkedToPosition::operator=(int v)
{
  SetValue(v);
  return *this;
}


H450_ParkedToPosition & H450_ParkedToPosition::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_ParkedToPosition::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_ParkedToPosition::Class()), PInvalidCast);
#endif
  return new H450_ParkedToPosition(*this);
}


//
// ParkCondition
//

H450_ParkCondition::H450_ParkCondition(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "unspecified "
        "parkedToUserIdle "
        "parkedToUserBusy "
        "parkedToGroup "
#endif
    )
{
}


H450_ParkCondition & H450_ParkCondition::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_ParkCondition::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_ParkCondition::Class()), PInvalidCast);
#endif
  return new H450_ParkCondition(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_ParkCondition::preShowEthereal( void )
{
}

PString H450_ParkCondition::getSummary( void ) 
{
  return PString( "ParkCondition" );
}

void H450_ParkCondition::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  switch( GetValue() ) {
  case e_unspecified:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_ParkCondition_enum, tvb, offset + GetStartByte(), GetByteLength() , "unspecified");
    break;
  case e_parkedToUserIdle:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_ParkCondition_enum, tvb, offset + GetStartByte(), GetByteLength() , "parkedToUserIdle");
    break;
  case e_parkedToUserBusy:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_ParkCondition_enum, tvb, offset + GetStartByte(), GetByteLength() , "parkedToUserBusy");
    break;
  case e_parkedToGroup:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_ParkCondition_enum, tvb, offset + GetStartByte(), GetByteLength() , "parkedToGroup");
    break;
  default:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_ParkCondition_enum, tvb, offset + GetStartByte(), GetByteLength() , "default switch case");
    break;
  }
}
#endif  //USE_FOR_ETHEREAL

//
// CallType
//

H450_CallType::H450_CallType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
      , "parkedCall "
        "alertingCall "
#endif
    )
{
}


H450_CallType & H450_CallType::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_CallType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CallType::Class()), PInvalidCast);
#endif
  return new H450_CallType(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CallType::preShowEthereal( void )
{
}

PString H450_CallType::getSummary( void ) 
{
  return PString( "CallType" );
}

void H450_CallType::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  switch( GetValue() ) {
  case e_parkedCall:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallType_enum, tvb, offset + GetStartByte(), GetByteLength() , "parkedCall");
    break;
  case e_alertingCall:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallType_enum, tvb, offset + GetStartByte(), GetByteLength() , "alertingCall");
    break;
  default:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallType_enum, tvb, offset + GetStartByte(), GetByteLength() , "default switch case");
    break;
  }
}
#endif  //USE_FOR_ETHEREAL

//
// CallPickupErrors
//

H450_CallPickupErrors::H450_CallPickupErrors(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 2002, FALSE
#ifndef PASN_NOPRINTON
      , "callPickupIdInvalid=2000 "
        "callAlreadyPickedUp "
        "undefined "
#endif
    )
{
}


H450_CallPickupErrors & H450_CallPickupErrors::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_CallPickupErrors::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CallPickupErrors::Class()), PInvalidCast);
#endif
  return new H450_CallPickupErrors(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CallPickupErrors::preShowEthereal( void )
{
}

PString H450_CallPickupErrors::getSummary( void ) 
{
  return PString( "CallPickupErrors" );
}

void H450_CallPickupErrors::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  switch( GetValue() ) {
  case e_callPickupIdInvalid:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallPickupErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "callPickupIdInvalid");
    break;
  case e_callAlreadyPickedUp:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallPickupErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "callAlreadyPickedUp");
    break;
  case e_undefined:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallPickupErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "undefined");
    break;
  default:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallPickupErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "default switch case");
    break;
  }
}
#endif  //USE_FOR_ETHEREAL

//
// DiversionReason
//

H450_DiversionReason::H450_DiversionReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "unknown "
        "cfu "
        "cfb "
        "cfnr "
#endif
    )
{
}


H450_DiversionReason & H450_DiversionReason::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_DiversionReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_DiversionReason::Class()), PInvalidCast);
#endif
  return new H450_DiversionReason(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_DiversionReason::preShowEthereal( void )
{
}

PString H450_DiversionReason::getSummary( void ) 
{
  return PString( "DiversionReason" );
}

void H450_DiversionReason::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  switch( GetValue() ) {
  case e_unknown:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_DiversionReason_enum, tvb, offset + GetStartByte(), GetByteLength() , "unknown");
    break;
  case e_cfu:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_DiversionReason_enum, tvb, offset + GetStartByte(), GetByteLength() , "cfu");
    break;
  case e_cfb:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_DiversionReason_enum, tvb, offset + GetStartByte(), GetByteLength() , "cfb");
    break;
  case e_cfnr:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_DiversionReason_enum, tvb, offset + GetStartByte(), GetByteLength() , "cfnr");
    break;
  default:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_DiversionReason_enum, tvb, offset + GetStartByte(), GetByteLength() , "default switch case");
    break;
  }
}
#endif  //USE_FOR_ETHEREAL

//
// IntResultList
//

H450_IntResultList::H450_IntResultList(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 29);
}


PASN_Object * H450_IntResultList::CreateObject() const
{
  return new H450_IntResult;
}


H450_IntResult & H450_IntResultList::operator[](PINDEX i) const
{
  return (H450_IntResult &)array[i];
}


PObject * H450_IntResultList::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_IntResultList::Class()), PInvalidCast);
#endif
  return new H450_IntResultList(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_IntResultList::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H450_IntResult& ) array[i] ).preShowEthereal();
  }
}

PString H450_IntResultList::getSummary( void ) 
{
  return PString( "IntResultList" );
}

void H450_IntResultList::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *IntResultList_tree = (proto_tree*) NULL;
  proto_item *IntResultList_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    IntResultList_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (IntResult)", i );
    IntResultList_tree = proto_item_add_subtree( IntResultList_ti, hCont->h450_1.ett_h450_IntResultList );
    array[i].showEthereal( IntResultList_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// Procedure
//

H450_Procedure::H450_Procedure(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "cfu "
        "cfb "
        "cfnr "
#endif
    )
{
}


H450_Procedure & H450_Procedure::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_Procedure::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_Procedure::Class()), PInvalidCast);
#endif
  return new H450_Procedure(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_Procedure::preShowEthereal( void )
{
}

PString H450_Procedure::getSummary( void ) 
{
  return PString( "Procedure" );
}

void H450_Procedure::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  switch( GetValue() ) {
  case e_cfu:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_Procedure_enum, tvb, offset + GetStartByte(), GetByteLength() , "cfu");
    break;
  case e_cfb:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_Procedure_enum, tvb, offset + GetStartByte(), GetByteLength() , "cfb");
    break;
  case e_cfnr:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_Procedure_enum, tvb, offset + GetStartByte(), GetByteLength() , "cfnr");
    break;
  default:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_Procedure_enum, tvb, offset + GetStartByte(), GetByteLength() , "default switch case");
    break;
  }
}
#endif  //USE_FOR_ETHEREAL

//
// SubscriptionOption
//

H450_SubscriptionOption::H450_SubscriptionOption(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "noNotification "
        "notificationWithoutDivertedToNr "
        "notificationWithDivertedToNr "
#endif
    )
{
}


H450_SubscriptionOption & H450_SubscriptionOption::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_SubscriptionOption::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_SubscriptionOption::Class()), PInvalidCast);
#endif
  return new H450_SubscriptionOption(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_SubscriptionOption::preShowEthereal( void )
{
}

PString H450_SubscriptionOption::getSummary( void ) 
{
  return PString( "SubscriptionOption" );
}

void H450_SubscriptionOption::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  switch( GetValue() ) {
  case e_noNotification:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_SubscriptionOption_enum, tvb, offset + GetStartByte(), GetByteLength() , "noNotification");
    break;
  case e_notificationWithoutDivertedToNr:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_SubscriptionOption_enum, tvb, offset + GetStartByte(), GetByteLength() , "notificationWithoutDivertedToNr");
    break;
  case e_notificationWithDivertedToNr:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_SubscriptionOption_enum, tvb, offset + GetStartByte(), GetByteLength() , "notificationWithDivertedToNr");
    break;
  default:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_SubscriptionOption_enum, tvb, offset + GetStartByte(), GetByteLength() , "default switch case");
    break;
  }
}
#endif  //USE_FOR_ETHEREAL

//
// CallDiversionErrors
//

H450_CallDiversionErrors::H450_CallDiversionErrors(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 1008, FALSE
#ifndef PASN_NOPRINTON
      , "invalidDivertedNumber=12 "
        "specialServiceNumber=14 "
        "diversionToServedUserNumber "
        "numberOfDiversionsExceeded=24 "
        "temporarilyUnavailable=1000 "
        "notAuthorized=1007 "
        "unspecified "
#endif
    )
{
}


H450_CallDiversionErrors & H450_CallDiversionErrors::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_CallDiversionErrors::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CallDiversionErrors::Class()), PInvalidCast);
#endif
  return new H450_CallDiversionErrors(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CallDiversionErrors::preShowEthereal( void )
{
}

PString H450_CallDiversionErrors::getSummary( void ) 
{
  return PString( "CallDiversionErrors" );
}

void H450_CallDiversionErrors::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  switch( GetValue() ) {
  case e_invalidDivertedNumber:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallDiversionErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "invalidDivertedNumber");
    break;
  case e_specialServiceNumber:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallDiversionErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "specialServiceNumber");
    break;
  case e_diversionToServedUserNumber:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallDiversionErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "diversionToServedUserNumber");
    break;
  case e_numberOfDiversionsExceeded:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallDiversionErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "numberOfDiversionsExceeded");
    break;
  case e_temporarilyUnavailable:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallDiversionErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "temporarilyUnavailable");
    break;
  case e_notAuthorized:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallDiversionErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "notAuthorized");
    break;
  case e_unspecified:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallDiversionErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "unspecified");
    break;
  default:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallDiversionErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "default switch case");
    break;
  }
}
#endif  //USE_FOR_ETHEREAL

//
// DummyArg
//

H450_DummyArg::H450_DummyArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
      , "extensionSeq "
        "nonStandardData "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_DummyArg::operator H450_ExtensionSeq &() const
#else
H450_DummyArg::operator H450_ExtensionSeq &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ExtensionSeq::Class()), PInvalidCast);
#endif
  return *(H450_ExtensionSeq *)choice;
}


H450_DummyArg::operator const H450_ExtensionSeq &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ExtensionSeq::Class()), PInvalidCast);
#endif
  return *(H450_ExtensionSeq *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_DummyArg::operator H225_NonStandardParameter &() const
#else
H450_DummyArg::operator H225_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


H450_DummyArg::operator const H225_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


BOOL H450_DummyArg::CreateObject()
{
  switch (tag) {
    case e_extensionSeq :
      choice = new H450_ExtensionSeq();
      return TRUE;
    case e_nonStandardData :
      choice = new H225_NonStandardParameter();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_DummyArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_DummyArg::Class()), PInvalidCast);
#endif
  return new H450_DummyArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_DummyArg::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_extensionSeq :
        ( ( H450_ExtensionSeq * ) choice )->preShowEthereal();
        break;
      case e_nonStandardData :
        ( ( H225_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_DummyArg::getSummary( void ) 
{
  return PString( "DummyArg" );
}

void H450_DummyArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* The class H225_NonStandardParameter of which the choice type
     * nonStandardData is an instantation of, is defined
     * outside the current ASN.1 file, therefore it's not
     * known what type it is. A non-terminal is presumed
     */
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h450_1.ett_h450_DummyArg_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// EndDesignation
//

H450_EndDesignation::H450_EndDesignation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
      , "primaryEnd "
        "secondaryEnd "
#endif
    )
{
}


H450_EndDesignation & H450_EndDesignation::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_EndDesignation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_EndDesignation::Class()), PInvalidCast);
#endif
  return new H450_EndDesignation(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_EndDesignation::preShowEthereal( void )
{
}

PString H450_EndDesignation::getSummary( void ) 
{
  return PString( "EndDesignation" );
}

void H450_EndDesignation::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  switch( GetValue() ) {
  case e_primaryEnd:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_EndDesignation_enum, tvb, offset + GetStartByte(), GetByteLength() , "primaryEnd");
    break;
  case e_secondaryEnd:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_EndDesignation_enum, tvb, offset + GetStartByte(), GetByteLength() , "secondaryEnd");
    break;
  default:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_EndDesignation_enum, tvb, offset + GetStartByte(), GetByteLength() , "default switch case");
    break;
  }
}
#endif  //USE_FOR_ETHEREAL

//
// CallStatus
//

H450_CallStatus::H450_CallStatus(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
      , "answered "
        "alerting "
#endif
    )
{
}


H450_CallStatus & H450_CallStatus::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_CallStatus::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CallStatus::Class()), PInvalidCast);
#endif
  return new H450_CallStatus(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CallStatus::preShowEthereal( void )
{
}

PString H450_CallStatus::getSummary( void ) 
{
  return PString( "CallStatus" );
}

void H450_CallStatus::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  switch( GetValue() ) {
  case e_answered:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallStatus_enum, tvb, offset + GetStartByte(), GetByteLength() , "answered");
    break;
  case e_alerting:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallStatus_enum, tvb, offset + GetStartByte(), GetByteLength() , "alerting");
    break;
  default:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallStatus_enum, tvb, offset + GetStartByte(), GetByteLength() , "default switch case");
    break;
  }
}
#endif  //USE_FOR_ETHEREAL

//
// CallIdentity
//

H450_CallIdentity::H450_CallIdentity(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_NumericString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 4);
}


H450_CallIdentity & H450_CallIdentity::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H450_CallIdentity & H450_CallIdentity::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


PObject * H450_CallIdentity::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CallIdentity::Class()), PInvalidCast);
#endif
  return new H450_CallIdentity(*this);
}


//
// ExtensionSeq
//

H450_ExtensionSeq::H450_ExtensionSeq(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H450_ExtensionSeq::CreateObject() const
{
  return new H450_Extension;
}


H450_Extension & H450_ExtensionSeq::operator[](PINDEX i) const
{
  return (H450_Extension &)array[i];
}


PObject * H450_ExtensionSeq::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_ExtensionSeq::Class()), PInvalidCast);
#endif
  return new H450_ExtensionSeq(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_ExtensionSeq::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H450_Extension& ) array[i] ).preShowEthereal();
  }
}

PString H450_ExtensionSeq::getSummary( void ) 
{
  return PString( "ExtensionSeq" );
}

void H450_ExtensionSeq::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ExtensionSeq_tree = (proto_tree*) NULL;
  proto_item *ExtensionSeq_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ExtensionSeq_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (Extension)", i );
    ExtensionSeq_tree = proto_item_add_subtree( ExtensionSeq_ti, hCont->h450_1.ett_h450_ExtensionSeq );
    array[i].showEthereal( ExtensionSeq_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// CallTransferOperation
//

H450_CallTransferOperation::H450_CallTransferOperation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 14, FALSE
#ifndef PASN_NOPRINTON
      , "callTransferIdentify=7 "
        "callTransferAbandon "
        "callTransferInitiate "
        "callTransferSetup "
        "callTransferUpdate=13 "
        "subaddressTransfer "
        "callTransferComplete=12 "
        "callTransferActive=11 "
#endif
    )
{
}


H450_CallTransferOperation & H450_CallTransferOperation::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_CallTransferOperation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CallTransferOperation::Class()), PInvalidCast);
#endif
  return new H450_CallTransferOperation(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CallTransferOperation::preShowEthereal( void )
{
}

PString H450_CallTransferOperation::getSummary( void ) 
{
  return PString( "CallTransferOperation" );
}

void H450_CallTransferOperation::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  switch( GetValue() ) {
  case e_callTransferIdentify:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallTransferOperation_enum, tvb, offset + GetStartByte(), GetByteLength() , "callTransferIdentify");
    break;
  case e_callTransferAbandon:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallTransferOperation_enum, tvb, offset + GetStartByte(), GetByteLength() , "callTransferAbandon");
    break;
  case e_callTransferInitiate:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallTransferOperation_enum, tvb, offset + GetStartByte(), GetByteLength() , "callTransferInitiate");
    break;
  case e_callTransferSetup:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallTransferOperation_enum, tvb, offset + GetStartByte(), GetByteLength() , "callTransferSetup");
    break;
  case e_callTransferUpdate:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallTransferOperation_enum, tvb, offset + GetStartByte(), GetByteLength() , "callTransferUpdate");
    break;
  case e_subaddressTransfer:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallTransferOperation_enum, tvb, offset + GetStartByte(), GetByteLength() , "subaddressTransfer");
    break;
  case e_callTransferComplete:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallTransferOperation_enum, tvb, offset + GetStartByte(), GetByteLength() , "callTransferComplete");
    break;
  case e_callTransferActive:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallTransferOperation_enum, tvb, offset + GetStartByte(), GetByteLength() , "callTransferActive");
    break;
  default:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallTransferOperation_enum, tvb, offset + GetStartByte(), GetByteLength() , "default switch case");
    break;
  }
}
#endif  //USE_FOR_ETHEREAL

//
// CallTransferErrors
//

H450_CallTransferErrors::H450_CallTransferErrors(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 1008, FALSE
#ifndef PASN_NOPRINTON
      , "unspecified=1008 "
        "invalidReroutingNumber=1004 "
        "unrecognizedCallIdentity "
        "establishmentFailure "
#endif
    )
{
}


H450_CallTransferErrors & H450_CallTransferErrors::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_CallTransferErrors::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CallTransferErrors::Class()), PInvalidCast);
#endif
  return new H450_CallTransferErrors(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CallTransferErrors::preShowEthereal( void )
{
}

PString H450_CallTransferErrors::getSummary( void ) 
{
  return PString( "CallTransferErrors" );
}

void H450_CallTransferErrors::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  switch( GetValue() ) {
  case e_unspecified:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallTransferErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "unspecified");
    break;
  case e_invalidReroutingNumber:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallTransferErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "invalidReroutingNumber");
    break;
  case e_unrecognizedCallIdentity:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallTransferErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "unrecognizedCallIdentity");
    break;
  case e_establishmentFailure:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallTransferErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "establishmentFailure");
    break;
  default:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallTransferErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "default switch case");
    break;
  }
}
#endif  //USE_FOR_ETHEREAL

//
// CICapabilityLevel
//

H450_CICapabilityLevel::H450_CICapabilityLevel(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
}


H450_CICapabilityLevel & H450_CICapabilityLevel::operator=(int v)
{
  SetValue(v);
  return *this;
}


H450_CICapabilityLevel & H450_CICapabilityLevel::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_CICapabilityLevel::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CICapabilityLevel::Class()), PInvalidCast);
#endif
  return new H450_CICapabilityLevel(*this);
}


//
// CIProtectionLevel
//

H450_CIProtectionLevel::H450_CIProtectionLevel(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
}


H450_CIProtectionLevel & H450_CIProtectionLevel::operator=(int v)
{
  SetValue(v);
  return *this;
}


H450_CIProtectionLevel & H450_CIProtectionLevel::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_CIProtectionLevel::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CIProtectionLevel::Class()), PInvalidCast);
#endif
  return new H450_CIProtectionLevel(*this);
}


//
// CIStatusInformation
//

H450_CIStatusInformation::H450_CIStatusInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 6, TRUE
#ifndef PASN_NOPRINTON
      , "callIntrusionImpending "
        "callIntruded "
        "callIsolated "
        "callForceReleased "
        "callIntrusionComplete "
        "callIntrusionEnd "
#endif
    )
{
}


BOOL H450_CIStatusInformation::CreateObject()
{
  switch (tag) {
    case e_callIntrusionImpending :
    case e_callIntruded :
    case e_callIsolated :
    case e_callForceReleased :
    case e_callIntrusionComplete :
    case e_callIntrusionEnd :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_CIStatusInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CIStatusInformation::Class()), PInvalidCast);
#endif
  return new H450_CIStatusInformation(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CIStatusInformation::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_callIntrusionImpending :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_callIntruded :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_callIsolated :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_callForceReleased :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_callIntrusionComplete :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_callIntrusionEnd :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_CIStatusInformation::getSummary( void ) 
{
  return PString( "CIStatusInformation" );
}

void H450_CIStatusInformation::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "callIntrusionImpending" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_CIStatusInformation_callIntrusionImpending, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "callIntruded" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_CIStatusInformation_callIntruded, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "callIsolated" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_CIStatusInformation_callIsolated, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "callForceReleased" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_CIStatusInformation_callForceReleased, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "callIntrusionComplete" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_CIStatusInformation_callIntrusionComplete, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "callIntrusionEnd" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h450_1.hf_h450_CIStatusInformation_callIntrusionEnd, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// CallIntrusionErrors
//

H450_CallIntrusionErrors::H450_CallIntrusionErrors(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 1009, FALSE
#ifndef PASN_NOPRINTON
      , "notBusy=1009 "
        "temporarilyUnavailable=1000 "
        "notAuthorized=1007 "
#endif
    )
{
}


H450_CallIntrusionErrors & H450_CallIntrusionErrors::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H450_CallIntrusionErrors::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CallIntrusionErrors::Class()), PInvalidCast);
#endif
  return new H450_CallIntrusionErrors(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CallIntrusionErrors::preShowEthereal( void )
{
}

PString H450_CallIntrusionErrors::getSummary( void ) 
{
  return PString( "CallIntrusionErrors" );
}

void H450_CallIntrusionErrors::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  switch( GetValue() ) {
  case e_notBusy:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallIntrusionErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "notBusy");
    break;
  case e_temporarilyUnavailable:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallIntrusionErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "temporarilyUnavailable");
    break;
  case e_notAuthorized:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallIntrusionErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "notAuthorized");
    break;
  default:
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CallIntrusionErrors_enum, tvb, offset + GetStartByte(), GetByteLength() , "default switch case");
    break;
  }
}
#endif  //USE_FOR_ETHEREAL

//
// ReturnResult_result
//

H450_ReturnResult_result::H450_ReturnResult_result(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H450_ReturnResult_result::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "opcode = " << setprecision(indent) << m_opcode << '\n';
  strm << setw(indent+9) << "result = " << setprecision(indent) << m_result << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_ReturnResult_result::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_ReturnResult_result::Class()), PInvalidCast);
#endif
  const H450_ReturnResult_result & other = (const H450_ReturnResult_result &)obj;

  Comparison result;

  if ((result = m_opcode.Compare(other.m_opcode)) != EqualTo)
    return result;
  if ((result = m_result.Compare(other.m_result)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_ReturnResult_result::GetDataLength() const
{
  PINDEX length = 0;
  length += m_opcode.GetObjectLength();
  length += m_result.GetObjectLength();
  return length;
}


BOOL H450_ReturnResult_result::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_opcode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_result.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_ReturnResult_result::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_opcode.Encode(strm);
  m_result.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_opcode.Encode(strm);
  m_result.Encode(strm);
}


PObject * H450_ReturnResult_result::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_ReturnResult_result::Class()), PInvalidCast);
#endif
  return new H450_ReturnResult_result(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_ReturnResult_result::preShowEthereal( void )
{
  m_opcode.preShowEthereal( );
  m_result.preShowEthereal( );
}

PString H450_ReturnResult_result::getSummary( void ) 
{
  return PString( "ReturnResult_result" );
}

void H450_ReturnResult_result::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *opcode_tree = (proto_tree*) NULL;
  proto_item *opcode_ti = (proto_item*) NULL;
  opcode_ti = proto_tree_add_text( tree, tvb, offset + m_opcode.GetStartByte(), m_opcode.GetByteLength(), "opcode (%s)", ( const char* ) m_opcode.GetTagName() );
  opcode_tree = proto_item_add_subtree( opcode_ti, hCont->h450_1.ett_h450_ReturnResult_result_opcode );

  m_opcode.showEthereal( opcode_tree, tvb, offset );

  /*char* presult = m_result.getValue();
  proto_tree_add_string( tree, hCont->h450_1.hf_h450_ReturnResult_result_result, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength() , presult );
  delete[] presult;
  */
//  if ( HasOptionalField( e_result ) ) {
    //Only check if local choice is made
    if( strcmp( m_opcode.GetTagName(), "local" ) == 0 )
    {
      proto_tree *argument_tree = (proto_tree*) NULL;
      proto_item *argument_ti = (proto_item*) NULL;
      argument_ti = proto_tree_add_text( tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "argument" );
      argument_tree = proto_item_add_subtree( argument_ti, hCont->h450_1.ett_h450_Invoke_argument );
      switch( ((PASN_Integer) m_opcode).GetValue() )
      {
      case 7:	//"callTransferIdentify - H.450.2"},
        {
          PPER_Stream per = m_result;
          
          H450_CTIdentifyRes olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "Unable to decode Result argument as " );
          }
        }
        break;
      case 9:	//"callTransferInitiate - H.450.2"},
        {
          PPER_Stream per = m_result;
          
          H450_DummyRes olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "Unable to decode Result argument as " );
          }
        }
        break;
      case 10:	//"callTransferSetup - H.450.2"},
        {
          PPER_Stream per = m_result;
          
          H450_DummyRes olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "Unable to decode Result argument as " );
          }
        }
        break;
      case 15:	//"activateDiversionQ - H.450.3"},
        // H450.3 is still incomplete, the OpenH323 ASN.1 files are 
        // not filled in completely. Seems not too difficult....
        break;
      case 16:	//"deactivateDiversionQ - H.450.3"},
        break;
      case 17:	//"interrogateDiversionQ - H.450.3"},
        break;
      case 18:	//"checkRestriction - H.450.3"},
        break;
      case 19:	//"callRerouting - H.450.3"},
        break;
      case 20:	//"divertingLegInformation1 - H.450.3"},
        break;
      case 21:	//"divertingLegInformation2 - H.450.3"},
        break;
      case 22:	//"divertingLegInformation3 - H.450.3"},
        break;
      case 23:	//"cfnrDivertedLegFailed - H.450.3"},
        break;
      case 27:	//"ccnrRequest - H.450.9"},
        {
          PPER_Stream per = m_result;
          
          H450_CcRequestRes olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "Unable to decode Result argument as " );
          }
        }
        break;
      case 40:	//"ccbsRequest - H.450.9"},
        {
          PPER_Stream per = m_result;
          
          H450_CcRequestRes olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "Unable to decode Result argument as " );
          }
        }
        break;
      case 43:	//"callIntrusionRequest - H.450.11"},
        {
          PPER_Stream per = m_result;
          
          H450_CIRequestRes olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "Unable to decode Result argument as " );
          }
        }
        break;
      case 44:	//"callIntrusionGetCIPL - H.450.11"},
        {
          PPER_Stream per = m_result;
          
          H450_CIGetCIPLRes olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "Unable to decode Result argument as " );
          }
        }
        break;
      case 45:	//"callIntrusionIsolate - H.450.11"},
        {
          PPER_Stream per = m_result;
          
          H450_CIIsOptRes olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "Unable to decode Result argument as " );
          }
        }
        break;
      case 46:	//"callIntrusionForcedRelease - H.450.11"},
        {
          PPER_Stream per = m_result;
          
          H450_CIFrcRelOptRes olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "Unable to decode Result argument as " );
          }
        }
        break;
      case 47:	//"callIntrusionWOBRequest - H.450.11"},
        {
          PPER_Stream per = m_result;
          
          H450_CIWobOptRes olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "Unable to decode Result argument as " );
          }
        }
        break;
      case 80:	//"mwiActivate - H.450.7"},
        {
          PPER_Stream per = m_result;
          
          H450_DummyRes olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "Unable to decode Result argument as " );
          }
        }
        break;
      case 81:	//"mwiDeactivate - H.450.7"},
        {
          PPER_Stream per = m_result;
          
          H450_DummyRes olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "Unable to decode Result argument as " );
          }
        }
        break;
      case 82:	//"mwiInterrogate - H.450.7"},
        {
          PPER_Stream per = m_result;
          
          H450_MWIInterrogateRes olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "Unable to decode Result argument as " );
          }
        }
        break;
      case 84:	//"cmnRequest - H.450.12"},
      /*  {
          PPER_Stream per = m_result;
          
          H450_CmnArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
        */
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "H.450.12 Not yet implemented" );
        /*  }
        }*/
        break;
      case 100:	//"divertingLegInformation4"},
        break;
      case 103:	//"remoteHold - H.450.4"},
        {
          PPER_Stream per = m_result;
          
          H450_RemoteHoldRes olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "Unable to decode Result argument as " );
          }
        }
        break;
      case 104:	//"remoteRetreive - H.450.4"},
        {
          PPER_Stream per = m_result;
          
          H450_RemoteRetrieveRes olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "Unable to decode Result argument as " );
          }
        }
        break;
      case 106:	//"cpRequest - H.450.5"},
        {
          PPER_Stream per = m_result;
          
          H450_CpRequestRes olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "Unable to decode Result argument as " );
          }
        }
        break;
      case 107:	//"cpSetup - H.450.5"},
        {
          PPER_Stream per = m_result;
          
          H450_CpSetupRes olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "Unable to decode Result argument as " );
          }
        }
        break;
      case 108:	//"groupIndicationOn - H.450.5"},
        {
          PPER_Stream per = m_result;
          
          H450_GroupIndicationOnRes olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "Unable to decode Result argument as " );
          }
        }
        break;
      case 109:	//"groupIndicationOff - H.450.5"},
        {
          PPER_Stream per = m_result;
          
          H450_GroupIndicationOffRes olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "Unable to decode Result argument as " );
          }
        }
        break;
      case 110:	//"pickrequ - H.450.5"},
        {
          PPER_Stream per = m_result;
          
          H450_PickrequRes olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "Unable to decode Result argument as " );
          }
        }
        break;
      case 111:	//"pickup - H.450.5"},
        {
          PPER_Stream per = m_result;
          
          H450_PickupRes olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "Unable to decode Result argument as " );
          }
        }
        break;
      case 112:	//"pickExe - H.450.5"},
        {
          PPER_Stream per = m_result;
          
          H450_PickExeRes olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "Unable to decode Result argument as " );
          }
        }
        break;
      case 116:	//"callIntrusionSilentMonitor - H.450.11"},
        {
          PPER_Stream per = m_result;
          
          H450_CISilentOptRes olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_result.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "Unable to decode Result argument as " );
          }
        }
        break;
      default:
        proto_tree_add_text( argument_tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "This opcode should not return a ReturnResult" );
        break;
      }
    }
  //}

}
#endif  //USE_FOR_ETHEREAL

//
// Reject_problem
//

H450_Reject_problem::H450_Reject_problem(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, FALSE
#ifndef PASN_NOPRINTON
      , "general "
        "invoke "
        "returnResult "
        "returnError "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_Reject_problem::operator H450_GeneralProblem &() const
#else
H450_Reject_problem::operator H450_GeneralProblem &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_GeneralProblem::Class()), PInvalidCast);
#endif
  return *(H450_GeneralProblem *)choice;
}


H450_Reject_problem::operator const H450_GeneralProblem &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_GeneralProblem::Class()), PInvalidCast);
#endif
  return *(H450_GeneralProblem *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_Reject_problem::operator H450_InvokeProblem &() const
#else
H450_Reject_problem::operator H450_InvokeProblem &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_InvokeProblem::Class()), PInvalidCast);
#endif
  return *(H450_InvokeProblem *)choice;
}


H450_Reject_problem::operator const H450_InvokeProblem &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_InvokeProblem::Class()), PInvalidCast);
#endif
  return *(H450_InvokeProblem *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_Reject_problem::operator H450_ReturnResultProblem &() const
#else
H450_Reject_problem::operator H450_ReturnResultProblem &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ReturnResultProblem::Class()), PInvalidCast);
#endif
  return *(H450_ReturnResultProblem *)choice;
}


H450_Reject_problem::operator const H450_ReturnResultProblem &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ReturnResultProblem::Class()), PInvalidCast);
#endif
  return *(H450_ReturnResultProblem *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_Reject_problem::operator H450_ReturnErrorProblem &() const
#else
H450_Reject_problem::operator H450_ReturnErrorProblem &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ReturnErrorProblem::Class()), PInvalidCast);
#endif
  return *(H450_ReturnErrorProblem *)choice;
}


H450_Reject_problem::operator const H450_ReturnErrorProblem &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ReturnErrorProblem::Class()), PInvalidCast);
#endif
  return *(H450_ReturnErrorProblem *)choice;
}


BOOL H450_Reject_problem::CreateObject()
{
  switch (tag) {
    case e_general :
      choice = new H450_GeneralProblem();
      return TRUE;
    case e_invoke :
      choice = new H450_InvokeProblem();
      return TRUE;
    case e_returnResult :
      choice = new H450_ReturnResultProblem();
      return TRUE;
    case e_returnError :
      choice = new H450_ReturnErrorProblem();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_Reject_problem::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_Reject_problem::Class()), PInvalidCast);
#endif
  return new H450_Reject_problem(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_Reject_problem::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_general :
        ( ( H450_GeneralProblem * ) choice )->preShowEthereal();
        break;
      case e_invoke :
        ( ( H450_InvokeProblem * ) choice )->preShowEthereal();
        break;
      case e_returnResult :
        ( ( H450_ReturnResultProblem * ) choice )->preShowEthereal();
        break;
      case e_returnError :
        ( ( H450_ReturnErrorProblem * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_Reject_problem::getSummary( void ) 
{
  return PString( "Reject_problem" );
}

void H450_Reject_problem::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "general" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h450_1.hf_h450_Reject_problem_general, tvb, offset + ( ( H450_GeneralProblem* ) choice) ->GetStartByte(), ( ( H450_GeneralProblem* ) choice) ->GetByteLength(),  ( ( H450_GeneralProblem* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "invoke" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h450_1.hf_h450_Reject_problem_invoke, tvb, offset + ( ( H450_InvokeProblem* ) choice) ->GetStartByte(), ( ( H450_InvokeProblem* ) choice) ->GetByteLength(),  ( ( H450_InvokeProblem* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "returnResult" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h450_1.hf_h450_Reject_problem_returnResult, tvb, offset + ( ( H450_ReturnResultProblem* ) choice) ->GetStartByte(), ( ( H450_ReturnResultProblem* ) choice) ->GetByteLength(),  ( ( H450_ReturnResultProblem* ) choice) ->GetValue() );
      return;
    }

    if ( strcmp( GetTagName(), "returnError" ) == 0 ) {
    proto_tree_add_uint( tree, hCont->h450_1.hf_h450_Reject_problem_returnError, tvb, offset + ( ( H450_ReturnErrorProblem* ) choice) ->GetStartByte(), ( ( H450_ReturnErrorProblem* ) choice) ->GetByteLength(),  ( ( H450_ReturnErrorProblem* ) choice) ->GetValue() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_ROS
//

H450_ArrayOf_ROS::H450_ArrayOf_ROS(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H450_ArrayOf_ROS::CreateObject() const
{
  return new H450_ROS;
}


H450_ROS & H450_ArrayOf_ROS::operator[](PINDEX i) const
{
  return (H450_ROS &)array[i];
}


PObject * H450_ArrayOf_ROS::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_ArrayOf_ROS::Class()), PInvalidCast);
#endif
  return new H450_ArrayOf_ROS(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_ArrayOf_ROS::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H450_ROS& ) array[i] ).preShowEthereal();
  }
}

PString H450_ArrayOf_ROS::getSummary( void ) 
{
  return PString( "ArrayOf_ROS" );
}

void H450_ArrayOf_ROS::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_ROS_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_ROS_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_ROS_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (%s)", i, (const char*) ( ( PASN_Choice* ) &( array[i] ) )->GetTagName() );
    ArrayOf_ROS_tree = proto_item_add_subtree( ArrayOf_ROS_ti, hCont->h450_1.ett_h450_ArrayOf_ROS );
    array[i].showEthereal( ArrayOf_ROS_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_AliasAddress
//

H450_ArrayOf_AliasAddress::H450_ArrayOf_AliasAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H450_ArrayOf_AliasAddress::CreateObject() const
{
  return new H225_AliasAddress;
}


H225_AliasAddress & H450_ArrayOf_AliasAddress::operator[](PINDEX i) const
{
  return (H225_AliasAddress &)array[i];
}


PObject * H450_ArrayOf_AliasAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_ArrayOf_AliasAddress::Class()), PInvalidCast);
#endif
  return new H450_ArrayOf_AliasAddress(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_ArrayOf_AliasAddress::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H225_AliasAddress& ) array[i] ).preShowEthereal();
  }
}

PString H450_ArrayOf_AliasAddress::getSummary( void ) 
{
  return PString( "ArrayOf_AliasAddress" );
}

void H450_ArrayOf_AliasAddress::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_AliasAddress_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_AliasAddress_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_AliasAddress_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (H225-AliasAddress)", i );
    ArrayOf_AliasAddress_tree = proto_item_add_subtree( ArrayOf_AliasAddress_ti, hCont->h450_1.ett_h450_ArrayOf_AliasAddress );
    array[i].showEthereal( ArrayOf_AliasAddress_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_MixedExtension
//

H450_ArrayOf_MixedExtension::H450_ArrayOf_MixedExtension(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H450_ArrayOf_MixedExtension::CreateObject() const
{
  return new H450_MixedExtension;
}


H450_MixedExtension & H450_ArrayOf_MixedExtension::operator[](PINDEX i) const
{
  return (H450_MixedExtension &)array[i];
}


PObject * H450_ArrayOf_MixedExtension::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_ArrayOf_MixedExtension::Class()), PInvalidCast);
#endif
  return new H450_ArrayOf_MixedExtension(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_ArrayOf_MixedExtension::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H450_MixedExtension& ) array[i] ).preShowEthereal();
  }
}

PString H450_ArrayOf_MixedExtension::getSummary( void ) 
{
  return PString( "ArrayOf_MixedExtension" );
}

void H450_ArrayOf_MixedExtension::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_MixedExtension_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_MixedExtension_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_MixedExtension_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (%s)", i, (const char*) ( ( PASN_Choice* ) &( array[i] ) )->GetTagName() );
    ArrayOf_MixedExtension_tree = proto_item_add_subtree( ArrayOf_MixedExtension_ti, hCont->h450_1.ett_h450_ArrayOf_MixedExtension );
    array[i].showEthereal( ArrayOf_MixedExtension_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// IntResult_extension
//

H450_IntResult_extension::H450_IntResult_extension(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
      , "extensionSeq "
        "nonStandardData "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_IntResult_extension::operator H450_ExtensionSeq &() const
#else
H450_IntResult_extension::operator H450_ExtensionSeq &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ExtensionSeq::Class()), PInvalidCast);
#endif
  return *(H450_ExtensionSeq *)choice;
}


H450_IntResult_extension::operator const H450_ExtensionSeq &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ExtensionSeq::Class()), PInvalidCast);
#endif
  return *(H450_ExtensionSeq *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_IntResult_extension::operator H225_NonStandardParameter &() const
#else
H450_IntResult_extension::operator H225_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


H450_IntResult_extension::operator const H225_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


BOOL H450_IntResult_extension::CreateObject()
{
  switch (tag) {
    case e_extensionSeq :
      choice = new H450_ExtensionSeq();
      return TRUE;
    case e_nonStandardData :
      choice = new H225_NonStandardParameter();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_IntResult_extension::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_IntResult_extension::Class()), PInvalidCast);
#endif
  return new H450_IntResult_extension(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_IntResult_extension::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_extensionSeq :
        ( ( H450_ExtensionSeq * ) choice )->preShowEthereal();
        break;
      case e_nonStandardData :
        ( ( H225_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_IntResult_extension::getSummary( void ) 
{
  return PString( "IntResult_extension" );
}

void H450_IntResult_extension::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* The class H225_NonStandardParameter of which the choice type
     * nonStandardData is an instantation of, is defined
     * outside the current ASN.1 file, therefore it's not
     * known what type it is. A non-terminal is presumed
     */
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h450_1.ett_h450_IntResult_extension_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// CTInitiateArg_argumentExtension
//

H450_CTInitiateArg_argumentExtension::H450_CTInitiateArg_argumentExtension(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
      , "extensionSeq "
        "nonStandardData "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_CTInitiateArg_argumentExtension::operator H450_ExtensionSeq &() const
#else
H450_CTInitiateArg_argumentExtension::operator H450_ExtensionSeq &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ExtensionSeq::Class()), PInvalidCast);
#endif
  return *(H450_ExtensionSeq *)choice;
}


H450_CTInitiateArg_argumentExtension::operator const H450_ExtensionSeq &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ExtensionSeq::Class()), PInvalidCast);
#endif
  return *(H450_ExtensionSeq *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_CTInitiateArg_argumentExtension::operator H225_NonStandardParameter &() const
#else
H450_CTInitiateArg_argumentExtension::operator H225_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


H450_CTInitiateArg_argumentExtension::operator const H225_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


BOOL H450_CTInitiateArg_argumentExtension::CreateObject()
{
  switch (tag) {
    case e_extensionSeq :
      choice = new H450_ExtensionSeq();
      return TRUE;
    case e_nonStandardData :
      choice = new H225_NonStandardParameter();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_CTInitiateArg_argumentExtension::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CTInitiateArg_argumentExtension::Class()), PInvalidCast);
#endif
  return new H450_CTInitiateArg_argumentExtension(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CTInitiateArg_argumentExtension::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_extensionSeq :
        ( ( H450_ExtensionSeq * ) choice )->preShowEthereal();
        break;
      case e_nonStandardData :
        ( ( H225_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_CTInitiateArg_argumentExtension::getSummary( void ) 
{
  return PString( "CTInitiateArg_argumentExtension" );
}

void H450_CTInitiateArg_argumentExtension::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* The class H225_NonStandardParameter of which the choice type
     * nonStandardData is an instantation of, is defined
     * outside the current ASN.1 file, therefore it's not
     * known what type it is. A non-terminal is presumed
     */
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h450_1.ett_h450_CTInitiateArg_argumentExtension_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// CTSetupArg_argumentExtension
//

H450_CTSetupArg_argumentExtension::H450_CTSetupArg_argumentExtension(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
      , "extensionSeq "
        "nonStandardData "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_CTSetupArg_argumentExtension::operator H450_ExtensionSeq &() const
#else
H450_CTSetupArg_argumentExtension::operator H450_ExtensionSeq &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ExtensionSeq::Class()), PInvalidCast);
#endif
  return *(H450_ExtensionSeq *)choice;
}


H450_CTSetupArg_argumentExtension::operator const H450_ExtensionSeq &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ExtensionSeq::Class()), PInvalidCast);
#endif
  return *(H450_ExtensionSeq *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_CTSetupArg_argumentExtension::operator H225_NonStandardParameter &() const
#else
H450_CTSetupArg_argumentExtension::operator H225_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


H450_CTSetupArg_argumentExtension::operator const H225_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


BOOL H450_CTSetupArg_argumentExtension::CreateObject()
{
  switch (tag) {
    case e_extensionSeq :
      choice = new H450_ExtensionSeq();
      return TRUE;
    case e_nonStandardData :
      choice = new H225_NonStandardParameter();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_CTSetupArg_argumentExtension::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CTSetupArg_argumentExtension::Class()), PInvalidCast);
#endif
  return new H450_CTSetupArg_argumentExtension(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CTSetupArg_argumentExtension::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_extensionSeq :
        ( ( H450_ExtensionSeq * ) choice )->preShowEthereal();
        break;
      case e_nonStandardData :
        ( ( H225_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_CTSetupArg_argumentExtension::getSummary( void ) 
{
  return PString( "CTSetupArg_argumentExtension" );
}

void H450_CTSetupArg_argumentExtension::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* The class H225_NonStandardParameter of which the choice type
     * nonStandardData is an instantation of, is defined
     * outside the current ASN.1 file, therefore it's not
     * known what type it is. A non-terminal is presumed
     */
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h450_1.ett_h450_CTSetupArg_argumentExtension_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// CTIdentifyRes_resultExtension
//

H450_CTIdentifyRes_resultExtension::H450_CTIdentifyRes_resultExtension(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
      , "extensionSeq "
        "nonStandardData "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_CTIdentifyRes_resultExtension::operator H450_ExtensionSeq &() const
#else
H450_CTIdentifyRes_resultExtension::operator H450_ExtensionSeq &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ExtensionSeq::Class()), PInvalidCast);
#endif
  return *(H450_ExtensionSeq *)choice;
}


H450_CTIdentifyRes_resultExtension::operator const H450_ExtensionSeq &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ExtensionSeq::Class()), PInvalidCast);
#endif
  return *(H450_ExtensionSeq *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_CTIdentifyRes_resultExtension::operator H225_NonStandardParameter &() const
#else
H450_CTIdentifyRes_resultExtension::operator H225_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


H450_CTIdentifyRes_resultExtension::operator const H225_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


BOOL H450_CTIdentifyRes_resultExtension::CreateObject()
{
  switch (tag) {
    case e_extensionSeq :
      choice = new H450_ExtensionSeq();
      return TRUE;
    case e_nonStandardData :
      choice = new H225_NonStandardParameter();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_CTIdentifyRes_resultExtension::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CTIdentifyRes_resultExtension::Class()), PInvalidCast);
#endif
  return new H450_CTIdentifyRes_resultExtension(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CTIdentifyRes_resultExtension::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_extensionSeq :
        ( ( H450_ExtensionSeq * ) choice )->preShowEthereal();
        break;
      case e_nonStandardData :
        ( ( H225_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_CTIdentifyRes_resultExtension::getSummary( void ) 
{
  return PString( "CTIdentifyRes_resultExtension" );
}

void H450_CTIdentifyRes_resultExtension::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* The class H225_NonStandardParameter of which the choice type
     * nonStandardData is an instantation of, is defined
     * outside the current ASN.1 file, therefore it's not
     * known what type it is. A non-terminal is presumed
     */
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h450_1.ett_h450_CTIdentifyRes_resultExtension_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// CTUpdateArg_argumentExtension
//

H450_CTUpdateArg_argumentExtension::H450_CTUpdateArg_argumentExtension(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
      , "extensionSeq "
        "nonStandardData "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_CTUpdateArg_argumentExtension::operator H450_ExtensionSeq &() const
#else
H450_CTUpdateArg_argumentExtension::operator H450_ExtensionSeq &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ExtensionSeq::Class()), PInvalidCast);
#endif
  return *(H450_ExtensionSeq *)choice;
}


H450_CTUpdateArg_argumentExtension::operator const H450_ExtensionSeq &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ExtensionSeq::Class()), PInvalidCast);
#endif
  return *(H450_ExtensionSeq *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_CTUpdateArg_argumentExtension::operator H225_NonStandardParameter &() const
#else
H450_CTUpdateArg_argumentExtension::operator H225_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


H450_CTUpdateArg_argumentExtension::operator const H225_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


BOOL H450_CTUpdateArg_argumentExtension::CreateObject()
{
  switch (tag) {
    case e_extensionSeq :
      choice = new H450_ExtensionSeq();
      return TRUE;
    case e_nonStandardData :
      choice = new H225_NonStandardParameter();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_CTUpdateArg_argumentExtension::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CTUpdateArg_argumentExtension::Class()), PInvalidCast);
#endif
  return new H450_CTUpdateArg_argumentExtension(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CTUpdateArg_argumentExtension::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_extensionSeq :
        ( ( H450_ExtensionSeq * ) choice )->preShowEthereal();
        break;
      case e_nonStandardData :
        ( ( H225_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_CTUpdateArg_argumentExtension::getSummary( void ) 
{
  return PString( "CTUpdateArg_argumentExtension" );
}

void H450_CTUpdateArg_argumentExtension::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* The class H225_NonStandardParameter of which the choice type
     * nonStandardData is an instantation of, is defined
     * outside the current ASN.1 file, therefore it's not
     * known what type it is. A non-terminal is presumed
     */
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h450_1.ett_h450_CTUpdateArg_argumentExtension_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// SubaddressTransferArg_argumentExtension
//

H450_SubaddressTransferArg_argumentExtension::H450_SubaddressTransferArg_argumentExtension(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
      , "extensionSeq "
        "nonStandardData "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_SubaddressTransferArg_argumentExtension::operator H450_ExtensionSeq &() const
#else
H450_SubaddressTransferArg_argumentExtension::operator H450_ExtensionSeq &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ExtensionSeq::Class()), PInvalidCast);
#endif
  return *(H450_ExtensionSeq *)choice;
}


H450_SubaddressTransferArg_argumentExtension::operator const H450_ExtensionSeq &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ExtensionSeq::Class()), PInvalidCast);
#endif
  return *(H450_ExtensionSeq *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_SubaddressTransferArg_argumentExtension::operator H225_NonStandardParameter &() const
#else
H450_SubaddressTransferArg_argumentExtension::operator H225_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


H450_SubaddressTransferArg_argumentExtension::operator const H225_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


BOOL H450_SubaddressTransferArg_argumentExtension::CreateObject()
{
  switch (tag) {
    case e_extensionSeq :
      choice = new H450_ExtensionSeq();
      return TRUE;
    case e_nonStandardData :
      choice = new H225_NonStandardParameter();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_SubaddressTransferArg_argumentExtension::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_SubaddressTransferArg_argumentExtension::Class()), PInvalidCast);
#endif
  return new H450_SubaddressTransferArg_argumentExtension(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_SubaddressTransferArg_argumentExtension::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_extensionSeq :
        ( ( H450_ExtensionSeq * ) choice )->preShowEthereal();
        break;
      case e_nonStandardData :
        ( ( H225_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_SubaddressTransferArg_argumentExtension::getSummary( void ) 
{
  return PString( "SubaddressTransferArg_argumentExtension" );
}

void H450_SubaddressTransferArg_argumentExtension::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* The class H225_NonStandardParameter of which the choice type
     * nonStandardData is an instantation of, is defined
     * outside the current ASN.1 file, therefore it's not
     * known what type it is. A non-terminal is presumed
     */
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h450_1.ett_h450_SubaddressTransferArg_argumentExtension_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// CTCompleteArg_argumentExtension
//

H450_CTCompleteArg_argumentExtension::H450_CTCompleteArg_argumentExtension(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
      , "extensionSeq "
        "nonStandardData "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_CTCompleteArg_argumentExtension::operator H450_ExtensionSeq &() const
#else
H450_CTCompleteArg_argumentExtension::operator H450_ExtensionSeq &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ExtensionSeq::Class()), PInvalidCast);
#endif
  return *(H450_ExtensionSeq *)choice;
}


H450_CTCompleteArg_argumentExtension::operator const H450_ExtensionSeq &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ExtensionSeq::Class()), PInvalidCast);
#endif
  return *(H450_ExtensionSeq *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_CTCompleteArg_argumentExtension::operator H225_NonStandardParameter &() const
#else
H450_CTCompleteArg_argumentExtension::operator H225_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


H450_CTCompleteArg_argumentExtension::operator const H225_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


BOOL H450_CTCompleteArg_argumentExtension::CreateObject()
{
  switch (tag) {
    case e_extensionSeq :
      choice = new H450_ExtensionSeq();
      return TRUE;
    case e_nonStandardData :
      choice = new H225_NonStandardParameter();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_CTCompleteArg_argumentExtension::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CTCompleteArg_argumentExtension::Class()), PInvalidCast);
#endif
  return new H450_CTCompleteArg_argumentExtension(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CTCompleteArg_argumentExtension::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_extensionSeq :
        ( ( H450_ExtensionSeq * ) choice )->preShowEthereal();
        break;
      case e_nonStandardData :
        ( ( H225_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_CTCompleteArg_argumentExtension::getSummary( void ) 
{
  return PString( "CTCompleteArg_argumentExtension" );
}

void H450_CTCompleteArg_argumentExtension::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* The class H225_NonStandardParameter of which the choice type
     * nonStandardData is an instantation of, is defined
     * outside the current ASN.1 file, therefore it's not
     * known what type it is. A non-terminal is presumed
     */
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h450_1.ett_h450_CTCompleteArg_argumentExtension_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// CTActiveArg_argumentExtension
//

H450_CTActiveArg_argumentExtension::H450_CTActiveArg_argumentExtension(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
      , "extensionSeq "
        "nonStandardData "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_CTActiveArg_argumentExtension::operator H450_ExtensionSeq &() const
#else
H450_CTActiveArg_argumentExtension::operator H450_ExtensionSeq &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ExtensionSeq::Class()), PInvalidCast);
#endif
  return *(H450_ExtensionSeq *)choice;
}


H450_CTActiveArg_argumentExtension::operator const H450_ExtensionSeq &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H450_ExtensionSeq::Class()), PInvalidCast);
#endif
  return *(H450_ExtensionSeq *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H450_CTActiveArg_argumentExtension::operator H225_NonStandardParameter &() const
#else
H450_CTActiveArg_argumentExtension::operator H225_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


H450_CTActiveArg_argumentExtension::operator const H225_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


BOOL H450_CTActiveArg_argumentExtension::CreateObject()
{
  switch (tag) {
    case e_extensionSeq :
      choice = new H450_ExtensionSeq();
      return TRUE;
    case e_nonStandardData :
      choice = new H225_NonStandardParameter();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H450_CTActiveArg_argumentExtension::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CTActiveArg_argumentExtension::Class()), PInvalidCast);
#endif
  return new H450_CTActiveArg_argumentExtension(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CTActiveArg_argumentExtension::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_extensionSeq :
        ( ( H450_ExtensionSeq * ) choice )->preShowEthereal();
        break;
      case e_nonStandardData :
        ( ( H225_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H450_CTActiveArg_argumentExtension::getSummary( void ) 
{
  return PString( "CTActiveArg_argumentExtension" );
}

void H450_CTActiveArg_argumentExtension::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* The class H225_NonStandardParameter of which the choice type
     * nonStandardData is an instantation of, is defined
     * outside the current ASN.1 file, therefore it's not
     * known what type it is. A non-terminal is presumed
     */
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h450_1.ett_h450_CTActiveArg_argumentExtension_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// Invoke
//

H450_Invoke::H450_Invoke(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, FALSE, 0)
{
  m_invokeId.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H450_Invoke::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "invokeId = " << setprecision(indent) << m_invokeId << '\n';
  if (HasOptionalField(e_linkedId))
    strm << setw(indent+11) << "linkedId = " << setprecision(indent) << m_linkedId << '\n';
  strm << setw(indent+9) << "opcode = " << setprecision(indent) << m_opcode << '\n';
  if (HasOptionalField(e_argument))
    strm << setw(indent+11) << "argument = " << setprecision(indent) << m_argument << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_Invoke::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_Invoke::Class()), PInvalidCast);
#endif
  const H450_Invoke & other = (const H450_Invoke &)obj;

  Comparison result;

  if ((result = m_invokeId.Compare(other.m_invokeId)) != EqualTo)
    return result;
  if ((result = m_linkedId.Compare(other.m_linkedId)) != EqualTo)
    return result;
  if ((result = m_opcode.Compare(other.m_opcode)) != EqualTo)
    return result;
  if ((result = m_argument.Compare(other.m_argument)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_Invoke::GetDataLength() const
{
  PINDEX length = 0;
  length += m_invokeId.GetObjectLength();
  if (HasOptionalField(e_linkedId))
    length += m_linkedId.GetObjectLength();
  length += m_opcode.GetObjectLength();
  if (HasOptionalField(e_argument))
    length += m_argument.GetObjectLength();
  return length;
}


BOOL H450_Invoke::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_invokeId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_linkedId ) && !m_linkedId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_opcode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_argument ) && !m_argument.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_Invoke::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_invokeId.Encode(strm);
  if (HasOptionalField(e_linkedId))
    m_linkedId.Encode(strm);
  m_opcode.Encode(strm);
  if (HasOptionalField(e_argument))
    m_argument.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_invokeId.Encode(strm);
  if (HasOptionalField(e_linkedId))
    m_linkedId.Encode(strm);
  m_opcode.Encode(strm);
  if (HasOptionalField(e_argument))
    m_argument.Encode(strm);
}


PObject * H450_Invoke::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_Invoke::Class()), PInvalidCast);
#endif
  return new H450_Invoke(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_Invoke::preShowEthereal( void )
{
  m_invokeId.preShowEthereal( );
  if ( HasOptionalField( e_linkedId ) ) 
      m_linkedId.preShowEthereal( );
  m_opcode.preShowEthereal( );
  if ( HasOptionalField( e_argument ) ) 
      m_argument.preShowEthereal( );
}

PString H450_Invoke::getSummary( void ) 
{
  return PString( "Invoke" );
}

void H450_Invoke::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h450_1.hf_h450_Invoke_invokeId, tvb, offset + m_invokeId.GetStartByte(), m_invokeId.GetByteLength() , m_invokeId.GetValue() );

  if ( HasOptionalField( e_linkedId ) ) {
    proto_tree_add_uint( tree, hCont->h450_1.hf_h450_Invoke_linkedId, tvb, offset + m_linkedId.GetStartByte(), m_linkedId.GetByteLength() , m_linkedId.GetValue() );
  }

  proto_tree *opcode_tree = (proto_tree*) NULL;
  proto_item *opcode_ti = (proto_item*) NULL;
  opcode_ti = proto_tree_add_text( tree, tvb, offset + m_opcode.GetStartByte(), m_opcode.GetByteLength(), "opcode (%s)", ( const char* ) m_opcode.GetTagName() );
  opcode_tree = proto_item_add_subtree( opcode_ti, hCont->h450_1.ett_h450_Invoke_opcode );

  m_opcode.showEthereal( opcode_tree, tvb, offset );

  //if ( HasOptionalField( e_argument ) ) {
  //  char* pargument = m_argument.getValue();
  //  proto_tree_add_string( tree, hCont->h450_1.hf_h450_Invoke_argument, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength() , pargument );
  //  delete[] pargument;
  ///}

  //    if ( strcmp( GetTagName(), "local" ) == 0 ) {
  //  proto_tree_add_uint( tree, hCont->h450_1.hf_h450_Code_local, tvb, offset + ( ( PASN_Integer* ) choice) ->GetStartByte(), ( ( PASN_Integer* ) choice) ->GetByteLength(),  ( ( PASN_Integer* ) choice) ->GetValue() );
  //    return;
  //  }
  if ( HasOptionalField( e_argument ) ) {
    //Only check if local choice is made
    if( strcmp( m_opcode.GetTagName(), "local" ) == 0 )
    {
      proto_tree *argument_tree = (proto_tree*) NULL;
      proto_item *argument_ti = (proto_item*) NULL;
      argument_ti = proto_tree_add_text( tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "argument" );
      argument_tree = proto_item_add_subtree( argument_ti, hCont->h450_1.ett_h450_Invoke_argument );
      switch( ((PASN_Integer) m_opcode).GetValue() )
      {
      case 0:	//"callingName - H.450.8"},
        // H450.8 is not complete in OpenH323, ASN code oes not seem difficult.
        break;
      case 1:	//"alertingName - H.450.8"},
        break;
      case 2:	//"connectedName - H.450.8"},
        break;
      case 3:	//"busyName - H.450.8"},
        break;
      case 7:	//"callTransferIdentify - H.450.2"},
        {
          PPER_Stream per = m_argument;
          
          H450_DummyArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as CTInitiateArg" );
          }
        }
        break;
      case 8:	//"callTransferAbandon - H.450.2"},
        {
          PPER_Stream per = m_argument;
          
          H450_DummyArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as CTInitiateArg" );
          }
        }
        break;
      case 9:	//"callTransferInitiate - H.450.2"},
        {
          PPER_Stream per = m_argument;
          
          H450_CTInitiateArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as CTInitiateArg" );
          }
        }
        break;
      case 10:	//"callTransferSetup - H.450.2"},
        {
          PPER_Stream per = m_argument;
          
          H450_CTSetupArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as CTInitiateArg" );
          }
        }
        break;
      case 11:	//"callTransferActive - H.450.2"},
        {
          PPER_Stream per = m_argument;
          
          H450_CTActiveArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as CTInitiateArg" );
          }
        }
        break;
      case 12:	//"callTransferComplete - H.450.2"},
        {
          PPER_Stream per = m_argument;
          
          H450_CTCompleteArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as CTInitiateArg" );
          }
        }
        break;
      case 13:	//"callTransferUpdate - H.450.2"},
        {
          PPER_Stream per = m_argument;
          
          H450_CTUpdateArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as CTInitiateArg" );
          }
        }
        break;
      case 14:	//"subAddressTransfer - H.450.2"},
        {
          PPER_Stream per = m_argument;
          
          H450_SubaddressTransferArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as CTInitiateArg" );
          }
        }
        break;
      case 15:	//"activateDiversionQ - H.450.3"},
        // H450.3 is still incomplete, the OpenH323 ASN.1 files are 
        // not filled in completely. Seems not too difficult....
        break;
      case 16:	//"deactivateDiversionQ - H.450.3"},
        break;
      case 17:	//"interrogateDiversionQ - H.450.3"},
        break;
      case 18:	//"checkRestriction - H.450.3"},
        break;
      case 19:	//"callRerouting - H.450.3"},
        break;
      case 20:	//"divertingLegInformation1 - H.450.3"},
        break;
      case 21:	//"divertingLegInformation2 - H.450.3"},
        break;
      case 22:	//"divertingLegInformation3 - H.450.3"},
        break;
      case 23:	//"cfnrDivertedLegFailed - H.450.3"},
        break;
      case 27:	//"ccnrRequest - H.450.9"},
        {
          PPER_Stream per = m_argument;
          
          H450_CcRequestArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as CTInitiateArg" );
          }
        }
        break;
      case 28:	//"ccCancel - H.450.9"},
      case 29:	//"ccExecPossible - H.450.9"},
      case 33:	//"ccResume - H.450.9"},
        {
          PPER_Stream per = m_argument;
          
          H450_CcArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as CTInitiateArg" );
          }
        }
        break;
      case 31:	//"ccRingout - H.450.9"},
      case 32:	//"ccSuspend - H.450.9"},
        {
          PPER_Stream per = m_argument;
          
          H450_CcShortArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as CTInitiateArg" );
          }
        }
        break;
      case 34:	//"callOfferRequest - H.450.10"},
        {
          PPER_Stream per = m_argument;
          
          H450_CoReqOptArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as CTInitiateArg" );
          }
        }
        break;
      case 40:	//"ccbsRequest - H.450.9"},
        {
          PPER_Stream per = m_argument;
          
          H450_CcRequestArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as CTInitiateArg" );
          }
        }
        break;
      case 43:	//"callIntrusionRequest - H.450.11"},
        {
          PPER_Stream per = m_argument;
          
          H450_CIRequestArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as CTInitiateArg" );
          }
        }
        break;
      case 44:	//"callIntrusionGetCIPL - H.450.11"},
        {
          PPER_Stream per = m_argument;
          
          H450_CIGetCIPLOptArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as CTInitiateArg" );
          }
        }
        break;
      case 45:	//"callIntrusionIsolate - H.450.11"},
        {
          PPER_Stream per = m_argument;
          
          H450_CIIsOptArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as CTInitiateArg" );
          }
        }
        break;
      case 46:	//"callIntrusionForcedRelease - H.450.11"},
        {
          PPER_Stream per = m_argument;
          
          H450_CIFrcRelArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as CTInitiateArg" );
          }
        }
        break;
      case 47:	//"callIntrusionWOBRequest - H.450.11"},
        {
          PPER_Stream per = m_argument;
          
          H450_CIWobOptArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as CTInitiateArg" );
          }
        }
        break;
      case 49:	//"cfbOverride - H.450.10"},
        {
          PPER_Stream per = m_argument;
          
          H450_CfbOvrOptArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as CTInitiateArg" );
          }
        }
        break;
      case 80:	//"mwiActivate - H.450.7"},
        {
          PPER_Stream per = m_argument;
          
          H450_MWIActivateArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as holdNotificArg" );
          }
        }
        break;
      case 81:	//"mwiDeactivate - H.450.7"},
        {
          PPER_Stream per = m_argument;
          
          H450_MWIDeactivateArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as holdNotificArg" );
          }
        }
        break;
      case 82:	//"mwiInterrogate - H.450.7"},
        {
          PPER_Stream per = m_argument;
          
          H450_MWIInterrogateArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as holdNotificArg" );
          }
        }
        break;
      case 84:	//"cmnRequest - H.450.12"},
        {
          PPER_Stream per = m_argument;
          
          H450_DummyArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as CTInitiateArg" );
          }
        }
        break;
      case 85:	//"cmnInform - H.450.12"},
        {
/*          PPER_Stream per = m_argument;
          
          H450_CmnArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {*/
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "H.450.12 is not implemented yet" );
          //}
        }
        break;
      case 100:	//"divertingLegInformation4"},
        break;
      case 101:	//"holdNotific - H.450.4"},
        {
          PPER_Stream per = m_argument;
          
          H450_HoldNotificArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as holdNotificArg" );
          }
        }
        break;
      case 102:	//"retreiveNotific - H.450.4"},
        {
          PPER_Stream per = m_argument;
          
          H450_RetrieveNotificArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as holdNotificArg" );
          }
        }
        break;
      case 103:	//"remoteHold - H.450.4"},
        {
          PPER_Stream per = m_argument;
          
          H450_RemoteHoldArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as holdNotificArg" );
          }
        }
        break;
      case 104:	//"remoteRetreive - H.450.4"},
        {
          PPER_Stream per = m_argument;
          
          H450_RemoteRetrieveArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as holdNotificArg" );
          }
        }
        break;
      case 105:	//"callWaiting - H.450.6"},
        {
          PPER_Stream per = m_argument;
          
          H450_CallWaitingArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as holdNotificArg" );
          }
        }
        break;
      case 106:	//"cpRequest - H.450.5"},
        {
          PPER_Stream per = m_argument;
          
          H450_CpRequestArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as holdNotificArg" );
          }
        }
        break;
      case 107:	//"cpSetup - H.450.5"},
        {
          PPER_Stream per = m_argument;
          
          H450_CpSetupArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as holdNotificArg" );
          }
        }
        break;
      case 108:	//"groupIndicationOn - H.450.5"},
        {
          PPER_Stream per = m_argument;
          
          H450_GroupIndicationOnArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as holdNotificArg" );
          }
        }
        break;
      case 109:	//"groupIndicationOff - H.450.5"},
        {
          PPER_Stream per = m_argument;
          
          H450_GroupIndicationOffArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as holdNotificArg" );
          }
        }
        break;
      case 110:	//"pickrequ - H.450.5"},
        {
          PPER_Stream per = m_argument;
          
          H450_PickrequArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as holdNotificArg" );
          }
        }
        break;
      case 111:	//"pickup - H.450.5"},
        {
          PPER_Stream per = m_argument;
          
          H450_PickupArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as holdNotificArg" );
          }
        }
        break;
      case 112:	//"pickExe - H.450.5"},
        {
          PPER_Stream per = m_argument;
          
          H450_PickExeArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as holdNotificArg" );
          }
        }
        break;
      case 113:	//"cpNotify - H.450.5"},
        {
          PPER_Stream per = m_argument;
          
          H450_CpNotifyArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as holdNotificArg" );
          }
        }
        break;
      case 114:	//"cpickupNotify - H.450.5"},
        {
          PPER_Stream per = m_argument;
          
          H450_CpickupNotifyArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as holdNotificArg" );
          }
        }
        break;
      case 115:	//"remoteUserAlerting - H.450.10"},
        {
          PPER_Stream per = m_argument;
          
          H450_RUAlertOptArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as CTInitiateArg" );
          }
        }
        break;
      case 116:	//"callIntrusionSilentMonitor - H.450.11"},
        {
          PPER_Stream per = m_argument;
          
          H450_CISilentArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as CTInitiateArg" );
          }
        }
        break;
      case 117:	//"callIntrusionNotification - H.450.11"},
        {
          PPER_Stream per = m_argument;
          
          H450_CINotificationArg olc;
          if ( olc.Decode( per ) )
          {
            olc.showEthereal( argument_tree, tvb, offset + m_argument.GetStartByte() );
          }
          else
          {
            proto_tree_add_text( argument_tree, tvb, offset + m_argument.GetStartByte(), m_argument.GetByteLength(), "Unable to decode argument as CTInitiateArg" );
          }
        }
        break;
      default:
        break;
      }
    }
  }


}
#endif  //USE_FOR_ETHEREAL

//
// ReturnResult
//

H450_ReturnResult::H450_ReturnResult(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H450_ReturnResult::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "invokeId = " << setprecision(indent) << m_invokeId << '\n';
  if (HasOptionalField(e_result))
    strm << setw(indent+9) << "result = " << setprecision(indent) << m_result << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_ReturnResult::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_ReturnResult::Class()), PInvalidCast);
#endif
  const H450_ReturnResult & other = (const H450_ReturnResult &)obj;

  Comparison result;

  if ((result = m_invokeId.Compare(other.m_invokeId)) != EqualTo)
    return result;
  if ((result = m_result.Compare(other.m_result)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_ReturnResult::GetDataLength() const
{
  PINDEX length = 0;
  length += m_invokeId.GetObjectLength();
  if (HasOptionalField(e_result))
    length += m_result.GetObjectLength();
  return length;
}


BOOL H450_ReturnResult::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_invokeId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_result ) && !m_result.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_ReturnResult::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_invokeId.Encode(strm);
  if (HasOptionalField(e_result))
    m_result.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_invokeId.Encode(strm);
  if (HasOptionalField(e_result))
    m_result.Encode(strm);
}


PObject * H450_ReturnResult::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_ReturnResult::Class()), PInvalidCast);
#endif
  return new H450_ReturnResult(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_ReturnResult::preShowEthereal( void )
{
  m_invokeId.preShowEthereal( );
  if ( HasOptionalField( e_result ) ) 
      m_result.preShowEthereal( );
}

PString H450_ReturnResult::getSummary( void ) 
{
  return PString( "ReturnResult" );
}

void H450_ReturnResult::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h450_1.hf_h450_ReturnResult_invokeId, tvb, offset + m_invokeId.GetStartByte(), m_invokeId.GetByteLength() , m_invokeId.GetValue() );

  if ( HasOptionalField( e_result ) ) {
    proto_tree *result_tree = (proto_tree*) NULL;
    proto_item *result_ti = (proto_item*) NULL;
    result_ti = proto_tree_add_text( tree, tvb, offset + m_result.GetStartByte(), m_result.GetByteLength(), "result (ReturnResult-result)" );
    result_tree = proto_item_add_subtree( result_ti, hCont->h450_1.ett_h450_ReturnResult_result );
    m_result.showEthereal( result_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// ReturnError
//

H450_ReturnError::H450_ReturnError(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H450_ReturnError::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "invokeId = " << setprecision(indent) << m_invokeId << '\n';
  strm << setw(indent+12) << "errorCode = " << setprecision(indent) << m_errorCode << '\n';
  if (HasOptionalField(e_parameter))
    strm << setw(indent+12) << "parameter = " << setprecision(indent) << m_parameter << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_ReturnError::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_ReturnError::Class()), PInvalidCast);
#endif
  const H450_ReturnError & other = (const H450_ReturnError &)obj;

  Comparison result;

  if ((result = m_invokeId.Compare(other.m_invokeId)) != EqualTo)
    return result;
  if ((result = m_errorCode.Compare(other.m_errorCode)) != EqualTo)
    return result;
  if ((result = m_parameter.Compare(other.m_parameter)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_ReturnError::GetDataLength() const
{
  PINDEX length = 0;
  length += m_invokeId.GetObjectLength();
  length += m_errorCode.GetObjectLength();
  if (HasOptionalField(e_parameter))
    length += m_parameter.GetObjectLength();
  return length;
}


BOOL H450_ReturnError::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_invokeId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_errorCode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_parameter ) && !m_parameter.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_ReturnError::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_invokeId.Encode(strm);
  m_errorCode.Encode(strm);
  if (HasOptionalField(e_parameter))
    m_parameter.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_invokeId.Encode(strm);
  m_errorCode.Encode(strm);
  if (HasOptionalField(e_parameter))
    m_parameter.Encode(strm);
}


PObject * H450_ReturnError::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_ReturnError::Class()), PInvalidCast);
#endif
  return new H450_ReturnError(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_ReturnError::preShowEthereal( void )
{
  m_invokeId.preShowEthereal( );
  m_errorCode.preShowEthereal( );
  if ( HasOptionalField( e_parameter ) ) 
      m_parameter.preShowEthereal( );
}

PString H450_ReturnError::getSummary( void ) 
{
  return PString( "ReturnError" );
}

void H450_ReturnError::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h450_1.hf_h450_ReturnError_invokeId, tvb, offset + m_invokeId.GetStartByte(), m_invokeId.GetByteLength() , m_invokeId.GetValue() );

  proto_tree *errorCode_tree = (proto_tree*) NULL;
  proto_item *errorCode_ti = (proto_item*) NULL;
  errorCode_ti = proto_tree_add_text( tree, tvb, offset + m_errorCode.GetStartByte(), m_errorCode.GetByteLength(), "errorCode (%s)", ( const char* ) m_errorCode.GetTagName() );
  errorCode_tree = proto_item_add_subtree( errorCode_ti, hCont->h450_1.ett_h450_ReturnError_errorCode );

  m_errorCode.showEthereal( errorCode_tree, tvb, offset );

  if ( HasOptionalField( e_parameter ) ) {
    char* pparameter = m_parameter.getValue();
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_ReturnError_parameter, tvb, offset + m_parameter.GetStartByte(), m_parameter.GetByteLength() , pparameter );
    delete[] pparameter;
  }

}
#endif  //USE_FOR_ETHEREAL

//
// Reject
//

H450_Reject::H450_Reject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H450_Reject::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "invokeId = " << setprecision(indent) << m_invokeId << '\n';
  strm << setw(indent+10) << "problem = " << setprecision(indent) << m_problem << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_Reject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_Reject::Class()), PInvalidCast);
#endif
  const H450_Reject & other = (const H450_Reject &)obj;

  Comparison result;

  if ((result = m_invokeId.Compare(other.m_invokeId)) != EqualTo)
    return result;
  if ((result = m_problem.Compare(other.m_problem)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_Reject::GetDataLength() const
{
  PINDEX length = 0;
  length += m_invokeId.GetObjectLength();
  length += m_problem.GetObjectLength();
  return length;
}


BOOL H450_Reject::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_invokeId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_problem.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_Reject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_invokeId.Encode(strm);
  m_problem.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_invokeId.Encode(strm);
  m_problem.Encode(strm);
}


PObject * H450_Reject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_Reject::Class()), PInvalidCast);
#endif
  return new H450_Reject(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_Reject::preShowEthereal( void )
{
  m_invokeId.preShowEthereal( );
  m_problem.preShowEthereal( );
}

PString H450_Reject::getSummary( void ) 
{
  return PString( "Reject" );
}

void H450_Reject::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h450_1.hf_h450_Reject_invokeId, tvb, offset + m_invokeId.GetStartByte(), m_invokeId.GetByteLength() , m_invokeId.GetValue() );

  proto_tree *problem_tree = (proto_tree*) NULL;
  proto_item *problem_ti = (proto_item*) NULL;
  problem_ti = proto_tree_add_text( tree, tvb, offset + m_problem.GetStartByte(), m_problem.GetByteLength(), "problem (%s)", ( const char* ) m_problem.GetTagName() );
  problem_tree = proto_item_add_subtree( problem_ti, hCont->h450_1.ett_h450_Reject_problem );

  m_problem.showEthereal( problem_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// NetworkFacilityExtension
//

H450_NetworkFacilityExtension::H450_NetworkFacilityExtension(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H450_NetworkFacilityExtension::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "sourceEntity = " << setprecision(indent) << m_sourceEntity << '\n';
  if (HasOptionalField(e_sourceEntityAddress))
    strm << setw(indent+22) << "sourceEntityAddress = " << setprecision(indent) << m_sourceEntityAddress << '\n';
  strm << setw(indent+20) << "destinationEntity = " << setprecision(indent) << m_destinationEntity << '\n';
  if (HasOptionalField(e_destinationEntityAddress))
    strm << setw(indent+27) << "destinationEntityAddress = " << setprecision(indent) << m_destinationEntityAddress << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_NetworkFacilityExtension::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_NetworkFacilityExtension::Class()), PInvalidCast);
#endif
  const H450_NetworkFacilityExtension & other = (const H450_NetworkFacilityExtension &)obj;

  Comparison result;

  if ((result = m_sourceEntity.Compare(other.m_sourceEntity)) != EqualTo)
    return result;
  if ((result = m_sourceEntityAddress.Compare(other.m_sourceEntityAddress)) != EqualTo)
    return result;
  if ((result = m_destinationEntity.Compare(other.m_destinationEntity)) != EqualTo)
    return result;
  if ((result = m_destinationEntityAddress.Compare(other.m_destinationEntityAddress)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_NetworkFacilityExtension::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sourceEntity.GetObjectLength();
  if (HasOptionalField(e_sourceEntityAddress))
    length += m_sourceEntityAddress.GetObjectLength();
  length += m_destinationEntity.GetObjectLength();
  if (HasOptionalField(e_destinationEntityAddress))
    length += m_destinationEntityAddress.GetObjectLength();
  return length;
}


BOOL H450_NetworkFacilityExtension::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sourceEntity.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_sourceEntityAddress ) && !m_sourceEntityAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_destinationEntity.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_destinationEntityAddress ) && !m_destinationEntityAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_NetworkFacilityExtension::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sourceEntity.Encode(strm);
  if (HasOptionalField(e_sourceEntityAddress))
    m_sourceEntityAddress.Encode(strm);
  m_destinationEntity.Encode(strm);
  if (HasOptionalField(e_destinationEntityAddress))
    m_destinationEntityAddress.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_sourceEntity.Encode(strm);
  if (HasOptionalField(e_sourceEntityAddress))
    m_sourceEntityAddress.Encode(strm);
  m_destinationEntity.Encode(strm);
  if (HasOptionalField(e_destinationEntityAddress))
    m_destinationEntityAddress.Encode(strm);
}


PObject * H450_NetworkFacilityExtension::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_NetworkFacilityExtension::Class()), PInvalidCast);
#endif
  return new H450_NetworkFacilityExtension(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_NetworkFacilityExtension::preShowEthereal( void )
{
  m_sourceEntity.preShowEthereal( );
  if ( HasOptionalField( e_sourceEntityAddress ) ) 
      m_sourceEntityAddress.preShowEthereal( );
  m_destinationEntity.preShowEthereal( );
  if ( HasOptionalField( e_destinationEntityAddress ) ) 
      m_destinationEntityAddress.preShowEthereal( );
}

PString H450_NetworkFacilityExtension::getSummary( void ) 
{
  return PString( "NetworkFacilityExtension" );
}

void H450_NetworkFacilityExtension::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *sourceEntity_tree = (proto_tree*) NULL;
  proto_item *sourceEntity_ti = (proto_item*) NULL;
  sourceEntity_ti = proto_tree_add_text( tree, tvb, offset + m_sourceEntity.GetStartByte(), m_sourceEntity.GetByteLength(), "sourceEntity (%s)", ( const char* ) m_sourceEntity.GetTagName() );
  sourceEntity_tree = proto_item_add_subtree( sourceEntity_ti, hCont->h450_1.ett_h450_NetworkFacilityExtension_sourceEntity );

  m_sourceEntity.showEthereal( sourceEntity_tree, tvb, offset );

  /* This member is defined outside the current ASN.1 file, 
   * therefore it's not known what type it is. The safest
   * solution is to add another subtree and let the class handle itself
   */
  if ( HasOptionalField( e_sourceEntityAddress ) ) {
    proto_tree *sourceEntityAddress_tree = (proto_tree*) NULL;
    proto_item *sourceEntityAddress_ti = (proto_item*) NULL;
    sourceEntityAddress_ti = proto_tree_add_text( tree, tvb, offset + m_sourceEntityAddress.GetStartByte(), m_sourceEntityAddress.GetByteLength(), "sourceEntityAddress (AddressInformation)" );
    sourceEntityAddress_tree = proto_item_add_subtree( sourceEntityAddress_ti, hCont->h450_1.ett_h450_NetworkFacilityExtension_sourceEntityAddress );
    m_sourceEntityAddress.showEthereal( sourceEntityAddress_tree, tvb, offset );
  }

  proto_tree *destinationEntity_tree = (proto_tree*) NULL;
  proto_item *destinationEntity_ti = (proto_item*) NULL;
  destinationEntity_ti = proto_tree_add_text( tree, tvb, offset + m_destinationEntity.GetStartByte(), m_destinationEntity.GetByteLength(), "destinationEntity (%s)", ( const char* ) m_destinationEntity.GetTagName() );
  destinationEntity_tree = proto_item_add_subtree( destinationEntity_ti, hCont->h450_1.ett_h450_NetworkFacilityExtension_destinationEntity );

  m_destinationEntity.showEthereal( destinationEntity_tree, tvb, offset );

  /* This member is defined outside the current ASN.1 file, 
   * therefore it's not known what type it is. The safest
   * solution is to add another subtree and let the class handle itself
   */
  if ( HasOptionalField( e_destinationEntityAddress ) ) {
    proto_tree *destinationEntityAddress_tree = (proto_tree*) NULL;
    proto_item *destinationEntityAddress_ti = (proto_item*) NULL;
    destinationEntityAddress_ti = proto_tree_add_text( tree, tvb, offset + m_destinationEntityAddress.GetStartByte(), m_destinationEntityAddress.GetByteLength(), "destinationEntityAddress (AddressInformation)" );
    destinationEntityAddress_tree = proto_item_add_subtree( destinationEntityAddress_ti, hCont->h450_1.ett_h450_NetworkFacilityExtension_destinationEntityAddress );
    m_destinationEntityAddress.showEthereal( destinationEntityAddress_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// AddressScreened
//

H450_AddressScreened::H450_AddressScreened(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H450_AddressScreened::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "partyNumber = " << setprecision(indent) << m_partyNumber << '\n';
  strm << setw(indent+21) << "screeningIndicator = " << setprecision(indent) << m_screeningIndicator << '\n';
  if (HasOptionalField(e_partySubaddress))
    strm << setw(indent+18) << "partySubaddress = " << setprecision(indent) << m_partySubaddress << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_AddressScreened::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_AddressScreened::Class()), PInvalidCast);
#endif
  const H450_AddressScreened & other = (const H450_AddressScreened &)obj;

  Comparison result;

  if ((result = m_partyNumber.Compare(other.m_partyNumber)) != EqualTo)
    return result;
  if ((result = m_screeningIndicator.Compare(other.m_screeningIndicator)) != EqualTo)
    return result;
  if ((result = m_partySubaddress.Compare(other.m_partySubaddress)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_AddressScreened::GetDataLength() const
{
  PINDEX length = 0;
  length += m_partyNumber.GetObjectLength();
  length += m_screeningIndicator.GetObjectLength();
  if (HasOptionalField(e_partySubaddress))
    length += m_partySubaddress.GetObjectLength();
  return length;
}


BOOL H450_AddressScreened::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_partyNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_screeningIndicator.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_partySubaddress ) && !m_partySubaddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_AddressScreened::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_partyNumber.Encode(strm);
  m_screeningIndicator.Encode(strm);
  if (HasOptionalField(e_partySubaddress))
    m_partySubaddress.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_partyNumber.Encode(strm);
  m_screeningIndicator.Encode(strm);
  if (HasOptionalField(e_partySubaddress))
    m_partySubaddress.Encode(strm);
}


PObject * H450_AddressScreened::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_AddressScreened::Class()), PInvalidCast);
#endif
  return new H450_AddressScreened(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_AddressScreened::preShowEthereal( void )
{
  m_partyNumber.preShowEthereal( );
  m_screeningIndicator.preShowEthereal( );
  if ( HasOptionalField( e_partySubaddress ) ) 
      m_partySubaddress.preShowEthereal( );
}

PString H450_AddressScreened::getSummary( void ) 
{
  return PString( "AddressScreened" );
}

void H450_AddressScreened::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  /* This member is defined outside the current ASN.1 file, 
   * therefore it's not known what type it is. The safest
   * solution is to add another subtree and let the class handle itself
   */
  proto_tree *partyNumber_tree = (proto_tree*) NULL;
  proto_item *partyNumber_ti = (proto_item*) NULL;
  partyNumber_ti = proto_tree_add_text( tree, tvb, offset + m_partyNumber.GetStartByte(), m_partyNumber.GetByteLength(), "partyNumber (H225-PartyNumber)" );
  partyNumber_tree = proto_item_add_subtree( partyNumber_ti, hCont->h450_1.ett_h450_AddressScreened_partyNumber );

  m_partyNumber.showEthereal( partyNumber_tree, tvb, offset );

  proto_tree *screeningIndicator_tree = (proto_tree*) NULL;
  proto_item *screeningIndicator_ti = (proto_item*) NULL;
  screeningIndicator_ti = proto_tree_add_text( tree, tvb, offset + m_screeningIndicator.GetStartByte(), m_screeningIndicator.GetByteLength(), "screeningIndicator (ScreeningIndicator)" );
  screeningIndicator_tree = proto_item_add_subtree( screeningIndicator_ti, hCont->h450_1.ett_h450_AddressScreened_screeningIndicator );

  m_screeningIndicator.showEthereal( screeningIndicator_tree, tvb, offset );

  if ( HasOptionalField( e_partySubaddress ) ) {
    proto_tree *partySubaddress_tree = (proto_tree*) NULL;
    proto_item *partySubaddress_ti = (proto_item*) NULL;
    partySubaddress_ti = proto_tree_add_text( tree, tvb, offset + m_partySubaddress.GetStartByte(), m_partySubaddress.GetByteLength(), "partySubaddress (%s)", ( const char* ) m_partySubaddress.GetTagName() );
    partySubaddress_tree = proto_item_add_subtree( partySubaddress_ti, hCont->h450_1.ett_h450_AddressScreened_partySubaddress );
    m_partySubaddress.showEthereal( partySubaddress_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// NumberScreened
//

H450_NumberScreened::H450_NumberScreened(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H450_NumberScreened::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "partyNumber = " << setprecision(indent) << m_partyNumber << '\n';
  strm << setw(indent+21) << "screeningIndicator = " << setprecision(indent) << m_screeningIndicator << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_NumberScreened::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_NumberScreened::Class()), PInvalidCast);
#endif
  const H450_NumberScreened & other = (const H450_NumberScreened &)obj;

  Comparison result;

  if ((result = m_partyNumber.Compare(other.m_partyNumber)) != EqualTo)
    return result;
  if ((result = m_screeningIndicator.Compare(other.m_screeningIndicator)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_NumberScreened::GetDataLength() const
{
  PINDEX length = 0;
  length += m_partyNumber.GetObjectLength();
  length += m_screeningIndicator.GetObjectLength();
  return length;
}


BOOL H450_NumberScreened::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_partyNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_screeningIndicator.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_NumberScreened::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_partyNumber.Encode(strm);
  m_screeningIndicator.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_partyNumber.Encode(strm);
  m_screeningIndicator.Encode(strm);
}


PObject * H450_NumberScreened::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_NumberScreened::Class()), PInvalidCast);
#endif
  return new H450_NumberScreened(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_NumberScreened::preShowEthereal( void )
{
  m_partyNumber.preShowEthereal( );
  m_screeningIndicator.preShowEthereal( );
}

PString H450_NumberScreened::getSummary( void ) 
{
  return PString( "NumberScreened" );
}

void H450_NumberScreened::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  /* This member is defined outside the current ASN.1 file, 
   * therefore it's not known what type it is. The safest
   * solution is to add another subtree and let the class handle itself
   */
  proto_tree *partyNumber_tree = (proto_tree*) NULL;
  proto_item *partyNumber_ti = (proto_item*) NULL;
  partyNumber_ti = proto_tree_add_text( tree, tvb, offset + m_partyNumber.GetStartByte(), m_partyNumber.GetByteLength(), "partyNumber (H225-PartyNumber)" );
  partyNumber_tree = proto_item_add_subtree( partyNumber_ti, hCont->h450_1.ett_h450_NumberScreened_partyNumber );

  m_partyNumber.showEthereal( partyNumber_tree, tvb, offset );

  proto_tree *screeningIndicator_tree = (proto_tree*) NULL;
  proto_item *screeningIndicator_ti = (proto_item*) NULL;
  screeningIndicator_ti = proto_tree_add_text( tree, tvb, offset + m_screeningIndicator.GetStartByte(), m_screeningIndicator.GetByteLength(), "screeningIndicator (ScreeningIndicator)" );
  screeningIndicator_tree = proto_item_add_subtree( screeningIndicator_ti, hCont->h450_1.ett_h450_NumberScreened_screeningIndicator );

  m_screeningIndicator.showEthereal( screeningIndicator_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// Address
//

H450_Address::H450_Address(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H450_Address::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "partyNumber = " << setprecision(indent) << m_partyNumber << '\n';
  if (HasOptionalField(e_partySubaddress))
    strm << setw(indent+18) << "partySubaddress = " << setprecision(indent) << m_partySubaddress << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_Address::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_Address::Class()), PInvalidCast);
#endif
  const H450_Address & other = (const H450_Address &)obj;

  Comparison result;

  if ((result = m_partyNumber.Compare(other.m_partyNumber)) != EqualTo)
    return result;
  if ((result = m_partySubaddress.Compare(other.m_partySubaddress)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_Address::GetDataLength() const
{
  PINDEX length = 0;
  length += m_partyNumber.GetObjectLength();
  if (HasOptionalField(e_partySubaddress))
    length += m_partySubaddress.GetObjectLength();
  return length;
}


BOOL H450_Address::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_partyNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_partySubaddress ) && !m_partySubaddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_Address::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_partyNumber.Encode(strm);
  if (HasOptionalField(e_partySubaddress))
    m_partySubaddress.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_partyNumber.Encode(strm);
  if (HasOptionalField(e_partySubaddress))
    m_partySubaddress.Encode(strm);
}


PObject * H450_Address::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_Address::Class()), PInvalidCast);
#endif
  return new H450_Address(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_Address::preShowEthereal( void )
{
  m_partyNumber.preShowEthereal( );
  if ( HasOptionalField( e_partySubaddress ) ) 
      m_partySubaddress.preShowEthereal( );
}

PString H450_Address::getSummary( void ) 
{
  return PString( "Address" );
}

void H450_Address::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  /* This member is defined outside the current ASN.1 file, 
   * therefore it's not known what type it is. The safest
   * solution is to add another subtree and let the class handle itself
   */
  proto_tree *partyNumber_tree = (proto_tree*) NULL;
  proto_item *partyNumber_ti = (proto_item*) NULL;
  partyNumber_ti = proto_tree_add_text( tree, tvb, offset + m_partyNumber.GetStartByte(), m_partyNumber.GetByteLength(), "partyNumber (H225-PartyNumber)" );
  partyNumber_tree = proto_item_add_subtree( partyNumber_ti, hCont->h450_1.ett_h450_Address_partyNumber );

  m_partyNumber.showEthereal( partyNumber_tree, tvb, offset );

  if ( HasOptionalField( e_partySubaddress ) ) {
    proto_tree *partySubaddress_tree = (proto_tree*) NULL;
    proto_item *partySubaddress_ti = (proto_item*) NULL;
    partySubaddress_ti = proto_tree_add_text( tree, tvb, offset + m_partySubaddress.GetStartByte(), m_partySubaddress.GetByteLength(), "partySubaddress (%s)", ( const char* ) m_partySubaddress.GetTagName() );
    partySubaddress_tree = proto_item_add_subtree( partySubaddress_ti, hCont->h450_1.ett_h450_Address_partySubaddress );
    m_partySubaddress.showEthereal( partySubaddress_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// EndpointAddress
//

H450_EndpointAddress::H450_EndpointAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H450_EndpointAddress::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "destinationAddress = " << setprecision(indent) << m_destinationAddress << '\n';
  if (HasOptionalField(e_remoteExtensionAddress))
    strm << setw(indent+25) << "remoteExtensionAddress = " << setprecision(indent) << m_remoteExtensionAddress << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_EndpointAddress::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_EndpointAddress::Class()), PInvalidCast);
#endif
  const H450_EndpointAddress & other = (const H450_EndpointAddress &)obj;

  Comparison result;

  if ((result = m_destinationAddress.Compare(other.m_destinationAddress)) != EqualTo)
    return result;
  if ((result = m_remoteExtensionAddress.Compare(other.m_remoteExtensionAddress)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_EndpointAddress::GetDataLength() const
{
  PINDEX length = 0;
  length += m_destinationAddress.GetObjectLength();
  if (HasOptionalField(e_remoteExtensionAddress))
    length += m_remoteExtensionAddress.GetObjectLength();
  return length;
}


BOOL H450_EndpointAddress::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_destinationAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_remoteExtensionAddress ) && !m_remoteExtensionAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_EndpointAddress::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_destinationAddress.Encode(strm);
  if (HasOptionalField(e_remoteExtensionAddress))
    m_remoteExtensionAddress.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_destinationAddress.Encode(strm);
  if (HasOptionalField(e_remoteExtensionAddress))
    m_remoteExtensionAddress.Encode(strm);
}


PObject * H450_EndpointAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_EndpointAddress::Class()), PInvalidCast);
#endif
  return new H450_EndpointAddress(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_EndpointAddress::preShowEthereal( void )
{
  m_destinationAddress.preShowEthereal( );
  if ( HasOptionalField( e_remoteExtensionAddress ) ) 
      m_remoteExtensionAddress.preShowEthereal( );
}

PString H450_EndpointAddress::getSummary( void ) 
{
  return PString( "EndpointAddress" );
}

void H450_EndpointAddress::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *destinationAddress_tree = (proto_tree*) NULL;
  proto_item *destinationAddress_ti = (proto_item*) NULL;
  destinationAddress_ti = proto_tree_add_text( tree, tvb, offset + m_destinationAddress.GetStartByte(), m_destinationAddress.GetByteLength(), "destinationAddress (AliasAddress)" );
  destinationAddress_tree = proto_item_add_subtree( destinationAddress_ti, hCont->h450_1.ett_h450_EndpointAddress_destinationAddress );

  m_destinationAddress.showEthereal( destinationAddress_tree, tvb, offset );

  /* This member is defined outside the current ASN.1 file, 
   * therefore it's not known what type it is. The safest
   * solution is to add another subtree and let the class handle itself
   */
  if ( HasOptionalField( e_remoteExtensionAddress ) ) {
    proto_tree *remoteExtensionAddress_tree = (proto_tree*) NULL;
    proto_item *remoteExtensionAddress_ti = (proto_item*) NULL;
    remoteExtensionAddress_ti = proto_tree_add_text( tree, tvb, offset + m_remoteExtensionAddress.GetStartByte(), m_remoteExtensionAddress.GetByteLength(), "remoteExtensionAddress (H225-AliasAddress)" );
    remoteExtensionAddress_tree = proto_item_add_subtree( remoteExtensionAddress_ti, hCont->h450_1.ett_h450_EndpointAddress_remoteExtensionAddress );
    m_remoteExtensionAddress.showEthereal( remoteExtensionAddress_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// UserSpecifiedSubaddress
//

H450_UserSpecifiedSubaddress::H450_UserSpecifiedSubaddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H450_UserSpecifiedSubaddress::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "subaddressInformation = " << setprecision(indent) << m_subaddressInformation << '\n';
  if (HasOptionalField(e_oddCountIndicator))
    strm << setw(indent+20) << "oddCountIndicator = " << setprecision(indent) << m_oddCountIndicator << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_UserSpecifiedSubaddress::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_UserSpecifiedSubaddress::Class()), PInvalidCast);
#endif
  const H450_UserSpecifiedSubaddress & other = (const H450_UserSpecifiedSubaddress &)obj;

  Comparison result;

  if ((result = m_subaddressInformation.Compare(other.m_subaddressInformation)) != EqualTo)
    return result;
  if ((result = m_oddCountIndicator.Compare(other.m_oddCountIndicator)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_UserSpecifiedSubaddress::GetDataLength() const
{
  PINDEX length = 0;
  length += m_subaddressInformation.GetObjectLength();
  if (HasOptionalField(e_oddCountIndicator))
    length += m_oddCountIndicator.GetObjectLength();
  return length;
}


BOOL H450_UserSpecifiedSubaddress::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_subaddressInformation.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_oddCountIndicator ) && !m_oddCountIndicator.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_UserSpecifiedSubaddress::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_subaddressInformation.Encode(strm);
  if (HasOptionalField(e_oddCountIndicator))
    m_oddCountIndicator.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_subaddressInformation.Encode(strm);
  if (HasOptionalField(e_oddCountIndicator))
    m_oddCountIndicator.Encode(strm);
}


PObject * H450_UserSpecifiedSubaddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_UserSpecifiedSubaddress::Class()), PInvalidCast);
#endif
  return new H450_UserSpecifiedSubaddress(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_UserSpecifiedSubaddress::preShowEthereal( void )
{
  m_subaddressInformation.preShowEthereal( );
  if ( HasOptionalField( e_oddCountIndicator ) ) 
      m_oddCountIndicator.preShowEthereal( );
}

PString H450_UserSpecifiedSubaddress::getSummary( void ) 
{
  return PString( "UserSpecifiedSubaddress" );
}

void H450_UserSpecifiedSubaddress::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* psubaddressInformation = m_subaddressInformation.getValue();
  proto_tree_add_string( tree, hCont->h450_1.hf_h450_UserSpecifiedSubaddress_subaddressInformation, tvb, offset + m_subaddressInformation.GetStartByte(), m_subaddressInformation.GetByteLength() , psubaddressInformation );
  delete[] psubaddressInformation;

  if ( HasOptionalField( e_oddCountIndicator ) ) {
    proto_tree_add_boolean( tree, hCont->h450_1.hf_h450_UserSpecifiedSubaddress_oddCountIndicator, tvb, offset + m_oddCountIndicator.GetStartByte(), m_oddCountIndicator.GetByteLength() , m_oddCountIndicator.GetValue() );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// HoldNotificArg
//

H450_HoldNotificArg::H450_HoldNotificArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_extensionArg.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_HoldNotificArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_extensionArg))
    strm << setw(indent+15) << "extensionArg = " << setprecision(indent) << m_extensionArg << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_HoldNotificArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_HoldNotificArg::Class()), PInvalidCast);
#endif
  const H450_HoldNotificArg & other = (const H450_HoldNotificArg &)obj;

  Comparison result;

  if ((result = m_extensionArg.Compare(other.m_extensionArg)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_HoldNotificArg::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_extensionArg))
    length += m_extensionArg.GetObjectLength();
  return length;
}


BOOL H450_HoldNotificArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionArg ) && !m_extensionArg.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_HoldNotificArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);
}


PObject * H450_HoldNotificArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_HoldNotificArg::Class()), PInvalidCast);
#endif
  return new H450_HoldNotificArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_HoldNotificArg::preShowEthereal( void )
{
  if ( HasOptionalField( e_extensionArg ) ) 
      m_extensionArg.preShowEthereal( );
}

PString H450_HoldNotificArg::getSummary( void ) 
{
  return PString( "HoldNotificArg" );
}

void H450_HoldNotificArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_extensionArg ) ) {
    proto_tree *extensionArg_tree = (proto_tree*) NULL;
    proto_item *extensionArg_ti = (proto_item*) NULL;
    extensionArg_ti = proto_tree_add_text( tree, tvb, offset + m_extensionArg.GetStartByte(), m_extensionArg.GetByteLength(), "extensionArg (MixedExtension)" );
    extensionArg_tree = proto_item_add_subtree( extensionArg_ti, hCont->h450_1.ett_h450_HoldNotificArg_extensionArg );
    m_extensionArg.showEthereal( extensionArg_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// RetrieveNotificArg
//

H450_RetrieveNotificArg::H450_RetrieveNotificArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_extensionArg.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_RetrieveNotificArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_extensionArg))
    strm << setw(indent+15) << "extensionArg = " << setprecision(indent) << m_extensionArg << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_RetrieveNotificArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_RetrieveNotificArg::Class()), PInvalidCast);
#endif
  const H450_RetrieveNotificArg & other = (const H450_RetrieveNotificArg &)obj;

  Comparison result;

  if ((result = m_extensionArg.Compare(other.m_extensionArg)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_RetrieveNotificArg::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_extensionArg))
    length += m_extensionArg.GetObjectLength();
  return length;
}


BOOL H450_RetrieveNotificArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionArg ) && !m_extensionArg.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_RetrieveNotificArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);
}


PObject * H450_RetrieveNotificArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_RetrieveNotificArg::Class()), PInvalidCast);
#endif
  return new H450_RetrieveNotificArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_RetrieveNotificArg::preShowEthereal( void )
{
  if ( HasOptionalField( e_extensionArg ) ) 
      m_extensionArg.preShowEthereal( );
}

PString H450_RetrieveNotificArg::getSummary( void ) 
{
  return PString( "RetrieveNotificArg" );
}

void H450_RetrieveNotificArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_extensionArg ) ) {
    proto_tree *extensionArg_tree = (proto_tree*) NULL;
    proto_item *extensionArg_ti = (proto_item*) NULL;
    extensionArg_ti = proto_tree_add_text( tree, tvb, offset + m_extensionArg.GetStartByte(), m_extensionArg.GetByteLength(), "extensionArg (MixedExtension)" );
    extensionArg_tree = proto_item_add_subtree( extensionArg_ti, hCont->h450_1.ett_h450_RetrieveNotificArg_extensionArg );
    m_extensionArg.showEthereal( extensionArg_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// RemoteHoldArg
//

H450_RemoteHoldArg::H450_RemoteHoldArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_extensionArg.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_RemoteHoldArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_extensionArg))
    strm << setw(indent+15) << "extensionArg = " << setprecision(indent) << m_extensionArg << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_RemoteHoldArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_RemoteHoldArg::Class()), PInvalidCast);
#endif
  const H450_RemoteHoldArg & other = (const H450_RemoteHoldArg &)obj;

  Comparison result;

  if ((result = m_extensionArg.Compare(other.m_extensionArg)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_RemoteHoldArg::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_extensionArg))
    length += m_extensionArg.GetObjectLength();
  return length;
}


BOOL H450_RemoteHoldArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionArg ) && !m_extensionArg.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_RemoteHoldArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);
}


PObject * H450_RemoteHoldArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_RemoteHoldArg::Class()), PInvalidCast);
#endif
  return new H450_RemoteHoldArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_RemoteHoldArg::preShowEthereal( void )
{
  if ( HasOptionalField( e_extensionArg ) ) 
      m_extensionArg.preShowEthereal( );
}

PString H450_RemoteHoldArg::getSummary( void ) 
{
  return PString( "RemoteHoldArg" );
}

void H450_RemoteHoldArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_extensionArg ) ) {
    proto_tree *extensionArg_tree = (proto_tree*) NULL;
    proto_item *extensionArg_ti = (proto_item*) NULL;
    extensionArg_ti = proto_tree_add_text( tree, tvb, offset + m_extensionArg.GetStartByte(), m_extensionArg.GetByteLength(), "extensionArg (MixedExtension)" );
    extensionArg_tree = proto_item_add_subtree( extensionArg_ti, hCont->h450_1.ett_h450_RemoteHoldArg_extensionArg );
    m_extensionArg.showEthereal( extensionArg_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// RemoteHoldRes
//

H450_RemoteHoldRes::H450_RemoteHoldRes(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_extensionRes.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_RemoteHoldRes::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_extensionRes))
    strm << setw(indent+15) << "extensionRes = " << setprecision(indent) << m_extensionRes << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_RemoteHoldRes::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_RemoteHoldRes::Class()), PInvalidCast);
#endif
  const H450_RemoteHoldRes & other = (const H450_RemoteHoldRes &)obj;

  Comparison result;

  if ((result = m_extensionRes.Compare(other.m_extensionRes)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_RemoteHoldRes::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_extensionRes))
    length += m_extensionRes.GetObjectLength();
  return length;
}


BOOL H450_RemoteHoldRes::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionRes ) && !m_extensionRes.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_RemoteHoldRes::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_extensionRes))
    m_extensionRes.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_extensionRes))
    m_extensionRes.Encode(strm);
}


PObject * H450_RemoteHoldRes::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_RemoteHoldRes::Class()), PInvalidCast);
#endif
  return new H450_RemoteHoldRes(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_RemoteHoldRes::preShowEthereal( void )
{
  if ( HasOptionalField( e_extensionRes ) ) 
      m_extensionRes.preShowEthereal( );
}

PString H450_RemoteHoldRes::getSummary( void ) 
{
  return PString( "RemoteHoldRes" );
}

void H450_RemoteHoldRes::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_extensionRes ) ) {
    proto_tree *extensionRes_tree = (proto_tree*) NULL;
    proto_item *extensionRes_ti = (proto_item*) NULL;
    extensionRes_ti = proto_tree_add_text( tree, tvb, offset + m_extensionRes.GetStartByte(), m_extensionRes.GetByteLength(), "extensionRes (MixedExtension)" );
    extensionRes_tree = proto_item_add_subtree( extensionRes_ti, hCont->h450_1.ett_h450_RemoteHoldRes_extensionRes );
    m_extensionRes.showEthereal( extensionRes_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// RemoteRetrieveArg
//

H450_RemoteRetrieveArg::H450_RemoteRetrieveArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_extensionArg.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_RemoteRetrieveArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_extensionArg))
    strm << setw(indent+15) << "extensionArg = " << setprecision(indent) << m_extensionArg << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_RemoteRetrieveArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_RemoteRetrieveArg::Class()), PInvalidCast);
#endif
  const H450_RemoteRetrieveArg & other = (const H450_RemoteRetrieveArg &)obj;

  Comparison result;

  if ((result = m_extensionArg.Compare(other.m_extensionArg)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_RemoteRetrieveArg::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_extensionArg))
    length += m_extensionArg.GetObjectLength();
  return length;
}


BOOL H450_RemoteRetrieveArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionArg ) && !m_extensionArg.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_RemoteRetrieveArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);
}


PObject * H450_RemoteRetrieveArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_RemoteRetrieveArg::Class()), PInvalidCast);
#endif
  return new H450_RemoteRetrieveArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_RemoteRetrieveArg::preShowEthereal( void )
{
  if ( HasOptionalField( e_extensionArg ) ) 
      m_extensionArg.preShowEthereal( );
}

PString H450_RemoteRetrieveArg::getSummary( void ) 
{
  return PString( "RemoteRetrieveArg" );
}

void H450_RemoteRetrieveArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_extensionArg ) ) {
    proto_tree *extensionArg_tree = (proto_tree*) NULL;
    proto_item *extensionArg_ti = (proto_item*) NULL;
    extensionArg_ti = proto_tree_add_text( tree, tvb, offset + m_extensionArg.GetStartByte(), m_extensionArg.GetByteLength(), "extensionArg (MixedExtension)" );
    extensionArg_tree = proto_item_add_subtree( extensionArg_ti, hCont->h450_1.ett_h450_RemoteRetrieveArg_extensionArg );
    m_extensionArg.showEthereal( extensionArg_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// RemoteRetrieveRes
//

H450_RemoteRetrieveRes::H450_RemoteRetrieveRes(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_extensionRes.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_RemoteRetrieveRes::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_extensionRes))
    strm << setw(indent+15) << "extensionRes = " << setprecision(indent) << m_extensionRes << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_RemoteRetrieveRes::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_RemoteRetrieveRes::Class()), PInvalidCast);
#endif
  const H450_RemoteRetrieveRes & other = (const H450_RemoteRetrieveRes &)obj;

  Comparison result;

  if ((result = m_extensionRes.Compare(other.m_extensionRes)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_RemoteRetrieveRes::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_extensionRes))
    length += m_extensionRes.GetObjectLength();
  return length;
}


BOOL H450_RemoteRetrieveRes::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionRes ) && !m_extensionRes.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_RemoteRetrieveRes::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_extensionRes))
    m_extensionRes.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_extensionRes))
    m_extensionRes.Encode(strm);
}


PObject * H450_RemoteRetrieveRes::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_RemoteRetrieveRes::Class()), PInvalidCast);
#endif
  return new H450_RemoteRetrieveRes(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_RemoteRetrieveRes::preShowEthereal( void )
{
  if ( HasOptionalField( e_extensionRes ) ) 
      m_extensionRes.preShowEthereal( );
}

PString H450_RemoteRetrieveRes::getSummary( void ) 
{
  return PString( "RemoteRetrieveRes" );
}

void H450_RemoteRetrieveRes::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_extensionRes ) ) {
    proto_tree *extensionRes_tree = (proto_tree*) NULL;
    proto_item *extensionRes_ti = (proto_item*) NULL;
    extensionRes_ti = proto_tree_add_text( tree, tvb, offset + m_extensionRes.GetStartByte(), m_extensionRes.GetByteLength(), "extensionRes (MixedExtension)" );
    extensionRes_tree = proto_item_add_subtree( extensionRes_ti, hCont->h450_1.ett_h450_RemoteRetrieveRes_extensionRes );
    m_extensionRes.showEthereal( extensionRes_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CcRequestArg
//

H450_CcRequestArg::H450_CcRequestArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
  m_extension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CcRequestArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "numberA = " << setprecision(indent) << m_numberA << '\n';
  strm << setw(indent+10) << "numberB = " << setprecision(indent) << m_numberB << '\n';
  if (HasOptionalField(e_ccIdentifier))
    strm << setw(indent+15) << "ccIdentifier = " << setprecision(indent) << m_ccIdentifier << '\n';
  strm << setw(indent+10) << "service = " << setprecision(indent) << m_service << '\n';
  strm << setw(indent+21) << "can_retain_service = " << setprecision(indent) << m_can_retain_service << '\n';
  if (HasOptionalField(e_retain_sig_connection))
    strm << setw(indent+24) << "retain_sig_connection = " << setprecision(indent) << m_retain_sig_connection << '\n';
  if (HasOptionalField(e_extension))
    strm << setw(indent+12) << "extension = " << setprecision(indent) << m_extension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CcRequestArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CcRequestArg::Class()), PInvalidCast);
#endif
  const H450_CcRequestArg & other = (const H450_CcRequestArg &)obj;

  Comparison result;

  if ((result = m_numberA.Compare(other.m_numberA)) != EqualTo)
    return result;
  if ((result = m_numberB.Compare(other.m_numberB)) != EqualTo)
    return result;
  if ((result = m_ccIdentifier.Compare(other.m_ccIdentifier)) != EqualTo)
    return result;
  if ((result = m_service.Compare(other.m_service)) != EqualTo)
    return result;
  if ((result = m_can_retain_service.Compare(other.m_can_retain_service)) != EqualTo)
    return result;
  if ((result = m_retain_sig_connection.Compare(other.m_retain_sig_connection)) != EqualTo)
    return result;
  if ((result = m_extension.Compare(other.m_extension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CcRequestArg::GetDataLength() const
{
  PINDEX length = 0;
  length += m_numberA.GetObjectLength();
  length += m_numberB.GetObjectLength();
  if (HasOptionalField(e_ccIdentifier))
    length += m_ccIdentifier.GetObjectLength();
  length += m_service.GetObjectLength();
  length += m_can_retain_service.GetObjectLength();
  if (HasOptionalField(e_retain_sig_connection))
    length += m_retain_sig_connection.GetObjectLength();
  if (HasOptionalField(e_extension))
    length += m_extension.GetObjectLength();
  return length;
}


BOOL H450_CcRequestArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_numberA.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_numberB.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_ccIdentifier ) && !m_ccIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_service.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_can_retain_service.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_retain_sig_connection ) && !m_retain_sig_connection.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extension ) && !m_extension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CcRequestArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_numberA.Encode(strm);
  m_numberB.Encode(strm);
  if (HasOptionalField(e_ccIdentifier))
    m_ccIdentifier.Encode(strm);
  m_service.Encode(strm);
  m_can_retain_service.Encode(strm);
  if (HasOptionalField(e_retain_sig_connection))
    m_retain_sig_connection.Encode(strm);
  if (HasOptionalField(e_extension))
    m_extension.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_numberA.Encode(strm);
  m_numberB.Encode(strm);
  if (HasOptionalField(e_ccIdentifier))
    m_ccIdentifier.Encode(strm);
  m_service.Encode(strm);
  m_can_retain_service.Encode(strm);
  if (HasOptionalField(e_retain_sig_connection))
    m_retain_sig_connection.Encode(strm);
  if (HasOptionalField(e_extension))
    m_extension.Encode(strm);
}


PObject * H450_CcRequestArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CcRequestArg::Class()), PInvalidCast);
#endif
  return new H450_CcRequestArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CcRequestArg::preShowEthereal( void )
{
  m_numberA.preShowEthereal( );
  m_numberB.preShowEthereal( );
  if ( HasOptionalField( e_ccIdentifier ) ) 
      m_ccIdentifier.preShowEthereal( );
  m_service.preShowEthereal( );
  m_can_retain_service.preShowEthereal( );
  if ( HasOptionalField( e_retain_sig_connection ) ) 
      m_retain_sig_connection.preShowEthereal( );
  if ( HasOptionalField( e_extension ) ) 
      m_extension.preShowEthereal( );
}

PString H450_CcRequestArg::getSummary( void ) 
{
  return PString( "CcRequestArg" );
}

void H450_CcRequestArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *numberA_tree = (proto_tree*) NULL;
  proto_item *numberA_ti = (proto_item*) NULL;
  numberA_ti = proto_tree_add_text( tree, tvb, offset + m_numberA.GetStartByte(), m_numberA.GetByteLength(), "numberA (EndpointAddress)" );
  numberA_tree = proto_item_add_subtree( numberA_ti, hCont->h450_1.ett_h450_CcRequestArg_numberA );

  m_numberA.showEthereal( numberA_tree, tvb, offset );

  proto_tree *numberB_tree = (proto_tree*) NULL;
  proto_item *numberB_ti = (proto_item*) NULL;
  numberB_ti = proto_tree_add_text( tree, tvb, offset + m_numberB.GetStartByte(), m_numberB.GetByteLength(), "numberB (EndpointAddress)" );
  numberB_tree = proto_item_add_subtree( numberB_ti, hCont->h450_1.ett_h450_CcRequestArg_numberB );

  m_numberB.showEthereal( numberB_tree, tvb, offset );

  /* This member is defined outside the current ASN.1 file, 
   * therefore it's not known what type it is. The safest
   * solution is to add another subtree and let the class handle itself
   */
  if ( HasOptionalField( e_ccIdentifier ) ) {
    proto_tree *ccIdentifier_tree = (proto_tree*) NULL;
    proto_item *ccIdentifier_ti = (proto_item*) NULL;
    ccIdentifier_ti = proto_tree_add_text( tree, tvb, offset + m_ccIdentifier.GetStartByte(), m_ccIdentifier.GetByteLength(), "ccIdentifier (H225-CallIdentifier)" );
    ccIdentifier_tree = proto_item_add_subtree( ccIdentifier_ti, hCont->h450_1.ett_h450_CcRequestArg_ccIdentifier );
    m_ccIdentifier.showEthereal( ccIdentifier_tree, tvb, offset );
  }

  proto_tree *service_tree = (proto_tree*) NULL;
  proto_item *service_ti = (proto_item*) NULL;
  service_ti = proto_tree_add_text( tree, tvb, offset + m_service.GetStartByte(), m_service.GetByteLength(), "service (BasicService)" );
  service_tree = proto_item_add_subtree( service_ti, hCont->h450_1.ett_h450_CcRequestArg_service );

  m_service.showEthereal( service_tree, tvb, offset );

  proto_tree_add_boolean( tree, hCont->h450_1.hf_h450_CcRequestArg_can_retain_service, tvb, offset + m_can_retain_service.GetStartByte(), m_can_retain_service.GetByteLength() , m_can_retain_service.GetValue() );

  if ( HasOptionalField( e_retain_sig_connection ) ) {
    proto_tree_add_boolean( tree, hCont->h450_1.hf_h450_CcRequestArg_retain_sig_connection, tvb, offset + m_retain_sig_connection.GetStartByte(), m_retain_sig_connection.GetByteLength() , m_retain_sig_connection.GetValue() );
  }

  if ( HasOptionalField( e_extension ) ) {
    proto_tree *extension_tree = (proto_tree*) NULL;
    proto_item *extension_ti = (proto_item*) NULL;
    extension_ti = proto_tree_add_text( tree, tvb, offset + m_extension.GetStartByte(), m_extension.GetByteLength(), "extension (MixedExtension)" );
    extension_tree = proto_item_add_subtree( extension_ti, hCont->h450_1.ett_h450_CcRequestArg_extension );
    m_extension.showEthereal( extension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CcRequestRes
//

H450_CcRequestRes::H450_CcRequestRes(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_extension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CcRequestRes::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "retain_service = " << setprecision(indent) << m_retain_service << '\n';
  if (HasOptionalField(e_extension))
    strm << setw(indent+12) << "extension = " << setprecision(indent) << m_extension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CcRequestRes::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CcRequestRes::Class()), PInvalidCast);
#endif
  const H450_CcRequestRes & other = (const H450_CcRequestRes &)obj;

  Comparison result;

  if ((result = m_retain_service.Compare(other.m_retain_service)) != EqualTo)
    return result;
  if ((result = m_extension.Compare(other.m_extension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CcRequestRes::GetDataLength() const
{
  PINDEX length = 0;
  length += m_retain_service.GetObjectLength();
  if (HasOptionalField(e_extension))
    length += m_extension.GetObjectLength();
  return length;
}


BOOL H450_CcRequestRes::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_retain_service.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extension ) && !m_extension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CcRequestRes::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_retain_service.Encode(strm);
  if (HasOptionalField(e_extension))
    m_extension.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_retain_service.Encode(strm);
  if (HasOptionalField(e_extension))
    m_extension.Encode(strm);
}


PObject * H450_CcRequestRes::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CcRequestRes::Class()), PInvalidCast);
#endif
  return new H450_CcRequestRes(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CcRequestRes::preShowEthereal( void )
{
  m_retain_service.preShowEthereal( );
  if ( HasOptionalField( e_extension ) ) 
      m_extension.preShowEthereal( );
}

PString H450_CcRequestRes::getSummary( void ) 
{
  return PString( "CcRequestRes" );
}

void H450_CcRequestRes::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h450_1.hf_h450_CcRequestRes_retain_service, tvb, offset + m_retain_service.GetStartByte(), m_retain_service.GetByteLength() , m_retain_service.GetValue() );

  if ( HasOptionalField( e_extension ) ) {
    proto_tree *extension_tree = (proto_tree*) NULL;
    proto_item *extension_ti = (proto_item*) NULL;
    extension_ti = proto_tree_add_text( tree, tvb, offset + m_extension.GetStartByte(), m_extension.GetByteLength(), "extension (MixedExtension)" );
    extension_tree = proto_item_add_subtree( extension_ti, hCont->h450_1.ett_h450_CcRequestRes_extension );
    m_extension.showEthereal( extension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CcShortArg
//

H450_CcShortArg::H450_CcShortArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_extension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CcShortArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_ccIdentifier))
    strm << setw(indent+15) << "ccIdentifier = " << setprecision(indent) << m_ccIdentifier << '\n';
  if (HasOptionalField(e_extension))
    strm << setw(indent+12) << "extension = " << setprecision(indent) << m_extension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CcShortArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CcShortArg::Class()), PInvalidCast);
#endif
  const H450_CcShortArg & other = (const H450_CcShortArg &)obj;

  Comparison result;

  if ((result = m_ccIdentifier.Compare(other.m_ccIdentifier)) != EqualTo)
    return result;
  if ((result = m_extension.Compare(other.m_extension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CcShortArg::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_ccIdentifier))
    length += m_ccIdentifier.GetObjectLength();
  if (HasOptionalField(e_extension))
    length += m_extension.GetObjectLength();
  return length;
}


BOOL H450_CcShortArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_ccIdentifier ) && !m_ccIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extension ) && !m_extension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CcShortArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_ccIdentifier))
    m_ccIdentifier.Encode(strm);
  if (HasOptionalField(e_extension))
    m_extension.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_ccIdentifier))
    m_ccIdentifier.Encode(strm);
  if (HasOptionalField(e_extension))
    m_extension.Encode(strm);
}


PObject * H450_CcShortArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CcShortArg::Class()), PInvalidCast);
#endif
  return new H450_CcShortArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CcShortArg::preShowEthereal( void )
{
  if ( HasOptionalField( e_ccIdentifier ) ) 
      m_ccIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_extension ) ) 
      m_extension.preShowEthereal( );
}

PString H450_CcShortArg::getSummary( void ) 
{
  return PString( "CcShortArg" );
}

void H450_CcShortArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  /* This member is defined outside the current ASN.1 file, 
   * therefore it's not known what type it is. The safest
   * solution is to add another subtree and let the class handle itself
   */
  if ( HasOptionalField( e_ccIdentifier ) ) {
    proto_tree *ccIdentifier_tree = (proto_tree*) NULL;
    proto_item *ccIdentifier_ti = (proto_item*) NULL;
    ccIdentifier_ti = proto_tree_add_text( tree, tvb, offset + m_ccIdentifier.GetStartByte(), m_ccIdentifier.GetByteLength(), "ccIdentifier (H225-CallIdentifier)" );
    ccIdentifier_tree = proto_item_add_subtree( ccIdentifier_ti, hCont->h450_1.ett_h450_CcShortArg_ccIdentifier );
    m_ccIdentifier.showEthereal( ccIdentifier_tree, tvb, offset );
  }

  if ( HasOptionalField( e_extension ) ) {
    proto_tree *extension_tree = (proto_tree*) NULL;
    proto_item *extension_ti = (proto_item*) NULL;
    extension_ti = proto_tree_add_text( tree, tvb, offset + m_extension.GetStartByte(), m_extension.GetByteLength(), "extension (MixedExtension)" );
    extension_tree = proto_item_add_subtree( extension_ti, hCont->h450_1.ett_h450_CcShortArg_extension );
    m_extension.showEthereal( extension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CcLongArg
//

H450_CcLongArg::H450_CcLongArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 5, TRUE, 0)
{
  m_extension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CcLongArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_numberA))
    strm << setw(indent+10) << "numberA = " << setprecision(indent) << m_numberA << '\n';
  if (HasOptionalField(e_numberB))
    strm << setw(indent+10) << "numberB = " << setprecision(indent) << m_numberB << '\n';
  if (HasOptionalField(e_ccIdentifier))
    strm << setw(indent+15) << "ccIdentifier = " << setprecision(indent) << m_ccIdentifier << '\n';
  if (HasOptionalField(e_service))
    strm << setw(indent+10) << "service = " << setprecision(indent) << m_service << '\n';
  if (HasOptionalField(e_extension))
    strm << setw(indent+12) << "extension = " << setprecision(indent) << m_extension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CcLongArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CcLongArg::Class()), PInvalidCast);
#endif
  const H450_CcLongArg & other = (const H450_CcLongArg &)obj;

  Comparison result;

  if ((result = m_numberA.Compare(other.m_numberA)) != EqualTo)
    return result;
  if ((result = m_numberB.Compare(other.m_numberB)) != EqualTo)
    return result;
  if ((result = m_ccIdentifier.Compare(other.m_ccIdentifier)) != EqualTo)
    return result;
  if ((result = m_service.Compare(other.m_service)) != EqualTo)
    return result;
  if ((result = m_extension.Compare(other.m_extension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CcLongArg::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_numberA))
    length += m_numberA.GetObjectLength();
  if (HasOptionalField(e_numberB))
    length += m_numberB.GetObjectLength();
  if (HasOptionalField(e_ccIdentifier))
    length += m_ccIdentifier.GetObjectLength();
  if (HasOptionalField(e_service))
    length += m_service.GetObjectLength();
  if (HasOptionalField(e_extension))
    length += m_extension.GetObjectLength();
  return length;
}


BOOL H450_CcLongArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_numberA ) && !m_numberA.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_numberB ) && !m_numberB.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_ccIdentifier ) && !m_ccIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_service ) && !m_service.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extension ) && !m_extension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CcLongArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_numberA))
    m_numberA.Encode(strm);
  if (HasOptionalField(e_numberB))
    m_numberB.Encode(strm);
  if (HasOptionalField(e_ccIdentifier))
    m_ccIdentifier.Encode(strm);
  if (HasOptionalField(e_service))
    m_service.Encode(strm);
  if (HasOptionalField(e_extension))
    m_extension.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_numberA))
    m_numberA.Encode(strm);
  if (HasOptionalField(e_numberB))
    m_numberB.Encode(strm);
  if (HasOptionalField(e_ccIdentifier))
    m_ccIdentifier.Encode(strm);
  if (HasOptionalField(e_service))
    m_service.Encode(strm);
  if (HasOptionalField(e_extension))
    m_extension.Encode(strm);
}


PObject * H450_CcLongArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CcLongArg::Class()), PInvalidCast);
#endif
  return new H450_CcLongArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CcLongArg::preShowEthereal( void )
{
  if ( HasOptionalField( e_numberA ) ) 
      m_numberA.preShowEthereal( );
  if ( HasOptionalField( e_numberB ) ) 
      m_numberB.preShowEthereal( );
  if ( HasOptionalField( e_ccIdentifier ) ) 
      m_ccIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_service ) ) 
      m_service.preShowEthereal( );
  if ( HasOptionalField( e_extension ) ) 
      m_extension.preShowEthereal( );
}

PString H450_CcLongArg::getSummary( void ) 
{
  return PString( "CcLongArg" );
}

void H450_CcLongArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_numberA ) ) {
    proto_tree *numberA_tree = (proto_tree*) NULL;
    proto_item *numberA_ti = (proto_item*) NULL;
    numberA_ti = proto_tree_add_text( tree, tvb, offset + m_numberA.GetStartByte(), m_numberA.GetByteLength(), "numberA (EndpointAddress)" );
    numberA_tree = proto_item_add_subtree( numberA_ti, hCont->h450_1.ett_h450_CcLongArg_numberA );
    m_numberA.showEthereal( numberA_tree, tvb, offset );
  }

  if ( HasOptionalField( e_numberB ) ) {
    proto_tree *numberB_tree = (proto_tree*) NULL;
    proto_item *numberB_ti = (proto_item*) NULL;
    numberB_ti = proto_tree_add_text( tree, tvb, offset + m_numberB.GetStartByte(), m_numberB.GetByteLength(), "numberB (EndpointAddress)" );
    numberB_tree = proto_item_add_subtree( numberB_ti, hCont->h450_1.ett_h450_CcLongArg_numberB );
    m_numberB.showEthereal( numberB_tree, tvb, offset );
  }

  /* This member is defined outside the current ASN.1 file, 
   * therefore it's not known what type it is. The safest
   * solution is to add another subtree and let the class handle itself
   */
  if ( HasOptionalField( e_ccIdentifier ) ) {
    proto_tree *ccIdentifier_tree = (proto_tree*) NULL;
    proto_item *ccIdentifier_ti = (proto_item*) NULL;
    ccIdentifier_ti = proto_tree_add_text( tree, tvb, offset + m_ccIdentifier.GetStartByte(), m_ccIdentifier.GetByteLength(), "ccIdentifier (H225-CallIdentifier)" );
    ccIdentifier_tree = proto_item_add_subtree( ccIdentifier_ti, hCont->h450_1.ett_h450_CcLongArg_ccIdentifier );
    m_ccIdentifier.showEthereal( ccIdentifier_tree, tvb, offset );
  }

  if ( HasOptionalField( e_service ) ) {
    proto_tree *service_tree = (proto_tree*) NULL;
    proto_item *service_ti = (proto_item*) NULL;
    service_ti = proto_tree_add_text( tree, tvb, offset + m_service.GetStartByte(), m_service.GetByteLength(), "service (BasicService)" );
    service_tree = proto_item_add_subtree( service_ti, hCont->h450_1.ett_h450_CcLongArg_service );
    m_service.showEthereal( service_tree, tvb, offset );
  }

  if ( HasOptionalField( e_extension ) ) {
    proto_tree *extension_tree = (proto_tree*) NULL;
    proto_item *extension_ti = (proto_item*) NULL;
    extension_ti = proto_tree_add_text( tree, tvb, offset + m_extension.GetStartByte(), m_extension.GetByteLength(), "extension (MixedExtension)" );
    extension_tree = proto_item_add_subtree( extension_ti, hCont->h450_1.ett_h450_CcLongArg_extension );
    m_extension.showEthereal( extension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// MWIActivateArg
//

H450_MWIActivateArg::H450_MWIActivateArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 6, TRUE, 0)
{
  m_priority.SetConstraints(PASN_Object::FixedConstraint, 0, 9);
  m_extensionArg.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_MWIActivateArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "servedUserNr = " << setprecision(indent) << m_servedUserNr << '\n';
  strm << setw(indent+15) << "basicService = " << setprecision(indent) << m_basicService << '\n';
  if (HasOptionalField(e_msgCentreId))
    strm << setw(indent+14) << "msgCentreId = " << setprecision(indent) << m_msgCentreId << '\n';
  if (HasOptionalField(e_nbOfMessages))
    strm << setw(indent+15) << "nbOfMessages = " << setprecision(indent) << m_nbOfMessages << '\n';
  if (HasOptionalField(e_originatingNr))
    strm << setw(indent+16) << "originatingNr = " << setprecision(indent) << m_originatingNr << '\n';
  if (HasOptionalField(e_timestamp))
    strm << setw(indent+12) << "timestamp = " << setprecision(indent) << m_timestamp << '\n';
  if (HasOptionalField(e_priority))
    strm << setw(indent+11) << "priority = " << setprecision(indent) << m_priority << '\n';
  if (HasOptionalField(e_extensionArg))
    strm << setw(indent+15) << "extensionArg = " << setprecision(indent) << m_extensionArg << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_MWIActivateArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_MWIActivateArg::Class()), PInvalidCast);
#endif
  const H450_MWIActivateArg & other = (const H450_MWIActivateArg &)obj;

  Comparison result;

  if ((result = m_servedUserNr.Compare(other.m_servedUserNr)) != EqualTo)
    return result;
  if ((result = m_basicService.Compare(other.m_basicService)) != EqualTo)
    return result;
  if ((result = m_msgCentreId.Compare(other.m_msgCentreId)) != EqualTo)
    return result;
  if ((result = m_nbOfMessages.Compare(other.m_nbOfMessages)) != EqualTo)
    return result;
  if ((result = m_originatingNr.Compare(other.m_originatingNr)) != EqualTo)
    return result;
  if ((result = m_timestamp.Compare(other.m_timestamp)) != EqualTo)
    return result;
  if ((result = m_priority.Compare(other.m_priority)) != EqualTo)
    return result;
  if ((result = m_extensionArg.Compare(other.m_extensionArg)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_MWIActivateArg::GetDataLength() const
{
  PINDEX length = 0;
  length += m_servedUserNr.GetObjectLength();
  length += m_basicService.GetObjectLength();
  if (HasOptionalField(e_msgCentreId))
    length += m_msgCentreId.GetObjectLength();
  if (HasOptionalField(e_nbOfMessages))
    length += m_nbOfMessages.GetObjectLength();
  if (HasOptionalField(e_originatingNr))
    length += m_originatingNr.GetObjectLength();
  if (HasOptionalField(e_timestamp))
    length += m_timestamp.GetObjectLength();
  if (HasOptionalField(e_priority))
    length += m_priority.GetObjectLength();
  if (HasOptionalField(e_extensionArg))
    length += m_extensionArg.GetObjectLength();
  return length;
}


BOOL H450_MWIActivateArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_servedUserNr.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_basicService.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_msgCentreId ) && !m_msgCentreId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nbOfMessages ) && !m_nbOfMessages.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_originatingNr ) && !m_originatingNr.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_timestamp ) && !m_timestamp.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_priority ) && !m_priority.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionArg ) && !m_extensionArg.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_MWIActivateArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_servedUserNr.Encode(strm);
  m_basicService.Encode(strm);
  if (HasOptionalField(e_msgCentreId))
    m_msgCentreId.Encode(strm);
  if (HasOptionalField(e_nbOfMessages))
    m_nbOfMessages.Encode(strm);
  if (HasOptionalField(e_originatingNr))
    m_originatingNr.Encode(strm);
  if (HasOptionalField(e_timestamp))
    m_timestamp.Encode(strm);
  if (HasOptionalField(e_priority))
    m_priority.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_servedUserNr.Encode(strm);
  m_basicService.Encode(strm);
  if (HasOptionalField(e_msgCentreId))
    m_msgCentreId.Encode(strm);
  if (HasOptionalField(e_nbOfMessages))
    m_nbOfMessages.Encode(strm);
  if (HasOptionalField(e_originatingNr))
    m_originatingNr.Encode(strm);
  if (HasOptionalField(e_timestamp))
    m_timestamp.Encode(strm);
  if (HasOptionalField(e_priority))
    m_priority.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);
}


PObject * H450_MWIActivateArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_MWIActivateArg::Class()), PInvalidCast);
#endif
  return new H450_MWIActivateArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_MWIActivateArg::preShowEthereal( void )
{
  m_servedUserNr.preShowEthereal( );
  m_basicService.preShowEthereal( );
  if ( HasOptionalField( e_msgCentreId ) ) 
      m_msgCentreId.preShowEthereal( );
  if ( HasOptionalField( e_nbOfMessages ) ) 
      m_nbOfMessages.preShowEthereal( );
  if ( HasOptionalField( e_originatingNr ) ) 
      m_originatingNr.preShowEthereal( );
  if ( HasOptionalField( e_timestamp ) ) 
      m_timestamp.preShowEthereal( );
  if ( HasOptionalField( e_priority ) ) 
      m_priority.preShowEthereal( );
  if ( HasOptionalField( e_extensionArg ) ) 
      m_extensionArg.preShowEthereal( );
}

PString H450_MWIActivateArg::getSummary( void ) 
{
  return PString( "MWIActivateArg" );
}

void H450_MWIActivateArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *servedUserNr_tree = (proto_tree*) NULL;
  proto_item *servedUserNr_ti = (proto_item*) NULL;
  servedUserNr_ti = proto_tree_add_text( tree, tvb, offset + m_servedUserNr.GetStartByte(), m_servedUserNr.GetByteLength(), "servedUserNr (EndpointAddress)" );
  servedUserNr_tree = proto_item_add_subtree( servedUserNr_ti, hCont->h450_1.ett_h450_MWIActivateArg_servedUserNr );

  m_servedUserNr.showEthereal( servedUserNr_tree, tvb, offset );

  proto_tree *basicService_tree = (proto_tree*) NULL;
  proto_item *basicService_ti = (proto_item*) NULL;
  basicService_ti = proto_tree_add_text( tree, tvb, offset + m_basicService.GetStartByte(), m_basicService.GetByteLength(), "basicService (BasicService)" );
  basicService_tree = proto_item_add_subtree( basicService_ti, hCont->h450_1.ett_h450_MWIActivateArg_basicService );

  m_basicService.showEthereal( basicService_tree, tvb, offset );

  if ( HasOptionalField( e_msgCentreId ) ) {
    proto_tree *msgCentreId_tree = (proto_tree*) NULL;
    proto_item *msgCentreId_ti = (proto_item*) NULL;
    msgCentreId_ti = proto_tree_add_text( tree, tvb, offset + m_msgCentreId.GetStartByte(), m_msgCentreId.GetByteLength(), "msgCentreId (%s)", ( const char* ) m_msgCentreId.GetTagName() );
    msgCentreId_tree = proto_item_add_subtree( msgCentreId_ti, hCont->h450_1.ett_h450_MWIActivateArg_msgCentreId );
    m_msgCentreId.showEthereal( msgCentreId_tree, tvb, offset );
  }

  if ( HasOptionalField( e_nbOfMessages ) ) {
    proto_tree_add_uint( tree, hCont->h450_1.hf_h450_MWIActivateArg_nbOfMessages, tvb, offset + m_nbOfMessages.GetStartByte(), m_nbOfMessages.GetByteLength() , m_nbOfMessages.GetValue() );
  }

  if ( HasOptionalField( e_originatingNr ) ) {
    proto_tree *originatingNr_tree = (proto_tree*) NULL;
    proto_item *originatingNr_ti = (proto_item*) NULL;
    originatingNr_ti = proto_tree_add_text( tree, tvb, offset + m_originatingNr.GetStartByte(), m_originatingNr.GetByteLength(), "originatingNr (EndpointAddress)" );
    originatingNr_tree = proto_item_add_subtree( originatingNr_ti, hCont->h450_1.ett_h450_MWIActivateArg_originatingNr );
    m_originatingNr.showEthereal( originatingNr_tree, tvb, offset );
  }

  if ( HasOptionalField( e_timestamp ) ) {
  // Something went very wrong here, check GenerateProtoTreeAddItemCall() in main.cxx
  }

  if ( HasOptionalField( e_priority ) ) {
    proto_tree_add_uint( tree, hCont->h450_1.hf_h450_MWIActivateArg_priority, tvb, offset + m_priority.GetStartByte(), m_priority.GetByteLength() , m_priority.GetValue() );
  }

  if ( HasOptionalField( e_extensionArg ) ) {
    proto_tree *extensionArg_tree = (proto_tree*) NULL;
    proto_item *extensionArg_ti = (proto_item*) NULL;
    extensionArg_ti = proto_tree_add_text( tree, tvb, offset + m_extensionArg.GetStartByte(), m_extensionArg.GetByteLength(), "extensionArg (MixedExtension)" );
    extensionArg_tree = proto_item_add_subtree( extensionArg_ti, hCont->h450_1.ett_h450_MWIActivateArg_extensionArg );
    m_extensionArg.showEthereal( extensionArg_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// MWIDeactivateArg
//

H450_MWIDeactivateArg::H450_MWIDeactivateArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
  m_extensionArg.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_MWIDeactivateArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "servedUserNr = " << setprecision(indent) << m_servedUserNr << '\n';
  strm << setw(indent+15) << "basicService = " << setprecision(indent) << m_basicService << '\n';
  if (HasOptionalField(e_msgCentreId))
    strm << setw(indent+14) << "msgCentreId = " << setprecision(indent) << m_msgCentreId << '\n';
  if (HasOptionalField(e_callbackReq))
    strm << setw(indent+14) << "callbackReq = " << setprecision(indent) << m_callbackReq << '\n';
  if (HasOptionalField(e_extensionArg))
    strm << setw(indent+15) << "extensionArg = " << setprecision(indent) << m_extensionArg << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_MWIDeactivateArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_MWIDeactivateArg::Class()), PInvalidCast);
#endif
  const H450_MWIDeactivateArg & other = (const H450_MWIDeactivateArg &)obj;

  Comparison result;

  if ((result = m_servedUserNr.Compare(other.m_servedUserNr)) != EqualTo)
    return result;
  if ((result = m_basicService.Compare(other.m_basicService)) != EqualTo)
    return result;
  if ((result = m_msgCentreId.Compare(other.m_msgCentreId)) != EqualTo)
    return result;
  if ((result = m_callbackReq.Compare(other.m_callbackReq)) != EqualTo)
    return result;
  if ((result = m_extensionArg.Compare(other.m_extensionArg)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_MWIDeactivateArg::GetDataLength() const
{
  PINDEX length = 0;
  length += m_servedUserNr.GetObjectLength();
  length += m_basicService.GetObjectLength();
  if (HasOptionalField(e_msgCentreId))
    length += m_msgCentreId.GetObjectLength();
  if (HasOptionalField(e_callbackReq))
    length += m_callbackReq.GetObjectLength();
  if (HasOptionalField(e_extensionArg))
    length += m_extensionArg.GetObjectLength();
  return length;
}


BOOL H450_MWIDeactivateArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_servedUserNr.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_basicService.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_msgCentreId ) && !m_msgCentreId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_callbackReq ) && !m_callbackReq.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionArg ) && !m_extensionArg.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_MWIDeactivateArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_servedUserNr.Encode(strm);
  m_basicService.Encode(strm);
  if (HasOptionalField(e_msgCentreId))
    m_msgCentreId.Encode(strm);
  if (HasOptionalField(e_callbackReq))
    m_callbackReq.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_servedUserNr.Encode(strm);
  m_basicService.Encode(strm);
  if (HasOptionalField(e_msgCentreId))
    m_msgCentreId.Encode(strm);
  if (HasOptionalField(e_callbackReq))
    m_callbackReq.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);
}


PObject * H450_MWIDeactivateArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_MWIDeactivateArg::Class()), PInvalidCast);
#endif
  return new H450_MWIDeactivateArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_MWIDeactivateArg::preShowEthereal( void )
{
  m_servedUserNr.preShowEthereal( );
  m_basicService.preShowEthereal( );
  if ( HasOptionalField( e_msgCentreId ) ) 
      m_msgCentreId.preShowEthereal( );
  if ( HasOptionalField( e_callbackReq ) ) 
      m_callbackReq.preShowEthereal( );
  if ( HasOptionalField( e_extensionArg ) ) 
      m_extensionArg.preShowEthereal( );
}

PString H450_MWIDeactivateArg::getSummary( void ) 
{
  return PString( "MWIDeactivateArg" );
}

void H450_MWIDeactivateArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *servedUserNr_tree = (proto_tree*) NULL;
  proto_item *servedUserNr_ti = (proto_item*) NULL;
  servedUserNr_ti = proto_tree_add_text( tree, tvb, offset + m_servedUserNr.GetStartByte(), m_servedUserNr.GetByteLength(), "servedUserNr (EndpointAddress)" );
  servedUserNr_tree = proto_item_add_subtree( servedUserNr_ti, hCont->h450_1.ett_h450_MWIDeactivateArg_servedUserNr );

  m_servedUserNr.showEthereal( servedUserNr_tree, tvb, offset );

  proto_tree *basicService_tree = (proto_tree*) NULL;
  proto_item *basicService_ti = (proto_item*) NULL;
  basicService_ti = proto_tree_add_text( tree, tvb, offset + m_basicService.GetStartByte(), m_basicService.GetByteLength(), "basicService (BasicService)" );
  basicService_tree = proto_item_add_subtree( basicService_ti, hCont->h450_1.ett_h450_MWIDeactivateArg_basicService );

  m_basicService.showEthereal( basicService_tree, tvb, offset );

  if ( HasOptionalField( e_msgCentreId ) ) {
    proto_tree *msgCentreId_tree = (proto_tree*) NULL;
    proto_item *msgCentreId_ti = (proto_item*) NULL;
    msgCentreId_ti = proto_tree_add_text( tree, tvb, offset + m_msgCentreId.GetStartByte(), m_msgCentreId.GetByteLength(), "msgCentreId (%s)", ( const char* ) m_msgCentreId.GetTagName() );
    msgCentreId_tree = proto_item_add_subtree( msgCentreId_ti, hCont->h450_1.ett_h450_MWIDeactivateArg_msgCentreId );
    m_msgCentreId.showEthereal( msgCentreId_tree, tvb, offset );
  }

  if ( HasOptionalField( e_callbackReq ) ) {
    proto_tree_add_boolean( tree, hCont->h450_1.hf_h450_MWIDeactivateArg_callbackReq, tvb, offset + m_callbackReq.GetStartByte(), m_callbackReq.GetByteLength() , m_callbackReq.GetValue() );
  }

  if ( HasOptionalField( e_extensionArg ) ) {
    proto_tree *extensionArg_tree = (proto_tree*) NULL;
    proto_item *extensionArg_ti = (proto_item*) NULL;
    extensionArg_ti = proto_tree_add_text( tree, tvb, offset + m_extensionArg.GetStartByte(), m_extensionArg.GetByteLength(), "extensionArg (MixedExtension)" );
    extensionArg_tree = proto_item_add_subtree( extensionArg_ti, hCont->h450_1.ett_h450_MWIDeactivateArg_extensionArg );
    m_extensionArg.showEthereal( extensionArg_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// MWIInterrogateArg
//

H450_MWIInterrogateArg::H450_MWIInterrogateArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
  m_extensionArg.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_MWIInterrogateArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "servedUserNr = " << setprecision(indent) << m_servedUserNr << '\n';
  strm << setw(indent+15) << "basicService = " << setprecision(indent) << m_basicService << '\n';
  if (HasOptionalField(e_msgCentreId))
    strm << setw(indent+14) << "msgCentreId = " << setprecision(indent) << m_msgCentreId << '\n';
  if (HasOptionalField(e_callbackReq))
    strm << setw(indent+14) << "callbackReq = " << setprecision(indent) << m_callbackReq << '\n';
  if (HasOptionalField(e_extensionArg))
    strm << setw(indent+15) << "extensionArg = " << setprecision(indent) << m_extensionArg << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_MWIInterrogateArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_MWIInterrogateArg::Class()), PInvalidCast);
#endif
  const H450_MWIInterrogateArg & other = (const H450_MWIInterrogateArg &)obj;

  Comparison result;

  if ((result = m_servedUserNr.Compare(other.m_servedUserNr)) != EqualTo)
    return result;
  if ((result = m_basicService.Compare(other.m_basicService)) != EqualTo)
    return result;
  if ((result = m_msgCentreId.Compare(other.m_msgCentreId)) != EqualTo)
    return result;
  if ((result = m_callbackReq.Compare(other.m_callbackReq)) != EqualTo)
    return result;
  if ((result = m_extensionArg.Compare(other.m_extensionArg)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_MWIInterrogateArg::GetDataLength() const
{
  PINDEX length = 0;
  length += m_servedUserNr.GetObjectLength();
  length += m_basicService.GetObjectLength();
  if (HasOptionalField(e_msgCentreId))
    length += m_msgCentreId.GetObjectLength();
  if (HasOptionalField(e_callbackReq))
    length += m_callbackReq.GetObjectLength();
  if (HasOptionalField(e_extensionArg))
    length += m_extensionArg.GetObjectLength();
  return length;
}


BOOL H450_MWIInterrogateArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_servedUserNr.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_basicService.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_msgCentreId ) && !m_msgCentreId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_callbackReq ) && !m_callbackReq.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionArg ) && !m_extensionArg.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_MWIInterrogateArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_servedUserNr.Encode(strm);
  m_basicService.Encode(strm);
  if (HasOptionalField(e_msgCentreId))
    m_msgCentreId.Encode(strm);
  if (HasOptionalField(e_callbackReq))
    m_callbackReq.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_servedUserNr.Encode(strm);
  m_basicService.Encode(strm);
  if (HasOptionalField(e_msgCentreId))
    m_msgCentreId.Encode(strm);
  if (HasOptionalField(e_callbackReq))
    m_callbackReq.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);
}


PObject * H450_MWIInterrogateArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_MWIInterrogateArg::Class()), PInvalidCast);
#endif
  return new H450_MWIInterrogateArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_MWIInterrogateArg::preShowEthereal( void )
{
  m_servedUserNr.preShowEthereal( );
  m_basicService.preShowEthereal( );
  if ( HasOptionalField( e_msgCentreId ) ) 
      m_msgCentreId.preShowEthereal( );
  if ( HasOptionalField( e_callbackReq ) ) 
      m_callbackReq.preShowEthereal( );
  if ( HasOptionalField( e_extensionArg ) ) 
      m_extensionArg.preShowEthereal( );
}

PString H450_MWIInterrogateArg::getSummary( void ) 
{
  return PString( "MWIInterrogateArg" );
}

void H450_MWIInterrogateArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *servedUserNr_tree = (proto_tree*) NULL;
  proto_item *servedUserNr_ti = (proto_item*) NULL;
  servedUserNr_ti = proto_tree_add_text( tree, tvb, offset + m_servedUserNr.GetStartByte(), m_servedUserNr.GetByteLength(), "servedUserNr (EndpointAddress)" );
  servedUserNr_tree = proto_item_add_subtree( servedUserNr_ti, hCont->h450_1.ett_h450_MWIInterrogateArg_servedUserNr );

  m_servedUserNr.showEthereal( servedUserNr_tree, tvb, offset );

  proto_tree *basicService_tree = (proto_tree*) NULL;
  proto_item *basicService_ti = (proto_item*) NULL;
  basicService_ti = proto_tree_add_text( tree, tvb, offset + m_basicService.GetStartByte(), m_basicService.GetByteLength(), "basicService (BasicService)" );
  basicService_tree = proto_item_add_subtree( basicService_ti, hCont->h450_1.ett_h450_MWIInterrogateArg_basicService );

  m_basicService.showEthereal( basicService_tree, tvb, offset );

  if ( HasOptionalField( e_msgCentreId ) ) {
    proto_tree *msgCentreId_tree = (proto_tree*) NULL;
    proto_item *msgCentreId_ti = (proto_item*) NULL;
    msgCentreId_ti = proto_tree_add_text( tree, tvb, offset + m_msgCentreId.GetStartByte(), m_msgCentreId.GetByteLength(), "msgCentreId (%s)", ( const char* ) m_msgCentreId.GetTagName() );
    msgCentreId_tree = proto_item_add_subtree( msgCentreId_ti, hCont->h450_1.ett_h450_MWIInterrogateArg_msgCentreId );
    m_msgCentreId.showEthereal( msgCentreId_tree, tvb, offset );
  }

  if ( HasOptionalField( e_callbackReq ) ) {
    proto_tree_add_boolean( tree, hCont->h450_1.hf_h450_MWIInterrogateArg_callbackReq, tvb, offset + m_callbackReq.GetStartByte(), m_callbackReq.GetByteLength() , m_callbackReq.GetValue() );
  }

  if ( HasOptionalField( e_extensionArg ) ) {
    proto_tree *extensionArg_tree = (proto_tree*) NULL;
    proto_item *extensionArg_ti = (proto_item*) NULL;
    extensionArg_ti = proto_tree_add_text( tree, tvb, offset + m_extensionArg.GetStartByte(), m_extensionArg.GetByteLength(), "extensionArg (MixedExtension)" );
    extensionArg_tree = proto_item_add_subtree( extensionArg_ti, hCont->h450_1.ett_h450_MWIInterrogateArg_extensionArg );
    m_extensionArg.showEthereal( extensionArg_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// MWIInterrogateResElt
//

H450_MWIInterrogateResElt::H450_MWIInterrogateResElt(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 6, TRUE, 0)
{
  m_priority.SetConstraints(PASN_Object::FixedConstraint, 0, 9);
  m_extensionArg.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_MWIInterrogateResElt::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "basicService = " << setprecision(indent) << m_basicService << '\n';
  if (HasOptionalField(e_msgCentreId))
    strm << setw(indent+14) << "msgCentreId = " << setprecision(indent) << m_msgCentreId << '\n';
  if (HasOptionalField(e_nbOfMessages))
    strm << setw(indent+15) << "nbOfMessages = " << setprecision(indent) << m_nbOfMessages << '\n';
  if (HasOptionalField(e_originatingNr))
    strm << setw(indent+16) << "originatingNr = " << setprecision(indent) << m_originatingNr << '\n';
  if (HasOptionalField(e_timestamp))
    strm << setw(indent+12) << "timestamp = " << setprecision(indent) << m_timestamp << '\n';
  if (HasOptionalField(e_priority))
    strm << setw(indent+11) << "priority = " << setprecision(indent) << m_priority << '\n';
  if (HasOptionalField(e_extensionArg))
    strm << setw(indent+15) << "extensionArg = " << setprecision(indent) << m_extensionArg << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_MWIInterrogateResElt::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_MWIInterrogateResElt::Class()), PInvalidCast);
#endif
  const H450_MWIInterrogateResElt & other = (const H450_MWIInterrogateResElt &)obj;

  Comparison result;

  if ((result = m_basicService.Compare(other.m_basicService)) != EqualTo)
    return result;
  if ((result = m_msgCentreId.Compare(other.m_msgCentreId)) != EqualTo)
    return result;
  if ((result = m_nbOfMessages.Compare(other.m_nbOfMessages)) != EqualTo)
    return result;
  if ((result = m_originatingNr.Compare(other.m_originatingNr)) != EqualTo)
    return result;
  if ((result = m_timestamp.Compare(other.m_timestamp)) != EqualTo)
    return result;
  if ((result = m_priority.Compare(other.m_priority)) != EqualTo)
    return result;
  if ((result = m_extensionArg.Compare(other.m_extensionArg)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_MWIInterrogateResElt::GetDataLength() const
{
  PINDEX length = 0;
  length += m_basicService.GetObjectLength();
  if (HasOptionalField(e_msgCentreId))
    length += m_msgCentreId.GetObjectLength();
  if (HasOptionalField(e_nbOfMessages))
    length += m_nbOfMessages.GetObjectLength();
  if (HasOptionalField(e_originatingNr))
    length += m_originatingNr.GetObjectLength();
  if (HasOptionalField(e_timestamp))
    length += m_timestamp.GetObjectLength();
  if (HasOptionalField(e_priority))
    length += m_priority.GetObjectLength();
  if (HasOptionalField(e_extensionArg))
    length += m_extensionArg.GetObjectLength();
  return length;
}


BOOL H450_MWIInterrogateResElt::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_basicService.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_msgCentreId ) && !m_msgCentreId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nbOfMessages ) && !m_nbOfMessages.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_originatingNr ) && !m_originatingNr.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_timestamp ) && !m_timestamp.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_priority ) && !m_priority.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionArg ) && !m_extensionArg.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_MWIInterrogateResElt::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_basicService.Encode(strm);
  if (HasOptionalField(e_msgCentreId))
    m_msgCentreId.Encode(strm);
  if (HasOptionalField(e_nbOfMessages))
    m_nbOfMessages.Encode(strm);
  if (HasOptionalField(e_originatingNr))
    m_originatingNr.Encode(strm);
  if (HasOptionalField(e_timestamp))
    m_timestamp.Encode(strm);
  if (HasOptionalField(e_priority))
    m_priority.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_basicService.Encode(strm);
  if (HasOptionalField(e_msgCentreId))
    m_msgCentreId.Encode(strm);
  if (HasOptionalField(e_nbOfMessages))
    m_nbOfMessages.Encode(strm);
  if (HasOptionalField(e_originatingNr))
    m_originatingNr.Encode(strm);
  if (HasOptionalField(e_timestamp))
    m_timestamp.Encode(strm);
  if (HasOptionalField(e_priority))
    m_priority.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);
}


PObject * H450_MWIInterrogateResElt::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_MWIInterrogateResElt::Class()), PInvalidCast);
#endif
  return new H450_MWIInterrogateResElt(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_MWIInterrogateResElt::preShowEthereal( void )
{
  m_basicService.preShowEthereal( );
  if ( HasOptionalField( e_msgCentreId ) ) 
      m_msgCentreId.preShowEthereal( );
  if ( HasOptionalField( e_nbOfMessages ) ) 
      m_nbOfMessages.preShowEthereal( );
  if ( HasOptionalField( e_originatingNr ) ) 
      m_originatingNr.preShowEthereal( );
  if ( HasOptionalField( e_timestamp ) ) 
      m_timestamp.preShowEthereal( );
  if ( HasOptionalField( e_priority ) ) 
      m_priority.preShowEthereal( );
  if ( HasOptionalField( e_extensionArg ) ) 
      m_extensionArg.preShowEthereal( );
}

PString H450_MWIInterrogateResElt::getSummary( void ) 
{
  return PString( "MWIInterrogateResElt" );
}

void H450_MWIInterrogateResElt::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *basicService_tree = (proto_tree*) NULL;
  proto_item *basicService_ti = (proto_item*) NULL;
  basicService_ti = proto_tree_add_text( tree, tvb, offset + m_basicService.GetStartByte(), m_basicService.GetByteLength(), "basicService (BasicService)" );
  basicService_tree = proto_item_add_subtree( basicService_ti, hCont->h450_1.ett_h450_MWIInterrogateResElt_basicService );

  m_basicService.showEthereal( basicService_tree, tvb, offset );

  if ( HasOptionalField( e_msgCentreId ) ) {
    proto_tree *msgCentreId_tree = (proto_tree*) NULL;
    proto_item *msgCentreId_ti = (proto_item*) NULL;
    msgCentreId_ti = proto_tree_add_text( tree, tvb, offset + m_msgCentreId.GetStartByte(), m_msgCentreId.GetByteLength(), "msgCentreId (%s)", ( const char* ) m_msgCentreId.GetTagName() );
    msgCentreId_tree = proto_item_add_subtree( msgCentreId_ti, hCont->h450_1.ett_h450_MWIInterrogateResElt_msgCentreId );
    m_msgCentreId.showEthereal( msgCentreId_tree, tvb, offset );
  }

  if ( HasOptionalField( e_nbOfMessages ) ) {
    proto_tree_add_uint( tree, hCont->h450_1.hf_h450_MWIInterrogateResElt_nbOfMessages, tvb, offset + m_nbOfMessages.GetStartByte(), m_nbOfMessages.GetByteLength() , m_nbOfMessages.GetValue() );
  }

  if ( HasOptionalField( e_originatingNr ) ) {
    proto_tree *originatingNr_tree = (proto_tree*) NULL;
    proto_item *originatingNr_ti = (proto_item*) NULL;
    originatingNr_ti = proto_tree_add_text( tree, tvb, offset + m_originatingNr.GetStartByte(), m_originatingNr.GetByteLength(), "originatingNr (EndpointAddress)" );
    originatingNr_tree = proto_item_add_subtree( originatingNr_ti, hCont->h450_1.ett_h450_MWIInterrogateResElt_originatingNr );
    m_originatingNr.showEthereal( originatingNr_tree, tvb, offset );
  }

  if ( HasOptionalField( e_timestamp ) ) {
  // Something went very wrong here, check GenerateProtoTreeAddItemCall() in main.cxx
  }

  if ( HasOptionalField( e_priority ) ) {
    proto_tree_add_uint( tree, hCont->h450_1.hf_h450_MWIInterrogateResElt_priority, tvb, offset + m_priority.GetStartByte(), m_priority.GetByteLength() , m_priority.GetValue() );
  }

  if ( HasOptionalField( e_extensionArg ) ) {
    proto_tree *extensionArg_tree = (proto_tree*) NULL;
    proto_item *extensionArg_ti = (proto_item*) NULL;
    extensionArg_ti = proto_tree_add_text( tree, tvb, offset + m_extensionArg.GetStartByte(), m_extensionArg.GetByteLength(), "extensionArg (MixedExtension)" );
    extensionArg_tree = proto_item_add_subtree( extensionArg_ti, hCont->h450_1.ett_h450_MWIInterrogateResElt_extensionArg );
    m_extensionArg.showEthereal( extensionArg_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CoReqOptArg
//

H450_CoReqOptArg::H450_CoReqOptArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_extension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CoReqOptArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_extension))
    strm << setw(indent+12) << "extension = " << setprecision(indent) << m_extension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CoReqOptArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CoReqOptArg::Class()), PInvalidCast);
#endif
  const H450_CoReqOptArg & other = (const H450_CoReqOptArg &)obj;

  Comparison result;

  if ((result = m_extension.Compare(other.m_extension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CoReqOptArg::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_extension))
    length += m_extension.GetObjectLength();
  return length;
}


BOOL H450_CoReqOptArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extension ) && !m_extension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CoReqOptArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_extension))
    m_extension.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_extension))
    m_extension.Encode(strm);
}


PObject * H450_CoReqOptArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CoReqOptArg::Class()), PInvalidCast);
#endif
  return new H450_CoReqOptArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CoReqOptArg::preShowEthereal( void )
{
  if ( HasOptionalField( e_extension ) ) 
      m_extension.preShowEthereal( );
}

PString H450_CoReqOptArg::getSummary( void ) 
{
  return PString( "CoReqOptArg" );
}

void H450_CoReqOptArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_extension ) ) {
    proto_tree *extension_tree = (proto_tree*) NULL;
    proto_item *extension_ti = (proto_item*) NULL;
    extension_ti = proto_tree_add_text( tree, tvb, offset + m_extension.GetStartByte(), m_extension.GetByteLength(), "extension (MixedExtension)" );
    extension_tree = proto_item_add_subtree( extension_ti, hCont->h450_1.ett_h450_CoReqOptArg_extension );
    m_extension.showEthereal( extension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// RUAlertOptArg
//

H450_RUAlertOptArg::H450_RUAlertOptArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_extension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_RUAlertOptArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_extension))
    strm << setw(indent+12) << "extension = " << setprecision(indent) << m_extension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_RUAlertOptArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_RUAlertOptArg::Class()), PInvalidCast);
#endif
  const H450_RUAlertOptArg & other = (const H450_RUAlertOptArg &)obj;

  Comparison result;

  if ((result = m_extension.Compare(other.m_extension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_RUAlertOptArg::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_extension))
    length += m_extension.GetObjectLength();
  return length;
}


BOOL H450_RUAlertOptArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extension ) && !m_extension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_RUAlertOptArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_extension))
    m_extension.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_extension))
    m_extension.Encode(strm);
}


PObject * H450_RUAlertOptArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_RUAlertOptArg::Class()), PInvalidCast);
#endif
  return new H450_RUAlertOptArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_RUAlertOptArg::preShowEthereal( void )
{
  if ( HasOptionalField( e_extension ) ) 
      m_extension.preShowEthereal( );
}

PString H450_RUAlertOptArg::getSummary( void ) 
{
  return PString( "RUAlertOptArg" );
}

void H450_RUAlertOptArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_extension ) ) {
    proto_tree *extension_tree = (proto_tree*) NULL;
    proto_item *extension_ti = (proto_item*) NULL;
    extension_ti = proto_tree_add_text( tree, tvb, offset + m_extension.GetStartByte(), m_extension.GetByteLength(), "extension (MixedExtension)" );
    extension_tree = proto_item_add_subtree( extension_ti, hCont->h450_1.ett_h450_RUAlertOptArg_extension );
    m_extension.showEthereal( extension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CfbOvrOptArg
//

H450_CfbOvrOptArg::H450_CfbOvrOptArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_extension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CfbOvrOptArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_extension))
    strm << setw(indent+12) << "extension = " << setprecision(indent) << m_extension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CfbOvrOptArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CfbOvrOptArg::Class()), PInvalidCast);
#endif
  const H450_CfbOvrOptArg & other = (const H450_CfbOvrOptArg &)obj;

  Comparison result;

  if ((result = m_extension.Compare(other.m_extension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CfbOvrOptArg::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_extension))
    length += m_extension.GetObjectLength();
  return length;
}


BOOL H450_CfbOvrOptArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extension ) && !m_extension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CfbOvrOptArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_extension))
    m_extension.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_extension))
    m_extension.Encode(strm);
}


PObject * H450_CfbOvrOptArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CfbOvrOptArg::Class()), PInvalidCast);
#endif
  return new H450_CfbOvrOptArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CfbOvrOptArg::preShowEthereal( void )
{
  if ( HasOptionalField( e_extension ) ) 
      m_extension.preShowEthereal( );
}

PString H450_CfbOvrOptArg::getSummary( void ) 
{
  return PString( "CfbOvrOptArg" );
}

void H450_CfbOvrOptArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_extension ) ) {
    proto_tree *extension_tree = (proto_tree*) NULL;
    proto_item *extension_ti = (proto_item*) NULL;
    extension_ti = proto_tree_add_text( tree, tvb, offset + m_extension.GetStartByte(), m_extension.GetByteLength(), "extension (MixedExtension)" );
    extension_tree = proto_item_add_subtree( extension_ti, hCont->h450_1.ett_h450_CfbOvrOptArg_extension );
    m_extension.showEthereal( extension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CpRequestArg
//

H450_CpRequestArg::H450_CpRequestArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_extensionArg.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CpRequestArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "parkingNumber = " << setprecision(indent) << m_parkingNumber << '\n';
  strm << setw(indent+15) << "parkedNumber = " << setprecision(indent) << m_parkedNumber << '\n';
  strm << setw(indent+17) << "parkedToNumber = " << setprecision(indent) << m_parkedToNumber << '\n';
  if (HasOptionalField(e_parkedToPosition))
    strm << setw(indent+19) << "parkedToPosition = " << setprecision(indent) << m_parkedToPosition << '\n';
  if (HasOptionalField(e_extensionArg))
    strm << setw(indent+15) << "extensionArg = " << setprecision(indent) << m_extensionArg << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CpRequestArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CpRequestArg::Class()), PInvalidCast);
#endif
  const H450_CpRequestArg & other = (const H450_CpRequestArg &)obj;

  Comparison result;

  if ((result = m_parkingNumber.Compare(other.m_parkingNumber)) != EqualTo)
    return result;
  if ((result = m_parkedNumber.Compare(other.m_parkedNumber)) != EqualTo)
    return result;
  if ((result = m_parkedToNumber.Compare(other.m_parkedToNumber)) != EqualTo)
    return result;
  if ((result = m_parkedToPosition.Compare(other.m_parkedToPosition)) != EqualTo)
    return result;
  if ((result = m_extensionArg.Compare(other.m_extensionArg)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CpRequestArg::GetDataLength() const
{
  PINDEX length = 0;
  length += m_parkingNumber.GetObjectLength();
  length += m_parkedNumber.GetObjectLength();
  length += m_parkedToNumber.GetObjectLength();
  if (HasOptionalField(e_parkedToPosition))
    length += m_parkedToPosition.GetObjectLength();
  if (HasOptionalField(e_extensionArg))
    length += m_extensionArg.GetObjectLength();
  return length;
}


BOOL H450_CpRequestArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_parkingNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_parkedNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_parkedToNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_parkedToPosition ) && !m_parkedToPosition.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionArg ) && !m_extensionArg.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CpRequestArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_parkingNumber.Encode(strm);
  m_parkedNumber.Encode(strm);
  m_parkedToNumber.Encode(strm);
  if (HasOptionalField(e_parkedToPosition))
    m_parkedToPosition.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_parkingNumber.Encode(strm);
  m_parkedNumber.Encode(strm);
  m_parkedToNumber.Encode(strm);
  if (HasOptionalField(e_parkedToPosition))
    m_parkedToPosition.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);
}


PObject * H450_CpRequestArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CpRequestArg::Class()), PInvalidCast);
#endif
  return new H450_CpRequestArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CpRequestArg::preShowEthereal( void )
{
  m_parkingNumber.preShowEthereal( );
  m_parkedNumber.preShowEthereal( );
  m_parkedToNumber.preShowEthereal( );
  if ( HasOptionalField( e_parkedToPosition ) ) 
      m_parkedToPosition.preShowEthereal( );
  if ( HasOptionalField( e_extensionArg ) ) 
      m_extensionArg.preShowEthereal( );
}

PString H450_CpRequestArg::getSummary( void ) 
{
  return PString( "CpRequestArg" );
}

void H450_CpRequestArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *parkingNumber_tree = (proto_tree*) NULL;
  proto_item *parkingNumber_ti = (proto_item*) NULL;
  parkingNumber_ti = proto_tree_add_text( tree, tvb, offset + m_parkingNumber.GetStartByte(), m_parkingNumber.GetByteLength(), "parkingNumber (EndpointAddress)" );
  parkingNumber_tree = proto_item_add_subtree( parkingNumber_ti, hCont->h450_1.ett_h450_CpRequestArg_parkingNumber );

  m_parkingNumber.showEthereal( parkingNumber_tree, tvb, offset );

  proto_tree *parkedNumber_tree = (proto_tree*) NULL;
  proto_item *parkedNumber_ti = (proto_item*) NULL;
  parkedNumber_ti = proto_tree_add_text( tree, tvb, offset + m_parkedNumber.GetStartByte(), m_parkedNumber.GetByteLength(), "parkedNumber (EndpointAddress)" );
  parkedNumber_tree = proto_item_add_subtree( parkedNumber_ti, hCont->h450_1.ett_h450_CpRequestArg_parkedNumber );

  m_parkedNumber.showEthereal( parkedNumber_tree, tvb, offset );

  proto_tree *parkedToNumber_tree = (proto_tree*) NULL;
  proto_item *parkedToNumber_ti = (proto_item*) NULL;
  parkedToNumber_ti = proto_tree_add_text( tree, tvb, offset + m_parkedToNumber.GetStartByte(), m_parkedToNumber.GetByteLength(), "parkedToNumber (EndpointAddress)" );
  parkedToNumber_tree = proto_item_add_subtree( parkedToNumber_ti, hCont->h450_1.ett_h450_CpRequestArg_parkedToNumber );

  m_parkedToNumber.showEthereal( parkedToNumber_tree, tvb, offset );

  if ( HasOptionalField( e_parkedToPosition ) ) {
    proto_tree_add_uint( tree, hCont->h450_1.hf_h450_CpRequestArg_parkedToPosition, tvb, offset + m_parkedToPosition.GetStartByte(), m_parkedToPosition.GetByteLength() , m_parkedToPosition.GetValue() );
  }

  if ( HasOptionalField( e_extensionArg ) ) {
    proto_tree *extensionArg_tree = (proto_tree*) NULL;
    proto_item *extensionArg_ti = (proto_item*) NULL;
    extensionArg_ti = proto_tree_add_text( tree, tvb, offset + m_extensionArg.GetStartByte(), m_extensionArg.GetByteLength(), "extensionArg (MixedExtension)" );
    extensionArg_tree = proto_item_add_subtree( extensionArg_ti, hCont->h450_1.ett_h450_CpRequestArg_extensionArg );
    m_extensionArg.showEthereal( extensionArg_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CpRequestRes
//

H450_CpRequestRes::H450_CpRequestRes(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_extensionRes.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CpRequestRes::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "parkedToNumber = " << setprecision(indent) << m_parkedToNumber << '\n';
  if (HasOptionalField(e_parkedToPosition))
    strm << setw(indent+19) << "parkedToPosition = " << setprecision(indent) << m_parkedToPosition << '\n';
  strm << setw(indent+16) << "parkCondition = " << setprecision(indent) << m_parkCondition << '\n';
  if (HasOptionalField(e_extensionRes))
    strm << setw(indent+15) << "extensionRes = " << setprecision(indent) << m_extensionRes << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CpRequestRes::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CpRequestRes::Class()), PInvalidCast);
#endif
  const H450_CpRequestRes & other = (const H450_CpRequestRes &)obj;

  Comparison result;

  if ((result = m_parkedToNumber.Compare(other.m_parkedToNumber)) != EqualTo)
    return result;
  if ((result = m_parkedToPosition.Compare(other.m_parkedToPosition)) != EqualTo)
    return result;
  if ((result = m_parkCondition.Compare(other.m_parkCondition)) != EqualTo)
    return result;
  if ((result = m_extensionRes.Compare(other.m_extensionRes)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CpRequestRes::GetDataLength() const
{
  PINDEX length = 0;
  length += m_parkedToNumber.GetObjectLength();
  if (HasOptionalField(e_parkedToPosition))
    length += m_parkedToPosition.GetObjectLength();
  length += m_parkCondition.GetObjectLength();
  if (HasOptionalField(e_extensionRes))
    length += m_extensionRes.GetObjectLength();
  return length;
}


BOOL H450_CpRequestRes::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_parkedToNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_parkedToPosition ) && !m_parkedToPosition.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_parkCondition.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionRes ) && !m_extensionRes.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CpRequestRes::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_parkedToNumber.Encode(strm);
  if (HasOptionalField(e_parkedToPosition))
    m_parkedToPosition.Encode(strm);
  m_parkCondition.Encode(strm);
  if (HasOptionalField(e_extensionRes))
    m_extensionRes.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_parkedToNumber.Encode(strm);
  if (HasOptionalField(e_parkedToPosition))
    m_parkedToPosition.Encode(strm);
  m_parkCondition.Encode(strm);
  if (HasOptionalField(e_extensionRes))
    m_extensionRes.Encode(strm);
}


PObject * H450_CpRequestRes::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CpRequestRes::Class()), PInvalidCast);
#endif
  return new H450_CpRequestRes(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CpRequestRes::preShowEthereal( void )
{
  m_parkedToNumber.preShowEthereal( );
  if ( HasOptionalField( e_parkedToPosition ) ) 
      m_parkedToPosition.preShowEthereal( );
  m_parkCondition.preShowEthereal( );
  if ( HasOptionalField( e_extensionRes ) ) 
      m_extensionRes.preShowEthereal( );
}

PString H450_CpRequestRes::getSummary( void ) 
{
  return PString( "CpRequestRes" );
}

void H450_CpRequestRes::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *parkedToNumber_tree = (proto_tree*) NULL;
  proto_item *parkedToNumber_ti = (proto_item*) NULL;
  parkedToNumber_ti = proto_tree_add_text( tree, tvb, offset + m_parkedToNumber.GetStartByte(), m_parkedToNumber.GetByteLength(), "parkedToNumber (EndpointAddress)" );
  parkedToNumber_tree = proto_item_add_subtree( parkedToNumber_ti, hCont->h450_1.ett_h450_CpRequestRes_parkedToNumber );

  m_parkedToNumber.showEthereal( parkedToNumber_tree, tvb, offset );

  if ( HasOptionalField( e_parkedToPosition ) ) {
    proto_tree_add_uint( tree, hCont->h450_1.hf_h450_CpRequestRes_parkedToPosition, tvb, offset + m_parkedToPosition.GetStartByte(), m_parkedToPosition.GetByteLength() , m_parkedToPosition.GetValue() );
  }

  proto_tree *parkCondition_tree = (proto_tree*) NULL;
  proto_item *parkCondition_ti = (proto_item*) NULL;
  parkCondition_ti = proto_tree_add_text( tree, tvb, offset + m_parkCondition.GetStartByte(), m_parkCondition.GetByteLength(), "parkCondition (ParkCondition)" );
  parkCondition_tree = proto_item_add_subtree( parkCondition_ti, hCont->h450_1.ett_h450_CpRequestRes_parkCondition );

  m_parkCondition.showEthereal( parkCondition_tree, tvb, offset );

  if ( HasOptionalField( e_extensionRes ) ) {
    proto_tree *extensionRes_tree = (proto_tree*) NULL;
    proto_item *extensionRes_ti = (proto_item*) NULL;
    extensionRes_ti = proto_tree_add_text( tree, tvb, offset + m_extensionRes.GetStartByte(), m_extensionRes.GetByteLength(), "extensionRes (MixedExtension)" );
    extensionRes_tree = proto_item_add_subtree( extensionRes_ti, hCont->h450_1.ett_h450_CpRequestRes_extensionRes );
    m_extensionRes.showEthereal( extensionRes_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CpSetupArg
//

H450_CpSetupArg::H450_CpSetupArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_extensionArg.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CpSetupArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "parkingNumber = " << setprecision(indent) << m_parkingNumber << '\n';
  strm << setw(indent+15) << "parkedNumber = " << setprecision(indent) << m_parkedNumber << '\n';
  strm << setw(indent+17) << "parkedToNumber = " << setprecision(indent) << m_parkedToNumber << '\n';
  if (HasOptionalField(e_parkedToPosition))
    strm << setw(indent+19) << "parkedToPosition = " << setprecision(indent) << m_parkedToPosition << '\n';
  if (HasOptionalField(e_extensionArg))
    strm << setw(indent+15) << "extensionArg = " << setprecision(indent) << m_extensionArg << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CpSetupArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CpSetupArg::Class()), PInvalidCast);
#endif
  const H450_CpSetupArg & other = (const H450_CpSetupArg &)obj;

  Comparison result;

  if ((result = m_parkingNumber.Compare(other.m_parkingNumber)) != EqualTo)
    return result;
  if ((result = m_parkedNumber.Compare(other.m_parkedNumber)) != EqualTo)
    return result;
  if ((result = m_parkedToNumber.Compare(other.m_parkedToNumber)) != EqualTo)
    return result;
  if ((result = m_parkedToPosition.Compare(other.m_parkedToPosition)) != EqualTo)
    return result;
  if ((result = m_extensionArg.Compare(other.m_extensionArg)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CpSetupArg::GetDataLength() const
{
  PINDEX length = 0;
  length += m_parkingNumber.GetObjectLength();
  length += m_parkedNumber.GetObjectLength();
  length += m_parkedToNumber.GetObjectLength();
  if (HasOptionalField(e_parkedToPosition))
    length += m_parkedToPosition.GetObjectLength();
  if (HasOptionalField(e_extensionArg))
    length += m_extensionArg.GetObjectLength();
  return length;
}


BOOL H450_CpSetupArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_parkingNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_parkedNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_parkedToNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_parkedToPosition ) && !m_parkedToPosition.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionArg ) && !m_extensionArg.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CpSetupArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_parkingNumber.Encode(strm);
  m_parkedNumber.Encode(strm);
  m_parkedToNumber.Encode(strm);
  if (HasOptionalField(e_parkedToPosition))
    m_parkedToPosition.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_parkingNumber.Encode(strm);
  m_parkedNumber.Encode(strm);
  m_parkedToNumber.Encode(strm);
  if (HasOptionalField(e_parkedToPosition))
    m_parkedToPosition.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);
}


PObject * H450_CpSetupArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CpSetupArg::Class()), PInvalidCast);
#endif
  return new H450_CpSetupArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CpSetupArg::preShowEthereal( void )
{
  m_parkingNumber.preShowEthereal( );
  m_parkedNumber.preShowEthereal( );
  m_parkedToNumber.preShowEthereal( );
  if ( HasOptionalField( e_parkedToPosition ) ) 
      m_parkedToPosition.preShowEthereal( );
  if ( HasOptionalField( e_extensionArg ) ) 
      m_extensionArg.preShowEthereal( );
}

PString H450_CpSetupArg::getSummary( void ) 
{
  return PString( "CpSetupArg" );
}

void H450_CpSetupArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *parkingNumber_tree = (proto_tree*) NULL;
  proto_item *parkingNumber_ti = (proto_item*) NULL;
  parkingNumber_ti = proto_tree_add_text( tree, tvb, offset + m_parkingNumber.GetStartByte(), m_parkingNumber.GetByteLength(), "parkingNumber (EndpointAddress)" );
  parkingNumber_tree = proto_item_add_subtree( parkingNumber_ti, hCont->h450_1.ett_h450_CpSetupArg_parkingNumber );

  m_parkingNumber.showEthereal( parkingNumber_tree, tvb, offset );

  proto_tree *parkedNumber_tree = (proto_tree*) NULL;
  proto_item *parkedNumber_ti = (proto_item*) NULL;
  parkedNumber_ti = proto_tree_add_text( tree, tvb, offset + m_parkedNumber.GetStartByte(), m_parkedNumber.GetByteLength(), "parkedNumber (EndpointAddress)" );
  parkedNumber_tree = proto_item_add_subtree( parkedNumber_ti, hCont->h450_1.ett_h450_CpSetupArg_parkedNumber );

  m_parkedNumber.showEthereal( parkedNumber_tree, tvb, offset );

  proto_tree *parkedToNumber_tree = (proto_tree*) NULL;
  proto_item *parkedToNumber_ti = (proto_item*) NULL;
  parkedToNumber_ti = proto_tree_add_text( tree, tvb, offset + m_parkedToNumber.GetStartByte(), m_parkedToNumber.GetByteLength(), "parkedToNumber (EndpointAddress)" );
  parkedToNumber_tree = proto_item_add_subtree( parkedToNumber_ti, hCont->h450_1.ett_h450_CpSetupArg_parkedToNumber );

  m_parkedToNumber.showEthereal( parkedToNumber_tree, tvb, offset );

  if ( HasOptionalField( e_parkedToPosition ) ) {
    proto_tree_add_uint( tree, hCont->h450_1.hf_h450_CpSetupArg_parkedToPosition, tvb, offset + m_parkedToPosition.GetStartByte(), m_parkedToPosition.GetByteLength() , m_parkedToPosition.GetValue() );
  }

  if ( HasOptionalField( e_extensionArg ) ) {
    proto_tree *extensionArg_tree = (proto_tree*) NULL;
    proto_item *extensionArg_ti = (proto_item*) NULL;
    extensionArg_ti = proto_tree_add_text( tree, tvb, offset + m_extensionArg.GetStartByte(), m_extensionArg.GetByteLength(), "extensionArg (MixedExtension)" );
    extensionArg_tree = proto_item_add_subtree( extensionArg_ti, hCont->h450_1.ett_h450_CpSetupArg_extensionArg );
    m_extensionArg.showEthereal( extensionArg_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CpSetupRes
//

H450_CpSetupRes::H450_CpSetupRes(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_extensionRes.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CpSetupRes::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "parkedToNumber = " << setprecision(indent) << m_parkedToNumber << '\n';
  if (HasOptionalField(e_parkedToPosition))
    strm << setw(indent+19) << "parkedToPosition = " << setprecision(indent) << m_parkedToPosition << '\n';
  strm << setw(indent+16) << "parkCondition = " << setprecision(indent) << m_parkCondition << '\n';
  if (HasOptionalField(e_extensionRes))
    strm << setw(indent+15) << "extensionRes = " << setprecision(indent) << m_extensionRes << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CpSetupRes::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CpSetupRes::Class()), PInvalidCast);
#endif
  const H450_CpSetupRes & other = (const H450_CpSetupRes &)obj;

  Comparison result;

  if ((result = m_parkedToNumber.Compare(other.m_parkedToNumber)) != EqualTo)
    return result;
  if ((result = m_parkedToPosition.Compare(other.m_parkedToPosition)) != EqualTo)
    return result;
  if ((result = m_parkCondition.Compare(other.m_parkCondition)) != EqualTo)
    return result;
  if ((result = m_extensionRes.Compare(other.m_extensionRes)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CpSetupRes::GetDataLength() const
{
  PINDEX length = 0;
  length += m_parkedToNumber.GetObjectLength();
  if (HasOptionalField(e_parkedToPosition))
    length += m_parkedToPosition.GetObjectLength();
  length += m_parkCondition.GetObjectLength();
  if (HasOptionalField(e_extensionRes))
    length += m_extensionRes.GetObjectLength();
  return length;
}


BOOL H450_CpSetupRes::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_parkedToNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_parkedToPosition ) && !m_parkedToPosition.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_parkCondition.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionRes ) && !m_extensionRes.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CpSetupRes::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_parkedToNumber.Encode(strm);
  if (HasOptionalField(e_parkedToPosition))
    m_parkedToPosition.Encode(strm);
  m_parkCondition.Encode(strm);
  if (HasOptionalField(e_extensionRes))
    m_extensionRes.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_parkedToNumber.Encode(strm);
  if (HasOptionalField(e_parkedToPosition))
    m_parkedToPosition.Encode(strm);
  m_parkCondition.Encode(strm);
  if (HasOptionalField(e_extensionRes))
    m_extensionRes.Encode(strm);
}


PObject * H450_CpSetupRes::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CpSetupRes::Class()), PInvalidCast);
#endif
  return new H450_CpSetupRes(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CpSetupRes::preShowEthereal( void )
{
  m_parkedToNumber.preShowEthereal( );
  if ( HasOptionalField( e_parkedToPosition ) ) 
      m_parkedToPosition.preShowEthereal( );
  m_parkCondition.preShowEthereal( );
  if ( HasOptionalField( e_extensionRes ) ) 
      m_extensionRes.preShowEthereal( );
}

PString H450_CpSetupRes::getSummary( void ) 
{
  return PString( "CpSetupRes" );
}

void H450_CpSetupRes::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *parkedToNumber_tree = (proto_tree*) NULL;
  proto_item *parkedToNumber_ti = (proto_item*) NULL;
  parkedToNumber_ti = proto_tree_add_text( tree, tvb, offset + m_parkedToNumber.GetStartByte(), m_parkedToNumber.GetByteLength(), "parkedToNumber (EndpointAddress)" );
  parkedToNumber_tree = proto_item_add_subtree( parkedToNumber_ti, hCont->h450_1.ett_h450_CpSetupRes_parkedToNumber );

  m_parkedToNumber.showEthereal( parkedToNumber_tree, tvb, offset );

  if ( HasOptionalField( e_parkedToPosition ) ) {
    proto_tree_add_uint( tree, hCont->h450_1.hf_h450_CpSetupRes_parkedToPosition, tvb, offset + m_parkedToPosition.GetStartByte(), m_parkedToPosition.GetByteLength() , m_parkedToPosition.GetValue() );
  }

  proto_tree *parkCondition_tree = (proto_tree*) NULL;
  proto_item *parkCondition_ti = (proto_item*) NULL;
  parkCondition_ti = proto_tree_add_text( tree, tvb, offset + m_parkCondition.GetStartByte(), m_parkCondition.GetByteLength(), "parkCondition (ParkCondition)" );
  parkCondition_tree = proto_item_add_subtree( parkCondition_ti, hCont->h450_1.ett_h450_CpSetupRes_parkCondition );

  m_parkCondition.showEthereal( parkCondition_tree, tvb, offset );

  if ( HasOptionalField( e_extensionRes ) ) {
    proto_tree *extensionRes_tree = (proto_tree*) NULL;
    proto_item *extensionRes_ti = (proto_item*) NULL;
    extensionRes_ti = proto_tree_add_text( tree, tvb, offset + m_extensionRes.GetStartByte(), m_extensionRes.GetByteLength(), "extensionRes (MixedExtension)" );
    extensionRes_tree = proto_item_add_subtree( extensionRes_ti, hCont->h450_1.ett_h450_CpSetupRes_extensionRes );
    m_extensionRes.showEthereal( extensionRes_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// GroupIndicationOnArg
//

H450_GroupIndicationOnArg::H450_GroupIndicationOnArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_extensionArg.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_GroupIndicationOnArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "callPickupId = " << setprecision(indent) << m_callPickupId << '\n';
  strm << setw(indent+20) << "groupMemberUserNr = " << setprecision(indent) << m_groupMemberUserNr << '\n';
  strm << setw(indent+19) << "retrieveCallType = " << setprecision(indent) << m_retrieveCallType << '\n';
  strm << setw(indent+18) << "partyToRetrieve = " << setprecision(indent) << m_partyToRetrieve << '\n';
  strm << setw(indent+18) << "retrieveAddress = " << setprecision(indent) << m_retrieveAddress << '\n';
  if (HasOptionalField(e_parkPosition))
    strm << setw(indent+15) << "parkPosition = " << setprecision(indent) << m_parkPosition << '\n';
  if (HasOptionalField(e_extensionArg))
    strm << setw(indent+15) << "extensionArg = " << setprecision(indent) << m_extensionArg << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_GroupIndicationOnArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_GroupIndicationOnArg::Class()), PInvalidCast);
#endif
  const H450_GroupIndicationOnArg & other = (const H450_GroupIndicationOnArg &)obj;

  Comparison result;

  if ((result = m_callPickupId.Compare(other.m_callPickupId)) != EqualTo)
    return result;
  if ((result = m_groupMemberUserNr.Compare(other.m_groupMemberUserNr)) != EqualTo)
    return result;
  if ((result = m_retrieveCallType.Compare(other.m_retrieveCallType)) != EqualTo)
    return result;
  if ((result = m_partyToRetrieve.Compare(other.m_partyToRetrieve)) != EqualTo)
    return result;
  if ((result = m_retrieveAddress.Compare(other.m_retrieveAddress)) != EqualTo)
    return result;
  if ((result = m_parkPosition.Compare(other.m_parkPosition)) != EqualTo)
    return result;
  if ((result = m_extensionArg.Compare(other.m_extensionArg)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_GroupIndicationOnArg::GetDataLength() const
{
  PINDEX length = 0;
  length += m_callPickupId.GetObjectLength();
  length += m_groupMemberUserNr.GetObjectLength();
  length += m_retrieveCallType.GetObjectLength();
  length += m_partyToRetrieve.GetObjectLength();
  length += m_retrieveAddress.GetObjectLength();
  if (HasOptionalField(e_parkPosition))
    length += m_parkPosition.GetObjectLength();
  if (HasOptionalField(e_extensionArg))
    length += m_extensionArg.GetObjectLength();
  return length;
}


BOOL H450_GroupIndicationOnArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callPickupId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_groupMemberUserNr.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_retrieveCallType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_partyToRetrieve.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_retrieveAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_parkPosition ) && !m_parkPosition.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionArg ) && !m_extensionArg.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_GroupIndicationOnArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_callPickupId.Encode(strm);
  m_groupMemberUserNr.Encode(strm);
  m_retrieveCallType.Encode(strm);
  m_partyToRetrieve.Encode(strm);
  m_retrieveAddress.Encode(strm);
  if (HasOptionalField(e_parkPosition))
    m_parkPosition.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_callPickupId.Encode(strm);
  m_groupMemberUserNr.Encode(strm);
  m_retrieveCallType.Encode(strm);
  m_partyToRetrieve.Encode(strm);
  m_retrieveAddress.Encode(strm);
  if (HasOptionalField(e_parkPosition))
    m_parkPosition.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);
}


PObject * H450_GroupIndicationOnArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_GroupIndicationOnArg::Class()), PInvalidCast);
#endif
  return new H450_GroupIndicationOnArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_GroupIndicationOnArg::preShowEthereal( void )
{
  m_callPickupId.preShowEthereal( );
  m_groupMemberUserNr.preShowEthereal( );
  m_retrieveCallType.preShowEthereal( );
  m_partyToRetrieve.preShowEthereal( );
  m_retrieveAddress.preShowEthereal( );
  if ( HasOptionalField( e_parkPosition ) ) 
      m_parkPosition.preShowEthereal( );
  if ( HasOptionalField( e_extensionArg ) ) 
      m_extensionArg.preShowEthereal( );
}

PString H450_GroupIndicationOnArg::getSummary( void ) 
{
  return PString( "GroupIndicationOnArg" );
}

void H450_GroupIndicationOnArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  /* This member is defined outside the current ASN.1 file, 
   * therefore it's not known what type it is. The safest
   * solution is to add another subtree and let the class handle itself
   */
  proto_tree *callPickupId_tree = (proto_tree*) NULL;
  proto_item *callPickupId_ti = (proto_item*) NULL;
  callPickupId_ti = proto_tree_add_text( tree, tvb, offset + m_callPickupId.GetStartByte(), m_callPickupId.GetByteLength(), "callPickupId (H225-CallIdentifier)" );
  callPickupId_tree = proto_item_add_subtree( callPickupId_ti, hCont->h450_1.ett_h450_GroupIndicationOnArg_callPickupId );

  m_callPickupId.showEthereal( callPickupId_tree, tvb, offset );

  proto_tree *groupMemberUserNr_tree = (proto_tree*) NULL;
  proto_item *groupMemberUserNr_ti = (proto_item*) NULL;
  groupMemberUserNr_ti = proto_tree_add_text( tree, tvb, offset + m_groupMemberUserNr.GetStartByte(), m_groupMemberUserNr.GetByteLength(), "groupMemberUserNr (EndpointAddress)" );
  groupMemberUserNr_tree = proto_item_add_subtree( groupMemberUserNr_ti, hCont->h450_1.ett_h450_GroupIndicationOnArg_groupMemberUserNr );

  m_groupMemberUserNr.showEthereal( groupMemberUserNr_tree, tvb, offset );

  proto_tree *retrieveCallType_tree = (proto_tree*) NULL;
  proto_item *retrieveCallType_ti = (proto_item*) NULL;
  retrieveCallType_ti = proto_tree_add_text( tree, tvb, offset + m_retrieveCallType.GetStartByte(), m_retrieveCallType.GetByteLength(), "retrieveCallType (CallType)" );
  retrieveCallType_tree = proto_item_add_subtree( retrieveCallType_ti, hCont->h450_1.ett_h450_GroupIndicationOnArg_retrieveCallType );

  m_retrieveCallType.showEthereal( retrieveCallType_tree, tvb, offset );

  proto_tree *partyToRetrieve_tree = (proto_tree*) NULL;
  proto_item *partyToRetrieve_ti = (proto_item*) NULL;
  partyToRetrieve_ti = proto_tree_add_text( tree, tvb, offset + m_partyToRetrieve.GetStartByte(), m_partyToRetrieve.GetByteLength(), "partyToRetrieve (EndpointAddress)" );
  partyToRetrieve_tree = proto_item_add_subtree( partyToRetrieve_ti, hCont->h450_1.ett_h450_GroupIndicationOnArg_partyToRetrieve );

  m_partyToRetrieve.showEthereal( partyToRetrieve_tree, tvb, offset );

  proto_tree *retrieveAddress_tree = (proto_tree*) NULL;
  proto_item *retrieveAddress_ti = (proto_item*) NULL;
  retrieveAddress_ti = proto_tree_add_text( tree, tvb, offset + m_retrieveAddress.GetStartByte(), m_retrieveAddress.GetByteLength(), "retrieveAddress (EndpointAddress)" );
  retrieveAddress_tree = proto_item_add_subtree( retrieveAddress_ti, hCont->h450_1.ett_h450_GroupIndicationOnArg_retrieveAddress );

  m_retrieveAddress.showEthereal( retrieveAddress_tree, tvb, offset );

  if ( HasOptionalField( e_parkPosition ) ) {
    proto_tree_add_uint( tree, hCont->h450_1.hf_h450_GroupIndicationOnArg_parkPosition, tvb, offset + m_parkPosition.GetStartByte(), m_parkPosition.GetByteLength() , m_parkPosition.GetValue() );
  }

  if ( HasOptionalField( e_extensionArg ) ) {
    proto_tree *extensionArg_tree = (proto_tree*) NULL;
    proto_item *extensionArg_ti = (proto_item*) NULL;
    extensionArg_ti = proto_tree_add_text( tree, tvb, offset + m_extensionArg.GetStartByte(), m_extensionArg.GetByteLength(), "extensionArg (MixedExtension)" );
    extensionArg_tree = proto_item_add_subtree( extensionArg_ti, hCont->h450_1.ett_h450_GroupIndicationOnArg_extensionArg );
    m_extensionArg.showEthereal( extensionArg_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// GroupIndicationOnRes
//

H450_GroupIndicationOnRes::H450_GroupIndicationOnRes(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_extensionRes.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_GroupIndicationOnRes::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_extensionRes))
    strm << setw(indent+15) << "extensionRes = " << setprecision(indent) << m_extensionRes << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_GroupIndicationOnRes::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_GroupIndicationOnRes::Class()), PInvalidCast);
#endif
  const H450_GroupIndicationOnRes & other = (const H450_GroupIndicationOnRes &)obj;

  Comparison result;

  if ((result = m_extensionRes.Compare(other.m_extensionRes)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_GroupIndicationOnRes::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_extensionRes))
    length += m_extensionRes.GetObjectLength();
  return length;
}


BOOL H450_GroupIndicationOnRes::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionRes ) && !m_extensionRes.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_GroupIndicationOnRes::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_extensionRes))
    m_extensionRes.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_extensionRes))
    m_extensionRes.Encode(strm);
}


PObject * H450_GroupIndicationOnRes::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_GroupIndicationOnRes::Class()), PInvalidCast);
#endif
  return new H450_GroupIndicationOnRes(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_GroupIndicationOnRes::preShowEthereal( void )
{
  if ( HasOptionalField( e_extensionRes ) ) 
      m_extensionRes.preShowEthereal( );
}

PString H450_GroupIndicationOnRes::getSummary( void ) 
{
  return PString( "GroupIndicationOnRes" );
}

void H450_GroupIndicationOnRes::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_extensionRes ) ) {
    proto_tree *extensionRes_tree = (proto_tree*) NULL;
    proto_item *extensionRes_ti = (proto_item*) NULL;
    extensionRes_ti = proto_tree_add_text( tree, tvb, offset + m_extensionRes.GetStartByte(), m_extensionRes.GetByteLength(), "extensionRes (MixedExtension)" );
    extensionRes_tree = proto_item_add_subtree( extensionRes_ti, hCont->h450_1.ett_h450_GroupIndicationOnRes_extensionRes );
    m_extensionRes.showEthereal( extensionRes_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// GroupIndicationOffArg
//

H450_GroupIndicationOffArg::H450_GroupIndicationOffArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_extensionArg.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_GroupIndicationOffArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "callPickupId = " << setprecision(indent) << m_callPickupId << '\n';
  strm << setw(indent+20) << "groupMemberUserNr = " << setprecision(indent) << m_groupMemberUserNr << '\n';
  if (HasOptionalField(e_extensionArg))
    strm << setw(indent+15) << "extensionArg = " << setprecision(indent) << m_extensionArg << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_GroupIndicationOffArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_GroupIndicationOffArg::Class()), PInvalidCast);
#endif
  const H450_GroupIndicationOffArg & other = (const H450_GroupIndicationOffArg &)obj;

  Comparison result;

  if ((result = m_callPickupId.Compare(other.m_callPickupId)) != EqualTo)
    return result;
  if ((result = m_groupMemberUserNr.Compare(other.m_groupMemberUserNr)) != EqualTo)
    return result;
  if ((result = m_extensionArg.Compare(other.m_extensionArg)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_GroupIndicationOffArg::GetDataLength() const
{
  PINDEX length = 0;
  length += m_callPickupId.GetObjectLength();
  length += m_groupMemberUserNr.GetObjectLength();
  if (HasOptionalField(e_extensionArg))
    length += m_extensionArg.GetObjectLength();
  return length;
}


BOOL H450_GroupIndicationOffArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callPickupId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_groupMemberUserNr.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionArg ) && !m_extensionArg.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_GroupIndicationOffArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_callPickupId.Encode(strm);
  m_groupMemberUserNr.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_callPickupId.Encode(strm);
  m_groupMemberUserNr.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);
}


PObject * H450_GroupIndicationOffArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_GroupIndicationOffArg::Class()), PInvalidCast);
#endif
  return new H450_GroupIndicationOffArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_GroupIndicationOffArg::preShowEthereal( void )
{
  m_callPickupId.preShowEthereal( );
  m_groupMemberUserNr.preShowEthereal( );
  if ( HasOptionalField( e_extensionArg ) ) 
      m_extensionArg.preShowEthereal( );
}

PString H450_GroupIndicationOffArg::getSummary( void ) 
{
  return PString( "GroupIndicationOffArg" );
}

void H450_GroupIndicationOffArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  /* This member is defined outside the current ASN.1 file, 
   * therefore it's not known what type it is. The safest
   * solution is to add another subtree and let the class handle itself
   */
  proto_tree *callPickupId_tree = (proto_tree*) NULL;
  proto_item *callPickupId_ti = (proto_item*) NULL;
  callPickupId_ti = proto_tree_add_text( tree, tvb, offset + m_callPickupId.GetStartByte(), m_callPickupId.GetByteLength(), "callPickupId (H225-CallIdentifier)" );
  callPickupId_tree = proto_item_add_subtree( callPickupId_ti, hCont->h450_1.ett_h450_GroupIndicationOffArg_callPickupId );

  m_callPickupId.showEthereal( callPickupId_tree, tvb, offset );

  proto_tree *groupMemberUserNr_tree = (proto_tree*) NULL;
  proto_item *groupMemberUserNr_ti = (proto_item*) NULL;
  groupMemberUserNr_ti = proto_tree_add_text( tree, tvb, offset + m_groupMemberUserNr.GetStartByte(), m_groupMemberUserNr.GetByteLength(), "groupMemberUserNr (EndpointAddress)" );
  groupMemberUserNr_tree = proto_item_add_subtree( groupMemberUserNr_ti, hCont->h450_1.ett_h450_GroupIndicationOffArg_groupMemberUserNr );

  m_groupMemberUserNr.showEthereal( groupMemberUserNr_tree, tvb, offset );

  if ( HasOptionalField( e_extensionArg ) ) {
    proto_tree *extensionArg_tree = (proto_tree*) NULL;
    proto_item *extensionArg_ti = (proto_item*) NULL;
    extensionArg_ti = proto_tree_add_text( tree, tvb, offset + m_extensionArg.GetStartByte(), m_extensionArg.GetByteLength(), "extensionArg (MixedExtension)" );
    extensionArg_tree = proto_item_add_subtree( extensionArg_ti, hCont->h450_1.ett_h450_GroupIndicationOffArg_extensionArg );
    m_extensionArg.showEthereal( extensionArg_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// GroupIndicationOffRes
//

H450_GroupIndicationOffRes::H450_GroupIndicationOffRes(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_extensionRes.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_GroupIndicationOffRes::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_extensionRes))
    strm << setw(indent+15) << "extensionRes = " << setprecision(indent) << m_extensionRes << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_GroupIndicationOffRes::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_GroupIndicationOffRes::Class()), PInvalidCast);
#endif
  const H450_GroupIndicationOffRes & other = (const H450_GroupIndicationOffRes &)obj;

  Comparison result;

  if ((result = m_extensionRes.Compare(other.m_extensionRes)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_GroupIndicationOffRes::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_extensionRes))
    length += m_extensionRes.GetObjectLength();
  return length;
}


BOOL H450_GroupIndicationOffRes::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionRes ) && !m_extensionRes.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_GroupIndicationOffRes::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_extensionRes))
    m_extensionRes.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_extensionRes))
    m_extensionRes.Encode(strm);
}


PObject * H450_GroupIndicationOffRes::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_GroupIndicationOffRes::Class()), PInvalidCast);
#endif
  return new H450_GroupIndicationOffRes(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_GroupIndicationOffRes::preShowEthereal( void )
{
  if ( HasOptionalField( e_extensionRes ) ) 
      m_extensionRes.preShowEthereal( );
}

PString H450_GroupIndicationOffRes::getSummary( void ) 
{
  return PString( "GroupIndicationOffRes" );
}

void H450_GroupIndicationOffRes::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_extensionRes ) ) {
    proto_tree *extensionRes_tree = (proto_tree*) NULL;
    proto_item *extensionRes_ti = (proto_item*) NULL;
    extensionRes_ti = proto_tree_add_text( tree, tvb, offset + m_extensionRes.GetStartByte(), m_extensionRes.GetByteLength(), "extensionRes (MixedExtension)" );
    extensionRes_tree = proto_item_add_subtree( extensionRes_ti, hCont->h450_1.ett_h450_GroupIndicationOffRes_extensionRes );
    m_extensionRes.showEthereal( extensionRes_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// PickrequArg
//

H450_PickrequArg::H450_PickrequArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 4, TRUE, 0)
{
  m_extensionArg.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_PickrequArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+19) << "picking_upNumber = " << setprecision(indent) << m_picking_upNumber << '\n';
  if (HasOptionalField(e_callPickupId))
    strm << setw(indent+15) << "callPickupId = " << setprecision(indent) << m_callPickupId << '\n';
  if (HasOptionalField(e_partyToRetrieve))
    strm << setw(indent+18) << "partyToRetrieve = " << setprecision(indent) << m_partyToRetrieve << '\n';
  strm << setw(indent+18) << "retrieveAddress = " << setprecision(indent) << m_retrieveAddress << '\n';
  if (HasOptionalField(e_parkPosition))
    strm << setw(indent+15) << "parkPosition = " << setprecision(indent) << m_parkPosition << '\n';
  if (HasOptionalField(e_extensionArg))
    strm << setw(indent+15) << "extensionArg = " << setprecision(indent) << m_extensionArg << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_PickrequArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_PickrequArg::Class()), PInvalidCast);
#endif
  const H450_PickrequArg & other = (const H450_PickrequArg &)obj;

  Comparison result;

  if ((result = m_picking_upNumber.Compare(other.m_picking_upNumber)) != EqualTo)
    return result;
  if ((result = m_callPickupId.Compare(other.m_callPickupId)) != EqualTo)
    return result;
  if ((result = m_partyToRetrieve.Compare(other.m_partyToRetrieve)) != EqualTo)
    return result;
  if ((result = m_retrieveAddress.Compare(other.m_retrieveAddress)) != EqualTo)
    return result;
  if ((result = m_parkPosition.Compare(other.m_parkPosition)) != EqualTo)
    return result;
  if ((result = m_extensionArg.Compare(other.m_extensionArg)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_PickrequArg::GetDataLength() const
{
  PINDEX length = 0;
  length += m_picking_upNumber.GetObjectLength();
  if (HasOptionalField(e_callPickupId))
    length += m_callPickupId.GetObjectLength();
  if (HasOptionalField(e_partyToRetrieve))
    length += m_partyToRetrieve.GetObjectLength();
  length += m_retrieveAddress.GetObjectLength();
  if (HasOptionalField(e_parkPosition))
    length += m_parkPosition.GetObjectLength();
  if (HasOptionalField(e_extensionArg))
    length += m_extensionArg.GetObjectLength();
  return length;
}


BOOL H450_PickrequArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_picking_upNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_callPickupId ) && !m_callPickupId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_partyToRetrieve ) && !m_partyToRetrieve.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_retrieveAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_parkPosition ) && !m_parkPosition.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionArg ) && !m_extensionArg.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_PickrequArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_picking_upNumber.Encode(strm);
  if (HasOptionalField(e_callPickupId))
    m_callPickupId.Encode(strm);
  if (HasOptionalField(e_partyToRetrieve))
    m_partyToRetrieve.Encode(strm);
  m_retrieveAddress.Encode(strm);
  if (HasOptionalField(e_parkPosition))
    m_parkPosition.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_picking_upNumber.Encode(strm);
  if (HasOptionalField(e_callPickupId))
    m_callPickupId.Encode(strm);
  if (HasOptionalField(e_partyToRetrieve))
    m_partyToRetrieve.Encode(strm);
  m_retrieveAddress.Encode(strm);
  if (HasOptionalField(e_parkPosition))
    m_parkPosition.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);
}


PObject * H450_PickrequArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_PickrequArg::Class()), PInvalidCast);
#endif
  return new H450_PickrequArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_PickrequArg::preShowEthereal( void )
{
  m_picking_upNumber.preShowEthereal( );
  if ( HasOptionalField( e_callPickupId ) ) 
      m_callPickupId.preShowEthereal( );
  if ( HasOptionalField( e_partyToRetrieve ) ) 
      m_partyToRetrieve.preShowEthereal( );
  m_retrieveAddress.preShowEthereal( );
  if ( HasOptionalField( e_parkPosition ) ) 
      m_parkPosition.preShowEthereal( );
  if ( HasOptionalField( e_extensionArg ) ) 
      m_extensionArg.preShowEthereal( );
}

PString H450_PickrequArg::getSummary( void ) 
{
  return PString( "PickrequArg" );
}

void H450_PickrequArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *picking_upNumber_tree = (proto_tree*) NULL;
  proto_item *picking_upNumber_ti = (proto_item*) NULL;
  picking_upNumber_ti = proto_tree_add_text( tree, tvb, offset + m_picking_upNumber.GetStartByte(), m_picking_upNumber.GetByteLength(), "picking_upNumber (EndpointAddress)" );
  picking_upNumber_tree = proto_item_add_subtree( picking_upNumber_ti, hCont->h450_1.ett_h450_PickrequArg_picking_upNumber );

  m_picking_upNumber.showEthereal( picking_upNumber_tree, tvb, offset );

  /* This member is defined outside the current ASN.1 file, 
   * therefore it's not known what type it is. The safest
   * solution is to add another subtree and let the class handle itself
   */
  if ( HasOptionalField( e_callPickupId ) ) {
    proto_tree *callPickupId_tree = (proto_tree*) NULL;
    proto_item *callPickupId_ti = (proto_item*) NULL;
    callPickupId_ti = proto_tree_add_text( tree, tvb, offset + m_callPickupId.GetStartByte(), m_callPickupId.GetByteLength(), "callPickupId (H225-CallIdentifier)" );
    callPickupId_tree = proto_item_add_subtree( callPickupId_ti, hCont->h450_1.ett_h450_PickrequArg_callPickupId );
    m_callPickupId.showEthereal( callPickupId_tree, tvb, offset );
  }

  if ( HasOptionalField( e_partyToRetrieve ) ) {
    proto_tree *partyToRetrieve_tree = (proto_tree*) NULL;
    proto_item *partyToRetrieve_ti = (proto_item*) NULL;
    partyToRetrieve_ti = proto_tree_add_text( tree, tvb, offset + m_partyToRetrieve.GetStartByte(), m_partyToRetrieve.GetByteLength(), "partyToRetrieve (EndpointAddress)" );
    partyToRetrieve_tree = proto_item_add_subtree( partyToRetrieve_ti, hCont->h450_1.ett_h450_PickrequArg_partyToRetrieve );
    m_partyToRetrieve.showEthereal( partyToRetrieve_tree, tvb, offset );
  }

  proto_tree *retrieveAddress_tree = (proto_tree*) NULL;
  proto_item *retrieveAddress_ti = (proto_item*) NULL;
  retrieveAddress_ti = proto_tree_add_text( tree, tvb, offset + m_retrieveAddress.GetStartByte(), m_retrieveAddress.GetByteLength(), "retrieveAddress (EndpointAddress)" );
  retrieveAddress_tree = proto_item_add_subtree( retrieveAddress_ti, hCont->h450_1.ett_h450_PickrequArg_retrieveAddress );

  m_retrieveAddress.showEthereal( retrieveAddress_tree, tvb, offset );

  if ( HasOptionalField( e_parkPosition ) ) {
    proto_tree_add_uint( tree, hCont->h450_1.hf_h450_PickrequArg_parkPosition, tvb, offset + m_parkPosition.GetStartByte(), m_parkPosition.GetByteLength() , m_parkPosition.GetValue() );
  }

  if ( HasOptionalField( e_extensionArg ) ) {
    proto_tree *extensionArg_tree = (proto_tree*) NULL;
    proto_item *extensionArg_ti = (proto_item*) NULL;
    extensionArg_ti = proto_tree_add_text( tree, tvb, offset + m_extensionArg.GetStartByte(), m_extensionArg.GetByteLength(), "extensionArg (MixedExtension)" );
    extensionArg_tree = proto_item_add_subtree( extensionArg_ti, hCont->h450_1.ett_h450_PickrequArg_extensionArg );
    m_extensionArg.showEthereal( extensionArg_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// PickrequRes
//

H450_PickrequRes::H450_PickrequRes(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_extensionRes.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_PickrequRes::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "callPickupId = " << setprecision(indent) << m_callPickupId << '\n';
  if (HasOptionalField(e_extensionRes))
    strm << setw(indent+15) << "extensionRes = " << setprecision(indent) << m_extensionRes << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_PickrequRes::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_PickrequRes::Class()), PInvalidCast);
#endif
  const H450_PickrequRes & other = (const H450_PickrequRes &)obj;

  Comparison result;

  if ((result = m_callPickupId.Compare(other.m_callPickupId)) != EqualTo)
    return result;
  if ((result = m_extensionRes.Compare(other.m_extensionRes)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_PickrequRes::GetDataLength() const
{
  PINDEX length = 0;
  length += m_callPickupId.GetObjectLength();
  if (HasOptionalField(e_extensionRes))
    length += m_extensionRes.GetObjectLength();
  return length;
}


BOOL H450_PickrequRes::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callPickupId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionRes ) && !m_extensionRes.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_PickrequRes::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_callPickupId.Encode(strm);
  if (HasOptionalField(e_extensionRes))
    m_extensionRes.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_callPickupId.Encode(strm);
  if (HasOptionalField(e_extensionRes))
    m_extensionRes.Encode(strm);
}


PObject * H450_PickrequRes::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_PickrequRes::Class()), PInvalidCast);
#endif
  return new H450_PickrequRes(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_PickrequRes::preShowEthereal( void )
{
  m_callPickupId.preShowEthereal( );
  if ( HasOptionalField( e_extensionRes ) ) 
      m_extensionRes.preShowEthereal( );
}

PString H450_PickrequRes::getSummary( void ) 
{
  return PString( "PickrequRes" );
}

void H450_PickrequRes::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  /* This member is defined outside the current ASN.1 file, 
   * therefore it's not known what type it is. The safest
   * solution is to add another subtree and let the class handle itself
   */
  proto_tree *callPickupId_tree = (proto_tree*) NULL;
  proto_item *callPickupId_ti = (proto_item*) NULL;
  callPickupId_ti = proto_tree_add_text( tree, tvb, offset + m_callPickupId.GetStartByte(), m_callPickupId.GetByteLength(), "callPickupId (H225-CallIdentifier)" );
  callPickupId_tree = proto_item_add_subtree( callPickupId_ti, hCont->h450_1.ett_h450_PickrequRes_callPickupId );

  m_callPickupId.showEthereal( callPickupId_tree, tvb, offset );

  if ( HasOptionalField( e_extensionRes ) ) {
    proto_tree *extensionRes_tree = (proto_tree*) NULL;
    proto_item *extensionRes_ti = (proto_item*) NULL;
    extensionRes_ti = proto_tree_add_text( tree, tvb, offset + m_extensionRes.GetStartByte(), m_extensionRes.GetByteLength(), "extensionRes (MixedExtension)" );
    extensionRes_tree = proto_item_add_subtree( extensionRes_ti, hCont->h450_1.ett_h450_PickrequRes_extensionRes );
    m_extensionRes.showEthereal( extensionRes_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// PickupArg
//

H450_PickupArg::H450_PickupArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_extensionArg.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_PickupArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "callPickupId = " << setprecision(indent) << m_callPickupId << '\n';
  strm << setw(indent+19) << "picking_upNumber = " << setprecision(indent) << m_picking_upNumber << '\n';
  if (HasOptionalField(e_extensionArg))
    strm << setw(indent+15) << "extensionArg = " << setprecision(indent) << m_extensionArg << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_PickupArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_PickupArg::Class()), PInvalidCast);
#endif
  const H450_PickupArg & other = (const H450_PickupArg &)obj;

  Comparison result;

  if ((result = m_callPickupId.Compare(other.m_callPickupId)) != EqualTo)
    return result;
  if ((result = m_picking_upNumber.Compare(other.m_picking_upNumber)) != EqualTo)
    return result;
  if ((result = m_extensionArg.Compare(other.m_extensionArg)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_PickupArg::GetDataLength() const
{
  PINDEX length = 0;
  length += m_callPickupId.GetObjectLength();
  length += m_picking_upNumber.GetObjectLength();
  if (HasOptionalField(e_extensionArg))
    length += m_extensionArg.GetObjectLength();
  return length;
}


BOOL H450_PickupArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callPickupId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_picking_upNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionArg ) && !m_extensionArg.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_PickupArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_callPickupId.Encode(strm);
  m_picking_upNumber.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_callPickupId.Encode(strm);
  m_picking_upNumber.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);
}


PObject * H450_PickupArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_PickupArg::Class()), PInvalidCast);
#endif
  return new H450_PickupArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_PickupArg::preShowEthereal( void )
{
  m_callPickupId.preShowEthereal( );
  m_picking_upNumber.preShowEthereal( );
  if ( HasOptionalField( e_extensionArg ) ) 
      m_extensionArg.preShowEthereal( );
}

PString H450_PickupArg::getSummary( void ) 
{
  return PString( "PickupArg" );
}

void H450_PickupArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  /* This member is defined outside the current ASN.1 file, 
   * therefore it's not known what type it is. The safest
   * solution is to add another subtree and let the class handle itself
   */
  proto_tree *callPickupId_tree = (proto_tree*) NULL;
  proto_item *callPickupId_ti = (proto_item*) NULL;
  callPickupId_ti = proto_tree_add_text( tree, tvb, offset + m_callPickupId.GetStartByte(), m_callPickupId.GetByteLength(), "callPickupId (H225-CallIdentifier)" );
  callPickupId_tree = proto_item_add_subtree( callPickupId_ti, hCont->h450_1.ett_h450_PickupArg_callPickupId );

  m_callPickupId.showEthereal( callPickupId_tree, tvb, offset );

  proto_tree *picking_upNumber_tree = (proto_tree*) NULL;
  proto_item *picking_upNumber_ti = (proto_item*) NULL;
  picking_upNumber_ti = proto_tree_add_text( tree, tvb, offset + m_picking_upNumber.GetStartByte(), m_picking_upNumber.GetByteLength(), "picking_upNumber (EndpointAddress)" );
  picking_upNumber_tree = proto_item_add_subtree( picking_upNumber_ti, hCont->h450_1.ett_h450_PickupArg_picking_upNumber );

  m_picking_upNumber.showEthereal( picking_upNumber_tree, tvb, offset );

  if ( HasOptionalField( e_extensionArg ) ) {
    proto_tree *extensionArg_tree = (proto_tree*) NULL;
    proto_item *extensionArg_ti = (proto_item*) NULL;
    extensionArg_ti = proto_tree_add_text( tree, tvb, offset + m_extensionArg.GetStartByte(), m_extensionArg.GetByteLength(), "extensionArg (MixedExtension)" );
    extensionArg_tree = proto_item_add_subtree( extensionArg_ti, hCont->h450_1.ett_h450_PickupArg_extensionArg );
    m_extensionArg.showEthereal( extensionArg_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// PickupRes
//

H450_PickupRes::H450_PickupRes(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_extensionRes.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_PickupRes::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_extensionRes))
    strm << setw(indent+15) << "extensionRes = " << setprecision(indent) << m_extensionRes << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_PickupRes::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_PickupRes::Class()), PInvalidCast);
#endif
  const H450_PickupRes & other = (const H450_PickupRes &)obj;

  Comparison result;

  if ((result = m_extensionRes.Compare(other.m_extensionRes)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_PickupRes::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_extensionRes))
    length += m_extensionRes.GetObjectLength();
  return length;
}


BOOL H450_PickupRes::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionRes ) && !m_extensionRes.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_PickupRes::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_extensionRes))
    m_extensionRes.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_extensionRes))
    m_extensionRes.Encode(strm);
}


PObject * H450_PickupRes::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_PickupRes::Class()), PInvalidCast);
#endif
  return new H450_PickupRes(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_PickupRes::preShowEthereal( void )
{
  if ( HasOptionalField( e_extensionRes ) ) 
      m_extensionRes.preShowEthereal( );
}

PString H450_PickupRes::getSummary( void ) 
{
  return PString( "PickupRes" );
}

void H450_PickupRes::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_extensionRes ) ) {
    proto_tree *extensionRes_tree = (proto_tree*) NULL;
    proto_item *extensionRes_ti = (proto_item*) NULL;
    extensionRes_ti = proto_tree_add_text( tree, tvb, offset + m_extensionRes.GetStartByte(), m_extensionRes.GetByteLength(), "extensionRes (MixedExtension)" );
    extensionRes_tree = proto_item_add_subtree( extensionRes_ti, hCont->h450_1.ett_h450_PickupRes_extensionRes );
    m_extensionRes.showEthereal( extensionRes_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// PickExeArg
//

H450_PickExeArg::H450_PickExeArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_extensionArg.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_PickExeArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "callPickupId = " << setprecision(indent) << m_callPickupId << '\n';
  strm << setw(indent+19) << "picking_upNumber = " << setprecision(indent) << m_picking_upNumber << '\n';
  strm << setw(indent+18) << "partyToRetrieve = " << setprecision(indent) << m_partyToRetrieve << '\n';
  if (HasOptionalField(e_extensionArg))
    strm << setw(indent+15) << "extensionArg = " << setprecision(indent) << m_extensionArg << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_PickExeArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_PickExeArg::Class()), PInvalidCast);
#endif
  const H450_PickExeArg & other = (const H450_PickExeArg &)obj;

  Comparison result;

  if ((result = m_callPickupId.Compare(other.m_callPickupId)) != EqualTo)
    return result;
  if ((result = m_picking_upNumber.Compare(other.m_picking_upNumber)) != EqualTo)
    return result;
  if ((result = m_partyToRetrieve.Compare(other.m_partyToRetrieve)) != EqualTo)
    return result;
  if ((result = m_extensionArg.Compare(other.m_extensionArg)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_PickExeArg::GetDataLength() const
{
  PINDEX length = 0;
  length += m_callPickupId.GetObjectLength();
  length += m_picking_upNumber.GetObjectLength();
  length += m_partyToRetrieve.GetObjectLength();
  if (HasOptionalField(e_extensionArg))
    length += m_extensionArg.GetObjectLength();
  return length;
}


BOOL H450_PickExeArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callPickupId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_picking_upNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_partyToRetrieve.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionArg ) && !m_extensionArg.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_PickExeArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_callPickupId.Encode(strm);
  m_picking_upNumber.Encode(strm);
  m_partyToRetrieve.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_callPickupId.Encode(strm);
  m_picking_upNumber.Encode(strm);
  m_partyToRetrieve.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);
}


PObject * H450_PickExeArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_PickExeArg::Class()), PInvalidCast);
#endif
  return new H450_PickExeArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_PickExeArg::preShowEthereal( void )
{
  m_callPickupId.preShowEthereal( );
  m_picking_upNumber.preShowEthereal( );
  m_partyToRetrieve.preShowEthereal( );
  if ( HasOptionalField( e_extensionArg ) ) 
      m_extensionArg.preShowEthereal( );
}

PString H450_PickExeArg::getSummary( void ) 
{
  return PString( "PickExeArg" );
}

void H450_PickExeArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  /* This member is defined outside the current ASN.1 file, 
   * therefore it's not known what type it is. The safest
   * solution is to add another subtree and let the class handle itself
   */
  proto_tree *callPickupId_tree = (proto_tree*) NULL;
  proto_item *callPickupId_ti = (proto_item*) NULL;
  callPickupId_ti = proto_tree_add_text( tree, tvb, offset + m_callPickupId.GetStartByte(), m_callPickupId.GetByteLength(), "callPickupId (H225-CallIdentifier)" );
  callPickupId_tree = proto_item_add_subtree( callPickupId_ti, hCont->h450_1.ett_h450_PickExeArg_callPickupId );

  m_callPickupId.showEthereal( callPickupId_tree, tvb, offset );

  proto_tree *picking_upNumber_tree = (proto_tree*) NULL;
  proto_item *picking_upNumber_ti = (proto_item*) NULL;
  picking_upNumber_ti = proto_tree_add_text( tree, tvb, offset + m_picking_upNumber.GetStartByte(), m_picking_upNumber.GetByteLength(), "picking_upNumber (EndpointAddress)" );
  picking_upNumber_tree = proto_item_add_subtree( picking_upNumber_ti, hCont->h450_1.ett_h450_PickExeArg_picking_upNumber );

  m_picking_upNumber.showEthereal( picking_upNumber_tree, tvb, offset );

  proto_tree *partyToRetrieve_tree = (proto_tree*) NULL;
  proto_item *partyToRetrieve_ti = (proto_item*) NULL;
  partyToRetrieve_ti = proto_tree_add_text( tree, tvb, offset + m_partyToRetrieve.GetStartByte(), m_partyToRetrieve.GetByteLength(), "partyToRetrieve (EndpointAddress)" );
  partyToRetrieve_tree = proto_item_add_subtree( partyToRetrieve_ti, hCont->h450_1.ett_h450_PickExeArg_partyToRetrieve );

  m_partyToRetrieve.showEthereal( partyToRetrieve_tree, tvb, offset );

  if ( HasOptionalField( e_extensionArg ) ) {
    proto_tree *extensionArg_tree = (proto_tree*) NULL;
    proto_item *extensionArg_ti = (proto_item*) NULL;
    extensionArg_ti = proto_tree_add_text( tree, tvb, offset + m_extensionArg.GetStartByte(), m_extensionArg.GetByteLength(), "extensionArg (MixedExtension)" );
    extensionArg_tree = proto_item_add_subtree( extensionArg_ti, hCont->h450_1.ett_h450_PickExeArg_extensionArg );
    m_extensionArg.showEthereal( extensionArg_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// PickExeRes
//

H450_PickExeRes::H450_PickExeRes(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_extensionRes.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_PickExeRes::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_extensionRes))
    strm << setw(indent+15) << "extensionRes = " << setprecision(indent) << m_extensionRes << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_PickExeRes::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_PickExeRes::Class()), PInvalidCast);
#endif
  const H450_PickExeRes & other = (const H450_PickExeRes &)obj;

  Comparison result;

  if ((result = m_extensionRes.Compare(other.m_extensionRes)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_PickExeRes::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_extensionRes))
    length += m_extensionRes.GetObjectLength();
  return length;
}


BOOL H450_PickExeRes::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionRes ) && !m_extensionRes.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_PickExeRes::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_extensionRes))
    m_extensionRes.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_extensionRes))
    m_extensionRes.Encode(strm);
}


PObject * H450_PickExeRes::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_PickExeRes::Class()), PInvalidCast);
#endif
  return new H450_PickExeRes(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_PickExeRes::preShowEthereal( void )
{
  if ( HasOptionalField( e_extensionRes ) ) 
      m_extensionRes.preShowEthereal( );
}

PString H450_PickExeRes::getSummary( void ) 
{
  return PString( "PickExeRes" );
}

void H450_PickExeRes::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_extensionRes ) ) {
    proto_tree *extensionRes_tree = (proto_tree*) NULL;
    proto_item *extensionRes_ti = (proto_item*) NULL;
    extensionRes_ti = proto_tree_add_text( tree, tvb, offset + m_extensionRes.GetStartByte(), m_extensionRes.GetByteLength(), "extensionRes (MixedExtension)" );
    extensionRes_tree = proto_item_add_subtree( extensionRes_ti, hCont->h450_1.ett_h450_PickExeRes_extensionRes );
    m_extensionRes.showEthereal( extensionRes_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CpNotifyArg
//

H450_CpNotifyArg::H450_CpNotifyArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_extensionArg.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CpNotifyArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_parkingNumber))
    strm << setw(indent+16) << "parkingNumber = " << setprecision(indent) << m_parkingNumber << '\n';
  if (HasOptionalField(e_extensionArg))
    strm << setw(indent+15) << "extensionArg = " << setprecision(indent) << m_extensionArg << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CpNotifyArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CpNotifyArg::Class()), PInvalidCast);
#endif
  const H450_CpNotifyArg & other = (const H450_CpNotifyArg &)obj;

  Comparison result;

  if ((result = m_parkingNumber.Compare(other.m_parkingNumber)) != EqualTo)
    return result;
  if ((result = m_extensionArg.Compare(other.m_extensionArg)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CpNotifyArg::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_parkingNumber))
    length += m_parkingNumber.GetObjectLength();
  if (HasOptionalField(e_extensionArg))
    length += m_extensionArg.GetObjectLength();
  return length;
}


BOOL H450_CpNotifyArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_parkingNumber ) && !m_parkingNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionArg ) && !m_extensionArg.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CpNotifyArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_parkingNumber))
    m_parkingNumber.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_parkingNumber))
    m_parkingNumber.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);
}


PObject * H450_CpNotifyArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CpNotifyArg::Class()), PInvalidCast);
#endif
  return new H450_CpNotifyArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CpNotifyArg::preShowEthereal( void )
{
  if ( HasOptionalField( e_parkingNumber ) ) 
      m_parkingNumber.preShowEthereal( );
  if ( HasOptionalField( e_extensionArg ) ) 
      m_extensionArg.preShowEthereal( );
}

PString H450_CpNotifyArg::getSummary( void ) 
{
  return PString( "CpNotifyArg" );
}

void H450_CpNotifyArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_parkingNumber ) ) {
    proto_tree *parkingNumber_tree = (proto_tree*) NULL;
    proto_item *parkingNumber_ti = (proto_item*) NULL;
    parkingNumber_ti = proto_tree_add_text( tree, tvb, offset + m_parkingNumber.GetStartByte(), m_parkingNumber.GetByteLength(), "parkingNumber (EndpointAddress)" );
    parkingNumber_tree = proto_item_add_subtree( parkingNumber_ti, hCont->h450_1.ett_h450_CpNotifyArg_parkingNumber );
    m_parkingNumber.showEthereal( parkingNumber_tree, tvb, offset );
  }

  if ( HasOptionalField( e_extensionArg ) ) {
    proto_tree *extensionArg_tree = (proto_tree*) NULL;
    proto_item *extensionArg_ti = (proto_item*) NULL;
    extensionArg_ti = proto_tree_add_text( tree, tvb, offset + m_extensionArg.GetStartByte(), m_extensionArg.GetByteLength(), "extensionArg (MixedExtension)" );
    extensionArg_tree = proto_item_add_subtree( extensionArg_ti, hCont->h450_1.ett_h450_CpNotifyArg_extensionArg );
    m_extensionArg.showEthereal( extensionArg_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CpickupNotifyArg
//

H450_CpickupNotifyArg::H450_CpickupNotifyArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_extensionArg.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CpickupNotifyArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_picking_upNumber))
    strm << setw(indent+19) << "picking_upNumber = " << setprecision(indent) << m_picking_upNumber << '\n';
  if (HasOptionalField(e_extensionArg))
    strm << setw(indent+15) << "extensionArg = " << setprecision(indent) << m_extensionArg << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CpickupNotifyArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CpickupNotifyArg::Class()), PInvalidCast);
#endif
  const H450_CpickupNotifyArg & other = (const H450_CpickupNotifyArg &)obj;

  Comparison result;

  if ((result = m_picking_upNumber.Compare(other.m_picking_upNumber)) != EqualTo)
    return result;
  if ((result = m_extensionArg.Compare(other.m_extensionArg)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CpickupNotifyArg::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_picking_upNumber))
    length += m_picking_upNumber.GetObjectLength();
  if (HasOptionalField(e_extensionArg))
    length += m_extensionArg.GetObjectLength();
  return length;
}


BOOL H450_CpickupNotifyArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_picking_upNumber ) && !m_picking_upNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionArg ) && !m_extensionArg.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CpickupNotifyArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_picking_upNumber))
    m_picking_upNumber.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_picking_upNumber))
    m_picking_upNumber.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);
}


PObject * H450_CpickupNotifyArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CpickupNotifyArg::Class()), PInvalidCast);
#endif
  return new H450_CpickupNotifyArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CpickupNotifyArg::preShowEthereal( void )
{
  if ( HasOptionalField( e_picking_upNumber ) ) 
      m_picking_upNumber.preShowEthereal( );
  if ( HasOptionalField( e_extensionArg ) ) 
      m_extensionArg.preShowEthereal( );
}

PString H450_CpickupNotifyArg::getSummary( void ) 
{
  return PString( "CpickupNotifyArg" );
}

void H450_CpickupNotifyArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_picking_upNumber ) ) {
    proto_tree *picking_upNumber_tree = (proto_tree*) NULL;
    proto_item *picking_upNumber_ti = (proto_item*) NULL;
    picking_upNumber_ti = proto_tree_add_text( tree, tvb, offset + m_picking_upNumber.GetStartByte(), m_picking_upNumber.GetByteLength(), "picking_upNumber (EndpointAddress)" );
    picking_upNumber_tree = proto_item_add_subtree( picking_upNumber_ti, hCont->h450_1.ett_h450_CpickupNotifyArg_picking_upNumber );
    m_picking_upNumber.showEthereal( picking_upNumber_tree, tvb, offset );
  }

  if ( HasOptionalField( e_extensionArg ) ) {
    proto_tree *extensionArg_tree = (proto_tree*) NULL;
    proto_item *extensionArg_ti = (proto_item*) NULL;
    extensionArg_ti = proto_tree_add_text( tree, tvb, offset + m_extensionArg.GetStartByte(), m_extensionArg.GetByteLength(), "extensionArg (MixedExtension)" );
    extensionArg_tree = proto_item_add_subtree( extensionArg_ti, hCont->h450_1.ett_h450_CpickupNotifyArg_extensionArg );
    m_extensionArg.showEthereal( extensionArg_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// IntResult
//

H450_IntResult::H450_IntResult(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H450_IntResult::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "servedUserNr = " << setprecision(indent) << m_servedUserNr << '\n';
  strm << setw(indent+15) << "basicService = " << setprecision(indent) << m_basicService << '\n';
  strm << setw(indent+12) << "procedure = " << setprecision(indent) << m_procedure << '\n';
  strm << setw(indent+20) << "divertedToAddress = " << setprecision(indent) << m_divertedToAddress << '\n';
  strm << setw(indent+16) << "remoteEnabled = " << setprecision(indent) << m_remoteEnabled << '\n';
  if (HasOptionalField(e_extension))
    strm << setw(indent+12) << "extension = " << setprecision(indent) << m_extension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_IntResult::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_IntResult::Class()), PInvalidCast);
#endif
  const H450_IntResult & other = (const H450_IntResult &)obj;

  Comparison result;

  if ((result = m_servedUserNr.Compare(other.m_servedUserNr)) != EqualTo)
    return result;
  if ((result = m_basicService.Compare(other.m_basicService)) != EqualTo)
    return result;
  if ((result = m_procedure.Compare(other.m_procedure)) != EqualTo)
    return result;
  if ((result = m_divertedToAddress.Compare(other.m_divertedToAddress)) != EqualTo)
    return result;
  if ((result = m_remoteEnabled.Compare(other.m_remoteEnabled)) != EqualTo)
    return result;
  if ((result = m_extension.Compare(other.m_extension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_IntResult::GetDataLength() const
{
  PINDEX length = 0;
  length += m_servedUserNr.GetObjectLength();
  length += m_basicService.GetObjectLength();
  length += m_procedure.GetObjectLength();
  length += m_divertedToAddress.GetObjectLength();
  length += m_remoteEnabled.GetObjectLength();
  if (HasOptionalField(e_extension))
    length += m_extension.GetObjectLength();
  return length;
}


BOOL H450_IntResult::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_servedUserNr.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_basicService.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_procedure.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_divertedToAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_remoteEnabled.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extension ) && !m_extension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_IntResult::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_servedUserNr.Encode(strm);
  m_basicService.Encode(strm);
  m_procedure.Encode(strm);
  m_divertedToAddress.Encode(strm);
  m_remoteEnabled.Encode(strm);
  if (HasOptionalField(e_extension))
    m_extension.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_servedUserNr.Encode(strm);
  m_basicService.Encode(strm);
  m_procedure.Encode(strm);
  m_divertedToAddress.Encode(strm);
  m_remoteEnabled.Encode(strm);
  if (HasOptionalField(e_extension))
    m_extension.Encode(strm);
}


PObject * H450_IntResult::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_IntResult::Class()), PInvalidCast);
#endif
  return new H450_IntResult(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_IntResult::preShowEthereal( void )
{
  m_servedUserNr.preShowEthereal( );
  m_basicService.preShowEthereal( );
  m_procedure.preShowEthereal( );
  m_divertedToAddress.preShowEthereal( );
  m_remoteEnabled.preShowEthereal( );
  if ( HasOptionalField( e_extension ) ) 
      m_extension.preShowEthereal( );
}

PString H450_IntResult::getSummary( void ) 
{
  return PString( "IntResult" );
}

void H450_IntResult::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *servedUserNr_tree = (proto_tree*) NULL;
  proto_item *servedUserNr_ti = (proto_item*) NULL;
  servedUserNr_ti = proto_tree_add_text( tree, tvb, offset + m_servedUserNr.GetStartByte(), m_servedUserNr.GetByteLength(), "servedUserNr (EndpointAddress)" );
  servedUserNr_tree = proto_item_add_subtree( servedUserNr_ti, hCont->h450_1.ett_h450_IntResult_servedUserNr );

  m_servedUserNr.showEthereal( servedUserNr_tree, tvb, offset );

  proto_tree *basicService_tree = (proto_tree*) NULL;
  proto_item *basicService_ti = (proto_item*) NULL;
  basicService_ti = proto_tree_add_text( tree, tvb, offset + m_basicService.GetStartByte(), m_basicService.GetByteLength(), "basicService (BasicService)" );
  basicService_tree = proto_item_add_subtree( basicService_ti, hCont->h450_1.ett_h450_IntResult_basicService );

  m_basicService.showEthereal( basicService_tree, tvb, offset );

  proto_tree *procedure_tree = (proto_tree*) NULL;
  proto_item *procedure_ti = (proto_item*) NULL;
  procedure_ti = proto_tree_add_text( tree, tvb, offset + m_procedure.GetStartByte(), m_procedure.GetByteLength(), "procedure (Procedure)" );
  procedure_tree = proto_item_add_subtree( procedure_ti, hCont->h450_1.ett_h450_IntResult_procedure );

  m_procedure.showEthereal( procedure_tree, tvb, offset );

  proto_tree *divertedToAddress_tree = (proto_tree*) NULL;
  proto_item *divertedToAddress_ti = (proto_item*) NULL;
  divertedToAddress_ti = proto_tree_add_text( tree, tvb, offset + m_divertedToAddress.GetStartByte(), m_divertedToAddress.GetByteLength(), "divertedToAddress (EndpointAddress)" );
  divertedToAddress_tree = proto_item_add_subtree( divertedToAddress_ti, hCont->h450_1.ett_h450_IntResult_divertedToAddress );

  m_divertedToAddress.showEthereal( divertedToAddress_tree, tvb, offset );

  proto_tree_add_boolean( tree, hCont->h450_1.hf_h450_IntResult_remoteEnabled, tvb, offset + m_remoteEnabled.GetStartByte(), m_remoteEnabled.GetByteLength() , m_remoteEnabled.GetValue() );

  if ( HasOptionalField( e_extension ) ) {
    proto_tree *extension_tree = (proto_tree*) NULL;
    proto_item *extension_ti = (proto_item*) NULL;
    extension_ti = proto_tree_add_text( tree, tvb, offset + m_extension.GetStartByte(), m_extension.GetByteLength(), "extension (%s)", ( const char* ) m_extension.GetTagName() );
    extension_tree = proto_item_add_subtree( extension_ti, hCont->h450_1.ett_h450_IntResult_extension );
    m_extension.showEthereal( extension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CTInitiateArg
//

H450_CTInitiateArg::H450_CTInitiateArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H450_CTInitiateArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "callIdentity = " << setprecision(indent) << m_callIdentity << '\n';
  strm << setw(indent+18) << "reroutingNumber = " << setprecision(indent) << m_reroutingNumber << '\n';
  if (HasOptionalField(e_argumentExtension))
    strm << setw(indent+20) << "argumentExtension = " << setprecision(indent) << m_argumentExtension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CTInitiateArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CTInitiateArg::Class()), PInvalidCast);
#endif
  const H450_CTInitiateArg & other = (const H450_CTInitiateArg &)obj;

  Comparison result;

  if ((result = m_callIdentity.Compare(other.m_callIdentity)) != EqualTo)
    return result;
  if ((result = m_reroutingNumber.Compare(other.m_reroutingNumber)) != EqualTo)
    return result;
  if ((result = m_argumentExtension.Compare(other.m_argumentExtension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CTInitiateArg::GetDataLength() const
{
  PINDEX length = 0;
  length += m_callIdentity.GetObjectLength();
  length += m_reroutingNumber.GetObjectLength();
  if (HasOptionalField(e_argumentExtension))
    length += m_argumentExtension.GetObjectLength();
  return length;
}


BOOL H450_CTInitiateArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callIdentity.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_reroutingNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_argumentExtension ) && !m_argumentExtension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CTInitiateArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_callIdentity.Encode(strm);
  m_reroutingNumber.Encode(strm);
  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_callIdentity.Encode(strm);
  m_reroutingNumber.Encode(strm);
  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);
}


PObject * H450_CTInitiateArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CTInitiateArg::Class()), PInvalidCast);
#endif
  return new H450_CTInitiateArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CTInitiateArg::preShowEthereal( void )
{
  m_callIdentity.preShowEthereal( );
  m_reroutingNumber.preShowEthereal( );
  if ( HasOptionalField( e_argumentExtension ) ) 
      m_argumentExtension.preShowEthereal( );
}

PString H450_CTInitiateArg::getSummary( void ) 
{
  return PString( "CTInitiateArg" );
}

void H450_CTInitiateArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pcallIdentity = m_callIdentity.getValue();
  proto_tree_add_string( tree, hCont->h450_1.hf_h450_CTInitiateArg_callIdentity, tvb, offset + m_callIdentity.GetStartByte(), m_callIdentity.GetByteLength() , pcallIdentity );
  delete[] pcallIdentity;

  proto_tree *reroutingNumber_tree = (proto_tree*) NULL;
  proto_item *reroutingNumber_ti = (proto_item*) NULL;
  reroutingNumber_ti = proto_tree_add_text( tree, tvb, offset + m_reroutingNumber.GetStartByte(), m_reroutingNumber.GetByteLength(), "reroutingNumber (EndpointAddress)" );
  reroutingNumber_tree = proto_item_add_subtree( reroutingNumber_ti, hCont->h450_1.ett_h450_CTInitiateArg_reroutingNumber );

  m_reroutingNumber.showEthereal( reroutingNumber_tree, tvb, offset );

  if ( HasOptionalField( e_argumentExtension ) ) {
    proto_tree *argumentExtension_tree = (proto_tree*) NULL;
    proto_item *argumentExtension_ti = (proto_item*) NULL;
    argumentExtension_ti = proto_tree_add_text( tree, tvb, offset + m_argumentExtension.GetStartByte(), m_argumentExtension.GetByteLength(), "argumentExtension (%s)", ( const char* ) m_argumentExtension.GetTagName() );
    argumentExtension_tree = proto_item_add_subtree( argumentExtension_ti, hCont->h450_1.ett_h450_CTInitiateArg_argumentExtension );
    m_argumentExtension.showEthereal( argumentExtension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CTSetupArg
//

H450_CTSetupArg::H450_CTSetupArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H450_CTSetupArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "callIdentity = " << setprecision(indent) << m_callIdentity << '\n';
  if (HasOptionalField(e_transferringNumber))
    strm << setw(indent+21) << "transferringNumber = " << setprecision(indent) << m_transferringNumber << '\n';
  if (HasOptionalField(e_argumentExtension))
    strm << setw(indent+20) << "argumentExtension = " << setprecision(indent) << m_argumentExtension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CTSetupArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CTSetupArg::Class()), PInvalidCast);
#endif
  const H450_CTSetupArg & other = (const H450_CTSetupArg &)obj;

  Comparison result;

  if ((result = m_callIdentity.Compare(other.m_callIdentity)) != EqualTo)
    return result;
  if ((result = m_transferringNumber.Compare(other.m_transferringNumber)) != EqualTo)
    return result;
  if ((result = m_argumentExtension.Compare(other.m_argumentExtension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CTSetupArg::GetDataLength() const
{
  PINDEX length = 0;
  length += m_callIdentity.GetObjectLength();
  if (HasOptionalField(e_transferringNumber))
    length += m_transferringNumber.GetObjectLength();
  if (HasOptionalField(e_argumentExtension))
    length += m_argumentExtension.GetObjectLength();
  return length;
}


BOOL H450_CTSetupArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callIdentity.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_transferringNumber ) && !m_transferringNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_argumentExtension ) && !m_argumentExtension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CTSetupArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_callIdentity.Encode(strm);
  if (HasOptionalField(e_transferringNumber))
    m_transferringNumber.Encode(strm);
  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_callIdentity.Encode(strm);
  if (HasOptionalField(e_transferringNumber))
    m_transferringNumber.Encode(strm);
  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);
}


PObject * H450_CTSetupArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CTSetupArg::Class()), PInvalidCast);
#endif
  return new H450_CTSetupArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CTSetupArg::preShowEthereal( void )
{
  m_callIdentity.preShowEthereal( );
  if ( HasOptionalField( e_transferringNumber ) ) 
      m_transferringNumber.preShowEthereal( );
  if ( HasOptionalField( e_argumentExtension ) ) 
      m_argumentExtension.preShowEthereal( );
}

PString H450_CTSetupArg::getSummary( void ) 
{
  return PString( "CTSetupArg" );
}

void H450_CTSetupArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pcallIdentity = m_callIdentity.getValue();
  proto_tree_add_string( tree, hCont->h450_1.hf_h450_CTSetupArg_callIdentity, tvb, offset + m_callIdentity.GetStartByte(), m_callIdentity.GetByteLength() , pcallIdentity );
  delete[] pcallIdentity;

  if ( HasOptionalField( e_transferringNumber ) ) {
    proto_tree *transferringNumber_tree = (proto_tree*) NULL;
    proto_item *transferringNumber_ti = (proto_item*) NULL;
    transferringNumber_ti = proto_tree_add_text( tree, tvb, offset + m_transferringNumber.GetStartByte(), m_transferringNumber.GetByteLength(), "transferringNumber (EndpointAddress)" );
    transferringNumber_tree = proto_item_add_subtree( transferringNumber_ti, hCont->h450_1.ett_h450_CTSetupArg_transferringNumber );
    m_transferringNumber.showEthereal( transferringNumber_tree, tvb, offset );
  }

  if ( HasOptionalField( e_argumentExtension ) ) {
    proto_tree *argumentExtension_tree = (proto_tree*) NULL;
    proto_item *argumentExtension_ti = (proto_item*) NULL;
    argumentExtension_ti = proto_tree_add_text( tree, tvb, offset + m_argumentExtension.GetStartByte(), m_argumentExtension.GetByteLength(), "argumentExtension (%s)", ( const char* ) m_argumentExtension.GetTagName() );
    argumentExtension_tree = proto_item_add_subtree( argumentExtension_ti, hCont->h450_1.ett_h450_CTSetupArg_argumentExtension );
    m_argumentExtension.showEthereal( argumentExtension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CTIdentifyRes
//

H450_CTIdentifyRes::H450_CTIdentifyRes(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H450_CTIdentifyRes::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "callIdentity = " << setprecision(indent) << m_callIdentity << '\n';
  strm << setw(indent+18) << "reroutingNumber = " << setprecision(indent) << m_reroutingNumber << '\n';
  if (HasOptionalField(e_resultExtension))
    strm << setw(indent+18) << "resultExtension = " << setprecision(indent) << m_resultExtension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CTIdentifyRes::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CTIdentifyRes::Class()), PInvalidCast);
#endif
  const H450_CTIdentifyRes & other = (const H450_CTIdentifyRes &)obj;

  Comparison result;

  if ((result = m_callIdentity.Compare(other.m_callIdentity)) != EqualTo)
    return result;
  if ((result = m_reroutingNumber.Compare(other.m_reroutingNumber)) != EqualTo)
    return result;
  if ((result = m_resultExtension.Compare(other.m_resultExtension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CTIdentifyRes::GetDataLength() const
{
  PINDEX length = 0;
  length += m_callIdentity.GetObjectLength();
  length += m_reroutingNumber.GetObjectLength();
  if (HasOptionalField(e_resultExtension))
    length += m_resultExtension.GetObjectLength();
  return length;
}


BOOL H450_CTIdentifyRes::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callIdentity.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_reroutingNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_resultExtension ) && !m_resultExtension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CTIdentifyRes::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_callIdentity.Encode(strm);
  m_reroutingNumber.Encode(strm);
  if (HasOptionalField(e_resultExtension))
    m_resultExtension.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_callIdentity.Encode(strm);
  m_reroutingNumber.Encode(strm);
  if (HasOptionalField(e_resultExtension))
    m_resultExtension.Encode(strm);
}


PObject * H450_CTIdentifyRes::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CTIdentifyRes::Class()), PInvalidCast);
#endif
  return new H450_CTIdentifyRes(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CTIdentifyRes::preShowEthereal( void )
{
  m_callIdentity.preShowEthereal( );
  m_reroutingNumber.preShowEthereal( );
  if ( HasOptionalField( e_resultExtension ) ) 
      m_resultExtension.preShowEthereal( );
}

PString H450_CTIdentifyRes::getSummary( void ) 
{
  return PString( "CTIdentifyRes" );
}

void H450_CTIdentifyRes::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pcallIdentity = m_callIdentity.getValue();
  proto_tree_add_string( tree, hCont->h450_1.hf_h450_CTIdentifyRes_callIdentity, tvb, offset + m_callIdentity.GetStartByte(), m_callIdentity.GetByteLength() , pcallIdentity );
  delete[] pcallIdentity;

  proto_tree *reroutingNumber_tree = (proto_tree*) NULL;
  proto_item *reroutingNumber_ti = (proto_item*) NULL;
  reroutingNumber_ti = proto_tree_add_text( tree, tvb, offset + m_reroutingNumber.GetStartByte(), m_reroutingNumber.GetByteLength(), "reroutingNumber (EndpointAddress)" );
  reroutingNumber_tree = proto_item_add_subtree( reroutingNumber_ti, hCont->h450_1.ett_h450_CTIdentifyRes_reroutingNumber );

  m_reroutingNumber.showEthereal( reroutingNumber_tree, tvb, offset );

  if ( HasOptionalField( e_resultExtension ) ) {
    proto_tree *resultExtension_tree = (proto_tree*) NULL;
    proto_item *resultExtension_ti = (proto_item*) NULL;
    resultExtension_ti = proto_tree_add_text( tree, tvb, offset + m_resultExtension.GetStartByte(), m_resultExtension.GetByteLength(), "resultExtension (%s)", ( const char* ) m_resultExtension.GetTagName() );
    resultExtension_tree = proto_item_add_subtree( resultExtension_ti, hCont->h450_1.ett_h450_CTIdentifyRes_resultExtension );
    m_resultExtension.showEthereal( resultExtension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CTUpdateArg
//

H450_CTUpdateArg::H450_CTUpdateArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
  m_redirectionInfo.SetConstraints(PASN_Object::FixedConstraint, 1, 128);
}


#ifndef PASN_NOPRINTON
void H450_CTUpdateArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+20) << "redirectionNumber = " << setprecision(indent) << m_redirectionNumber << '\n';
  if (HasOptionalField(e_redirectionInfo))
    strm << setw(indent+18) << "redirectionInfo = " << setprecision(indent) << m_redirectionInfo << '\n';
  if (HasOptionalField(e_basicCallInfoElements))
    strm << setw(indent+24) << "basicCallInfoElements = " << setprecision(indent) << m_basicCallInfoElements << '\n';
  if (HasOptionalField(e_argumentExtension))
    strm << setw(indent+20) << "argumentExtension = " << setprecision(indent) << m_argumentExtension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CTUpdateArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CTUpdateArg::Class()), PInvalidCast);
#endif
  const H450_CTUpdateArg & other = (const H450_CTUpdateArg &)obj;

  Comparison result;

  if ((result = m_redirectionNumber.Compare(other.m_redirectionNumber)) != EqualTo)
    return result;
  if ((result = m_redirectionInfo.Compare(other.m_redirectionInfo)) != EqualTo)
    return result;
  if ((result = m_basicCallInfoElements.Compare(other.m_basicCallInfoElements)) != EqualTo)
    return result;
  if ((result = m_argumentExtension.Compare(other.m_argumentExtension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CTUpdateArg::GetDataLength() const
{
  PINDEX length = 0;
  length += m_redirectionNumber.GetObjectLength();
  if (HasOptionalField(e_redirectionInfo))
    length += m_redirectionInfo.GetObjectLength();
  if (HasOptionalField(e_basicCallInfoElements))
    length += m_basicCallInfoElements.GetObjectLength();
  if (HasOptionalField(e_argumentExtension))
    length += m_argumentExtension.GetObjectLength();
  return length;
}


BOOL H450_CTUpdateArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_redirectionNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_redirectionInfo ) && !m_redirectionInfo.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_basicCallInfoElements ) && !m_basicCallInfoElements.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_argumentExtension ) && !m_argumentExtension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CTUpdateArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_redirectionNumber.Encode(strm);
  if (HasOptionalField(e_redirectionInfo))
    m_redirectionInfo.Encode(strm);
  if (HasOptionalField(e_basicCallInfoElements))
    m_basicCallInfoElements.Encode(strm);
  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_redirectionNumber.Encode(strm);
  if (HasOptionalField(e_redirectionInfo))
    m_redirectionInfo.Encode(strm);
  if (HasOptionalField(e_basicCallInfoElements))
    m_basicCallInfoElements.Encode(strm);
  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);
}


PObject * H450_CTUpdateArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CTUpdateArg::Class()), PInvalidCast);
#endif
  return new H450_CTUpdateArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CTUpdateArg::preShowEthereal( void )
{
  m_redirectionNumber.preShowEthereal( );
  if ( HasOptionalField( e_redirectionInfo ) ) 
      m_redirectionInfo.preShowEthereal( );
  if ( HasOptionalField( e_basicCallInfoElements ) ) 
      m_basicCallInfoElements.preShowEthereal( );
  if ( HasOptionalField( e_argumentExtension ) ) 
      m_argumentExtension.preShowEthereal( );
}

PString H450_CTUpdateArg::getSummary( void ) 
{
  return PString( "CTUpdateArg" );
}

void H450_CTUpdateArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *redirectionNumber_tree = (proto_tree*) NULL;
  proto_item *redirectionNumber_ti = (proto_item*) NULL;
  redirectionNumber_ti = proto_tree_add_text( tree, tvb, offset + m_redirectionNumber.GetStartByte(), m_redirectionNumber.GetByteLength(), "redirectionNumber (EndpointAddress)" );
  redirectionNumber_tree = proto_item_add_subtree( redirectionNumber_ti, hCont->h450_1.ett_h450_CTUpdateArg_redirectionNumber );

  m_redirectionNumber.showEthereal( redirectionNumber_tree, tvb, offset );

  if ( HasOptionalField( e_redirectionInfo ) ) {
    char* predirectionInfo = m_redirectionInfo.getValue();
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CTUpdateArg_redirectionInfo, tvb, offset + m_redirectionInfo.GetStartByte(), m_redirectionInfo.GetByteLength() , predirectionInfo );
    delete[] predirectionInfo;
  }

  if ( HasOptionalField( e_basicCallInfoElements ) ) {
    char* pbasicCallInfoElements = m_basicCallInfoElements.getValue();
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CTUpdateArg_basicCallInfoElements, tvb, offset + m_basicCallInfoElements.GetStartByte(), m_basicCallInfoElements.GetByteLength() , pbasicCallInfoElements );
    delete[] pbasicCallInfoElements;
  }

  if ( HasOptionalField( e_argumentExtension ) ) {
    proto_tree *argumentExtension_tree = (proto_tree*) NULL;
    proto_item *argumentExtension_ti = (proto_item*) NULL;
    argumentExtension_ti = proto_tree_add_text( tree, tvb, offset + m_argumentExtension.GetStartByte(), m_argumentExtension.GetByteLength(), "argumentExtension (%s)", ( const char* ) m_argumentExtension.GetTagName() );
    argumentExtension_tree = proto_item_add_subtree( argumentExtension_ti, hCont->h450_1.ett_h450_CTUpdateArg_argumentExtension );
    m_argumentExtension.showEthereal( argumentExtension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// SubaddressTransferArg
//

H450_SubaddressTransferArg::H450_SubaddressTransferArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H450_SubaddressTransferArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "redirectionSubaddress = " << setprecision(indent) << m_redirectionSubaddress << '\n';
  if (HasOptionalField(e_argumentExtension))
    strm << setw(indent+20) << "argumentExtension = " << setprecision(indent) << m_argumentExtension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_SubaddressTransferArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_SubaddressTransferArg::Class()), PInvalidCast);
#endif
  const H450_SubaddressTransferArg & other = (const H450_SubaddressTransferArg &)obj;

  Comparison result;

  if ((result = m_redirectionSubaddress.Compare(other.m_redirectionSubaddress)) != EqualTo)
    return result;
  if ((result = m_argumentExtension.Compare(other.m_argumentExtension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_SubaddressTransferArg::GetDataLength() const
{
  PINDEX length = 0;
  length += m_redirectionSubaddress.GetObjectLength();
  if (HasOptionalField(e_argumentExtension))
    length += m_argumentExtension.GetObjectLength();
  return length;
}


BOOL H450_SubaddressTransferArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_redirectionSubaddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_argumentExtension ) && !m_argumentExtension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_SubaddressTransferArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_redirectionSubaddress.Encode(strm);
  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_redirectionSubaddress.Encode(strm);
  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);
}


PObject * H450_SubaddressTransferArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_SubaddressTransferArg::Class()), PInvalidCast);
#endif
  return new H450_SubaddressTransferArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_SubaddressTransferArg::preShowEthereal( void )
{
  m_redirectionSubaddress.preShowEthereal( );
  if ( HasOptionalField( e_argumentExtension ) ) 
      m_argumentExtension.preShowEthereal( );
}

PString H450_SubaddressTransferArg::getSummary( void ) 
{
  return PString( "SubaddressTransferArg" );
}

void H450_SubaddressTransferArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *redirectionSubaddress_tree = (proto_tree*) NULL;
  proto_item *redirectionSubaddress_ti = (proto_item*) NULL;
  redirectionSubaddress_ti = proto_tree_add_text( tree, tvb, offset + m_redirectionSubaddress.GetStartByte(), m_redirectionSubaddress.GetByteLength(), "redirectionSubaddress (%s)", ( const char* ) m_redirectionSubaddress.GetTagName() );
  redirectionSubaddress_tree = proto_item_add_subtree( redirectionSubaddress_ti, hCont->h450_1.ett_h450_SubaddressTransferArg_redirectionSubaddress );

  m_redirectionSubaddress.showEthereal( redirectionSubaddress_tree, tvb, offset );

  if ( HasOptionalField( e_argumentExtension ) ) {
    proto_tree *argumentExtension_tree = (proto_tree*) NULL;
    proto_item *argumentExtension_ti = (proto_item*) NULL;
    argumentExtension_ti = proto_tree_add_text( tree, tvb, offset + m_argumentExtension.GetStartByte(), m_argumentExtension.GetByteLength(), "argumentExtension (%s)", ( const char* ) m_argumentExtension.GetTagName() );
    argumentExtension_tree = proto_item_add_subtree( argumentExtension_ti, hCont->h450_1.ett_h450_SubaddressTransferArg_argumentExtension );
    m_argumentExtension.showEthereal( argumentExtension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CTCompleteArg
//

H450_CTCompleteArg::H450_CTCompleteArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
  m_redirectionInfo.SetConstraints(PASN_Object::FixedConstraint, 1, 128);
}


#ifndef PASN_NOPRINTON
void H450_CTCompleteArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "endDesignation = " << setprecision(indent) << m_endDesignation << '\n';
  strm << setw(indent+20) << "redirectionNumber = " << setprecision(indent) << m_redirectionNumber << '\n';
  if (HasOptionalField(e_basicCallInfoElements))
    strm << setw(indent+24) << "basicCallInfoElements = " << setprecision(indent) << m_basicCallInfoElements << '\n';
  if (HasOptionalField(e_redirectionInfo))
    strm << setw(indent+18) << "redirectionInfo = " << setprecision(indent) << m_redirectionInfo << '\n';
  strm << setw(indent+13) << "callStatus = " << setprecision(indent) << m_callStatus << '\n';
  if (HasOptionalField(e_argumentExtension))
    strm << setw(indent+20) << "argumentExtension = " << setprecision(indent) << m_argumentExtension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CTCompleteArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CTCompleteArg::Class()), PInvalidCast);
#endif
  const H450_CTCompleteArg & other = (const H450_CTCompleteArg &)obj;

  Comparison result;

  if ((result = m_endDesignation.Compare(other.m_endDesignation)) != EqualTo)
    return result;
  if ((result = m_redirectionNumber.Compare(other.m_redirectionNumber)) != EqualTo)
    return result;
  if ((result = m_basicCallInfoElements.Compare(other.m_basicCallInfoElements)) != EqualTo)
    return result;
  if ((result = m_redirectionInfo.Compare(other.m_redirectionInfo)) != EqualTo)
    return result;
  if ((result = m_callStatus.Compare(other.m_callStatus)) != EqualTo)
    return result;
  if ((result = m_argumentExtension.Compare(other.m_argumentExtension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CTCompleteArg::GetDataLength() const
{
  PINDEX length = 0;
  length += m_endDesignation.GetObjectLength();
  length += m_redirectionNumber.GetObjectLength();
  if (HasOptionalField(e_basicCallInfoElements))
    length += m_basicCallInfoElements.GetObjectLength();
  if (HasOptionalField(e_redirectionInfo))
    length += m_redirectionInfo.GetObjectLength();
  length += m_callStatus.GetObjectLength();
  if (HasOptionalField(e_argumentExtension))
    length += m_argumentExtension.GetObjectLength();
  return length;
}


BOOL H450_CTCompleteArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_endDesignation.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_redirectionNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_basicCallInfoElements ) && !m_basicCallInfoElements.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_redirectionInfo ) && !m_redirectionInfo.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callStatus.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_argumentExtension ) && !m_argumentExtension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CTCompleteArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_endDesignation.Encode(strm);
  m_redirectionNumber.Encode(strm);
  if (HasOptionalField(e_basicCallInfoElements))
    m_basicCallInfoElements.Encode(strm);
  if (HasOptionalField(e_redirectionInfo))
    m_redirectionInfo.Encode(strm);
  m_callStatus.Encode(strm);
  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_endDesignation.Encode(strm);
  m_redirectionNumber.Encode(strm);
  if (HasOptionalField(e_basicCallInfoElements))
    m_basicCallInfoElements.Encode(strm);
  if (HasOptionalField(e_redirectionInfo))
    m_redirectionInfo.Encode(strm);
  m_callStatus.Encode(strm);
  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);
}


PObject * H450_CTCompleteArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CTCompleteArg::Class()), PInvalidCast);
#endif
  return new H450_CTCompleteArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CTCompleteArg::preShowEthereal( void )
{
  m_endDesignation.preShowEthereal( );
  m_redirectionNumber.preShowEthereal( );
  if ( HasOptionalField( e_basicCallInfoElements ) ) 
      m_basicCallInfoElements.preShowEthereal( );
  if ( HasOptionalField( e_redirectionInfo ) ) 
      m_redirectionInfo.preShowEthereal( );
  m_callStatus.preShowEthereal( );
  if ( HasOptionalField( e_argumentExtension ) ) 
      m_argumentExtension.preShowEthereal( );
}

PString H450_CTCompleteArg::getSummary( void ) 
{
  return PString( "CTCompleteArg" );
}

void H450_CTCompleteArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *endDesignation_tree = (proto_tree*) NULL;
  proto_item *endDesignation_ti = (proto_item*) NULL;
  endDesignation_ti = proto_tree_add_text( tree, tvb, offset + m_endDesignation.GetStartByte(), m_endDesignation.GetByteLength(), "endDesignation (EndDesignation)" );
  endDesignation_tree = proto_item_add_subtree( endDesignation_ti, hCont->h450_1.ett_h450_CTCompleteArg_endDesignation );

  m_endDesignation.showEthereal( endDesignation_tree, tvb, offset );

  proto_tree *redirectionNumber_tree = (proto_tree*) NULL;
  proto_item *redirectionNumber_ti = (proto_item*) NULL;
  redirectionNumber_ti = proto_tree_add_text( tree, tvb, offset + m_redirectionNumber.GetStartByte(), m_redirectionNumber.GetByteLength(), "redirectionNumber (EndpointAddress)" );
  redirectionNumber_tree = proto_item_add_subtree( redirectionNumber_ti, hCont->h450_1.ett_h450_CTCompleteArg_redirectionNumber );

  m_redirectionNumber.showEthereal( redirectionNumber_tree, tvb, offset );

  if ( HasOptionalField( e_basicCallInfoElements ) ) {
    char* pbasicCallInfoElements = m_basicCallInfoElements.getValue();
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CTCompleteArg_basicCallInfoElements, tvb, offset + m_basicCallInfoElements.GetStartByte(), m_basicCallInfoElements.GetByteLength() , pbasicCallInfoElements );
    delete[] pbasicCallInfoElements;
  }

  if ( HasOptionalField( e_redirectionInfo ) ) {
    char* predirectionInfo = m_redirectionInfo.getValue();
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CTCompleteArg_redirectionInfo, tvb, offset + m_redirectionInfo.GetStartByte(), m_redirectionInfo.GetByteLength() , predirectionInfo );
    delete[] predirectionInfo;
  }

  proto_tree *callStatus_tree = (proto_tree*) NULL;
  proto_item *callStatus_ti = (proto_item*) NULL;
  callStatus_ti = proto_tree_add_text( tree, tvb, offset + m_callStatus.GetStartByte(), m_callStatus.GetByteLength(), "callStatus (CallStatus)" );
  callStatus_tree = proto_item_add_subtree( callStatus_ti, hCont->h450_1.ett_h450_CTCompleteArg_callStatus );

  m_callStatus.showEthereal( callStatus_tree, tvb, offset );

  if ( HasOptionalField( e_argumentExtension ) ) {
    proto_tree *argumentExtension_tree = (proto_tree*) NULL;
    proto_item *argumentExtension_ti = (proto_item*) NULL;
    argumentExtension_ti = proto_tree_add_text( tree, tvb, offset + m_argumentExtension.GetStartByte(), m_argumentExtension.GetByteLength(), "argumentExtension (%s)", ( const char* ) m_argumentExtension.GetTagName() );
    argumentExtension_tree = proto_item_add_subtree( argumentExtension_ti, hCont->h450_1.ett_h450_CTCompleteArg_argumentExtension );
    m_argumentExtension.showEthereal( argumentExtension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CTActiveArg
//

H450_CTActiveArg::H450_CTActiveArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
  m_connectedInfo.SetConstraints(PASN_Object::FixedConstraint, 1, 128);
}


#ifndef PASN_NOPRINTON
void H450_CTActiveArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+19) << "connectedAddress = " << setprecision(indent) << m_connectedAddress << '\n';
  if (HasOptionalField(e_basicCallInfoElements))
    strm << setw(indent+24) << "basicCallInfoElements = " << setprecision(indent) << m_basicCallInfoElements << '\n';
  if (HasOptionalField(e_connectedInfo))
    strm << setw(indent+16) << "connectedInfo = " << setprecision(indent) << m_connectedInfo << '\n';
  if (HasOptionalField(e_argumentExtension))
    strm << setw(indent+20) << "argumentExtension = " << setprecision(indent) << m_argumentExtension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CTActiveArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CTActiveArg::Class()), PInvalidCast);
#endif
  const H450_CTActiveArg & other = (const H450_CTActiveArg &)obj;

  Comparison result;

  if ((result = m_connectedAddress.Compare(other.m_connectedAddress)) != EqualTo)
    return result;
  if ((result = m_basicCallInfoElements.Compare(other.m_basicCallInfoElements)) != EqualTo)
    return result;
  if ((result = m_connectedInfo.Compare(other.m_connectedInfo)) != EqualTo)
    return result;
  if ((result = m_argumentExtension.Compare(other.m_argumentExtension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CTActiveArg::GetDataLength() const
{
  PINDEX length = 0;
  length += m_connectedAddress.GetObjectLength();
  if (HasOptionalField(e_basicCallInfoElements))
    length += m_basicCallInfoElements.GetObjectLength();
  if (HasOptionalField(e_connectedInfo))
    length += m_connectedInfo.GetObjectLength();
  if (HasOptionalField(e_argumentExtension))
    length += m_argumentExtension.GetObjectLength();
  return length;
}


BOOL H450_CTActiveArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_connectedAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_basicCallInfoElements ) && !m_basicCallInfoElements.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_connectedInfo ) && !m_connectedInfo.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_argumentExtension ) && !m_argumentExtension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CTActiveArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_connectedAddress.Encode(strm);
  if (HasOptionalField(e_basicCallInfoElements))
    m_basicCallInfoElements.Encode(strm);
  if (HasOptionalField(e_connectedInfo))
    m_connectedInfo.Encode(strm);
  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_connectedAddress.Encode(strm);
  if (HasOptionalField(e_basicCallInfoElements))
    m_basicCallInfoElements.Encode(strm);
  if (HasOptionalField(e_connectedInfo))
    m_connectedInfo.Encode(strm);
  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);
}


PObject * H450_CTActiveArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CTActiveArg::Class()), PInvalidCast);
#endif
  return new H450_CTActiveArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CTActiveArg::preShowEthereal( void )
{
  m_connectedAddress.preShowEthereal( );
  if ( HasOptionalField( e_basicCallInfoElements ) ) 
      m_basicCallInfoElements.preShowEthereal( );
  if ( HasOptionalField( e_connectedInfo ) ) 
      m_connectedInfo.preShowEthereal( );
  if ( HasOptionalField( e_argumentExtension ) ) 
      m_argumentExtension.preShowEthereal( );
}

PString H450_CTActiveArg::getSummary( void ) 
{
  return PString( "CTActiveArg" );
}

void H450_CTActiveArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *connectedAddress_tree = (proto_tree*) NULL;
  proto_item *connectedAddress_ti = (proto_item*) NULL;
  connectedAddress_ti = proto_tree_add_text( tree, tvb, offset + m_connectedAddress.GetStartByte(), m_connectedAddress.GetByteLength(), "connectedAddress (EndpointAddress)" );
  connectedAddress_tree = proto_item_add_subtree( connectedAddress_ti, hCont->h450_1.ett_h450_CTActiveArg_connectedAddress );

  m_connectedAddress.showEthereal( connectedAddress_tree, tvb, offset );

  if ( HasOptionalField( e_basicCallInfoElements ) ) {
    char* pbasicCallInfoElements = m_basicCallInfoElements.getValue();
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CTActiveArg_basicCallInfoElements, tvb, offset + m_basicCallInfoElements.GetStartByte(), m_basicCallInfoElements.GetByteLength() , pbasicCallInfoElements );
    delete[] pbasicCallInfoElements;
  }

  if ( HasOptionalField( e_connectedInfo ) ) {
    char* pconnectedInfo = m_connectedInfo.getValue();
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CTActiveArg_connectedInfo, tvb, offset + m_connectedInfo.GetStartByte(), m_connectedInfo.GetByteLength() , pconnectedInfo );
    delete[] pconnectedInfo;
  }

  if ( HasOptionalField( e_argumentExtension ) ) {
    proto_tree *argumentExtension_tree = (proto_tree*) NULL;
    proto_item *argumentExtension_ti = (proto_item*) NULL;
    argumentExtension_ti = proto_tree_add_text( tree, tvb, offset + m_argumentExtension.GetStartByte(), m_argumentExtension.GetByteLength(), "argumentExtension (%s)", ( const char* ) m_argumentExtension.GetTagName() );
    argumentExtension_tree = proto_item_add_subtree( argumentExtension_ti, hCont->h450_1.ett_h450_CTActiveArg_argumentExtension );
    m_argumentExtension.showEthereal( argumentExtension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CIRequestArg
//

H450_CIRequestArg::H450_CIRequestArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_argumentExtension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CIRequestArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+20) << "ciCapabilityLevel = " << setprecision(indent) << m_ciCapabilityLevel << '\n';
  if (HasOptionalField(e_argumentExtension))
    strm << setw(indent+20) << "argumentExtension = " << setprecision(indent) << m_argumentExtension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CIRequestArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CIRequestArg::Class()), PInvalidCast);
#endif
  const H450_CIRequestArg & other = (const H450_CIRequestArg &)obj;

  Comparison result;

  if ((result = m_ciCapabilityLevel.Compare(other.m_ciCapabilityLevel)) != EqualTo)
    return result;
  if ((result = m_argumentExtension.Compare(other.m_argumentExtension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CIRequestArg::GetDataLength() const
{
  PINDEX length = 0;
  length += m_ciCapabilityLevel.GetObjectLength();
  if (HasOptionalField(e_argumentExtension))
    length += m_argumentExtension.GetObjectLength();
  return length;
}


BOOL H450_CIRequestArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_ciCapabilityLevel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_argumentExtension ) && !m_argumentExtension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CIRequestArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_ciCapabilityLevel.Encode(strm);
  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_ciCapabilityLevel.Encode(strm);
  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);
}


PObject * H450_CIRequestArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CIRequestArg::Class()), PInvalidCast);
#endif
  return new H450_CIRequestArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CIRequestArg::preShowEthereal( void )
{
  m_ciCapabilityLevel.preShowEthereal( );
  if ( HasOptionalField( e_argumentExtension ) ) 
      m_argumentExtension.preShowEthereal( );
}

PString H450_CIRequestArg::getSummary( void ) 
{
  return PString( "CIRequestArg" );
}

void H450_CIRequestArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h450_1.hf_h450_CIRequestArg_ciCapabilityLevel, tvb, offset + m_ciCapabilityLevel.GetStartByte(), m_ciCapabilityLevel.GetByteLength() , m_ciCapabilityLevel.GetValue() );

  if ( HasOptionalField( e_argumentExtension ) ) {
    proto_tree *argumentExtension_tree = (proto_tree*) NULL;
    proto_item *argumentExtension_ti = (proto_item*) NULL;
    argumentExtension_ti = proto_tree_add_text( tree, tvb, offset + m_argumentExtension.GetStartByte(), m_argumentExtension.GetByteLength(), "argumentExtension (MixedExtension)" );
    argumentExtension_tree = proto_item_add_subtree( argumentExtension_ti, hCont->h450_1.ett_h450_CIRequestArg_argumentExtension );
    m_argumentExtension.showEthereal( argumentExtension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CIRequestRes
//

H450_CIRequestRes::H450_CIRequestRes(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_resultExtension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CIRequestRes::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "ciStatusInformation = " << setprecision(indent) << m_ciStatusInformation << '\n';
  if (HasOptionalField(e_resultExtension))
    strm << setw(indent+18) << "resultExtension = " << setprecision(indent) << m_resultExtension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CIRequestRes::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CIRequestRes::Class()), PInvalidCast);
#endif
  const H450_CIRequestRes & other = (const H450_CIRequestRes &)obj;

  Comparison result;

  if ((result = m_ciStatusInformation.Compare(other.m_ciStatusInformation)) != EqualTo)
    return result;
  if ((result = m_resultExtension.Compare(other.m_resultExtension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CIRequestRes::GetDataLength() const
{
  PINDEX length = 0;
  length += m_ciStatusInformation.GetObjectLength();
  if (HasOptionalField(e_resultExtension))
    length += m_resultExtension.GetObjectLength();
  return length;
}


BOOL H450_CIRequestRes::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_ciStatusInformation.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_resultExtension ) && !m_resultExtension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CIRequestRes::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_ciStatusInformation.Encode(strm);
  if (HasOptionalField(e_resultExtension))
    m_resultExtension.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_ciStatusInformation.Encode(strm);
  if (HasOptionalField(e_resultExtension))
    m_resultExtension.Encode(strm);
}


PObject * H450_CIRequestRes::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CIRequestRes::Class()), PInvalidCast);
#endif
  return new H450_CIRequestRes(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CIRequestRes::preShowEthereal( void )
{
  m_ciStatusInformation.preShowEthereal( );
  if ( HasOptionalField( e_resultExtension ) ) 
      m_resultExtension.preShowEthereal( );
}

PString H450_CIRequestRes::getSummary( void ) 
{
  return PString( "CIRequestRes" );
}

void H450_CIRequestRes::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ciStatusInformation_tree = (proto_tree*) NULL;
  proto_item *ciStatusInformation_ti = (proto_item*) NULL;
  ciStatusInformation_ti = proto_tree_add_text( tree, tvb, offset + m_ciStatusInformation.GetStartByte(), m_ciStatusInformation.GetByteLength(), "ciStatusInformation (%s)", ( const char* ) m_ciStatusInformation.GetTagName() );
  ciStatusInformation_tree = proto_item_add_subtree( ciStatusInformation_ti, hCont->h450_1.ett_h450_CIRequestRes_ciStatusInformation );

  m_ciStatusInformation.showEthereal( ciStatusInformation_tree, tvb, offset );

  if ( HasOptionalField( e_resultExtension ) ) {
    proto_tree *resultExtension_tree = (proto_tree*) NULL;
    proto_item *resultExtension_ti = (proto_item*) NULL;
    resultExtension_ti = proto_tree_add_text( tree, tvb, offset + m_resultExtension.GetStartByte(), m_resultExtension.GetByteLength(), "resultExtension (MixedExtension)" );
    resultExtension_tree = proto_item_add_subtree( resultExtension_ti, hCont->h450_1.ett_h450_CIRequestRes_resultExtension );
    m_resultExtension.showEthereal( resultExtension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CIGetCIPLOptArg
//

H450_CIGetCIPLOptArg::H450_CIGetCIPLOptArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_argumentExtension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CIGetCIPLOptArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_argumentExtension))
    strm << setw(indent+20) << "argumentExtension = " << setprecision(indent) << m_argumentExtension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CIGetCIPLOptArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CIGetCIPLOptArg::Class()), PInvalidCast);
#endif
  const H450_CIGetCIPLOptArg & other = (const H450_CIGetCIPLOptArg &)obj;

  Comparison result;

  if ((result = m_argumentExtension.Compare(other.m_argumentExtension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CIGetCIPLOptArg::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_argumentExtension))
    length += m_argumentExtension.GetObjectLength();
  return length;
}


BOOL H450_CIGetCIPLOptArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_argumentExtension ) && !m_argumentExtension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CIGetCIPLOptArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);
}


PObject * H450_CIGetCIPLOptArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CIGetCIPLOptArg::Class()), PInvalidCast);
#endif
  return new H450_CIGetCIPLOptArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CIGetCIPLOptArg::preShowEthereal( void )
{
  if ( HasOptionalField( e_argumentExtension ) ) 
      m_argumentExtension.preShowEthereal( );
}

PString H450_CIGetCIPLOptArg::getSummary( void ) 
{
  return PString( "CIGetCIPLOptArg" );
}

void H450_CIGetCIPLOptArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_argumentExtension ) ) {
    proto_tree *argumentExtension_tree = (proto_tree*) NULL;
    proto_item *argumentExtension_ti = (proto_item*) NULL;
    argumentExtension_ti = proto_tree_add_text( tree, tvb, offset + m_argumentExtension.GetStartByte(), m_argumentExtension.GetByteLength(), "argumentExtension (MixedExtension)" );
    argumentExtension_tree = proto_item_add_subtree( argumentExtension_ti, hCont->h450_1.ett_h450_CIGetCIPLOptArg_argumentExtension );
    m_argumentExtension.showEthereal( argumentExtension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CIGetCIPLRes
//

H450_CIGetCIPLRes::H450_CIGetCIPLRes(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_resultExtension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CIGetCIPLRes::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+20) << "ciProtectionLevel = " << setprecision(indent) << m_ciProtectionLevel << '\n';
  if (HasOptionalField(e_silentMonitoringPermitted))
    strm << setw(indent+28) << "silentMonitoringPermitted = " << setprecision(indent) << m_silentMonitoringPermitted << '\n';
  if (HasOptionalField(e_resultExtension))
    strm << setw(indent+18) << "resultExtension = " << setprecision(indent) << m_resultExtension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CIGetCIPLRes::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CIGetCIPLRes::Class()), PInvalidCast);
#endif
  const H450_CIGetCIPLRes & other = (const H450_CIGetCIPLRes &)obj;

  Comparison result;

  if ((result = m_ciProtectionLevel.Compare(other.m_ciProtectionLevel)) != EqualTo)
    return result;
  if ((result = m_silentMonitoringPermitted.Compare(other.m_silentMonitoringPermitted)) != EqualTo)
    return result;
  if ((result = m_resultExtension.Compare(other.m_resultExtension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CIGetCIPLRes::GetDataLength() const
{
  PINDEX length = 0;
  length += m_ciProtectionLevel.GetObjectLength();
  if (HasOptionalField(e_silentMonitoringPermitted))
    length += m_silentMonitoringPermitted.GetObjectLength();
  if (HasOptionalField(e_resultExtension))
    length += m_resultExtension.GetObjectLength();
  return length;
}


BOOL H450_CIGetCIPLRes::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_ciProtectionLevel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_silentMonitoringPermitted ) && !m_silentMonitoringPermitted.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_resultExtension ) && !m_resultExtension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CIGetCIPLRes::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_ciProtectionLevel.Encode(strm);
  if (HasOptionalField(e_silentMonitoringPermitted))
    m_silentMonitoringPermitted.Encode(strm);
  if (HasOptionalField(e_resultExtension))
    m_resultExtension.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_ciProtectionLevel.Encode(strm);
  if (HasOptionalField(e_silentMonitoringPermitted))
    m_silentMonitoringPermitted.Encode(strm);
  if (HasOptionalField(e_resultExtension))
    m_resultExtension.Encode(strm);
}


PObject * H450_CIGetCIPLRes::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CIGetCIPLRes::Class()), PInvalidCast);
#endif
  return new H450_CIGetCIPLRes(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CIGetCIPLRes::preShowEthereal( void )
{
  m_ciProtectionLevel.preShowEthereal( );
  if ( HasOptionalField( e_silentMonitoringPermitted ) ) 
      m_silentMonitoringPermitted.preShowEthereal( );
  if ( HasOptionalField( e_resultExtension ) ) 
      m_resultExtension.preShowEthereal( );
}

PString H450_CIGetCIPLRes::getSummary( void ) 
{
  return PString( "CIGetCIPLRes" );
}

void H450_CIGetCIPLRes::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h450_1.hf_h450_CIGetCIPLRes_ciProtectionLevel, tvb, offset + m_ciProtectionLevel.GetStartByte(), m_ciProtectionLevel.GetByteLength() , m_ciProtectionLevel.GetValue() );

  if ( HasOptionalField( e_silentMonitoringPermitted ) ) {
    proto_tree_add_string( tree, hCont->h450_1.hf_h450_CIGetCIPLRes_silentMonitoringPermitted, tvb, offset + m_silentMonitoringPermitted.GetStartByte(), m_silentMonitoringPermitted.GetByteLength() , "silentMonitoringPermitted: \"NULL\"" );
  }

  if ( HasOptionalField( e_resultExtension ) ) {
    proto_tree *resultExtension_tree = (proto_tree*) NULL;
    proto_item *resultExtension_ti = (proto_item*) NULL;
    resultExtension_ti = proto_tree_add_text( tree, tvb, offset + m_resultExtension.GetStartByte(), m_resultExtension.GetByteLength(), "resultExtension (MixedExtension)" );
    resultExtension_tree = proto_item_add_subtree( resultExtension_ti, hCont->h450_1.ett_h450_CIGetCIPLRes_resultExtension );
    m_resultExtension.showEthereal( resultExtension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CIIsOptArg
//

H450_CIIsOptArg::H450_CIIsOptArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_argumentExtension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CIIsOptArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_argumentExtension))
    strm << setw(indent+20) << "argumentExtension = " << setprecision(indent) << m_argumentExtension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CIIsOptArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CIIsOptArg::Class()), PInvalidCast);
#endif
  const H450_CIIsOptArg & other = (const H450_CIIsOptArg &)obj;

  Comparison result;

  if ((result = m_argumentExtension.Compare(other.m_argumentExtension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CIIsOptArg::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_argumentExtension))
    length += m_argumentExtension.GetObjectLength();
  return length;
}


BOOL H450_CIIsOptArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_argumentExtension ) && !m_argumentExtension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CIIsOptArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);
}


PObject * H450_CIIsOptArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CIIsOptArg::Class()), PInvalidCast);
#endif
  return new H450_CIIsOptArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CIIsOptArg::preShowEthereal( void )
{
  if ( HasOptionalField( e_argumentExtension ) ) 
      m_argumentExtension.preShowEthereal( );
}

PString H450_CIIsOptArg::getSummary( void ) 
{
  return PString( "CIIsOptArg" );
}

void H450_CIIsOptArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_argumentExtension ) ) {
    proto_tree *argumentExtension_tree = (proto_tree*) NULL;
    proto_item *argumentExtension_ti = (proto_item*) NULL;
    argumentExtension_ti = proto_tree_add_text( tree, tvb, offset + m_argumentExtension.GetStartByte(), m_argumentExtension.GetByteLength(), "argumentExtension (MixedExtension)" );
    argumentExtension_tree = proto_item_add_subtree( argumentExtension_ti, hCont->h450_1.ett_h450_CIIsOptArg_argumentExtension );
    m_argumentExtension.showEthereal( argumentExtension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CIIsOptRes
//

H450_CIIsOptRes::H450_CIIsOptRes(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_resultExtension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CIIsOptRes::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_resultExtension))
    strm << setw(indent+18) << "resultExtension = " << setprecision(indent) << m_resultExtension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CIIsOptRes::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CIIsOptRes::Class()), PInvalidCast);
#endif
  const H450_CIIsOptRes & other = (const H450_CIIsOptRes &)obj;

  Comparison result;

  if ((result = m_resultExtension.Compare(other.m_resultExtension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CIIsOptRes::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_resultExtension))
    length += m_resultExtension.GetObjectLength();
  return length;
}


BOOL H450_CIIsOptRes::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_resultExtension ) && !m_resultExtension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CIIsOptRes::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_resultExtension))
    m_resultExtension.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_resultExtension))
    m_resultExtension.Encode(strm);
}


PObject * H450_CIIsOptRes::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CIIsOptRes::Class()), PInvalidCast);
#endif
  return new H450_CIIsOptRes(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CIIsOptRes::preShowEthereal( void )
{
  if ( HasOptionalField( e_resultExtension ) ) 
      m_resultExtension.preShowEthereal( );
}

PString H450_CIIsOptRes::getSummary( void ) 
{
  return PString( "CIIsOptRes" );
}

void H450_CIIsOptRes::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_resultExtension ) ) {
    proto_tree *resultExtension_tree = (proto_tree*) NULL;
    proto_item *resultExtension_ti = (proto_item*) NULL;
    resultExtension_ti = proto_tree_add_text( tree, tvb, offset + m_resultExtension.GetStartByte(), m_resultExtension.GetByteLength(), "resultExtension (MixedExtension)" );
    resultExtension_tree = proto_item_add_subtree( resultExtension_ti, hCont->h450_1.ett_h450_CIIsOptRes_resultExtension );
    m_resultExtension.showEthereal( resultExtension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CIFrcRelArg
//

H450_CIFrcRelArg::H450_CIFrcRelArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_argumentExtension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CIFrcRelArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+20) << "ciCapabilityLevel = " << setprecision(indent) << m_ciCapabilityLevel << '\n';
  if (HasOptionalField(e_argumentExtension))
    strm << setw(indent+20) << "argumentExtension = " << setprecision(indent) << m_argumentExtension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CIFrcRelArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CIFrcRelArg::Class()), PInvalidCast);
#endif
  const H450_CIFrcRelArg & other = (const H450_CIFrcRelArg &)obj;

  Comparison result;

  if ((result = m_ciCapabilityLevel.Compare(other.m_ciCapabilityLevel)) != EqualTo)
    return result;
  if ((result = m_argumentExtension.Compare(other.m_argumentExtension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CIFrcRelArg::GetDataLength() const
{
  PINDEX length = 0;
  length += m_ciCapabilityLevel.GetObjectLength();
  if (HasOptionalField(e_argumentExtension))
    length += m_argumentExtension.GetObjectLength();
  return length;
}


BOOL H450_CIFrcRelArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_ciCapabilityLevel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_argumentExtension ) && !m_argumentExtension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CIFrcRelArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_ciCapabilityLevel.Encode(strm);
  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_ciCapabilityLevel.Encode(strm);
  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);
}


PObject * H450_CIFrcRelArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CIFrcRelArg::Class()), PInvalidCast);
#endif
  return new H450_CIFrcRelArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CIFrcRelArg::preShowEthereal( void )
{
  m_ciCapabilityLevel.preShowEthereal( );
  if ( HasOptionalField( e_argumentExtension ) ) 
      m_argumentExtension.preShowEthereal( );
}

PString H450_CIFrcRelArg::getSummary( void ) 
{
  return PString( "CIFrcRelArg" );
}

void H450_CIFrcRelArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h450_1.hf_h450_CIFrcRelArg_ciCapabilityLevel, tvb, offset + m_ciCapabilityLevel.GetStartByte(), m_ciCapabilityLevel.GetByteLength() , m_ciCapabilityLevel.GetValue() );

  if ( HasOptionalField( e_argumentExtension ) ) {
    proto_tree *argumentExtension_tree = (proto_tree*) NULL;
    proto_item *argumentExtension_ti = (proto_item*) NULL;
    argumentExtension_ti = proto_tree_add_text( tree, tvb, offset + m_argumentExtension.GetStartByte(), m_argumentExtension.GetByteLength(), "argumentExtension (MixedExtension)" );
    argumentExtension_tree = proto_item_add_subtree( argumentExtension_ti, hCont->h450_1.ett_h450_CIFrcRelArg_argumentExtension );
    m_argumentExtension.showEthereal( argumentExtension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CIFrcRelOptRes
//

H450_CIFrcRelOptRes::H450_CIFrcRelOptRes(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_resultExtension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CIFrcRelOptRes::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_resultExtension))
    strm << setw(indent+18) << "resultExtension = " << setprecision(indent) << m_resultExtension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CIFrcRelOptRes::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CIFrcRelOptRes::Class()), PInvalidCast);
#endif
  const H450_CIFrcRelOptRes & other = (const H450_CIFrcRelOptRes &)obj;

  Comparison result;

  if ((result = m_resultExtension.Compare(other.m_resultExtension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CIFrcRelOptRes::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_resultExtension))
    length += m_resultExtension.GetObjectLength();
  return length;
}


BOOL H450_CIFrcRelOptRes::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_resultExtension ) && !m_resultExtension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CIFrcRelOptRes::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_resultExtension))
    m_resultExtension.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_resultExtension))
    m_resultExtension.Encode(strm);
}


PObject * H450_CIFrcRelOptRes::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CIFrcRelOptRes::Class()), PInvalidCast);
#endif
  return new H450_CIFrcRelOptRes(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CIFrcRelOptRes::preShowEthereal( void )
{
  if ( HasOptionalField( e_resultExtension ) ) 
      m_resultExtension.preShowEthereal( );
}

PString H450_CIFrcRelOptRes::getSummary( void ) 
{
  return PString( "CIFrcRelOptRes" );
}

void H450_CIFrcRelOptRes::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_resultExtension ) ) {
    proto_tree *resultExtension_tree = (proto_tree*) NULL;
    proto_item *resultExtension_ti = (proto_item*) NULL;
    resultExtension_ti = proto_tree_add_text( tree, tvb, offset + m_resultExtension.GetStartByte(), m_resultExtension.GetByteLength(), "resultExtension (MixedExtension)" );
    resultExtension_tree = proto_item_add_subtree( resultExtension_ti, hCont->h450_1.ett_h450_CIFrcRelOptRes_resultExtension );
    m_resultExtension.showEthereal( resultExtension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CIWobOptArg
//

H450_CIWobOptArg::H450_CIWobOptArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_argumentExtension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CIWobOptArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_argumentExtension))
    strm << setw(indent+20) << "argumentExtension = " << setprecision(indent) << m_argumentExtension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CIWobOptArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CIWobOptArg::Class()), PInvalidCast);
#endif
  const H450_CIWobOptArg & other = (const H450_CIWobOptArg &)obj;

  Comparison result;

  if ((result = m_argumentExtension.Compare(other.m_argumentExtension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CIWobOptArg::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_argumentExtension))
    length += m_argumentExtension.GetObjectLength();
  return length;
}


BOOL H450_CIWobOptArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_argumentExtension ) && !m_argumentExtension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CIWobOptArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);
}


PObject * H450_CIWobOptArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CIWobOptArg::Class()), PInvalidCast);
#endif
  return new H450_CIWobOptArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CIWobOptArg::preShowEthereal( void )
{
  if ( HasOptionalField( e_argumentExtension ) ) 
      m_argumentExtension.preShowEthereal( );
}

PString H450_CIWobOptArg::getSummary( void ) 
{
  return PString( "CIWobOptArg" );
}

void H450_CIWobOptArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_argumentExtension ) ) {
    proto_tree *argumentExtension_tree = (proto_tree*) NULL;
    proto_item *argumentExtension_ti = (proto_item*) NULL;
    argumentExtension_ti = proto_tree_add_text( tree, tvb, offset + m_argumentExtension.GetStartByte(), m_argumentExtension.GetByteLength(), "argumentExtension (MixedExtension)" );
    argumentExtension_tree = proto_item_add_subtree( argumentExtension_ti, hCont->h450_1.ett_h450_CIWobOptArg_argumentExtension );
    m_argumentExtension.showEthereal( argumentExtension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CIWobOptRes
//

H450_CIWobOptRes::H450_CIWobOptRes(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_resultExtension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CIWobOptRes::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_resultExtension))
    strm << setw(indent+18) << "resultExtension = " << setprecision(indent) << m_resultExtension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CIWobOptRes::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CIWobOptRes::Class()), PInvalidCast);
#endif
  const H450_CIWobOptRes & other = (const H450_CIWobOptRes &)obj;

  Comparison result;

  if ((result = m_resultExtension.Compare(other.m_resultExtension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CIWobOptRes::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_resultExtension))
    length += m_resultExtension.GetObjectLength();
  return length;
}


BOOL H450_CIWobOptRes::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_resultExtension ) && !m_resultExtension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CIWobOptRes::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_resultExtension))
    m_resultExtension.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_resultExtension))
    m_resultExtension.Encode(strm);
}


PObject * H450_CIWobOptRes::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CIWobOptRes::Class()), PInvalidCast);
#endif
  return new H450_CIWobOptRes(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CIWobOptRes::preShowEthereal( void )
{
  if ( HasOptionalField( e_resultExtension ) ) 
      m_resultExtension.preShowEthereal( );
}

PString H450_CIWobOptRes::getSummary( void ) 
{
  return PString( "CIWobOptRes" );
}

void H450_CIWobOptRes::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_resultExtension ) ) {
    proto_tree *resultExtension_tree = (proto_tree*) NULL;
    proto_item *resultExtension_ti = (proto_item*) NULL;
    resultExtension_ti = proto_tree_add_text( tree, tvb, offset + m_resultExtension.GetStartByte(), m_resultExtension.GetByteLength(), "resultExtension (MixedExtension)" );
    resultExtension_tree = proto_item_add_subtree( resultExtension_ti, hCont->h450_1.ett_h450_CIWobOptRes_resultExtension );
    m_resultExtension.showEthereal( resultExtension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CISilentArg
//

H450_CISilentArg::H450_CISilentArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_argumentExtension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CISilentArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+20) << "ciCapabilityLevel = " << setprecision(indent) << m_ciCapabilityLevel << '\n';
  if (HasOptionalField(e_specificCall))
    strm << setw(indent+15) << "specificCall = " << setprecision(indent) << m_specificCall << '\n';
  if (HasOptionalField(e_argumentExtension))
    strm << setw(indent+20) << "argumentExtension = " << setprecision(indent) << m_argumentExtension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CISilentArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CISilentArg::Class()), PInvalidCast);
#endif
  const H450_CISilentArg & other = (const H450_CISilentArg &)obj;

  Comparison result;

  if ((result = m_ciCapabilityLevel.Compare(other.m_ciCapabilityLevel)) != EqualTo)
    return result;
  if ((result = m_specificCall.Compare(other.m_specificCall)) != EqualTo)
    return result;
  if ((result = m_argumentExtension.Compare(other.m_argumentExtension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CISilentArg::GetDataLength() const
{
  PINDEX length = 0;
  length += m_ciCapabilityLevel.GetObjectLength();
  if (HasOptionalField(e_specificCall))
    length += m_specificCall.GetObjectLength();
  if (HasOptionalField(e_argumentExtension))
    length += m_argumentExtension.GetObjectLength();
  return length;
}


BOOL H450_CISilentArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_ciCapabilityLevel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_specificCall ) && !m_specificCall.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_argumentExtension ) && !m_argumentExtension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CISilentArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_ciCapabilityLevel.Encode(strm);
  if (HasOptionalField(e_specificCall))
    m_specificCall.Encode(strm);
  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_ciCapabilityLevel.Encode(strm);
  if (HasOptionalField(e_specificCall))
    m_specificCall.Encode(strm);
  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);
}


PObject * H450_CISilentArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CISilentArg::Class()), PInvalidCast);
#endif
  return new H450_CISilentArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CISilentArg::preShowEthereal( void )
{
  m_ciCapabilityLevel.preShowEthereal( );
  if ( HasOptionalField( e_specificCall ) ) 
      m_specificCall.preShowEthereal( );
  if ( HasOptionalField( e_argumentExtension ) ) 
      m_argumentExtension.preShowEthereal( );
}

PString H450_CISilentArg::getSummary( void ) 
{
  return PString( "CISilentArg" );
}

void H450_CISilentArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h450_1.hf_h450_CISilentArg_ciCapabilityLevel, tvb, offset + m_ciCapabilityLevel.GetStartByte(), m_ciCapabilityLevel.GetByteLength() , m_ciCapabilityLevel.GetValue() );

  /* This member is defined outside the current ASN.1 file, 
   * therefore it's not known what type it is. The safest
   * solution is to add another subtree and let the class handle itself
   */
  if ( HasOptionalField( e_specificCall ) ) {
    proto_tree *specificCall_tree = (proto_tree*) NULL;
    proto_item *specificCall_ti = (proto_item*) NULL;
    specificCall_ti = proto_tree_add_text( tree, tvb, offset + m_specificCall.GetStartByte(), m_specificCall.GetByteLength(), "specificCall (H225-CallIdentifier)" );
    specificCall_tree = proto_item_add_subtree( specificCall_ti, hCont->h450_1.ett_h450_CISilentArg_specificCall );
    m_specificCall.showEthereal( specificCall_tree, tvb, offset );
  }

  if ( HasOptionalField( e_argumentExtension ) ) {
    proto_tree *argumentExtension_tree = (proto_tree*) NULL;
    proto_item *argumentExtension_ti = (proto_item*) NULL;
    argumentExtension_ti = proto_tree_add_text( tree, tvb, offset + m_argumentExtension.GetStartByte(), m_argumentExtension.GetByteLength(), "argumentExtension (MixedExtension)" );
    argumentExtension_tree = proto_item_add_subtree( argumentExtension_ti, hCont->h450_1.ett_h450_CISilentArg_argumentExtension );
    m_argumentExtension.showEthereal( argumentExtension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CISilentOptRes
//

H450_CISilentOptRes::H450_CISilentOptRes(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_resultExtension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CISilentOptRes::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_resultExtension))
    strm << setw(indent+18) << "resultExtension = " << setprecision(indent) << m_resultExtension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CISilentOptRes::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CISilentOptRes::Class()), PInvalidCast);
#endif
  const H450_CISilentOptRes & other = (const H450_CISilentOptRes &)obj;

  Comparison result;

  if ((result = m_resultExtension.Compare(other.m_resultExtension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CISilentOptRes::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_resultExtension))
    length += m_resultExtension.GetObjectLength();
  return length;
}


BOOL H450_CISilentOptRes::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_resultExtension ) && !m_resultExtension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CISilentOptRes::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_resultExtension))
    m_resultExtension.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_resultExtension))
    m_resultExtension.Encode(strm);
}


PObject * H450_CISilentOptRes::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CISilentOptRes::Class()), PInvalidCast);
#endif
  return new H450_CISilentOptRes(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CISilentOptRes::preShowEthereal( void )
{
  if ( HasOptionalField( e_resultExtension ) ) 
      m_resultExtension.preShowEthereal( );
}

PString H450_CISilentOptRes::getSummary( void ) 
{
  return PString( "CISilentOptRes" );
}

void H450_CISilentOptRes::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_resultExtension ) ) {
    proto_tree *resultExtension_tree = (proto_tree*) NULL;
    proto_item *resultExtension_ti = (proto_item*) NULL;
    resultExtension_ti = proto_tree_add_text( tree, tvb, offset + m_resultExtension.GetStartByte(), m_resultExtension.GetByteLength(), "resultExtension (MixedExtension)" );
    resultExtension_tree = proto_item_add_subtree( resultExtension_ti, hCont->h450_1.ett_h450_CISilentOptRes_resultExtension );
    m_resultExtension.showEthereal( resultExtension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CINotificationArg
//

H450_CINotificationArg::H450_CINotificationArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_argumentExtension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CINotificationArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "ciStatusInformation = " << setprecision(indent) << m_ciStatusInformation << '\n';
  if (HasOptionalField(e_argumentExtension))
    strm << setw(indent+20) << "argumentExtension = " << setprecision(indent) << m_argumentExtension << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CINotificationArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CINotificationArg::Class()), PInvalidCast);
#endif
  const H450_CINotificationArg & other = (const H450_CINotificationArg &)obj;

  Comparison result;

  if ((result = m_ciStatusInformation.Compare(other.m_ciStatusInformation)) != EqualTo)
    return result;
  if ((result = m_argumentExtension.Compare(other.m_argumentExtension)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CINotificationArg::GetDataLength() const
{
  PINDEX length = 0;
  length += m_ciStatusInformation.GetObjectLength();
  if (HasOptionalField(e_argumentExtension))
    length += m_argumentExtension.GetObjectLength();
  return length;
}


BOOL H450_CINotificationArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_ciStatusInformation.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_argumentExtension ) && !m_argumentExtension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CINotificationArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_ciStatusInformation.Encode(strm);
  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_ciStatusInformation.Encode(strm);
  if (HasOptionalField(e_argumentExtension))
    m_argumentExtension.Encode(strm);
}


PObject * H450_CINotificationArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CINotificationArg::Class()), PInvalidCast);
#endif
  return new H450_CINotificationArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CINotificationArg::preShowEthereal( void )
{
  m_ciStatusInformation.preShowEthereal( );
  if ( HasOptionalField( e_argumentExtension ) ) 
      m_argumentExtension.preShowEthereal( );
}

PString H450_CINotificationArg::getSummary( void ) 
{
  return PString( "CINotificationArg" );
}

void H450_CINotificationArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ciStatusInformation_tree = (proto_tree*) NULL;
  proto_item *ciStatusInformation_ti = (proto_item*) NULL;
  ciStatusInformation_ti = proto_tree_add_text( tree, tvb, offset + m_ciStatusInformation.GetStartByte(), m_ciStatusInformation.GetByteLength(), "ciStatusInformation (%s)", ( const char* ) m_ciStatusInformation.GetTagName() );
  ciStatusInformation_tree = proto_item_add_subtree( ciStatusInformation_ti, hCont->h450_1.ett_h450_CINotificationArg_ciStatusInformation );

  m_ciStatusInformation.showEthereal( ciStatusInformation_tree, tvb, offset );

  if ( HasOptionalField( e_argumentExtension ) ) {
    proto_tree *argumentExtension_tree = (proto_tree*) NULL;
    proto_item *argumentExtension_ti = (proto_item*) NULL;
    argumentExtension_ti = proto_tree_add_text( tree, tvb, offset + m_argumentExtension.GetStartByte(), m_argumentExtension.GetByteLength(), "argumentExtension (MixedExtension)" );
    argumentExtension_tree = proto_item_add_subtree( argumentExtension_ti, hCont->h450_1.ett_h450_CINotificationArg_argumentExtension );
    m_argumentExtension.showEthereal( argumentExtension_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CallWaitingArg
//

H450_CallWaitingArg::H450_CallWaitingArg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_nbOfAddWaitingCalls.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
  m_extensionArg.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H450_CallWaitingArg::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nbOfAddWaitingCalls))
    strm << setw(indent+22) << "nbOfAddWaitingCalls = " << setprecision(indent) << m_nbOfAddWaitingCalls << '\n';
  if (HasOptionalField(e_extensionArg))
    strm << setw(indent+15) << "extensionArg = " << setprecision(indent) << m_extensionArg << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_CallWaitingArg::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_CallWaitingArg::Class()), PInvalidCast);
#endif
  const H450_CallWaitingArg & other = (const H450_CallWaitingArg &)obj;

  Comparison result;

  if ((result = m_nbOfAddWaitingCalls.Compare(other.m_nbOfAddWaitingCalls)) != EqualTo)
    return result;
  if ((result = m_extensionArg.Compare(other.m_extensionArg)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_CallWaitingArg::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nbOfAddWaitingCalls))
    length += m_nbOfAddWaitingCalls.GetObjectLength();
  if (HasOptionalField(e_extensionArg))
    length += m_extensionArg.GetObjectLength();
  return length;
}


BOOL H450_CallWaitingArg::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nbOfAddWaitingCalls ) && !m_nbOfAddWaitingCalls.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_extensionArg ) && !m_extensionArg.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_CallWaitingArg::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nbOfAddWaitingCalls))
    m_nbOfAddWaitingCalls.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nbOfAddWaitingCalls))
    m_nbOfAddWaitingCalls.Encode(strm);
  if (HasOptionalField(e_extensionArg))
    m_extensionArg.Encode(strm);
}


PObject * H450_CallWaitingArg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_CallWaitingArg::Class()), PInvalidCast);
#endif
  return new H450_CallWaitingArg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_CallWaitingArg::preShowEthereal( void )
{
  if ( HasOptionalField( e_nbOfAddWaitingCalls ) ) 
      m_nbOfAddWaitingCalls.preShowEthereal( );
  if ( HasOptionalField( e_extensionArg ) ) 
      m_extensionArg.preShowEthereal( );
}

PString H450_CallWaitingArg::getSummary( void ) 
{
  return PString( "CallWaitingArg" );
}

void H450_CallWaitingArg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nbOfAddWaitingCalls ) ) {
    proto_tree_add_uint( tree, hCont->h450_1.hf_h450_CallWaitingArg_nbOfAddWaitingCalls, tvb, offset + m_nbOfAddWaitingCalls.GetStartByte(), m_nbOfAddWaitingCalls.GetByteLength() , m_nbOfAddWaitingCalls.GetValue() );
  }

  if ( HasOptionalField( e_extensionArg ) ) {
    proto_tree *extensionArg_tree = (proto_tree*) NULL;
    proto_item *extensionArg_ti = (proto_item*) NULL;
    extensionArg_ti = proto_tree_add_text( tree, tvb, offset + m_extensionArg.GetStartByte(), m_extensionArg.GetByteLength(), "extensionArg (MixedExtension)" );
    extensionArg_tree = proto_item_add_subtree( extensionArg_ti, hCont->h450_1.ett_h450_CallWaitingArg_extensionArg );
    m_extensionArg.showEthereal( extensionArg_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// SupplementaryService
//

H450_SupplementaryService::H450_SupplementaryService(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H450_SupplementaryService::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_networkFacilityExtension))
    strm << setw(indent+27) << "networkFacilityExtension = " << setprecision(indent) << m_networkFacilityExtension << '\n';
  if (HasOptionalField(e_interpretationApdu))
    strm << setw(indent+21) << "interpretationApdu = " << setprecision(indent) << m_interpretationApdu << '\n';
  strm << setw(indent+14) << "serviceApdu = " << setprecision(indent) << m_serviceApdu << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H450_SupplementaryService::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H450_SupplementaryService::Class()), PInvalidCast);
#endif
  const H450_SupplementaryService & other = (const H450_SupplementaryService &)obj;

  Comparison result;

  if ((result = m_networkFacilityExtension.Compare(other.m_networkFacilityExtension)) != EqualTo)
    return result;
  if ((result = m_interpretationApdu.Compare(other.m_interpretationApdu)) != EqualTo)
    return result;
  if ((result = m_serviceApdu.Compare(other.m_serviceApdu)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H450_SupplementaryService::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_networkFacilityExtension))
    length += m_networkFacilityExtension.GetObjectLength();
  if (HasOptionalField(e_interpretationApdu))
    length += m_interpretationApdu.GetObjectLength();
  length += m_serviceApdu.GetObjectLength();
  return length;
}


BOOL H450_SupplementaryService::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_networkFacilityExtension ) && !m_networkFacilityExtension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_interpretationApdu ) && !m_interpretationApdu.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_serviceApdu.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H450_SupplementaryService::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_networkFacilityExtension))
    m_networkFacilityExtension.Encode(strm);
  if (HasOptionalField(e_interpretationApdu))
    m_interpretationApdu.Encode(strm);
  m_serviceApdu.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_networkFacilityExtension))
    m_networkFacilityExtension.Encode(strm);
  if (HasOptionalField(e_interpretationApdu))
    m_interpretationApdu.Encode(strm);
  m_serviceApdu.Encode(strm);
}


PObject * H450_SupplementaryService::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H450_SupplementaryService::Class()), PInvalidCast);
#endif
  return new H450_SupplementaryService(*this);
}


#ifdef USE_FOR_ETHEREAL
void H450_SupplementaryService::preShowEthereal( void )
{
  if ( HasOptionalField( e_networkFacilityExtension ) ) 
      m_networkFacilityExtension.preShowEthereal( );
  if ( HasOptionalField( e_interpretationApdu ) ) 
      m_interpretationApdu.preShowEthereal( );
  m_serviceApdu.preShowEthereal( );
}

PString H450_SupplementaryService::getSummary( void ) 
{
  return PString( "SupplementaryService" );
}

void H450_SupplementaryService::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_networkFacilityExtension ) ) {
    proto_tree *networkFacilityExtension_tree = (proto_tree*) NULL;
    proto_item *networkFacilityExtension_ti = (proto_item*) NULL;
    networkFacilityExtension_ti = proto_tree_add_text( tree, tvb, offset + m_networkFacilityExtension.GetStartByte(), m_networkFacilityExtension.GetByteLength(), "networkFacilityExtension (NetworkFacilityExtension)" );
    networkFacilityExtension_tree = proto_item_add_subtree( networkFacilityExtension_ti, hCont->h450_1.ett_h450_SupplementaryService_networkFacilityExtension );
    m_networkFacilityExtension.showEthereal( networkFacilityExtension_tree, tvb, offset );
  }

  if ( HasOptionalField( e_interpretationApdu ) ) {
    proto_tree *interpretationApdu_tree = (proto_tree*) NULL;
    proto_item *interpretationApdu_ti = (proto_item*) NULL;
    interpretationApdu_ti = proto_tree_add_text( tree, tvb, offset + m_interpretationApdu.GetStartByte(), m_interpretationApdu.GetByteLength(), "interpretationApdu (%s)", ( const char* ) m_interpretationApdu.GetTagName() );
    interpretationApdu_tree = proto_item_add_subtree( interpretationApdu_ti, hCont->h450_1.ett_h450_SupplementaryService_interpretationApdu );
    m_interpretationApdu.showEthereal( interpretationApdu_tree, tvb, offset );
  }

  proto_tree *serviceApdu_tree = (proto_tree*) NULL;
  proto_item *serviceApdu_ti = (proto_item*) NULL;
  serviceApdu_ti = proto_tree_add_text( tree, tvb, offset + m_serviceApdu.GetStartByte(), m_serviceApdu.GetByteLength(), "serviceApdu (%s)", ( const char* ) m_serviceApdu.GetTagName() );
  serviceApdu_tree = proto_item_add_subtree( serviceApdu_ti, hCont->h450_1.ett_h450_SupplementaryService_serviceApdu );

  m_serviceApdu.showEthereal( serviceApdu_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL


// End of h450.cxx