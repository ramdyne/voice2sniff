/* 
 * h225.h
 *
 * Header for decoding H.225
 *
 * H.323 for Ethereal
 *
 * Copyright (c) 2002 Koninklijke Philips NV
 *
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.0 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is H.323 for Ethereal.
 *
 * The Initial Developer of the Original Code is Koninklijke Philips NV.
 *
 * All Rights Reserved.
 *
 * Contributor(s): ______________________________________.
 *
 *
 */

//
// h225.h
//
// Code automatically generated by asnparse.
//

#ifndef __H225_H
#define __H225_H

#ifdef __GNUC__
#pragma interface
#endif

#include "mini_ptlib/include/ptlib/asner.h"

#ifdef USE_FOR_ETHEREAL
//extern "C" {
// use these only if the dissector is meant to be a plug-in!
//  //#include "plugins/plugin_api.h"
//}
#  include "h225_container.h"
#endif //USE_FOR_ETHEREAL

#include "h235.h"
#include "h245.h"


void setH225Container( H225_Integer_Container* cont );

//
// ReleaseCompleteReason
//

class H225_NonStandardParameter;
class H225_ConferenceIdentifier;

class H225_ReleaseCompleteReason : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ReleaseCompleteReason, PASN_Choice);
#endif
  public:
    H225_ReleaseCompleteReason(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_noBandwidth,
      e_gatekeeperResources,
      e_unreachableDestination,
      e_destinationRejection,
      e_invalidRevision,
      e_noPermission,
      e_unreachableGatekeeper,
      e_gatewayResources,
      e_badFormatAddress,
      e_adaptiveBusy,
      e_inConf,
      e_undefinedReason,
      e_facilityCallDeflection,
      e_securityDenied,
      e_calledPartyNotRegistered,
      e_callerNotRegistered,
      e_newConnectionNeeded,
      e_nonStandardReason,
      e_replaceWithConferenceInvite
    };

#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_NonStandardParameter &() const;
#else
    operator H225_NonStandardParameter &();
    operator const H225_NonStandardParameter &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_ConferenceIdentifier &() const;
#else
    operator H225_ConferenceIdentifier &();
    operator const H225_ConferenceIdentifier &() const;
#endif

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ScnConnectionType
//

class H225_ScnConnectionType : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ScnConnectionType, PASN_Choice);
#endif
  public:
    H225_ScnConnectionType(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_unknown,
      e_bChannel,
      e_hybrid2x64,
      e_hybrid384,
      e_hybrid1536,
      e_hybrid1920,
      e_multirate
    };

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ScnConnectionAggregation
//

class H225_ScnConnectionAggregation : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ScnConnectionAggregation, PASN_Choice);
#endif
  public:
    H225_ScnConnectionAggregation(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_auto,
      e_none,
      e_h221,
      e_bonded_mode1,
      e_bonded_mode2,
      e_bonded_mode3
    };

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// PresentationIndicator
//

class H225_PresentationIndicator : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_PresentationIndicator, PASN_Choice);
#endif
  public:
    H225_PresentationIndicator(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_presentationAllowed,
      e_presentationRestricted,
      e_addressNotAvailable
    };

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ScreeningIndicator
//

class H225_ScreeningIndicator : public PASN_Enumeration
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ScreeningIndicator, PASN_Enumeration);
#endif
  public:
    H225_ScreeningIndicator(unsigned tag = UniversalEnumeration, TagClass tagClass = UniversalTagClass);

    enum Enumerations {
      e_userProvidedNotScreened,
      e_userProvidedVerifiedAndPassed,
      e_userProvidedVerifiedAndFailed,
      e_networkProvided
    };

    H225_ScreeningIndicator & operator=(unsigned v);
    PObject * Clone() const;
};


//
// FacilityReason
//

class H225_FacilityReason : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_FacilityReason, PASN_Choice);
#endif
  public:
    H225_FacilityReason(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_routeCallToGatekeeper,
      e_callForwarded,
      e_routeCallToMC,
      e_undefinedReason,
      e_conferenceListChoice,
      e_startH245,
      e_noH245
    };

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// TransportAddress
//

class H225_TransportAddress_ipAddress;
class H225_TransportAddress_ipSourceRoute;
class H225_TransportAddress_ipxAddress;
class H225_TransportAddress_ip6Address;
class H225_NonStandardParameter;

class H225_TransportAddress : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_TransportAddress, PASN_Choice);
#endif
  public:
    H225_TransportAddress(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_ipAddress,
      e_ipSourceRoute,
      e_ipxAddress,
      e_ip6Address,
      e_netBios,
      e_nsap,
      e_nonStandardAddress
    };

#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_TransportAddress_ipAddress &() const;
#else
    operator H225_TransportAddress_ipAddress &();
    operator const H225_TransportAddress_ipAddress &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_TransportAddress_ipSourceRoute &() const;
#else
    operator H225_TransportAddress_ipSourceRoute &();
    operator const H225_TransportAddress_ipSourceRoute &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_TransportAddress_ipxAddress &() const;
#else
    operator H225_TransportAddress_ipxAddress &();
    operator const H225_TransportAddress_ipxAddress &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_TransportAddress_ip6Address &() const;
#else
    operator H225_TransportAddress_ip6Address &();
    operator const H225_TransportAddress_ip6Address &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_NonStandardParameter &() const;
#else
    operator H225_NonStandardParameter &();
    operator const H225_NonStandardParameter &() const;
#endif

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// SupportedProtocols
//

class H225_NonStandardParameter;
class H225_H310Caps;
class H225_H320Caps;
class H225_H321Caps;
class H225_H322Caps;
class H225_H323Caps;
class H225_H324Caps;
class H225_VoiceCaps;
class H225_T120OnlyCaps;
class H225_NonStandardProtocol;
class H225_T38FaxAnnexbOnlyCaps;

class H225_SupportedProtocols : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_SupportedProtocols, PASN_Choice);
#endif
  public:
    H225_SupportedProtocols(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_nonStandardData,
      e_h310,
      e_h320,
      e_h321,
      e_h322,
      e_h323,
      e_h324,
      e_voice,
      e_t120_only,
      e_nonStandardProtocol,
      e_t38FaxAnnexbOnly
    };

#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_NonStandardParameter &() const;
#else
    operator H225_NonStandardParameter &();
    operator const H225_NonStandardParameter &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_H310Caps &() const;
#else
    operator H225_H310Caps &();
    operator const H225_H310Caps &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_H320Caps &() const;
#else
    operator H225_H320Caps &();
    operator const H225_H320Caps &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_H321Caps &() const;
#else
    operator H225_H321Caps &();
    operator const H225_H321Caps &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_H322Caps &() const;
#else
    operator H225_H322Caps &();
    operator const H225_H322Caps &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_H323Caps &() const;
#else
    operator H225_H323Caps &();
    operator const H225_H323Caps &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_H324Caps &() const;
#else
    operator H225_H324Caps &();
    operator const H225_H324Caps &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_VoiceCaps &() const;
#else
    operator H225_VoiceCaps &();
    operator const H225_VoiceCaps &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_T120OnlyCaps &() const;
#else
    operator H225_T120OnlyCaps &();
    operator const H225_T120OnlyCaps &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_NonStandardProtocol &() const;
#else
    operator H225_NonStandardProtocol &();
    operator const H225_NonStandardProtocol &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_T38FaxAnnexbOnlyCaps &() const;
#else
    operator H225_T38FaxAnnexbOnlyCaps &();
    operator const H225_T38FaxAnnexbOnlyCaps &() const;
#endif

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// H221NonStandard
//

class H225_H221NonStandard : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_H221NonStandard, PASN_Sequence);
#endif
  public:
    H225_H221NonStandard(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Integer m_t35CountryCode;
    PASN_Integer m_t35Extension;
    PASN_Integer m_manufacturerCode;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// NonStandardIdentifier
//

class H225_H221NonStandard;

class H225_NonStandardIdentifier : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_NonStandardIdentifier, PASN_Choice);
#endif
  public:
    H225_NonStandardIdentifier(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_object,
      e_h221NonStandard
    };

#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_H221NonStandard &() const;
#else
    operator H225_H221NonStandard &();
    operator const H225_H221NonStandard &() const;
#endif

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// AliasAddress
//

class H225_TransportAddress;
class H225_PartyNumber;

class H225_AliasAddress : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_AliasAddress, PASN_Choice);
#endif
  public:
    H225_AliasAddress(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_e164,
      e_h323_ID,
      e_url_ID,
      e_transportID,
      e_email_ID,
      e_partyNumber
    };

#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_TransportAddress &() const;
#else
    operator H225_TransportAddress &();
    operator const H225_TransportAddress &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_PartyNumber &() const;
#else
    operator H225_PartyNumber &();
    operator const H225_PartyNumber &() const;
#endif

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// PartyNumber
//

class H225_PublicPartyNumber;
class H225_NumberDigits;
class H225_NumberDigits;
class H225_PrivatePartyNumber;
class H225_NumberDigits;

class H225_PartyNumber : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_PartyNumber, PASN_Choice);
#endif
  public:
    H225_PartyNumber(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_publicNumber,
      e_dataPartyNumber,
      e_telexPartyNumber,
      e_privateNumber,
      e_nationalStandardPartyNumber
    };

#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_PublicPartyNumber &() const;
#else
    operator H225_PublicPartyNumber &();
    operator const H225_PublicPartyNumber &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_NumberDigits &() const;
#else
    operator H225_NumberDigits &();
    operator const H225_NumberDigits &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_PrivatePartyNumber &() const;
#else
    operator H225_PrivatePartyNumber &();
    operator const H225_PrivatePartyNumber &() const;
#endif

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// NumberDigits
//

class H225_NumberDigits : public PASN_IA5String
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_NumberDigits, PASN_IA5String);
#endif
  public:
    H225_NumberDigits(unsigned tag = UniversalIA5String, TagClass tagClass = UniversalTagClass);

    H225_NumberDigits & operator=(const char * v);
    H225_NumberDigits & operator=(const PString & v);
    PObject * Clone() const;
};


//
// PublicTypeOfNumber
//

class H225_PublicTypeOfNumber : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_PublicTypeOfNumber, PASN_Choice);
#endif
  public:
    H225_PublicTypeOfNumber(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_unknown,
      e_internationalNumber,
      e_nationalNumber,
      e_networkSpecificNumber,
      e_subscriberNumber,
      e_abbreviatedNumber
    };

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// PrivateTypeOfNumber
//

class H225_PrivateTypeOfNumber : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_PrivateTypeOfNumber, PASN_Choice);
#endif
  public:
    H225_PrivateTypeOfNumber(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_unknown,
      e_level2RegionalNumber,
      e_level1RegionalNumber,
      e_pISNSpecificNumber,
      e_localNumber,
      e_abbreviatedNumber
    };

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// UseSpecifiedTransport
//

class H225_UseSpecifiedTransport : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_UseSpecifiedTransport, PASN_Choice);
#endif
  public:
    H225_UseSpecifiedTransport(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_tcp,
      e_annexE
    };

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// SecurityServiceMode
//

class H225_NonStandardParameter;

class H225_SecurityServiceMode : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_SecurityServiceMode, PASN_Choice);
#endif
  public:
    H225_SecurityServiceMode(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_nonStandard,
      e_none,
      e_default
    };

#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_NonStandardParameter &() const;
#else
    operator H225_NonStandardParameter &();
    operator const H225_NonStandardParameter &() const;
#endif

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// H245Security
//

class H225_NonStandardParameter;
class H225_SecurityCapabilities;
class H225_SecurityCapabilities;

class H225_H245Security : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_H245Security, PASN_Choice);
#endif
  public:
    H225_H245Security(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_nonStandard,
      e_noSecurity,
      e_tls,
      e_ipsec
    };

#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_NonStandardParameter &() const;
#else
    operator H225_NonStandardParameter &();
    operator const H225_NonStandardParameter &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_SecurityCapabilities &() const;
#else
    operator H225_SecurityCapabilities &();
    operator const H225_SecurityCapabilities &() const;
#endif

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// Q954Details
//

class H225_Q954Details : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_Q954Details, PASN_Sequence);
#endif
  public:
    H225_Q954Details(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Boolean m_conferenceCalling;
    PASN_Boolean m_threePartyService;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// GloballyUniqueID
//

class H225_GloballyUniqueID : public PASN_OctetString
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_GloballyUniqueID, PASN_OctetString);
#endif
  public:
    H225_GloballyUniqueID(unsigned tag = UniversalOctetString, TagClass tagClass = UniversalTagClass);

    H225_GloballyUniqueID & operator=(const char * v);
    H225_GloballyUniqueID & operator=(const PString & v);
    H225_GloballyUniqueID & operator=(const PBYTEArray & v);
    PObject * Clone() const;
		virtual char* getValue( void ) const;
};


//
// ConferenceIdentifier
//

class H225_ConferenceIdentifier : public H225_GloballyUniqueID
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ConferenceIdentifier, H225_GloballyUniqueID);
#endif
  public:
    H225_ConferenceIdentifier(unsigned tag = UniversalOctetString, TagClass tagClass = UniversalTagClass);

    H225_ConferenceIdentifier & operator=(const char * v);
    H225_ConferenceIdentifier & operator=(const PString & v);
    H225_ConferenceIdentifier & operator=(const PBYTEArray & v);
    PObject * Clone() const;
};


//
// RequestSeqNum
//

class H225_RequestSeqNum : public PASN_Integer
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_RequestSeqNum, PASN_Integer);
#endif
  public:
    H225_RequestSeqNum(unsigned tag = UniversalInteger, TagClass tagClass = UniversalTagClass);

    H225_RequestSeqNum & operator=(int v);
    H225_RequestSeqNum & operator=(unsigned v);
    PObject * Clone() const;
};


//
// GatekeeperIdentifier
//

class H225_GatekeeperIdentifier : public PASN_BMPString
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_GatekeeperIdentifier, PASN_BMPString);
#endif
  public:
    H225_GatekeeperIdentifier(unsigned tag = UniversalBMPString, TagClass tagClass = UniversalTagClass);

    H225_GatekeeperIdentifier & operator=(const char * v);
    H225_GatekeeperIdentifier & operator=(const PString & v);
    PObject * Clone() const;
};


//
// BandWidth
//

class H225_BandWidth : public PASN_Integer
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_BandWidth, PASN_Integer);
#endif
  public:
    H225_BandWidth(unsigned tag = UniversalInteger, TagClass tagClass = UniversalTagClass);

    H225_BandWidth & operator=(int v);
    H225_BandWidth & operator=(unsigned v);
    PObject * Clone() const;
};


//
// CallReferenceValue
//

class H225_CallReferenceValue : public PASN_Integer
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_CallReferenceValue, PASN_Integer);
#endif
  public:
    H225_CallReferenceValue(unsigned tag = UniversalInteger, TagClass tagClass = UniversalTagClass);

    H225_CallReferenceValue & operator=(int v);
    H225_CallReferenceValue & operator=(unsigned v);
    PObject * Clone() const;
};


//
// EndpointIdentifier
//

class H225_EndpointIdentifier : public PASN_BMPString
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_EndpointIdentifier, PASN_BMPString);
#endif
  public:
    H225_EndpointIdentifier(unsigned tag = UniversalBMPString, TagClass tagClass = UniversalTagClass);

    H225_EndpointIdentifier & operator=(const char * v);
    H225_EndpointIdentifier & operator=(const PString & v);
    PObject * Clone() const;
};


//
// ProtocolIdentifier
//

class H225_ProtocolIdentifier : public PASN_ObjectId
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ProtocolIdentifier, PASN_ObjectId);
#endif
  public:
    H225_ProtocolIdentifier(unsigned tag = UniversalObjectId, TagClass tagClass = UniversalTagClass);

    PObject * Clone() const;
};


//
// TimeToLive
//

class H225_TimeToLive : public PASN_Integer
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_TimeToLive, PASN_Integer);
#endif
  public:
    H225_TimeToLive(unsigned tag = UniversalInteger, TagClass tagClass = UniversalTagClass);

    H225_TimeToLive & operator=(int v);
    H225_TimeToLive & operator=(unsigned v);
    PObject * Clone() const;
};


//
// CallIdentifier
//

class H225_CallIdentifier : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_CallIdentifier, PASN_Sequence);
#endif
  public:
    H225_CallIdentifier(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    H225_GloballyUniqueID m_guid;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// EncryptIntAlg
//

class H225_NonStandardParameter;

class H225_EncryptIntAlg : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_EncryptIntAlg, PASN_Choice);
#endif
  public:
    H225_EncryptIntAlg(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_nonStandard,
      e_isoAlgorithm
    };

#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_NonStandardParameter &() const;
#else
    operator H225_NonStandardParameter &();
    operator const H225_NonStandardParameter &() const;
#endif

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// NonIsoIntegrityMechanism
//

class H225_EncryptIntAlg;
class H225_EncryptIntAlg;

class H225_NonIsoIntegrityMechanism : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_NonIsoIntegrityMechanism, PASN_Choice);
#endif
  public:
    H225_NonIsoIntegrityMechanism(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_hMAC_MD5,
      e_hMAC_iso10118_2_s,
      e_hMAC_iso10118_2_l,
      e_hMAC_iso10118_3
    };

#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_EncryptIntAlg &() const;
#else
    operator H225_EncryptIntAlg &();
    operator const H225_EncryptIntAlg &() const;
#endif

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// IntegrityMechanism
//

class H225_NonStandardParameter;
class H225_NonIsoIntegrityMechanism;

class H225_IntegrityMechanism : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_IntegrityMechanism, PASN_Choice);
#endif
  public:
    H225_IntegrityMechanism(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_nonStandard,
      e_digSig,
      e_iso9797,
      e_nonIsoIM
    };

#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_NonStandardParameter &() const;
#else
    operator H225_NonStandardParameter &();
    operator const H225_NonStandardParameter &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_NonIsoIntegrityMechanism &() const;
#else
    operator H225_NonIsoIntegrityMechanism &();
    operator const H225_NonIsoIntegrityMechanism &() const;
#endif

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ICV
//

class H225_ICV : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ICV, PASN_Sequence);
#endif
  public:
    H225_ICV(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_ObjectId m_algorithmOID;
    PASN_BitString m_icv;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// FastStartToken
//

class H225_FastStartToken : public H235_ClearToken
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_FastStartToken, H235_ClearToken);
#endif
  public:
    H225_FastStartToken(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    PObject * Clone() const;
};


//
// EncodedFastStartToken
//

typedef H225_FastStartToken H225_EncodedFastStartToken;


//
// CryptoH323Token
//

class H225_CryptoH323Token_cryptoEPPwdHash;
class H225_CryptoH323Token_cryptoGKPwdHash;
class H235_CryptoToken;

class H225_CryptoH323Token : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_CryptoH323Token, PASN_Choice);
#endif
  public:
    H225_CryptoH323Token(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_cryptoEPPwdHash,
      e_cryptoGKPwdHash,
      e_cryptoEPPwdEncr,
      e_cryptoGKPwdEncr,
      e_cryptoEPCert,
      e_cryptoGKCert,
      e_cryptoFastStart,
      e_nestedcryptoToken
    };

#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_CryptoH323Token_cryptoEPPwdHash &() const;
#else
    operator H225_CryptoH323Token_cryptoEPPwdHash &();
    operator const H225_CryptoH323Token_cryptoEPPwdHash &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_CryptoH323Token_cryptoGKPwdHash &() const;
#else
    operator H225_CryptoH323Token_cryptoGKPwdHash &();
    operator const H225_CryptoH323Token_cryptoGKPwdHash &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H235_ENCRYPTED<H235_EncodedPwdCertToken> &() const;
#else
    operator H235_ENCRYPTED<H235_EncodedPwdCertToken> &();
    operator const H235_ENCRYPTED<H235_EncodedPwdCertToken> &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H235_SIGNED<H235_EncodedPwdCertToken> &() const;
#else
    operator H235_SIGNED<H235_EncodedPwdCertToken> &();
    operator const H235_SIGNED<H235_EncodedPwdCertToken> &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H235_SIGNED<H225_EncodedFastStartToken> &() const;
#else
    operator H235_SIGNED<H225_EncodedFastStartToken> &();
    operator const H235_SIGNED<H225_EncodedFastStartToken> &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H235_CryptoToken &() const;
#else
    operator H235_CryptoToken &();
    operator const H235_CryptoToken &() const;
#endif

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// RasMessage
//

class H225_GatekeeperRequest;
class H225_GatekeeperConfirm;
class H225_GatekeeperReject;
class H225_RegistrationRequest;
class H225_RegistrationConfirm;
class H225_RegistrationReject;
class H225_UnregistrationRequest;
class H225_UnregistrationConfirm;
class H225_UnregistrationReject;
class H225_AdmissionRequest;
class H225_AdmissionConfirm;
class H225_AdmissionReject;
class H225_BandwidthRequest;
class H225_BandwidthConfirm;
class H225_BandwidthReject;
class H225_DisengageRequest;
class H225_DisengageConfirm;
class H225_DisengageReject;
class H225_LocationRequest;
class H225_LocationConfirm;
class H225_LocationReject;
class H225_InfoRequest;
class H225_InfoRequestResponse;
class H225_NonStandardMessage;
class H225_UnknownMessageResponse;
class H225_RequestInProgress;
class H225_ResourcesAvailableIndicate;
class H225_ResourcesAvailableConfirm;
class H225_InfoRequestAck;
class H225_InfoRequestNak;

class H225_RasMessage : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_RasMessage, PASN_Choice);
#endif
  public:
    H225_RasMessage(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_gatekeeperRequest,
      e_gatekeeperConfirm,
      e_gatekeeperReject,
      e_registrationRequest,
      e_registrationConfirm,
      e_registrationReject,
      e_unregistrationRequest,
      e_unregistrationConfirm,
      e_unregistrationReject,
      e_admissionRequest,
      e_admissionConfirm,
      e_admissionReject,
      e_bandwidthRequest,
      e_bandwidthConfirm,
      e_bandwidthReject,
      e_disengageRequest,
      e_disengageConfirm,
      e_disengageReject,
      e_locationRequest,
      e_locationConfirm,
      e_locationReject,
      e_infoRequest,
      e_infoRequestResponse,
      e_nonStandardMessage,
      e_unknownMessageResponse,
      e_requestInProgress,
      e_resourcesAvailableIndicate,
      e_resourcesAvailableConfirm,
      e_infoRequestAck,
      e_infoRequestNak
    };

#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_GatekeeperRequest &() const;
#else
    operator H225_GatekeeperRequest &();
    operator const H225_GatekeeperRequest &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_GatekeeperConfirm &() const;
#else
    operator H225_GatekeeperConfirm &();
    operator const H225_GatekeeperConfirm &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_GatekeeperReject &() const;
#else
    operator H225_GatekeeperReject &();
    operator const H225_GatekeeperReject &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_RegistrationRequest &() const;
#else
    operator H225_RegistrationRequest &();
    operator const H225_RegistrationRequest &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_RegistrationConfirm &() const;
#else
    operator H225_RegistrationConfirm &();
    operator const H225_RegistrationConfirm &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_RegistrationReject &() const;
#else
    operator H225_RegistrationReject &();
    operator const H225_RegistrationReject &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_UnregistrationRequest &() const;
#else
    operator H225_UnregistrationRequest &();
    operator const H225_UnregistrationRequest &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_UnregistrationConfirm &() const;
#else
    operator H225_UnregistrationConfirm &();
    operator const H225_UnregistrationConfirm &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_UnregistrationReject &() const;
#else
    operator H225_UnregistrationReject &();
    operator const H225_UnregistrationReject &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_AdmissionRequest &() const;
#else
    operator H225_AdmissionRequest &();
    operator const H225_AdmissionRequest &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_AdmissionConfirm &() const;
#else
    operator H225_AdmissionConfirm &();
    operator const H225_AdmissionConfirm &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_AdmissionReject &() const;
#else
    operator H225_AdmissionReject &();
    operator const H225_AdmissionReject &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_BandwidthRequest &() const;
#else
    operator H225_BandwidthRequest &();
    operator const H225_BandwidthRequest &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_BandwidthConfirm &() const;
#else
    operator H225_BandwidthConfirm &();
    operator const H225_BandwidthConfirm &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_BandwidthReject &() const;
#else
    operator H225_BandwidthReject &();
    operator const H225_BandwidthReject &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_DisengageRequest &() const;
#else
    operator H225_DisengageRequest &();
    operator const H225_DisengageRequest &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_DisengageConfirm &() const;
#else
    operator H225_DisengageConfirm &();
    operator const H225_DisengageConfirm &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_DisengageReject &() const;
#else
    operator H225_DisengageReject &();
    operator const H225_DisengageReject &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_LocationRequest &() const;
#else
    operator H225_LocationRequest &();
    operator const H225_LocationRequest &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_LocationConfirm &() const;
#else
    operator H225_LocationConfirm &();
    operator const H225_LocationConfirm &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_LocationReject &() const;
#else
    operator H225_LocationReject &();
    operator const H225_LocationReject &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_InfoRequest &() const;
#else
    operator H225_InfoRequest &();
    operator const H225_InfoRequest &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_InfoRequestResponse &() const;
#else
    operator H225_InfoRequestResponse &();
    operator const H225_InfoRequestResponse &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_NonStandardMessage &() const;
#else
    operator H225_NonStandardMessage &();
    operator const H225_NonStandardMessage &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_UnknownMessageResponse &() const;
#else
    operator H225_UnknownMessageResponse &();
    operator const H225_UnknownMessageResponse &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_RequestInProgress &() const;
#else
    operator H225_RequestInProgress &();
    operator const H225_RequestInProgress &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_ResourcesAvailableIndicate &() const;
#else
    operator H225_ResourcesAvailableIndicate &();
    operator const H225_ResourcesAvailableIndicate &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_ResourcesAvailableConfirm &() const;
#else
    operator H225_ResourcesAvailableConfirm &();
    operator const H225_ResourcesAvailableConfirm &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_InfoRequestAck &() const;
#else
    operator H225_InfoRequestAck &();
    operator const H225_InfoRequestAck &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_InfoRequestNak &() const;
#else
    operator H225_InfoRequestNak &();
    operator const H225_InfoRequestNak &() const;
#endif

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// GatekeeperRejectReason
//

class H225_GatekeeperRejectReason : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_GatekeeperRejectReason, PASN_Choice);
#endif
  public:
    H225_GatekeeperRejectReason(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_resourceUnavailable,
      e_terminalExcluded,
      e_invalidRevision,
      e_undefinedReason,
      e_securityDenial
    };

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// RegistrationRejectReason
//

class H225_ArrayOf_AliasAddress;

class H225_RegistrationRejectReason : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_RegistrationRejectReason, PASN_Choice);
#endif
  public:
    H225_RegistrationRejectReason(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_discoveryRequired,
      e_invalidRevision,
      e_invalidCallSignalAddress,
      e_invalidRASAddress,
      e_duplicateAlias,
      e_invalidTerminalType,
      e_undefinedReason,
      e_transportNotSupported,
      e_transportQOSNotSupported,
      e_resourceUnavailable,
      e_invalidAlias,
      e_securityDenial,
      e_fullRegistrationRequired
    };

#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_ArrayOf_AliasAddress &() const;
#else
    operator H225_ArrayOf_AliasAddress &();
    operator const H225_ArrayOf_AliasAddress &() const;
#endif

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// UnregRequestReason
//

class H225_UnregRequestReason : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_UnregRequestReason, PASN_Choice);
#endif
  public:
    H225_UnregRequestReason(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_reregistrationRequired,
      e_ttlExpired,
      e_securityDenial,
      e_undefinedReason
    };

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// UnregRejectReason
//

class H225_UnregRejectReason : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_UnregRejectReason, PASN_Choice);
#endif
  public:
    H225_UnregRejectReason(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_notCurrentlyRegistered,
      e_callInProgress,
      e_undefinedReason,
      e_permissionDenied,
      e_securityDenial
    };

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// CallType
//

class H225_CallType : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_CallType, PASN_Choice);
#endif
  public:
    H225_CallType(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_pointToPoint,
      e_oneToN,
      e_nToOne,
      e_nToN
    };

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// CallModel
//

class H225_CallModel : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_CallModel, PASN_Choice);
#endif
  public:
    H225_CallModel(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_direct,
      e_gatekeeperRouted
    };

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// TransportQOS
//

class H225_TransportQOS : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_TransportQOS, PASN_Choice);
#endif
  public:
    H225_TransportQOS(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_endpointControlled,
      e_gatekeeperControlled,
      e_noControl
    };

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// UUIEsRequested
//

class H225_UUIEsRequested : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_UUIEsRequested, PASN_Sequence);
#endif
  public:
    H225_UUIEsRequested(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Boolean m_setup;
    PASN_Boolean m_callProceeding;
    PASN_Boolean m_connect;
    PASN_Boolean m_alerting;
    PASN_Boolean m_information;
    PASN_Boolean m_releaseComplete;
    PASN_Boolean m_facility;
    PASN_Boolean m_progress;
    PASN_Boolean m_empty;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// AdmissionRejectReason
//

class H225_ArrayOf_PartyNumber;

class H225_AdmissionRejectReason : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_AdmissionRejectReason, PASN_Choice);
#endif
  public:
    H225_AdmissionRejectReason(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_calledPartyNotRegistered,
      e_invalidPermission,
      e_requestDenied,
      e_undefinedReason,
      e_callerNotRegistered,
      e_routeCallToGatekeeper,
      e_invalidEndpointIdentifier,
      e_resourceUnavailable,
      e_securityDenial,
      e_qosControlNotSupported,
      e_incompleteAddress,
      e_routeCallToSCN,
      e_aliasesInconsistent
    };

#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_ArrayOf_PartyNumber &() const;
#else
    operator H225_ArrayOf_PartyNumber &();
    operator const H225_ArrayOf_PartyNumber &() const;
#endif

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// BandRejectReason
//

class H225_BandRejectReason : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_BandRejectReason, PASN_Choice);
#endif
  public:
    H225_BandRejectReason(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_notBound,
      e_invalidConferenceID,
      e_invalidPermission,
      e_insufficientResources,
      e_invalidRevision,
      e_undefinedReason,
      e_securityDenial
    };

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// LocationRejectReason
//

class H225_ArrayOf_PartyNumber;

class H225_LocationRejectReason : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_LocationRejectReason, PASN_Choice);
#endif
  public:
    H225_LocationRejectReason(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_notRegistered,
      e_invalidPermission,
      e_requestDenied,
      e_undefinedReason,
      e_securityDenial,
      e_aliasesInconsistent,
      e_routeCallToSCN
    };

#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_ArrayOf_PartyNumber &() const;
#else
    operator H225_ArrayOf_PartyNumber &();
    operator const H225_ArrayOf_PartyNumber &() const;
#endif

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// DisengageReason
//

class H225_DisengageReason : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_DisengageReason, PASN_Choice);
#endif
  public:
    H225_DisengageReason(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_forcedDrop,
      e_normalDrop,
      e_undefinedReason
    };

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// DisengageRejectReason
//

class H225_DisengageRejectReason : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_DisengageRejectReason, PASN_Choice);
#endif
  public:
    H225_DisengageRejectReason(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_notRegistered,
      e_requestToDropOther,
      e_securityDenial
    };

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// TransportChannelInfo
//

class H225_TransportChannelInfo : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_TransportChannelInfo, PASN_Sequence);
#endif
  public:
    H225_TransportChannelInfo(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_sendAddress,
      e_recvAddress
    };

    H225_TransportAddress m_sendAddress;
    H225_TransportAddress m_recvAddress;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// InfoRequestNakReason
//

class H225_InfoRequestNakReason : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_InfoRequestNakReason, PASN_Choice);
#endif
  public:
    H225_InfoRequestNakReason(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_notRegistered,
      e_securityDenial,
      e_undefinedReason
    };

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// H323-UserInformation_user-data
//

class H225_H323_UserInformation_user_data : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_H323_UserInformation_user_data, PASN_Sequence);
#endif
  public:
    H225_H323_UserInformation_user_data(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Integer m_protocol_discriminator;
    PASN_OctetString m_user_information;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// H323-UU-PDU_h323-message-body
//

class H225_Setup_UUIE;
class H225_CallProceeding_UUIE;
class H225_Connect_UUIE;
class H225_Alerting_UUIE;
class H225_Information_UUIE;
class H225_ReleaseComplete_UUIE;
class H225_Facility_UUIE;
class H225_Progress_UUIE;

class H225_H323_UU_PDU_h323_message_body : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_H323_UU_PDU_h323_message_body, PASN_Choice);
#endif
  public:
    H225_H323_UU_PDU_h323_message_body(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_setup,
      e_callProceeding,
      e_connect,
      e_alerting,
      e_information,
      e_releaseComplete,
      e_facility,
      e_progress,
      e_empty
    };

#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_Setup_UUIE &() const;
#else
    operator H225_Setup_UUIE &();
    operator const H225_Setup_UUIE &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_CallProceeding_UUIE &() const;
#else
    operator H225_CallProceeding_UUIE &();
    operator const H225_CallProceeding_UUIE &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_Connect_UUIE &() const;
#else
    operator H225_Connect_UUIE &();
    operator const H225_Connect_UUIE &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_Alerting_UUIE &() const;
#else
    operator H225_Alerting_UUIE &();
    operator const H225_Alerting_UUIE &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_Information_UUIE &() const;
#else
    operator H225_Information_UUIE &();
    operator const H225_Information_UUIE &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_ReleaseComplete_UUIE &() const;
#else
    operator H225_ReleaseComplete_UUIE &();
    operator const H225_ReleaseComplete_UUIE &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_Facility_UUIE &() const;
#else
    operator H225_Facility_UUIE &();
    operator const H225_Facility_UUIE &() const;
#endif
#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
    operator H225_Progress_UUIE &() const;
#else
    operator H225_Progress_UUIE &();
    operator const H225_Progress_UUIE &() const;
#endif

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ArrayOf_PASN_OctetString
//

class H225_ArrayOf_PASN_OctetString : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ArrayOf_PASN_OctetString, PASN_Array);
#endif
  public:
    H225_ArrayOf_PASN_OctetString(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    PASN_OctetString & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ArrayOf_NonStandardParameter
//

class H225_NonStandardParameter;

class H225_ArrayOf_NonStandardParameter : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ArrayOf_NonStandardParameter, PASN_Array);
#endif
  public:
    H225_ArrayOf_NonStandardParameter(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    H225_NonStandardParameter & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ArrayOf_ClearToken
//

class H235_ClearToken;

class H225_ArrayOf_ClearToken : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ArrayOf_ClearToken, PASN_Array);
#endif
  public:
    H225_ArrayOf_ClearToken(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    H235_ClearToken & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ArrayOf_CryptoH323Token
//

class H225_CryptoH323Token;

class H225_ArrayOf_CryptoH323Token : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ArrayOf_CryptoH323Token, PASN_Array);
#endif
  public:
    H225_ArrayOf_CryptoH323Token(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    H225_CryptoH323Token & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ArrayOf_AliasAddress
//

class H225_AliasAddress;

class H225_ArrayOf_AliasAddress : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ArrayOf_AliasAddress, PASN_Array);
#endif
  public:
    H225_ArrayOf_AliasAddress(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    H225_AliasAddress & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// Connect-UUIE_language
//

class H225_Connect_UUIE_language : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_Connect_UUIE_language, PASN_Array);
#endif
  public:
    H225_Connect_UUIE_language(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    PASN_IA5String & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ArrayOf_CallReferenceValue
//

class H225_CallReferenceValue;

class H225_ArrayOf_CallReferenceValue : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ArrayOf_CallReferenceValue, PASN_Array);
#endif
  public:
    H225_ArrayOf_CallReferenceValue(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    H225_CallReferenceValue & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// Setup-UUIE_conferenceGoal
//

class H225_Setup_UUIE_conferenceGoal : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_Setup_UUIE_conferenceGoal, PASN_Choice);
#endif
  public:
    H225_Setup_UUIE_conferenceGoal(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_create,
      e_join,
      e_invite,
      e_capability_negotiation,
      e_callIndependentSupplementaryService
    };

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ArrayOf_H245Security
//

class H225_H245Security;

class H225_ArrayOf_H245Security : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ArrayOf_H245Security, PASN_Array);
#endif
  public:
    H225_ArrayOf_H245Security(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    H225_H245Security & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// Setup-UUIE_connectionParameters
//

class H225_Setup_UUIE_connectionParameters : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_Setup_UUIE_connectionParameters, PASN_Sequence);
#endif
  public:
    H225_Setup_UUIE_connectionParameters(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    H225_ScnConnectionType m_connectionType;
    PASN_Integer m_numberOfScnConnections;
    H225_ScnConnectionAggregation m_connectionAggregation;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// Setup-UUIE_language
//

class H225_Setup_UUIE_language : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_Setup_UUIE_language, PASN_Array);
#endif
  public:
    H225_Setup_UUIE_language(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    PASN_IA5String & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ArrayOf_ConferenceList
//

class H225_ConferenceList;

class H225_ArrayOf_ConferenceList : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ArrayOf_ConferenceList, PASN_Array);
#endif
  public:
    H225_ArrayOf_ConferenceList(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    H225_ConferenceList & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// TransportAddress_ipAddress
//

class H225_TransportAddress_ipAddress : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_TransportAddress_ipAddress, PASN_Sequence);
#endif
  public:
    H225_TransportAddress_ipAddress(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_OctetString m_ip;
    PASN_Integer m_port;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// TransportAddress_ipxAddress
//

class H225_TransportAddress_ipxAddress : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_TransportAddress_ipxAddress, PASN_Sequence);
#endif
  public:
    H225_TransportAddress_ipxAddress(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_OctetString m_node;
    PASN_OctetString m_netnum;
    PASN_OctetString m_port;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// TransportAddress_ip6Address
//

class H225_TransportAddress_ip6Address : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_TransportAddress_ip6Address, PASN_Sequence);
#endif
  public:
    H225_TransportAddress_ip6Address(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_OctetString m_ip;
    PASN_Integer m_port;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ArrayOf_SupportedProtocols
//

class H225_SupportedProtocols;

class H225_ArrayOf_SupportedProtocols : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ArrayOf_SupportedProtocols, PASN_Array);
#endif
  public:
    H225_ArrayOf_SupportedProtocols(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    H225_SupportedProtocols & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ArrayOf_DataRate
//

class H225_DataRate;

class H225_ArrayOf_DataRate : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ArrayOf_DataRate, PASN_Array);
#endif
  public:
    H225_ArrayOf_DataRate(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    H225_DataRate & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ArrayOf_SupportedPrefix
//

class H225_SupportedPrefix;

class H225_ArrayOf_SupportedPrefix : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ArrayOf_SupportedPrefix, PASN_Array);
#endif
  public:
    H225_ArrayOf_SupportedPrefix(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    H225_SupportedPrefix & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ArrayOf_TransportAddress
//

class H225_TransportAddress;

class H225_ArrayOf_TransportAddress : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ArrayOf_TransportAddress, PASN_Array);
#endif
  public:
    H225_ArrayOf_TransportAddress(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    H225_TransportAddress & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ArrayOf_AlternateGK
//

class H225_AlternateGK;

class H225_ArrayOf_AlternateGK : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ArrayOf_AlternateGK, PASN_Array);
#endif
  public:
    H225_ArrayOf_AlternateGK(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    H225_AlternateGK & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// CryptoH323Token_cryptoEPPwdHash
//

class H225_CryptoH323Token_cryptoEPPwdHash : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_CryptoH323Token_cryptoEPPwdHash, PASN_Sequence);
#endif
  public:
    H225_CryptoH323Token_cryptoEPPwdHash(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    H225_AliasAddress m_alias;
    H235_TimeStamp m_timeStamp;
    H235_HASHED<H235_EncodedPwdCertToken> m_token;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// CryptoH323Token_cryptoGKPwdHash
//

class H225_CryptoH323Token_cryptoGKPwdHash : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_CryptoH323Token_cryptoGKPwdHash, PASN_Sequence);
#endif
  public:
    H225_CryptoH323Token_cryptoGKPwdHash(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    H225_GatekeeperIdentifier m_gatekeeperId;
    H235_TimeStamp m_timeStamp;
    H235_HASHED<H235_EncodedPwdCertToken> m_token;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ArrayOf_Endpoint
//

class H225_Endpoint;

class H225_ArrayOf_Endpoint : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ArrayOf_Endpoint, PASN_Array);
#endif
  public:
    H225_ArrayOf_Endpoint(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    H225_Endpoint & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ArrayOf_AuthenticationMechanism
//

class H235_AuthenticationMechanism;

class H225_ArrayOf_AuthenticationMechanism : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ArrayOf_AuthenticationMechanism, PASN_Array);
#endif
  public:
    H225_ArrayOf_AuthenticationMechanism(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    H235_AuthenticationMechanism & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ArrayOf_PASN_ObjectId
//

class H225_ArrayOf_PASN_ObjectId : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ArrayOf_PASN_ObjectId, PASN_Array);
#endif
  public:
    H225_ArrayOf_PASN_ObjectId(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    PASN_ObjectId & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ArrayOf_IntegrityMechanism
//

class H225_IntegrityMechanism;

class H225_ArrayOf_IntegrityMechanism : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ArrayOf_IntegrityMechanism, PASN_Array);
#endif
  public:
    H225_ArrayOf_IntegrityMechanism(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    H225_IntegrityMechanism & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// AdmissionConfirm_language
//

class H225_AdmissionConfirm_language : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_AdmissionConfirm_language, PASN_Array);
#endif
  public:
    H225_AdmissionConfirm_language(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    PASN_IA5String & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ArrayOf_PartyNumber
//

class H225_PartyNumber;

class H225_ArrayOf_PartyNumber : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ArrayOf_PartyNumber, PASN_Array);
#endif
  public:
    H225_ArrayOf_PartyNumber(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    H225_PartyNumber & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// InfoRequestResponse_perCallInfo
//

class H225_InfoRequestResponse_perCallInfo_subtype;

class H225_InfoRequestResponse_perCallInfo : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_InfoRequestResponse_perCallInfo, PASN_Array);
#endif
  public:
    H225_InfoRequestResponse_perCallInfo(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    H225_InfoRequestResponse_perCallInfo_subtype & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// RTPSession_associatedSessionIds
//

class H225_RTPSession_associatedSessionIds : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_RTPSession_associatedSessionIds, PASN_Array);
#endif
  public:
    H225_RTPSession_associatedSessionIds(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    PASN_Integer & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// TransportAddress_ipSourceRoute_route
//

class H225_TransportAddress_ipSourceRoute_route : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_TransportAddress_ipSourceRoute_route, PASN_Array);
#endif
  public:
    H225_TransportAddress_ipSourceRoute_route(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    PASN_OctetString & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// TransportAddress_ipSourceRoute_routing
//

class H225_TransportAddress_ipSourceRoute_routing : public PASN_Choice
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_TransportAddress_ipSourceRoute_routing, PASN_Choice);
#endif
  public:
    H225_TransportAddress_ipSourceRoute_routing(unsigned tag = 0, TagClass tagClass = UniversalTagClass);

    enum Choices {
      e_strict,
      e_loose
    };

    BOOL CreateObject();

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ArrayOf_RTPSession
//

class H225_RTPSession;

class H225_ArrayOf_RTPSession : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ArrayOf_RTPSession, PASN_Array);
#endif
  public:
    H225_ArrayOf_RTPSession(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    H225_RTPSession & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ArrayOf_TransportChannelInfo
//

class H225_TransportChannelInfo;

class H225_ArrayOf_TransportChannelInfo : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ArrayOf_TransportChannelInfo, PASN_Array);
#endif
  public:
    H225_ArrayOf_TransportChannelInfo(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    H225_TransportChannelInfo & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ArrayOf_ConferenceIdentifier
//

class H225_ConferenceIdentifier;

class H225_ArrayOf_ConferenceIdentifier : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ArrayOf_ConferenceIdentifier, PASN_Array);
#endif
  public:
    H225_ArrayOf_ConferenceIdentifier(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    H225_ConferenceIdentifier & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// InfoRequestResponse_perCallInfo_subtype_pdu
//

class H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype;

class H225_InfoRequestResponse_perCallInfo_subtype_pdu : public PASN_Array
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_InfoRequestResponse_perCallInfo_subtype_pdu, PASN_Array);
#endif
  public:
    H225_InfoRequestResponse_perCallInfo_subtype_pdu(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Object * CreateObject() const;
    H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype & operator[](PINDEX i) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// Information-UUIE
//

class H225_Information_UUIE : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_Information_UUIE, PASN_Sequence);
#endif
  public:
    H225_Information_UUIE(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_callIdentifier,
      e_tokens,
      e_cryptoTokens,
      e_fastStart,
      e_fastConnectRefused
    };

    H225_ProtocolIdentifier m_protocolIdentifier;
    H225_CallIdentifier m_callIdentifier;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ArrayOf_PASN_OctetString m_fastStart;
    PASN_Null m_fastConnectRefused;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ReleaseComplete-UUIE
//

class H225_ReleaseComplete_UUIE : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ReleaseComplete_UUIE, PASN_Sequence);
#endif
  public:
    H225_ReleaseComplete_UUIE(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_reason,
      e_callIdentifier,
      e_tokens,
      e_cryptoTokens,
      e_busyAddress,
      e_presentationIndicator,
      e_screeningIndicator
    };

    H225_ProtocolIdentifier m_protocolIdentifier;
    H225_ReleaseCompleteReason m_reason;
    H225_CallIdentifier m_callIdentifier;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ArrayOf_AliasAddress m_busyAddress;
    H225_PresentationIndicator m_presentationIndicator;
    H225_ScreeningIndicator m_screeningIndicator;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// Facility-UUIE
//

class H225_Facility_UUIE : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_Facility_UUIE, PASN_Sequence);
#endif
  public:
    H225_Facility_UUIE(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_alternativeAddress,
      e_alternativeAliasAddress,
      e_conferenceID,
      e_callIdentifier,
      e_destExtraCallInfo,
      e_remoteExtensionAddress,
      e_tokens,
      e_cryptoTokens,
      e_conferences,
      e_h245Address,
      e_fastStart,
      e_multipleCalls,
      e_maintainConnection,
      e_fastConnectRefused
    };

    H225_ProtocolIdentifier m_protocolIdentifier;
    H225_TransportAddress m_alternativeAddress;
    H225_ArrayOf_AliasAddress m_alternativeAliasAddress;
    H225_ConferenceIdentifier m_conferenceID;
    H225_FacilityReason m_reason;
    H225_CallIdentifier m_callIdentifier;
    H225_ArrayOf_AliasAddress m_destExtraCallInfo;
    H225_AliasAddress m_remoteExtensionAddress;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ArrayOf_ConferenceList m_conferences;
    H225_TransportAddress m_h245Address;
    H225_ArrayOf_PASN_OctetString m_fastStart;
    PASN_Boolean m_multipleCalls;
    PASN_Boolean m_maintainConnection;
    PASN_Null m_fastConnectRefused;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// CallLinkage
//

class H225_CallLinkage : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_CallLinkage, PASN_Sequence);
#endif
  public:
    H225_CallLinkage(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_globalCallId,
      e_threadId
    };

    H225_GloballyUniqueID m_globalCallId;
    H225_GloballyUniqueID m_threadId;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// VendorIdentifier
//

class H225_VendorIdentifier : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_VendorIdentifier, PASN_Sequence);
#endif
  public:
    H225_VendorIdentifier(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_productId,
      e_versionId
    };

    H225_H221NonStandard m_vendor;
    PASN_OctetString m_productId;
    PASN_OctetString m_versionId;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// NonStandardParameter
//

class H225_NonStandardParameter : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_NonStandardParameter, PASN_Sequence);
#endif
  public:
    H225_NonStandardParameter(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    H225_NonStandardIdentifier m_nonStandardIdentifier;
    PASN_OctetString m_data;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// PublicPartyNumber
//

class H225_PublicPartyNumber : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_PublicPartyNumber, PASN_Sequence);
#endif
  public:
    H225_PublicPartyNumber(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    H225_PublicTypeOfNumber m_publicTypeOfNumber;
    H225_NumberDigits m_publicNumberDigits;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// PrivatePartyNumber
//

class H225_PrivatePartyNumber : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_PrivatePartyNumber, PASN_Sequence);
#endif
  public:
    H225_PrivatePartyNumber(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    H225_PrivateTypeOfNumber m_privateTypeOfNumber;
    H225_NumberDigits m_privateNumberDigits;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// AlternateTransportAddresses
//

class H225_AlternateTransportAddresses : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_AlternateTransportAddresses, PASN_Sequence);
#endif
  public:
    H225_AlternateTransportAddresses(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_annexE
    };

    H225_ArrayOf_TransportAddress m_annexE;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// AlternateGK
//

class H225_AlternateGK : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_AlternateGK, PASN_Sequence);
#endif
  public:
    H225_AlternateGK(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_gatekeeperIdentifier
    };

    H225_TransportAddress m_rasAddress;
    H225_GatekeeperIdentifier m_gatekeeperIdentifier;
    PASN_Boolean m_needToRegister;
    PASN_Integer m_priority;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// AltGKInfo
//

class H225_AltGKInfo : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_AltGKInfo, PASN_Sequence);
#endif
  public:
    H225_AltGKInfo(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    H225_ArrayOf_AlternateGK m_alternateGatekeeper;
    PASN_Boolean m_altGKisPermanent;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// SecurityCapabilities
//

class H225_SecurityCapabilities : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_SecurityCapabilities, PASN_Sequence);
#endif
  public:
    H225_SecurityCapabilities(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandard
    };

    H225_NonStandardParameter m_nonStandard;
    H225_SecurityServiceMode m_encryption;
    H225_SecurityServiceMode m_authenticaton;
    H225_SecurityServiceMode m_integrity;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// QseriesOptions
//

class H225_QseriesOptions : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_QseriesOptions, PASN_Sequence);
#endif
  public:
    H225_QseriesOptions(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_Boolean m_q932Full;
    PASN_Boolean m_q951Full;
    PASN_Boolean m_q952Full;
    PASN_Boolean m_q953Full;
    PASN_Boolean m_q955Full;
    PASN_Boolean m_q956Full;
    PASN_Boolean m_q957Full;
    H225_Q954Details m_q954Info;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// DataRate
//

class H225_DataRate : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_DataRate, PASN_Sequence);
#endif
  public:
    H225_DataRate(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_channelMultiplier
    };

    H225_NonStandardParameter m_nonStandardData;
    H225_BandWidth m_channelRate;
    PASN_Integer m_channelMultiplier;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// SupportedPrefix
//

class H225_SupportedPrefix : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_SupportedPrefix, PASN_Sequence);
#endif
  public:
    H225_SupportedPrefix(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData
    };

    H225_NonStandardParameter m_nonStandardData;
    H225_AliasAddress m_prefix;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// GatekeeperConfirm
//

class H225_GatekeeperConfirm : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_GatekeeperConfirm, PASN_Sequence);
#endif
  public:
    H225_GatekeeperConfirm(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_gatekeeperIdentifier,
      e_alternateGatekeeper,
      e_authenticationMode,
      e_tokens,
      e_cryptoTokens,
      e_algorithmOID,
      e_integrity,
      e_integrityCheckValue
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_ProtocolIdentifier m_protocolIdentifier;
    H225_NonStandardParameter m_nonStandardData;
    H225_GatekeeperIdentifier m_gatekeeperIdentifier;
    H225_TransportAddress m_rasAddress;
    H225_ArrayOf_AlternateGK m_alternateGatekeeper;
    H235_AuthenticationMechanism m_authenticationMode;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    PASN_ObjectId m_algorithmOID;
    H225_ArrayOf_IntegrityMechanism m_integrity;
    H225_ICV m_integrityCheckValue;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// GatekeeperReject
//

class H225_GatekeeperReject : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_GatekeeperReject, PASN_Sequence);
#endif
  public:
    H225_GatekeeperReject(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_gatekeeperIdentifier,
      e_altGKInfo,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_ProtocolIdentifier m_protocolIdentifier;
    H225_NonStandardParameter m_nonStandardData;
    H225_GatekeeperIdentifier m_gatekeeperIdentifier;
    H225_GatekeeperRejectReason m_rejectReason;
    H225_AltGKInfo m_altGKInfo;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// RegistrationReject
//

class H225_RegistrationReject : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_RegistrationReject, PASN_Sequence);
#endif
  public:
    H225_RegistrationReject(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_gatekeeperIdentifier,
      e_altGKInfo,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_ProtocolIdentifier m_protocolIdentifier;
    H225_NonStandardParameter m_nonStandardData;
    H225_RegistrationRejectReason m_rejectReason;
    H225_GatekeeperIdentifier m_gatekeeperIdentifier;
    H225_AltGKInfo m_altGKInfo;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// UnregistrationRequest
//

class H225_UnregistrationRequest : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_UnregistrationRequest, PASN_Sequence);
#endif
  public:
    H225_UnregistrationRequest(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_endpointAlias,
      e_nonStandardData,
      e_endpointIdentifier,
      e_alternateEndpoints,
      e_gatekeeperIdentifier,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue,
      e_reason
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_ArrayOf_TransportAddress m_callSignalAddress;
    H225_ArrayOf_AliasAddress m_endpointAlias;
    H225_NonStandardParameter m_nonStandardData;
    H225_EndpointIdentifier m_endpointIdentifier;
    H225_ArrayOf_Endpoint m_alternateEndpoints;
    H225_GatekeeperIdentifier m_gatekeeperIdentifier;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;
    H225_UnregRequestReason m_reason;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// UnregistrationConfirm
//

class H225_UnregistrationConfirm : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_UnregistrationConfirm, PASN_Sequence);
#endif
  public:
    H225_UnregistrationConfirm(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_NonStandardParameter m_nonStandardData;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// UnregistrationReject
//

class H225_UnregistrationReject : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_UnregistrationReject, PASN_Sequence);
#endif
  public:
    H225_UnregistrationReject(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_altGKInfo,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_UnregRejectReason m_rejectReason;
    H225_NonStandardParameter m_nonStandardData;
    H225_AltGKInfo m_altGKInfo;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// AdmissionRequest
//

class H225_AdmissionRequest : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_AdmissionRequest, PASN_Sequence);
#endif
  public:
    H225_AdmissionRequest(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_callModel,
      e_destinationInfo,
      e_destCallSignalAddress,
      e_destExtraCallInfo,
      e_srcCallSignalAddress,
      e_nonStandardData,
      e_callServices,
      e_canMapAlias,
      e_callIdentifier,
      e_srcAlternatives,
      e_destAlternatives,
      e_gatekeeperIdentifier,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue,
      e_transportQOS,
      e_willSupplyUUIEs,
      e_callLinkage
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_CallType m_callType;
    H225_CallModel m_callModel;
    H225_EndpointIdentifier m_endpointIdentifier;
    H225_ArrayOf_AliasAddress m_destinationInfo;
    H225_TransportAddress m_destCallSignalAddress;
    H225_ArrayOf_AliasAddress m_destExtraCallInfo;
    H225_ArrayOf_AliasAddress m_srcInfo;
    H225_TransportAddress m_srcCallSignalAddress;
    H225_BandWidth m_bandWidth;
    H225_CallReferenceValue m_callReferenceValue;
    H225_NonStandardParameter m_nonStandardData;
    H225_QseriesOptions m_callServices;
    H225_ConferenceIdentifier m_conferenceID;
    PASN_Boolean m_activeMC;
    PASN_Boolean m_answerCall;
    PASN_Boolean m_canMapAlias;
    H225_CallIdentifier m_callIdentifier;
    H225_ArrayOf_Endpoint m_srcAlternatives;
    H225_ArrayOf_Endpoint m_destAlternatives;
    H225_GatekeeperIdentifier m_gatekeeperIdentifier;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;
    H225_TransportQOS m_transportQOS;
    PASN_Boolean m_willSupplyUUIEs;
    H225_CallLinkage m_callLinkage;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// AdmissionReject
//

class H225_AdmissionReject : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_AdmissionReject, PASN_Sequence);
#endif
  public:
    H225_AdmissionReject(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_altGKInfo,
      e_tokens,
      e_cryptoTokens,
      e_callSignalAddress,
      e_integrityCheckValue
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_AdmissionRejectReason m_rejectReason;
    H225_NonStandardParameter m_nonStandardData;
    H225_AltGKInfo m_altGKInfo;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ArrayOf_TransportAddress m_callSignalAddress;
    H225_ICV m_integrityCheckValue;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// BandwidthRequest
//

class H225_BandwidthRequest : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_BandwidthRequest, PASN_Sequence);
#endif
  public:
    H225_BandwidthRequest(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_callType,
      e_nonStandardData,
      e_callIdentifier,
      e_gatekeeperIdentifier,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue,
      e_answeredCall,
      e_callLinkage
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_EndpointIdentifier m_endpointIdentifier;
    H225_ConferenceIdentifier m_conferenceID;
    H225_CallReferenceValue m_callReferenceValue;
    H225_CallType m_callType;
    H225_BandWidth m_bandWidth;
    H225_NonStandardParameter m_nonStandardData;
    H225_CallIdentifier m_callIdentifier;
    H225_GatekeeperIdentifier m_gatekeeperIdentifier;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;
    PASN_Boolean m_answeredCall;
    H225_CallLinkage m_callLinkage;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// BandwidthConfirm
//

class H225_BandwidthConfirm : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_BandwidthConfirm, PASN_Sequence);
#endif
  public:
    H225_BandwidthConfirm(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_BandWidth m_bandWidth;
    H225_NonStandardParameter m_nonStandardData;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// BandwidthReject
//

class H225_BandwidthReject : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_BandwidthReject, PASN_Sequence);
#endif
  public:
    H225_BandwidthReject(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_altGKInfo,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_BandRejectReason m_rejectReason;
    H225_BandWidth m_allowedBandWidth;
    H225_NonStandardParameter m_nonStandardData;
    H225_AltGKInfo m_altGKInfo;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// LocationRequest
//

class H225_LocationRequest : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_LocationRequest, PASN_Sequence);
#endif
  public:
    H225_LocationRequest(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_endpointIdentifier,
      e_nonStandardData,
      e_sourceInfo,
      e_canMapAlias,
      e_gatekeeperIdentifier,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_EndpointIdentifier m_endpointIdentifier;
    H225_ArrayOf_AliasAddress m_destinationInfo;
    H225_NonStandardParameter m_nonStandardData;
    H225_TransportAddress m_replyAddress;
    H225_ArrayOf_AliasAddress m_sourceInfo;
    PASN_Boolean m_canMapAlias;
    H225_GatekeeperIdentifier m_gatekeeperIdentifier;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// LocationReject
//

class H225_LocationReject : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_LocationReject, PASN_Sequence);
#endif
  public:
    H225_LocationReject(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_altGKInfo,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_LocationRejectReason m_rejectReason;
    H225_NonStandardParameter m_nonStandardData;
    H225_AltGKInfo m_altGKInfo;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// DisengageRequest
//

class H225_DisengageRequest : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_DisengageRequest, PASN_Sequence);
#endif
  public:
    H225_DisengageRequest(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_callIdentifier,
      e_gatekeeperIdentifier,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue,
      e_answeredCall,
      e_callLinkage
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_EndpointIdentifier m_endpointIdentifier;
    H225_ConferenceIdentifier m_conferenceID;
    H225_CallReferenceValue m_callReferenceValue;
    H225_DisengageReason m_disengageReason;
    H225_NonStandardParameter m_nonStandardData;
    H225_CallIdentifier m_callIdentifier;
    H225_GatekeeperIdentifier m_gatekeeperIdentifier;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;
    PASN_Boolean m_answeredCall;
    H225_CallLinkage m_callLinkage;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// DisengageConfirm
//

class H225_DisengageConfirm : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_DisengageConfirm, PASN_Sequence);
#endif
  public:
    H225_DisengageConfirm(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_NonStandardParameter m_nonStandardData;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// DisengageReject
//

class H225_DisengageReject : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_DisengageReject, PASN_Sequence);
#endif
  public:
    H225_DisengageReject(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_altGKInfo,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_DisengageRejectReason m_rejectReason;
    H225_NonStandardParameter m_nonStandardData;
    H225_AltGKInfo m_altGKInfo;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// InfoRequest
//

class H225_InfoRequest : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_InfoRequest, PASN_Sequence);
#endif
  public:
    H225_InfoRequest(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_replyAddress,
      e_callIdentifier,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue,
      e_uuiesRequested,
      e_callLinkage
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_CallReferenceValue m_callReferenceValue;
    H225_NonStandardParameter m_nonStandardData;
    H225_TransportAddress m_replyAddress;
    H225_CallIdentifier m_callIdentifier;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;
    H225_UUIEsRequested m_uuiesRequested;
    H225_CallLinkage m_callLinkage;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// RTPSession
//

class H225_RTPSession : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_RTPSession, PASN_Sequence);
#endif
  public:
    H225_RTPSession(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    H225_TransportChannelInfo m_rtpAddress;
    H225_TransportChannelInfo m_rtcpAddress;
    PASN_PrintableString m_cname;
    PASN_Integer m_ssrc;
    PASN_Integer m_sessionId;
    H225_RTPSession_associatedSessionIds m_associatedSessionIds;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// InfoRequestAck
//

class H225_InfoRequestAck : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_InfoRequestAck, PASN_Sequence);
#endif
  public:
    H225_InfoRequestAck(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_NonStandardParameter m_nonStandardData;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// InfoRequestNak
//

class H225_InfoRequestNak : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_InfoRequestNak, PASN_Sequence);
#endif
  public:
    H225_InfoRequestNak(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_altGKInfo,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_NonStandardParameter m_nonStandardData;
    H225_InfoRequestNakReason m_nakReason;
    H225_AltGKInfo m_altGKInfo;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// NonStandardMessage
//

class H225_NonStandardMessage : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_NonStandardMessage, PASN_Sequence);
#endif
  public:
    H225_NonStandardMessage(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_NonStandardParameter m_nonStandardData;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// UnknownMessageResponse
//

class H225_UnknownMessageResponse : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_UnknownMessageResponse, PASN_Sequence);
#endif
  public:
    H225_UnknownMessageResponse(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// RequestInProgress
//

class H225_RequestInProgress : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_RequestInProgress, PASN_Sequence);
#endif
  public:
    H225_RequestInProgress(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_NonStandardParameter m_nonStandardData;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;
    PASN_Integer m_delay;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ResourcesAvailableIndicate
//

class H225_ResourcesAvailableIndicate : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ResourcesAvailableIndicate, PASN_Sequence);
#endif
  public:
    H225_ResourcesAvailableIndicate(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_ProtocolIdentifier m_protocolIdentifier;
    H225_NonStandardParameter m_nonStandardData;
    H225_EndpointIdentifier m_endpointIdentifier;
    H225_ArrayOf_SupportedProtocols m_protocols;
    PASN_Boolean m_almostOutOfResources;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ResourcesAvailableConfirm
//

class H225_ResourcesAvailableConfirm : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ResourcesAvailableConfirm, PASN_Sequence);
#endif
  public:
    H225_ResourcesAvailableConfirm(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_ProtocolIdentifier m_protocolIdentifier;
    H225_NonStandardParameter m_nonStandardData;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// TransportAddress_ipSourceRoute
//

class H225_TransportAddress_ipSourceRoute : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_TransportAddress_ipSourceRoute, PASN_Sequence);
#endif
  public:
    H225_TransportAddress_ipSourceRoute(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    PASN_OctetString m_ip;
    PASN_Integer m_port;
    H225_TransportAddress_ipSourceRoute_route m_route;
    H225_TransportAddress_ipSourceRoute_routing m_routing;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// RegistrationConfirm_preGrantedARQ
//

class H225_RegistrationConfirm_preGrantedARQ : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_RegistrationConfirm_preGrantedARQ, PASN_Sequence);
#endif
  public:
    H225_RegistrationConfirm_preGrantedARQ(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_irrFrequencyInCall,
      e_totalBandwidthRestriction,
      e_alternateTransportAddresses,
      e_useSpecifiedTransport
    };

    PASN_Boolean m_makeCall;
    PASN_Boolean m_useGKCallSignalAddressToMakeCall;
    PASN_Boolean m_answerCall;
    PASN_Boolean m_useGKCallSignalAddressToAnswer;
    PASN_Integer m_irrFrequencyInCall;
    H225_BandWidth m_totalBandwidthRestriction;
    H225_AlternateTransportAddresses m_alternateTransportAddresses;
    H225_UseSpecifiedTransport m_useSpecifiedTransport;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// InfoRequestResponse_perCallInfo_subtype
//

class H225_InfoRequestResponse_perCallInfo_subtype : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_InfoRequestResponse_perCallInfo_subtype, PASN_Sequence);
#endif
  public:
    H225_InfoRequestResponse_perCallInfo_subtype(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_originator,
      e_audio,
      e_video,
      e_data,
      e_callIdentifier,
      e_tokens,
      e_cryptoTokens,
      e_substituteConfIDs,
      e_pdu,
      e_callLinkage
    };

    H225_NonStandardParameter m_nonStandardData;
    H225_CallReferenceValue m_callReferenceValue;
    H225_ConferenceIdentifier m_conferenceID;
    PASN_Boolean m_originator;
    H225_ArrayOf_RTPSession m_audio;
    H225_ArrayOf_RTPSession m_video;
    H225_ArrayOf_TransportChannelInfo m_data;
    H225_TransportChannelInfo m_h245;
    H225_TransportChannelInfo m_callSignaling;
    H225_CallType m_callType;
    H225_BandWidth m_bandWidth;
    H225_CallModel m_callModel;
    H225_CallIdentifier m_callIdentifier;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ArrayOf_ConferenceIdentifier m_substituteConfIDs;
    H225_InfoRequestResponse_perCallInfo_subtype_pdu m_pdu;
    H225_CallLinkage m_callLinkage;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// H323-UU-PDU
//

class H225_H323_UU_PDU : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_H323_UU_PDU, PASN_Sequence);
#endif
  public:
    H225_H323_UU_PDU(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_h4501SupplementaryService,
      e_h245Tunneling,
      e_h245Control,
      e_nonStandardControl,
      e_callLinkage
    };

    H225_H323_UU_PDU_h323_message_body m_h323_message_body;
    H225_NonStandardParameter m_nonStandardData;
    H225_ArrayOf_PASN_OctetString m_h4501SupplementaryService;
    PASN_Boolean m_h245Tunneling;
    H225_ArrayOf_PASN_OctetString m_h245Control;
    H225_ArrayOf_NonStandardParameter m_nonStandardControl;
    H225_CallLinkage m_callLinkage;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// ConferenceList
//

class H225_ConferenceList : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_ConferenceList, PASN_Sequence);
#endif
  public:
    H225_ConferenceList(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_conferenceID,
      e_conferenceAlias,
      e_nonStandardData
    };

    H225_ConferenceIdentifier m_conferenceID;
    H225_AliasAddress m_conferenceAlias;
    H225_NonStandardParameter m_nonStandardData;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// GatewayInfo
//

class H225_GatewayInfo : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_GatewayInfo, PASN_Sequence);
#endif
  public:
    H225_GatewayInfo(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_protocol,
      e_nonStandardData
    };

    H225_ArrayOf_SupportedProtocols m_protocol;
    H225_NonStandardParameter m_nonStandardData;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// H310Caps
//

class H225_H310Caps : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_H310Caps, PASN_Sequence);
#endif
  public:
    H225_H310Caps(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_dataRatesSupported,
      e_supportedPrefixes
    };

    H225_NonStandardParameter m_nonStandardData;
    H225_ArrayOf_DataRate m_dataRatesSupported;
    H225_ArrayOf_SupportedPrefix m_supportedPrefixes;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// H320Caps
//

class H225_H320Caps : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_H320Caps, PASN_Sequence);
#endif
  public:
    H225_H320Caps(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_dataRatesSupported,
      e_supportedPrefixes
    };

    H225_NonStandardParameter m_nonStandardData;
    H225_ArrayOf_DataRate m_dataRatesSupported;
    H225_ArrayOf_SupportedPrefix m_supportedPrefixes;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// H321Caps
//

class H225_H321Caps : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_H321Caps, PASN_Sequence);
#endif
  public:
    H225_H321Caps(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_dataRatesSupported,
      e_supportedPrefixes
    };

    H225_NonStandardParameter m_nonStandardData;
    H225_ArrayOf_DataRate m_dataRatesSupported;
    H225_ArrayOf_SupportedPrefix m_supportedPrefixes;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// H322Caps
//

class H225_H322Caps : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_H322Caps, PASN_Sequence);
#endif
  public:
    H225_H322Caps(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_dataRatesSupported,
      e_supportedPrefixes
    };

    H225_NonStandardParameter m_nonStandardData;
    H225_ArrayOf_DataRate m_dataRatesSupported;
    H225_ArrayOf_SupportedPrefix m_supportedPrefixes;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// H323Caps
//

class H225_H323Caps : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_H323Caps, PASN_Sequence);
#endif
  public:
    H225_H323Caps(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_dataRatesSupported,
      e_supportedPrefixes
    };

    H225_NonStandardParameter m_nonStandardData;
    H225_ArrayOf_DataRate m_dataRatesSupported;
    H225_ArrayOf_SupportedPrefix m_supportedPrefixes;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// H324Caps
//

class H225_H324Caps : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_H324Caps, PASN_Sequence);
#endif
  public:
    H225_H324Caps(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_dataRatesSupported,
      e_supportedPrefixes
    };

    H225_NonStandardParameter m_nonStandardData;
    H225_ArrayOf_DataRate m_dataRatesSupported;
    H225_ArrayOf_SupportedPrefix m_supportedPrefixes;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// VoiceCaps
//

class H225_VoiceCaps : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_VoiceCaps, PASN_Sequence);
#endif
  public:
    H225_VoiceCaps(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_dataRatesSupported,
      e_supportedPrefixes
    };

    H225_NonStandardParameter m_nonStandardData;
    H225_ArrayOf_DataRate m_dataRatesSupported;
    H225_ArrayOf_SupportedPrefix m_supportedPrefixes;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// T120OnlyCaps
//

class H225_T120OnlyCaps : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_T120OnlyCaps, PASN_Sequence);
#endif
  public:
    H225_T120OnlyCaps(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_dataRatesSupported,
      e_supportedPrefixes
    };

    H225_NonStandardParameter m_nonStandardData;
    H225_ArrayOf_DataRate m_dataRatesSupported;
    H225_ArrayOf_SupportedPrefix m_supportedPrefixes;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// NonStandardProtocol
//

class H225_NonStandardProtocol : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_NonStandardProtocol, PASN_Sequence);
#endif
  public:
    H225_NonStandardProtocol(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_dataRatesSupported
    };

    H225_NonStandardParameter m_nonStandardData;
    H225_ArrayOf_DataRate m_dataRatesSupported;
    H225_ArrayOf_SupportedPrefix m_supportedPrefixes;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// T38FaxAnnexbOnlyCaps
//

class H225_T38FaxAnnexbOnlyCaps : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_T38FaxAnnexbOnlyCaps, PASN_Sequence);
#endif
  public:
    H225_T38FaxAnnexbOnlyCaps(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_dataRatesSupported
    };

    H225_NonStandardParameter m_nonStandardData;
    H225_ArrayOf_DataRate m_dataRatesSupported;
    H225_ArrayOf_SupportedPrefix m_supportedPrefixes;
    H245_DataProtocolCapability m_t38FaxProtocol;
    H245_T38FaxProfile m_t38FaxProfile;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// McuInfo
//

class H225_McuInfo : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_McuInfo, PASN_Sequence);
#endif
  public:
    H225_McuInfo(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData
    };

    H225_NonStandardParameter m_nonStandardData;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// TerminalInfo
//

class H225_TerminalInfo : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_TerminalInfo, PASN_Sequence);
#endif
  public:
    H225_TerminalInfo(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData
    };

    H225_NonStandardParameter m_nonStandardData;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// GatekeeperInfo
//

class H225_GatekeeperInfo : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_GatekeeperInfo, PASN_Sequence);
#endif
  public:
    H225_GatekeeperInfo(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData
    };

    H225_NonStandardParameter m_nonStandardData;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// RegistrationConfirm
//

class H225_RegistrationConfirm : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_RegistrationConfirm, PASN_Sequence);
#endif
  public:
    H225_RegistrationConfirm(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_terminalAlias,
      e_gatekeeperIdentifier,
      e_alternateGatekeeper,
      e_timeToLive,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue,
      e_willRespondToIRR,
      e_preGrantedARQ,
      e_maintainConnection
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_ProtocolIdentifier m_protocolIdentifier;
    H225_NonStandardParameter m_nonStandardData;
    H225_ArrayOf_TransportAddress m_callSignalAddress;
    H225_ArrayOf_AliasAddress m_terminalAlias;
    H225_GatekeeperIdentifier m_gatekeeperIdentifier;
    H225_EndpointIdentifier m_endpointIdentifier;
    H225_ArrayOf_AlternateGK m_alternateGatekeeper;
    H225_TimeToLive m_timeToLive;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;
    PASN_Boolean m_willRespondToIRR;
    H225_RegistrationConfirm_preGrantedARQ m_preGrantedARQ;
    PASN_Boolean m_maintainConnection;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// InfoRequestResponse_perCallInfo_subtype_pdu_subtype
//

class H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype, PASN_Sequence);
#endif
  public:
    H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    H225_H323_UU_PDU m_h323pdu;
    PASN_Boolean m_sent;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// H323-UserInformation
//

class H225_H323_UserInformation : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_H323_UserInformation, PASN_Sequence);
#endif
  public:
    H225_H323_UserInformation(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_user_data
    };

    H225_H323_UU_PDU m_h323_uu_pdu;
    H225_H323_UserInformation_user_data m_user_data;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// EndpointType
//

class H225_EndpointType : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_EndpointType, PASN_Sequence);
#endif
  public:
    H225_EndpointType(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_vendor,
      e_gatekeeper,
      e_gateway,
      e_mcu,
      e_terminal,
      e_set
    };

    H225_NonStandardParameter m_nonStandardData;
    H225_VendorIdentifier m_vendor;
    H225_GatekeeperInfo m_gatekeeper;
    H225_GatewayInfo m_gateway;
    H225_McuInfo m_mcu;
    H225_TerminalInfo m_terminal;
    PASN_Boolean m_mc;
    PASN_Boolean m_undefinedNode;
    PASN_BitString m_set;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// Endpoint
//

class H225_Endpoint : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_Endpoint, PASN_Sequence);
#endif
  public:
    H225_Endpoint(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_aliasAddress,
      e_callSignalAddress,
      e_rasAddress,
      e_endpointType,
      e_tokens,
      e_cryptoTokens,
      e_priority,
      e_remoteExtensionAddress,
      e_destExtraCallInfo,
      e_alternateTransportAddresses
    };

    H225_NonStandardParameter m_nonStandardData;
    H225_ArrayOf_AliasAddress m_aliasAddress;
    H225_ArrayOf_TransportAddress m_callSignalAddress;
    H225_ArrayOf_TransportAddress m_rasAddress;
    H225_EndpointType m_endpointType;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    PASN_Integer m_priority;
    H225_ArrayOf_AliasAddress m_remoteExtensionAddress;
    H225_ArrayOf_AliasAddress m_destExtraCallInfo;
    H225_AlternateTransportAddresses m_alternateTransportAddresses;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// GatekeeperRequest
//

class H225_GatekeeperRequest : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_GatekeeperRequest, PASN_Sequence);
#endif
  public:
    H225_GatekeeperRequest(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_gatekeeperIdentifier,
      e_callServices,
      e_endpointAlias,
      e_alternateEndpoints,
      e_tokens,
      e_cryptoTokens,
      e_authenticationCapability,
      e_algorithmOIDs,
      e_integrity,
      e_integrityCheckValue
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_ProtocolIdentifier m_protocolIdentifier;
    H225_NonStandardParameter m_nonStandardData;
    H225_TransportAddress m_rasAddress;
    H225_EndpointType m_endpointType;
    H225_GatekeeperIdentifier m_gatekeeperIdentifier;
    H225_QseriesOptions m_callServices;
    H225_ArrayOf_AliasAddress m_endpointAlias;
    H225_ArrayOf_Endpoint m_alternateEndpoints;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ArrayOf_AuthenticationMechanism m_authenticationCapability;
    H225_ArrayOf_PASN_ObjectId m_algorithmOIDs;
    H225_ArrayOf_IntegrityMechanism m_integrity;
    H225_ICV m_integrityCheckValue;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// RegistrationRequest
//

class H225_RegistrationRequest : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_RegistrationRequest, PASN_Sequence);
#endif
  public:
    H225_RegistrationRequest(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_terminalAlias,
      e_gatekeeperIdentifier,
      e_alternateEndpoints,
      e_timeToLive,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue,
      e_keepAlive,
      e_endpointIdentifier,
      e_willSupplyUUIEs,
      e_maintainConnection,
      e_alternateTransportAddresses
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_ProtocolIdentifier m_protocolIdentifier;
    H225_NonStandardParameter m_nonStandardData;
    PASN_Boolean m_discoveryComplete;
    H225_ArrayOf_TransportAddress m_callSignalAddress;
    H225_ArrayOf_TransportAddress m_rasAddress;
    H225_EndpointType m_terminalType;
    H225_ArrayOf_AliasAddress m_terminalAlias;
    H225_GatekeeperIdentifier m_gatekeeperIdentifier;
    H225_VendorIdentifier m_endpointVendor;
    H225_ArrayOf_Endpoint m_alternateEndpoints;
    H225_TimeToLive m_timeToLive;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;
    PASN_Boolean m_keepAlive;
    H225_EndpointIdentifier m_endpointIdentifier;
    PASN_Boolean m_willSupplyUUIEs;
    PASN_Boolean m_maintainConnection;
    H225_AlternateTransportAddresses m_alternateTransportAddresses;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// AdmissionConfirm
//

class H225_AdmissionConfirm : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_AdmissionConfirm, PASN_Sequence);
#endif
  public:
    H225_AdmissionConfirm(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_irrFrequency,
      e_nonStandardData,
      e_destinationInfo,
      e_destExtraCallInfo,
      e_destinationType,
      e_remoteExtensionAddress,
      e_alternateEndpoints,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue,
      e_transportQOS,
      e_willRespondToIRR,
      e_uuiesRequested,
      e_language,
      e_alternateTransportAddresses,
      e_useSpecifiedTransport
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_BandWidth m_bandWidth;
    H225_CallModel m_callModel;
    H225_TransportAddress m_destCallSignalAddress;
    PASN_Integer m_irrFrequency;
    H225_NonStandardParameter m_nonStandardData;
    H225_ArrayOf_AliasAddress m_destinationInfo;
    H225_ArrayOf_AliasAddress m_destExtraCallInfo;
    H225_EndpointType m_destinationType;
    H225_ArrayOf_AliasAddress m_remoteExtensionAddress;
    H225_ArrayOf_Endpoint m_alternateEndpoints;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;
    H225_TransportQOS m_transportQOS;
    PASN_Boolean m_willRespondToIRR;
    H225_UUIEsRequested m_uuiesRequested;
    H225_AdmissionConfirm_language m_language;
    H225_AlternateTransportAddresses m_alternateTransportAddresses;
    H225_UseSpecifiedTransport m_useSpecifiedTransport;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// LocationConfirm
//

class H225_LocationConfirm : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_LocationConfirm, PASN_Sequence);
#endif
  public:
    H225_LocationConfirm(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_destinationInfo,
      e_destExtraCallInfo,
      e_destinationType,
      e_remoteExtensionAddress,
      e_alternateEndpoints,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue,
      e_alternateTransportAddresses
    };

    H225_RequestSeqNum m_requestSeqNum;
    H225_TransportAddress m_callSignalAddress;
    H225_TransportAddress m_rasAddress;
    H225_NonStandardParameter m_nonStandardData;
    H225_ArrayOf_AliasAddress m_destinationInfo;
    H225_ArrayOf_AliasAddress m_destExtraCallInfo;
    H225_EndpointType m_destinationType;
    H225_ArrayOf_AliasAddress m_remoteExtensionAddress;
    H225_ArrayOf_Endpoint m_alternateEndpoints;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;
    H225_AlternateTransportAddresses m_alternateTransportAddresses;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// InfoRequestResponse
//

class H225_InfoRequestResponse : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_InfoRequestResponse, PASN_Sequence);
#endif
  public:
    H225_InfoRequestResponse(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_nonStandardData,
      e_endpointAlias,
      e_perCallInfo,
      e_tokens,
      e_cryptoTokens,
      e_integrityCheckValue,
      e_needResponse
    };

    H225_NonStandardParameter m_nonStandardData;
    H225_RequestSeqNum m_requestSeqNum;
    H225_EndpointType m_endpointType;
    H225_EndpointIdentifier m_endpointIdentifier;
    H225_TransportAddress m_rasAddress;
    H225_ArrayOf_TransportAddress m_callSignalAddress;
    H225_ArrayOf_AliasAddress m_endpointAlias;
    H225_InfoRequestResponse_perCallInfo m_perCallInfo;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ICV m_integrityCheckValue;
    PASN_Boolean m_needResponse;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// Alerting-UUIE
//

class H225_Alerting_UUIE : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_Alerting_UUIE, PASN_Sequence);
#endif
  public:
    H225_Alerting_UUIE(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_h245Address,
      e_callIdentifier,
      e_h245SecurityMode,
      e_tokens,
      e_cryptoTokens,
      e_fastStart,
      e_multipleCalls,
      e_maintainConnection,
      e_alertingAddress,
      e_presentationIndicator,
      e_screeningIndicator,
      e_fastConnectRefused
    };

    H225_ProtocolIdentifier m_protocolIdentifier;
    H225_EndpointType m_destinationInfo;
    H225_TransportAddress m_h245Address;
    H225_CallIdentifier m_callIdentifier;
    H225_H245Security m_h245SecurityMode;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ArrayOf_PASN_OctetString m_fastStart;
    PASN_Boolean m_multipleCalls;
    PASN_Boolean m_maintainConnection;
    H225_ArrayOf_AliasAddress m_alertingAddress;
    H225_PresentationIndicator m_presentationIndicator;
    H225_ScreeningIndicator m_screeningIndicator;
    PASN_Null m_fastConnectRefused;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// CallProceeding-UUIE
//

class H225_CallProceeding_UUIE : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_CallProceeding_UUIE, PASN_Sequence);
#endif
  public:
    H225_CallProceeding_UUIE(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_h245Address,
      e_callIdentifier,
      e_h245SecurityMode,
      e_tokens,
      e_cryptoTokens,
      e_fastStart,
      e_multipleCalls,
      e_maintainConnection,
      e_fastConnectRefused
    };

    H225_ProtocolIdentifier m_protocolIdentifier;
    H225_EndpointType m_destinationInfo;
    H225_TransportAddress m_h245Address;
    H225_CallIdentifier m_callIdentifier;
    H225_H245Security m_h245SecurityMode;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ArrayOf_PASN_OctetString m_fastStart;
    PASN_Boolean m_multipleCalls;
    PASN_Boolean m_maintainConnection;
    PASN_Null m_fastConnectRefused;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// Connect-UUIE
//

class H225_Connect_UUIE : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_Connect_UUIE, PASN_Sequence);
#endif
  public:
    H225_Connect_UUIE(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_h245Address,
      e_callIdentifier,
      e_h245SecurityMode,
      e_tokens,
      e_cryptoTokens,
      e_fastStart,
      e_multipleCalls,
      e_maintainConnection,
      e_language,
      e_connectedAddress,
      e_presentationIndicator,
      e_screeningIndicator,
      e_fastConnectRefused
    };

    H225_ProtocolIdentifier m_protocolIdentifier;
    H225_TransportAddress m_h245Address;
    H225_EndpointType m_destinationInfo;
    H225_ConferenceIdentifier m_conferenceID;
    H225_CallIdentifier m_callIdentifier;
    H225_H245Security m_h245SecurityMode;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ArrayOf_PASN_OctetString m_fastStart;
    PASN_Boolean m_multipleCalls;
    PASN_Boolean m_maintainConnection;
    H225_Connect_UUIE_language m_language;
    H225_ArrayOf_AliasAddress m_connectedAddress;
    H225_PresentationIndicator m_presentationIndicator;
    H225_ScreeningIndicator m_screeningIndicator;
    PASN_Null m_fastConnectRefused;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// Setup-UUIE
//

class H225_Setup_UUIE : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_Setup_UUIE, PASN_Sequence);
#endif
  public:
    H225_Setup_UUIE(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_h245Address,
      e_sourceAddress,
      e_destinationAddress,
      e_destCallSignalAddress,
      e_destExtraCallInfo,
      e_destExtraCRV,
      e_callServices,
      e_sourceCallSignalAddress,
      e_remoteExtensionAddress,
      e_callIdentifier,
      e_h245SecurityCapability,
      e_tokens,
      e_cryptoTokens,
      e_fastStart,
      e_mediaWaitForConnect,
      e_canOverlapSend,
      e_endpointIdentifier,
      e_multipleCalls,
      e_maintainConnection,
      e_connectionParameters,
      e_language,
      e_presentationIndicator,
      e_screeningIndicator
    };

    H225_ProtocolIdentifier m_protocolIdentifier;
    H225_TransportAddress m_h245Address;
    H225_ArrayOf_AliasAddress m_sourceAddress;
    H225_EndpointType m_sourceInfo;
    H225_ArrayOf_AliasAddress m_destinationAddress;
    H225_TransportAddress m_destCallSignalAddress;
    H225_ArrayOf_AliasAddress m_destExtraCallInfo;
    H225_ArrayOf_CallReferenceValue m_destExtraCRV;
    PASN_Boolean m_activeMC;
    H225_ConferenceIdentifier m_conferenceID;
    H225_Setup_UUIE_conferenceGoal m_conferenceGoal;
    H225_QseriesOptions m_callServices;
    H225_CallType m_callType;
    H225_TransportAddress m_sourceCallSignalAddress;
    H225_AliasAddress m_remoteExtensionAddress;
    H225_CallIdentifier m_callIdentifier;
    H225_ArrayOf_H245Security m_h245SecurityCapability;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ArrayOf_PASN_OctetString m_fastStart;
    PASN_Boolean m_mediaWaitForConnect;
    PASN_Boolean m_canOverlapSend;
    H225_EndpointIdentifier m_endpointIdentifier;
    PASN_Boolean m_multipleCalls;
    PASN_Boolean m_maintainConnection;
    H225_Setup_UUIE_connectionParameters m_connectionParameters;
    H225_Setup_UUIE_language m_language;
    H225_PresentationIndicator m_presentationIndicator;
    H225_ScreeningIndicator m_screeningIndicator;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


//
// Progress-UUIE
//

class H225_Progress_UUIE : public PASN_Sequence
{
#ifndef PASN_LEANANDMEAN
    PCLASSINFO(H225_Progress_UUIE, PASN_Sequence);
#endif
  public:
    H225_Progress_UUIE(unsigned tag = UniversalSequence, TagClass tagClass = UniversalTagClass);

    enum OptionalFields {
      e_h245Address,
      e_h245SecurityMode,
      e_tokens,
      e_cryptoTokens,
      e_fastStart,
      e_multipleCalls,
      e_maintainConnection,
      e_fastConnectRefused
    };

    H225_ProtocolIdentifier m_protocolIdentifier;
    H225_EndpointType m_destinationInfo;
    H225_TransportAddress m_h245Address;
    H225_CallIdentifier m_callIdentifier;
    H225_H245Security m_h245SecurityMode;
    H225_ArrayOf_ClearToken m_tokens;
    H225_ArrayOf_CryptoH323Token m_cryptoTokens;
    H225_ArrayOf_PASN_OctetString m_fastStart;
    PASN_Boolean m_multipleCalls;
    PASN_Boolean m_maintainConnection;
    PASN_Null m_fastConnectRefused;

    PINDEX GetDataLength() const;
    BOOL Decode(PASN_Stream & strm);
    void Encode(PASN_Stream & strm) const;
#ifndef PASN_NOPRINTON
    void PrintOn(ostream & strm) const;
#endif
    Comparison Compare(const PObject & obj) const;

#ifdef USE_FOR_ETHEREAL
    void showEthereal(proto_tree *tree, tvbuff_t *tvb, unsigned int offset) const;
    void preShowEthereal( void );
    PString getSummary( void );
#endif  //USE_FOR_ETHEREAL

    PObject * Clone() const;
};


#endif // __H225_H


// End of h225.h
