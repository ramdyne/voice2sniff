/* 
 * h225.cxx
 *
 * Sources for decoding the H.225.0 protocol
 *
 * H.323 for Ethereal
 *
 * Copyright (c) 2002 Koninklijke Philips NV
 *
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.0 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is H.323 for Ethereal.
 *
 * The Initial Developer of the Original Code is Koninklijke Philips NV.
 *
 * All Rights Reserved.
 *
 * Contributor(s): ______________________________________.
 *
 *
 */

//
// h225.cxx
//
// Code automatically generated by asnparse.
//

#ifdef __GNUC__
#pragma implementation "h225.h"
#endif


#ifdef USE_FOR_ETHEREAL

extern "C" {

#  ifdef HAVE_CONFIG_H
#    include "config.h"
#  endif

#  include "plugins/plugin_api.h"

#  include "moduleinfo.h"

#  ifdef HAVE_SYS_TYPES_H
#    include <sys/types.h>
#  endif

#  include <string.h>
#  include <ctype.h>
#  include <time.h>

#  include <gmodule.h>
#  ifdef HAVE_NETINET_IN_H
#    include <netinet/in.h>
#  endif
#  include <epan/packet.h>
#  include "packet-h225.h"

//#  include "plugins/plugin_api_defs.h"
//#  include "packet-h245.h"
}

extern "C++" {
#  include <stdio.h>
#  include <string.h>
#  include "h225_container.h"
#  include "mini_ptlib/include/mini_ptlib.h"
#  include "h225.h"
#  include "h450.h"
}
#endif//USE_FOR_ETHEREAL

#ifndef USE_FOR_ETHEREAL
#  include <ptlib.h>
#  include "h225.h"
#  include "h245.h"
#  include "h450.h"
#endif //USE_FOR_ETHEREAL

#define new PNEW
static H225_Integer_Container* hCont;

#include "h235_t.cxx"


void setH225Container( H225_Integer_Container* cont )
{
  hCont = cont;
}

//
// ReleaseCompleteReason
//

H225_ReleaseCompleteReason::H225_ReleaseCompleteReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 12, TRUE
#ifndef PASN_NOPRINTON
      , "noBandwidth "
        "gatekeeperResources "
        "unreachableDestination "
        "destinationRejection "
        "invalidRevision "
        "noPermission "
        "unreachableGatekeeper "
        "gatewayResources "
        "badFormatAddress "
        "adaptiveBusy "
        "inConf "
        "undefinedReason "
        "facilityCallDeflection "
        "securityDenied "
        "calledPartyNotRegistered "
        "callerNotRegistered "
        "newConnectionNeeded "
        "nonStandardReason "
        "replaceWithConferenceInvite "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_ReleaseCompleteReason::operator H225_NonStandardParameter &() const
#else
H225_ReleaseCompleteReason::operator H225_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


H225_ReleaseCompleteReason::operator const H225_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_ReleaseCompleteReason::operator H225_ConferenceIdentifier &() const
#else
H225_ReleaseCompleteReason::operator H225_ConferenceIdentifier &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_ConferenceIdentifier::Class()), PInvalidCast);
#endif
  return *(H225_ConferenceIdentifier *)choice;
}


H225_ReleaseCompleteReason::operator const H225_ConferenceIdentifier &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_ConferenceIdentifier::Class()), PInvalidCast);
#endif
  return *(H225_ConferenceIdentifier *)choice;
}


BOOL H225_ReleaseCompleteReason::CreateObject()
{
  switch (tag) {
    case e_noBandwidth :
    case e_gatekeeperResources :
    case e_unreachableDestination :
    case e_destinationRejection :
    case e_invalidRevision :
    case e_noPermission :
    case e_unreachableGatekeeper :
    case e_gatewayResources :
    case e_badFormatAddress :
    case e_adaptiveBusy :
    case e_inConf :
    case e_undefinedReason :
    case e_facilityCallDeflection :
    case e_securityDenied :
    case e_calledPartyNotRegistered :
    case e_callerNotRegistered :
    case e_newConnectionNeeded :
      choice = new PASN_Null();
      return TRUE;
    case e_nonStandardReason :
      choice = new H225_NonStandardParameter();
      return TRUE;
    case e_replaceWithConferenceInvite :
      choice = new H225_ConferenceIdentifier();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_ReleaseCompleteReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ReleaseCompleteReason::Class()), PInvalidCast);
#endif
  return new H225_ReleaseCompleteReason(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ReleaseCompleteReason::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_noBandwidth :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_gatekeeperResources :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_unreachableDestination :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_destinationRejection :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_invalidRevision :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_noPermission :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_unreachableGatekeeper :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_gatewayResources :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_badFormatAddress :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_adaptiveBusy :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_inConf :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_undefinedReason :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_facilityCallDeflection :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_securityDenied :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_calledPartyNotRegistered :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_callerNotRegistered :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_newConnectionNeeded :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_nonStandardReason :
        ( ( H225_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_replaceWithConferenceInvite :
        ( ( H225_ConferenceIdentifier * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_ReleaseCompleteReason::getSummary( void ) 
{
  return PString( "ReleaseCompleteReason" );
}

void H225_ReleaseCompleteReason::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "noBandwidth" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ReleaseCompleteReason_noBandwidth, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "gatekeeperResources" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ReleaseCompleteReason_gatekeeperResources, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "unreachableDestination" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ReleaseCompleteReason_unreachableDestination, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "destinationRejection" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ReleaseCompleteReason_destinationRejection, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "invalidRevision" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ReleaseCompleteReason_invalidRevision, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "noPermission" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ReleaseCompleteReason_noPermission, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "unreachableGatekeeper" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ReleaseCompleteReason_unreachableGatekeeper, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "gatewayResources" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ReleaseCompleteReason_gatewayResources, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "badFormatAddress" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ReleaseCompleteReason_badFormatAddress, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "adaptiveBusy" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ReleaseCompleteReason_adaptiveBusy, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "inConf" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ReleaseCompleteReason_inConf, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "undefinedReason" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ReleaseCompleteReason_undefinedReason, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "facilityCallDeflection" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ReleaseCompleteReason_facilityCallDeflection, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "securityDenied" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ReleaseCompleteReason_securityDenied, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "calledPartyNotRegistered" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ReleaseCompleteReason_calledPartyNotRegistered, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "callerNotRegistered" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ReleaseCompleteReason_callerNotRegistered, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "newConnectionNeeded" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ReleaseCompleteReason_newConnectionNeeded, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "replaceWithConferenceInvite" ) == 0 ) {
      char* pstring = ( ( H225_ConferenceIdentifier* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ReleaseCompleteReason_replaceWithConferenceInvite, tvb, offset + ( ( H225_ConferenceIdentifier* ) choice) ->GetStartByte(), ( ( H225_ConferenceIdentifier* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h225_0.ett_h225_ReleaseCompleteReason_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ScnConnectionType
//

H225_ScnConnectionType::H225_ScnConnectionType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 7, TRUE
#ifndef PASN_NOPRINTON
      , "unknown "
        "bChannel "
        "hybrid2x64 "
        "hybrid384 "
        "hybrid1536 "
        "hybrid1920 "
        "multirate "
#endif
    )
{
}


BOOL H225_ScnConnectionType::CreateObject()
{
  switch (tag) {
    case e_unknown :
    case e_bChannel :
    case e_hybrid2x64 :
    case e_hybrid384 :
    case e_hybrid1536 :
    case e_hybrid1920 :
    case e_multirate :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_ScnConnectionType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ScnConnectionType::Class()), PInvalidCast);
#endif
  return new H225_ScnConnectionType(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ScnConnectionType::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_unknown :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_bChannel :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_hybrid2x64 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_hybrid384 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_hybrid1536 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_hybrid1920 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_multirate :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_ScnConnectionType::getSummary( void ) 
{
  return PString( "ScnConnectionType" );
}

void H225_ScnConnectionType::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "unknown" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ScnConnectionType_unknown, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "bChannel" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ScnConnectionType_bChannel, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "hybrid2x64" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ScnConnectionType_hybrid2x64, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "hybrid384" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ScnConnectionType_hybrid384, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "hybrid1536" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ScnConnectionType_hybrid1536, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "hybrid1920" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ScnConnectionType_hybrid1920, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "multirate" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ScnConnectionType_multirate, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ScnConnectionAggregation
//

H225_ScnConnectionAggregation::H225_ScnConnectionAggregation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 6, TRUE
#ifndef PASN_NOPRINTON
      , "auto "
        "none "
        "h221 "
        "bonded_mode1 "
        "bonded_mode2 "
        "bonded_mode3 "
#endif
    )
{
}


BOOL H225_ScnConnectionAggregation::CreateObject()
{
  switch (tag) {
    case e_auto :
    case e_none :
    case e_h221 :
    case e_bonded_mode1 :
    case e_bonded_mode2 :
    case e_bonded_mode3 :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_ScnConnectionAggregation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ScnConnectionAggregation::Class()), PInvalidCast);
#endif
  return new H225_ScnConnectionAggregation(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ScnConnectionAggregation::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_auto :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_none :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_h221 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_bonded_mode1 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_bonded_mode2 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_bonded_mode3 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_ScnConnectionAggregation::getSummary( void ) 
{
  return PString( "ScnConnectionAggregation" );
}

void H225_ScnConnectionAggregation::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "auto" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ScnConnectionAggregation_auto, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "none" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ScnConnectionAggregation_none, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "h221" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ScnConnectionAggregation_h221, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "bonded_mode1" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ScnConnectionAggregation_bonded_mode1, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "bonded_mode2" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ScnConnectionAggregation_bonded_mode2, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "bonded_mode3" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_ScnConnectionAggregation_bonded_mode3, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// PresentationIndicator
//

H225_PresentationIndicator::H225_PresentationIndicator(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "presentationAllowed "
        "presentationRestricted "
        "addressNotAvailable "
#endif
    )
{
}


BOOL H225_PresentationIndicator::CreateObject()
{
  switch (tag) {
    case e_presentationAllowed :
    case e_presentationRestricted :
    case e_addressNotAvailable :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_PresentationIndicator::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_PresentationIndicator::Class()), PInvalidCast);
#endif
  return new H225_PresentationIndicator(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_PresentationIndicator::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_presentationAllowed :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_presentationRestricted :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_addressNotAvailable :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_PresentationIndicator::getSummary( void ) 
{
  return PString( "PresentationIndicator" );
}

void H225_PresentationIndicator::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "presentationAllowed" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_PresentationIndicator_presentationAllowed, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "presentationRestricted" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_PresentationIndicator_presentationRestricted, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "addressNotAvailable" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_PresentationIndicator_addressNotAvailable, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ScreeningIndicator
//

H225_ScreeningIndicator::H225_ScreeningIndicator(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "userProvidedNotScreened "
        "userProvidedVerifiedAndPassed "
        "userProvidedVerifiedAndFailed "
        "networkProvided "
#endif
    )
{
}


H225_ScreeningIndicator & H225_ScreeningIndicator::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H225_ScreeningIndicator::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ScreeningIndicator::Class()), PInvalidCast);
#endif
  return new H225_ScreeningIndicator(*this);
}


//
// FacilityReason
//

H225_FacilityReason::H225_FacilityReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "routeCallToGatekeeper "
        "callForwarded "
        "routeCallToMC "
        "undefinedReason "
        "conferenceListChoice "
        "startH245 "
        "noH245 "
#endif
    )
{
}


BOOL H225_FacilityReason::CreateObject()
{
  switch (tag) {
    case e_routeCallToGatekeeper :
    case e_callForwarded :
    case e_routeCallToMC :
    case e_undefinedReason :
    case e_conferenceListChoice :
    case e_startH245 :
    case e_noH245 :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_FacilityReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_FacilityReason::Class()), PInvalidCast);
#endif
  return new H225_FacilityReason(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_FacilityReason::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_routeCallToGatekeeper :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_callForwarded :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_routeCallToMC :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_undefinedReason :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_conferenceListChoice :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_startH245 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_noH245 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_FacilityReason::getSummary( void ) 
{
  return PString( "FacilityReason" );
}

void H225_FacilityReason::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "routeCallToGatekeeper" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_FacilityReason_routeCallToGatekeeper, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "callForwarded" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_FacilityReason_callForwarded, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "routeCallToMC" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_FacilityReason_routeCallToMC, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "undefinedReason" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_FacilityReason_undefinedReason, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "conferenceListChoice" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_FacilityReason_conferenceListChoice, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "startH245" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_FacilityReason_startH245, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "noH245" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_FacilityReason_noH245, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// TransportAddress
//

H225_TransportAddress::H225_TransportAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 7, TRUE
#ifndef PASN_NOPRINTON
      , "ipAddress "
        "ipSourceRoute "
        "ipxAddress "
        "ip6Address "
        "netBios "
        "nsap "
        "nonStandardAddress "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_TransportAddress::operator H225_TransportAddress_ipAddress &() const
#else
H225_TransportAddress::operator H225_TransportAddress_ipAddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_TransportAddress_ipAddress::Class()), PInvalidCast);
#endif
  return *(H225_TransportAddress_ipAddress *)choice;
}


H225_TransportAddress::operator const H225_TransportAddress_ipAddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_TransportAddress_ipAddress::Class()), PInvalidCast);
#endif
  return *(H225_TransportAddress_ipAddress *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_TransportAddress::operator H225_TransportAddress_ipSourceRoute &() const
#else
H225_TransportAddress::operator H225_TransportAddress_ipSourceRoute &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_TransportAddress_ipSourceRoute::Class()), PInvalidCast);
#endif
  return *(H225_TransportAddress_ipSourceRoute *)choice;
}


H225_TransportAddress::operator const H225_TransportAddress_ipSourceRoute &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_TransportAddress_ipSourceRoute::Class()), PInvalidCast);
#endif
  return *(H225_TransportAddress_ipSourceRoute *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_TransportAddress::operator H225_TransportAddress_ipxAddress &() const
#else
H225_TransportAddress::operator H225_TransportAddress_ipxAddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_TransportAddress_ipxAddress::Class()), PInvalidCast);
#endif
  return *(H225_TransportAddress_ipxAddress *)choice;
}


H225_TransportAddress::operator const H225_TransportAddress_ipxAddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_TransportAddress_ipxAddress::Class()), PInvalidCast);
#endif
  return *(H225_TransportAddress_ipxAddress *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_TransportAddress::operator H225_TransportAddress_ip6Address &() const
#else
H225_TransportAddress::operator H225_TransportAddress_ip6Address &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_TransportAddress_ip6Address::Class()), PInvalidCast);
#endif
  return *(H225_TransportAddress_ip6Address *)choice;
}


H225_TransportAddress::operator const H225_TransportAddress_ip6Address &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_TransportAddress_ip6Address::Class()), PInvalidCast);
#endif
  return *(H225_TransportAddress_ip6Address *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_TransportAddress::operator H225_NonStandardParameter &() const
#else
H225_TransportAddress::operator H225_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


H225_TransportAddress::operator const H225_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


BOOL H225_TransportAddress::CreateObject()
{
  switch (tag) {
    case e_ipAddress :
      choice = new H225_TransportAddress_ipAddress();
      return TRUE;
    case e_ipSourceRoute :
      choice = new H225_TransportAddress_ipSourceRoute();
      return TRUE;
    case e_ipxAddress :
      choice = new H225_TransportAddress_ipxAddress();
      return TRUE;
    case e_ip6Address :
      choice = new H225_TransportAddress_ip6Address();
      return TRUE;
    case e_netBios :
      choice = new PASN_OctetString();
      choice->SetConstraints(PASN_Object::FixedConstraint, 16, 16);
      return TRUE;
    case e_nsap :
      choice = new PASN_OctetString();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 20);
      return TRUE;
    case e_nonStandardAddress :
      choice = new H225_NonStandardParameter();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_TransportAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_TransportAddress::Class()), PInvalidCast);
#endif
  return new H225_TransportAddress(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_TransportAddress::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_ipAddress :
        ( ( H225_TransportAddress_ipAddress * ) choice )->preShowEthereal();
        break;
      case e_ipSourceRoute :
        ( ( H225_TransportAddress_ipSourceRoute * ) choice )->preShowEthereal();
        break;
      case e_ipxAddress :
        ( ( H225_TransportAddress_ipxAddress * ) choice )->preShowEthereal();
        break;
      case e_ip6Address :
        ( ( H225_TransportAddress_ip6Address * ) choice )->preShowEthereal();
        break;
      case e_netBios :
        ( ( PASN_OctetString * ) choice )->preShowEthereal();
        break;
      case e_nsap :
        ( ( PASN_OctetString * ) choice )->preShowEthereal();
        break;
      case e_nonStandardAddress :
        ( ( H225_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_TransportAddress::getSummary( void ) 
{
  return PString( "TransportAddress" );
}

void H225_TransportAddress::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "netBios" ) == 0 ) {
      char* pstring = ( ( PASN_OctetString* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_TransportAddress_netBios, tvb, offset + ( ( PASN_OctetString* ) choice) ->GetStartByte(), ( ( PASN_OctetString* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    if ( strcmp( GetTagName(), "nsap" ) == 0 ) {
      char* pstring = ( ( PASN_OctetString* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_TransportAddress_nsap, tvb, offset + ( ( PASN_OctetString* ) choice) ->GetStartByte(), ( ( PASN_OctetString* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h225_0.ett_h225_TransportAddress_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// SupportedProtocols
//

H225_SupportedProtocols::H225_SupportedProtocols(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 9, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandardData "
        "h310 "
        "h320 "
        "h321 "
        "h322 "
        "h323 "
        "h324 "
        "voice "
        "t120_only "
        "nonStandardProtocol "
        "t38FaxAnnexbOnly "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_SupportedProtocols::operator H225_NonStandardParameter &() const
#else
H225_SupportedProtocols::operator H225_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


H225_SupportedProtocols::operator const H225_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_SupportedProtocols::operator H225_H310Caps &() const
#else
H225_SupportedProtocols::operator H225_H310Caps &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_H310Caps::Class()), PInvalidCast);
#endif
  return *(H225_H310Caps *)choice;
}


H225_SupportedProtocols::operator const H225_H310Caps &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_H310Caps::Class()), PInvalidCast);
#endif
  return *(H225_H310Caps *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_SupportedProtocols::operator H225_H320Caps &() const
#else
H225_SupportedProtocols::operator H225_H320Caps &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_H320Caps::Class()), PInvalidCast);
#endif
  return *(H225_H320Caps *)choice;
}


H225_SupportedProtocols::operator const H225_H320Caps &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_H320Caps::Class()), PInvalidCast);
#endif
  return *(H225_H320Caps *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_SupportedProtocols::operator H225_H321Caps &() const
#else
H225_SupportedProtocols::operator H225_H321Caps &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_H321Caps::Class()), PInvalidCast);
#endif
  return *(H225_H321Caps *)choice;
}


H225_SupportedProtocols::operator const H225_H321Caps &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_H321Caps::Class()), PInvalidCast);
#endif
  return *(H225_H321Caps *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_SupportedProtocols::operator H225_H322Caps &() const
#else
H225_SupportedProtocols::operator H225_H322Caps &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_H322Caps::Class()), PInvalidCast);
#endif
  return *(H225_H322Caps *)choice;
}


H225_SupportedProtocols::operator const H225_H322Caps &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_H322Caps::Class()), PInvalidCast);
#endif
  return *(H225_H322Caps *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_SupportedProtocols::operator H225_H323Caps &() const
#else
H225_SupportedProtocols::operator H225_H323Caps &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_H323Caps::Class()), PInvalidCast);
#endif
  return *(H225_H323Caps *)choice;
}


H225_SupportedProtocols::operator const H225_H323Caps &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_H323Caps::Class()), PInvalidCast);
#endif
  return *(H225_H323Caps *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_SupportedProtocols::operator H225_H324Caps &() const
#else
H225_SupportedProtocols::operator H225_H324Caps &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_H324Caps::Class()), PInvalidCast);
#endif
  return *(H225_H324Caps *)choice;
}


H225_SupportedProtocols::operator const H225_H324Caps &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_H324Caps::Class()), PInvalidCast);
#endif
  return *(H225_H324Caps *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_SupportedProtocols::operator H225_VoiceCaps &() const
#else
H225_SupportedProtocols::operator H225_VoiceCaps &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_VoiceCaps::Class()), PInvalidCast);
#endif
  return *(H225_VoiceCaps *)choice;
}


H225_SupportedProtocols::operator const H225_VoiceCaps &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_VoiceCaps::Class()), PInvalidCast);
#endif
  return *(H225_VoiceCaps *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_SupportedProtocols::operator H225_T120OnlyCaps &() const
#else
H225_SupportedProtocols::operator H225_T120OnlyCaps &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_T120OnlyCaps::Class()), PInvalidCast);
#endif
  return *(H225_T120OnlyCaps *)choice;
}


H225_SupportedProtocols::operator const H225_T120OnlyCaps &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_T120OnlyCaps::Class()), PInvalidCast);
#endif
  return *(H225_T120OnlyCaps *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_SupportedProtocols::operator H225_NonStandardProtocol &() const
#else
H225_SupportedProtocols::operator H225_NonStandardProtocol &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardProtocol::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardProtocol *)choice;
}


H225_SupportedProtocols::operator const H225_NonStandardProtocol &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardProtocol::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardProtocol *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_SupportedProtocols::operator H225_T38FaxAnnexbOnlyCaps &() const
#else
H225_SupportedProtocols::operator H225_T38FaxAnnexbOnlyCaps &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_T38FaxAnnexbOnlyCaps::Class()), PInvalidCast);
#endif
  return *(H225_T38FaxAnnexbOnlyCaps *)choice;
}


H225_SupportedProtocols::operator const H225_T38FaxAnnexbOnlyCaps &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_T38FaxAnnexbOnlyCaps::Class()), PInvalidCast);
#endif
  return *(H225_T38FaxAnnexbOnlyCaps *)choice;
}


BOOL H225_SupportedProtocols::CreateObject()
{
  switch (tag) {
    case e_nonStandardData :
      choice = new H225_NonStandardParameter();
      return TRUE;
    case e_h310 :
      choice = new H225_H310Caps();
      return TRUE;
    case e_h320 :
      choice = new H225_H320Caps();
      return TRUE;
    case e_h321 :
      choice = new H225_H321Caps();
      return TRUE;
    case e_h322 :
      choice = new H225_H322Caps();
      return TRUE;
    case e_h323 :
      choice = new H225_H323Caps();
      return TRUE;
    case e_h324 :
      choice = new H225_H324Caps();
      return TRUE;
    case e_voice :
      choice = new H225_VoiceCaps();
      return TRUE;
    case e_t120_only :
      choice = new H225_T120OnlyCaps();
      return TRUE;
    case e_nonStandardProtocol :
      choice = new H225_NonStandardProtocol();
      return TRUE;
    case e_t38FaxAnnexbOnly :
      choice = new H225_T38FaxAnnexbOnlyCaps();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_SupportedProtocols::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_SupportedProtocols::Class()), PInvalidCast);
#endif
  return new H225_SupportedProtocols(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_SupportedProtocols::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandardData :
        ( ( H225_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_h310 :
        ( ( H225_H310Caps * ) choice )->preShowEthereal();
        break;
      case e_h320 :
        ( ( H225_H320Caps * ) choice )->preShowEthereal();
        break;
      case e_h321 :
        ( ( H225_H321Caps * ) choice )->preShowEthereal();
        break;
      case e_h322 :
        ( ( H225_H322Caps * ) choice )->preShowEthereal();
        break;
      case e_h323 :
        ( ( H225_H323Caps * ) choice )->preShowEthereal();
        break;
      case e_h324 :
        ( ( H225_H324Caps * ) choice )->preShowEthereal();
        break;
      case e_voice :
        ( ( H225_VoiceCaps * ) choice )->preShowEthereal();
        break;
      case e_t120_only :
        ( ( H225_T120OnlyCaps * ) choice )->preShowEthereal();
        break;
      case e_nonStandardProtocol :
        ( ( H225_NonStandardProtocol * ) choice )->preShowEthereal();
        break;
      case e_t38FaxAnnexbOnly :
        ( ( H225_T38FaxAnnexbOnlyCaps * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_SupportedProtocols::getSummary( void ) 
{
  return PString( "SupportedProtocols" );
}

void H225_SupportedProtocols::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h225_0.ett_h225_SupportedProtocols_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H221NonStandard
//

H225_H221NonStandard::H225_H221NonStandard(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_t35CountryCode.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
  m_t35Extension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
  m_manufacturerCode.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H225_H221NonStandard::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "t35CountryCode = " << setprecision(indent) << m_t35CountryCode << '\n';
  strm << setw(indent+15) << "t35Extension = " << setprecision(indent) << m_t35Extension << '\n';
  strm << setw(indent+19) << "manufacturerCode = " << setprecision(indent) << m_manufacturerCode << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_H221NonStandard::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_H221NonStandard::Class()), PInvalidCast);
#endif
  const H225_H221NonStandard & other = (const H225_H221NonStandard &)obj;

  Comparison result;

  if ((result = m_t35CountryCode.Compare(other.m_t35CountryCode)) != EqualTo)
    return result;
  if ((result = m_t35Extension.Compare(other.m_t35Extension)) != EqualTo)
    return result;
  if ((result = m_manufacturerCode.Compare(other.m_manufacturerCode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_H221NonStandard::GetDataLength() const
{
  return m_t35CountryCode.GetObjectLength() +
         m_t35Extension.GetObjectLength() +
         m_manufacturerCode.GetObjectLength();
}


BOOL H225_H221NonStandard::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_t35CountryCode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_t35Extension.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_manufacturerCode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_H221NonStandard::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_t35CountryCode.Encode(strm);
  m_t35Extension.Encode(strm);
  m_manufacturerCode.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_t35CountryCode.Encode(strm);
  m_t35Extension.Encode(strm);
  m_manufacturerCode.Encode(strm);
}


PObject * H225_H221NonStandard::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_H221NonStandard::Class()), PInvalidCast);
#endif
  return new H225_H221NonStandard(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_H221NonStandard::preShowEthereal( void )
{
  m_t35CountryCode.preShowEthereal( );
  m_t35Extension.preShowEthereal( );
  m_manufacturerCode.preShowEthereal( );
}

PString H225_H221NonStandard::getSummary( void ) 
{
  return PString( "H221NonStandard" );
}

void H225_H221NonStandard::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_0.hf_h225_H221NonStandard_t35CountryCode, tvb, offset + m_t35CountryCode.GetStartByte(), m_t35CountryCode.GetByteLength() , m_t35CountryCode.GetValue() );

  proto_tree_add_uint( tree, hCont->h225_0.hf_h225_H221NonStandard_t35Extension, tvb, offset + m_t35Extension.GetStartByte(), m_t35Extension.GetByteLength() , m_t35Extension.GetValue() );

  proto_tree_add_uint( tree, hCont->h225_0.hf_h225_H221NonStandard_manufacturerCode, tvb, offset + m_manufacturerCode.GetStartByte(), m_manufacturerCode.GetByteLength() , m_manufacturerCode.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// NonStandardIdentifier
//

H225_NonStandardIdentifier::H225_NonStandardIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "object "
        "h221NonStandard "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_NonStandardIdentifier::operator H225_H221NonStandard &() const
#else
H225_NonStandardIdentifier::operator H225_H221NonStandard &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_H221NonStandard::Class()), PInvalidCast);
#endif
  return *(H225_H221NonStandard *)choice;
}


H225_NonStandardIdentifier::operator const H225_H221NonStandard &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_H221NonStandard::Class()), PInvalidCast);
#endif
  return *(H225_H221NonStandard *)choice;
}


BOOL H225_NonStandardIdentifier::CreateObject()
{
  switch (tag) {
    case e_object :
      choice = new PASN_ObjectId();
      return TRUE;
    case e_h221NonStandard :
      choice = new H225_H221NonStandard();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_NonStandardIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_NonStandardIdentifier::Class()), PInvalidCast);
#endif
  return new H225_NonStandardIdentifier(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_NonStandardIdentifier::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_object :
        ( ( PASN_ObjectId * ) choice )->preShowEthereal();
        break;
      case e_h221NonStandard :
        ( ( H225_H221NonStandard * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_NonStandardIdentifier::getSummary( void ) 
{
  return PString( "NonStandardIdentifier" );
}

void H225_NonStandardIdentifier::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "object" ) == 0 ) {
      char* pstring = ( ( PASN_ObjectId* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_NonStandardIdentifier_object, tvb, offset + ( ( PASN_ObjectId* ) choice) ->GetStartByte(), ( ( PASN_ObjectId* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h225_0.ett_h225_NonStandardIdentifier_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// AliasAddress
//

H225_AliasAddress::H225_AliasAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "e164 "
        "h323_ID "
        "url_ID "
        "transportID "
        "email_ID "
        "partyNumber "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_AliasAddress::operator H225_TransportAddress &() const
#else
H225_AliasAddress::operator H225_TransportAddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_TransportAddress::Class()), PInvalidCast);
#endif
  return *(H225_TransportAddress *)choice;
}


H225_AliasAddress::operator const H225_TransportAddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_TransportAddress::Class()), PInvalidCast);
#endif
  return *(H225_TransportAddress *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_AliasAddress::operator H225_PartyNumber &() const
#else
H225_AliasAddress::operator H225_PartyNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_PartyNumber::Class()), PInvalidCast);
#endif
  return *(H225_PartyNumber *)choice;
}


H225_AliasAddress::operator const H225_PartyNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_PartyNumber::Class()), PInvalidCast);
#endif
  return *(H225_PartyNumber *)choice;
}


BOOL H225_AliasAddress::CreateObject()
{
  switch (tag) {
    case e_e164 :
      choice = new PASN_IA5String();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 128);
      choice->SetCharacterSet(PASN_Object::FixedConstraint, "0123456789#*,");
      return TRUE;
    case e_h323_ID :
      choice = new PASN_BMPString();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_url_ID :
      choice = new PASN_IA5String();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 512);
      return TRUE;
    case e_transportID :
      choice = new H225_TransportAddress();
      return TRUE;
    case e_email_ID :
      choice = new PASN_IA5String();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 512);
      return TRUE;
    case e_partyNumber :
      choice = new H225_PartyNumber();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_AliasAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_AliasAddress::Class()), PInvalidCast);
#endif
  return new H225_AliasAddress(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_AliasAddress::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_e164 :
        ( ( PASN_IA5String * ) choice )->preShowEthereal();
        break;
      case e_h323_ID :
        ( ( PASN_BMPString * ) choice )->preShowEthereal();
        break;
      case e_url_ID :
        ( ( PASN_IA5String * ) choice )->preShowEthereal();
        break;
      case e_transportID :
        ( ( H225_TransportAddress * ) choice )->preShowEthereal();
        break;
      case e_email_ID :
        ( ( PASN_IA5String * ) choice )->preShowEthereal();
        break;
      case e_partyNumber :
        ( ( H225_PartyNumber * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_AliasAddress::getSummary( void ) 
{
  return PString( "AliasAddress" );
}

void H225_AliasAddress::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "e164" ) == 0 ) {
      char* pstring = ( ( PASN_IA5String* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_AliasAddress_e164, tvb, offset + ( ( PASN_IA5String* ) choice) ->GetStartByte(), ( ( PASN_IA5String* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    if ( strcmp( GetTagName(), "h323_ID" ) == 0 ) {
      char* pstring = ( ( PASN_BMPString* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_AliasAddress_h323_ID, tvb, offset + ( ( PASN_BMPString* ) choice) ->GetStartByte(), ( ( PASN_BMPString* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    if ( strcmp( GetTagName(), "url_ID" ) == 0 ) {
      char* pstring = ( ( PASN_IA5String* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_AliasAddress_url_ID, tvb, offset + ( ( PASN_IA5String* ) choice) ->GetStartByte(), ( ( PASN_IA5String* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    if ( strcmp( GetTagName(), "email_ID" ) == 0 ) {
      char* pstring = ( ( PASN_IA5String* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_AliasAddress_email_ID, tvb, offset + ( ( PASN_IA5String* ) choice) ->GetStartByte(), ( ( PASN_IA5String* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h225_0.ett_h225_AliasAddress_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// PartyNumber
//

H225_PartyNumber::H225_PartyNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
      , "publicNumber "
        "dataPartyNumber "
        "telexPartyNumber "
        "privateNumber "
        "nationalStandardPartyNumber "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_PartyNumber::operator H225_PublicPartyNumber &() const
#else
H225_PartyNumber::operator H225_PublicPartyNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_PublicPartyNumber::Class()), PInvalidCast);
#endif
  return *(H225_PublicPartyNumber *)choice;
}


H225_PartyNumber::operator const H225_PublicPartyNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_PublicPartyNumber::Class()), PInvalidCast);
#endif
  return *(H225_PublicPartyNumber *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_PartyNumber::operator H225_NumberDigits &() const
#else
H225_PartyNumber::operator H225_NumberDigits &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NumberDigits::Class()), PInvalidCast);
#endif
  return *(H225_NumberDigits *)choice;
}


H225_PartyNumber::operator const H225_NumberDigits &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NumberDigits::Class()), PInvalidCast);
#endif
  return *(H225_NumberDigits *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_PartyNumber::operator H225_PrivatePartyNumber &() const
#else
H225_PartyNumber::operator H225_PrivatePartyNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_PrivatePartyNumber::Class()), PInvalidCast);
#endif
  return *(H225_PrivatePartyNumber *)choice;
}


H225_PartyNumber::operator const H225_PrivatePartyNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_PrivatePartyNumber::Class()), PInvalidCast);
#endif
  return *(H225_PrivatePartyNumber *)choice;
}


BOOL H225_PartyNumber::CreateObject()
{
  switch (tag) {
    case e_publicNumber :
      choice = new H225_PublicPartyNumber();
      return TRUE;
    case e_dataPartyNumber :
    case e_telexPartyNumber :
    case e_nationalStandardPartyNumber :
      choice = new H225_NumberDigits();
      return TRUE;
    case e_privateNumber :
      choice = new H225_PrivatePartyNumber();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_PartyNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_PartyNumber::Class()), PInvalidCast);
#endif
  return new H225_PartyNumber(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_PartyNumber::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_publicNumber :
        ( ( H225_PublicPartyNumber * ) choice )->preShowEthereal();
        break;
      case e_dataPartyNumber :
        ( ( H225_NumberDigits * ) choice )->preShowEthereal();
        break;
      case e_telexPartyNumber :
        ( ( H225_NumberDigits * ) choice )->preShowEthereal();
        break;
      case e_privateNumber :
        ( ( H225_PrivatePartyNumber * ) choice )->preShowEthereal();
        break;
      case e_nationalStandardPartyNumber :
        ( ( H225_NumberDigits * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_PartyNumber::getSummary( void ) 
{
  return PString( "PartyNumber" );
}

void H225_PartyNumber::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "dataPartyNumber" ) == 0 ) {
      char* pstring = ( ( H225_NumberDigits* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_PartyNumber_dataPartyNumber, tvb, offset + ( ( H225_NumberDigits* ) choice) ->GetStartByte(), ( ( H225_NumberDigits* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    if ( strcmp( GetTagName(), "telexPartyNumber" ) == 0 ) {
      char* pstring = ( ( H225_NumberDigits* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_PartyNumber_telexPartyNumber, tvb, offset + ( ( H225_NumberDigits* ) choice) ->GetStartByte(), ( ( H225_NumberDigits* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    if ( strcmp( GetTagName(), "nationalStandardPartyNumber" ) == 0 ) {
      char* pstring = ( ( H225_NumberDigits* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_PartyNumber_nationalStandardPartyNumber, tvb, offset + ( ( H225_NumberDigits* ) choice) ->GetStartByte(), ( ( H225_NumberDigits* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h225_0.ett_h225_PartyNumber_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// NumberDigits
//

H225_NumberDigits::H225_NumberDigits(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_IA5String(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 128);
  SetCharacterSet(PASN_Object::FixedConstraint, "0123456789#*,");
}


H225_NumberDigits & H225_NumberDigits::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H225_NumberDigits & H225_NumberDigits::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


PObject * H225_NumberDigits::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_NumberDigits::Class()), PInvalidCast);
#endif
  return new H225_NumberDigits(*this);
}


//
// PublicTypeOfNumber
//

H225_PublicTypeOfNumber::H225_PublicTypeOfNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 6, TRUE
#ifndef PASN_NOPRINTON
      , "unknown "
        "internationalNumber "
        "nationalNumber "
        "networkSpecificNumber "
        "subscriberNumber "
        "abbreviatedNumber "
#endif
    )
{
}


BOOL H225_PublicTypeOfNumber::CreateObject()
{
  switch (tag) {
    case e_unknown :
    case e_internationalNumber :
    case e_nationalNumber :
    case e_networkSpecificNumber :
    case e_subscriberNumber :
    case e_abbreviatedNumber :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_PublicTypeOfNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_PublicTypeOfNumber::Class()), PInvalidCast);
#endif
  return new H225_PublicTypeOfNumber(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_PublicTypeOfNumber::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_unknown :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_internationalNumber :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_nationalNumber :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_networkSpecificNumber :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_subscriberNumber :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_abbreviatedNumber :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_PublicTypeOfNumber::getSummary( void ) 
{
  return PString( "PublicTypeOfNumber" );
}

void H225_PublicTypeOfNumber::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "unknown" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_PublicTypeOfNumber_unknown, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "internationalNumber" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_PublicTypeOfNumber_internationalNumber, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "nationalNumber" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_PublicTypeOfNumber_nationalNumber, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "networkSpecificNumber" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_PublicTypeOfNumber_networkSpecificNumber, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "subscriberNumber" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_PublicTypeOfNumber_subscriberNumber, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "abbreviatedNumber" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_PublicTypeOfNumber_abbreviatedNumber, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// PrivateTypeOfNumber
//

H225_PrivateTypeOfNumber::H225_PrivateTypeOfNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 6, TRUE
#ifndef PASN_NOPRINTON
      , "unknown "
        "level2RegionalNumber "
        "level1RegionalNumber "
        "pISNSpecificNumber "
        "localNumber "
        "abbreviatedNumber "
#endif
    )
{
}


BOOL H225_PrivateTypeOfNumber::CreateObject()
{
  switch (tag) {
    case e_unknown :
    case e_level2RegionalNumber :
    case e_level1RegionalNumber :
    case e_pISNSpecificNumber :
    case e_localNumber :
    case e_abbreviatedNumber :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_PrivateTypeOfNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_PrivateTypeOfNumber::Class()), PInvalidCast);
#endif
  return new H225_PrivateTypeOfNumber(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_PrivateTypeOfNumber::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_unknown :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_level2RegionalNumber :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_level1RegionalNumber :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_pISNSpecificNumber :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_localNumber :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_abbreviatedNumber :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_PrivateTypeOfNumber::getSummary( void ) 
{
  return PString( "PrivateTypeOfNumber" );
}

void H225_PrivateTypeOfNumber::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "unknown" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_PrivateTypeOfNumber_unknown, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "level2RegionalNumber" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_PrivateTypeOfNumber_level2RegionalNumber, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "level1RegionalNumber" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_PrivateTypeOfNumber_level1RegionalNumber, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "pISNSpecificNumber" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_PrivateTypeOfNumber_pISNSpecificNumber, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "localNumber" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_PrivateTypeOfNumber_localNumber, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "abbreviatedNumber" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_PrivateTypeOfNumber_abbreviatedNumber, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// UseSpecifiedTransport
//

H225_UseSpecifiedTransport::H225_UseSpecifiedTransport(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "tcp "
        "annexE "
#endif
    )
{
}


BOOL H225_UseSpecifiedTransport::CreateObject()
{
  switch (tag) {
    case e_tcp :
    case e_annexE :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_UseSpecifiedTransport::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_UseSpecifiedTransport::Class()), PInvalidCast);
#endif
  return new H225_UseSpecifiedTransport(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_UseSpecifiedTransport::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_tcp :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_annexE :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_UseSpecifiedTransport::getSummary( void ) 
{
  return PString( "UseSpecifiedTransport" );
}

void H225_UseSpecifiedTransport::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "tcp" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_UseSpecifiedTransport_tcp, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "annexE" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_UseSpecifiedTransport_annexE, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// SecurityServiceMode
//

H225_SecurityServiceMode::H225_SecurityServiceMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "none "
        "default "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_SecurityServiceMode::operator H225_NonStandardParameter &() const
#else
H225_SecurityServiceMode::operator H225_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


H225_SecurityServiceMode::operator const H225_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


BOOL H225_SecurityServiceMode::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H225_NonStandardParameter();
      return TRUE;
    case e_none :
    case e_default :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_SecurityServiceMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_SecurityServiceMode::Class()), PInvalidCast);
#endif
  return new H225_SecurityServiceMode(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_SecurityServiceMode::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H225_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_none :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_default :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_SecurityServiceMode::getSummary( void ) 
{
  return PString( "SecurityServiceMode" );
}

void H225_SecurityServiceMode::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "none" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_SecurityServiceMode_none, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "default" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_SecurityServiceMode_default, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h225_0.ett_h225_SecurityServiceMode_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H245Security
//

H225_H245Security::H225_H245Security(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "noSecurity "
        "tls "
        "ipsec "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_H245Security::operator H225_NonStandardParameter &() const
#else
H225_H245Security::operator H225_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


H225_H245Security::operator const H225_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_H245Security::operator H225_SecurityCapabilities &() const
#else
H225_H245Security::operator H225_SecurityCapabilities &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_SecurityCapabilities::Class()), PInvalidCast);
#endif
  return *(H225_SecurityCapabilities *)choice;
}


H225_H245Security::operator const H225_SecurityCapabilities &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_SecurityCapabilities::Class()), PInvalidCast);
#endif
  return *(H225_SecurityCapabilities *)choice;
}


BOOL H225_H245Security::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H225_NonStandardParameter();
      return TRUE;
    case e_noSecurity :
      choice = new PASN_Null();
      return TRUE;
    case e_tls :
    case e_ipsec :
      choice = new H225_SecurityCapabilities();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_H245Security::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_H245Security::Class()), PInvalidCast);
#endif
  return new H225_H245Security(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_H245Security::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H225_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_noSecurity :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_tls :
        ( ( H225_SecurityCapabilities * ) choice )->preShowEthereal();
        break;
      case e_ipsec :
        ( ( H225_SecurityCapabilities * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_H245Security::getSummary( void ) 
{
  return PString( "H245Security" );
}

void H225_H245Security::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "noSecurity" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_H245Security_noSecurity, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h225_0.ett_h225_H245Security_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// Q954Details
//

H225_Q954Details::H225_Q954Details(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_Q954Details::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+20) << "conferenceCalling = " << setprecision(indent) << m_conferenceCalling << '\n';
  strm << setw(indent+20) << "threePartyService = " << setprecision(indent) << m_threePartyService << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_Q954Details::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_Q954Details::Class()), PInvalidCast);
#endif
  const H225_Q954Details & other = (const H225_Q954Details &)obj;

  Comparison result;

  if ((result = m_conferenceCalling.Compare(other.m_conferenceCalling)) != EqualTo)
    return result;
  if ((result = m_threePartyService.Compare(other.m_threePartyService)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_Q954Details::GetDataLength() const
{
  return m_conferenceCalling.GetObjectLength() +
         m_threePartyService.GetObjectLength();
}


BOOL H225_Q954Details::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_conferenceCalling.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_threePartyService.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_Q954Details::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_conferenceCalling.Encode(strm);
  m_threePartyService.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_conferenceCalling.Encode(strm);
  m_threePartyService.Encode(strm);
}


PObject * H225_Q954Details::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_Q954Details::Class()), PInvalidCast);
#endif
  return new H225_Q954Details(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_Q954Details::preShowEthereal( void )
{
  m_conferenceCalling.preShowEthereal( );
  m_threePartyService.preShowEthereal( );
}

PString H225_Q954Details::getSummary( void ) 
{
  return PString( "Q954Details" );
}

void H225_Q954Details::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_Q954Details_conferenceCalling, tvb, offset + m_conferenceCalling.GetStartByte(), m_conferenceCalling.GetByteLength() , m_conferenceCalling.GetValue() );

  proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_Q954Details_threePartyService, tvb, offset + m_threePartyService.GetStartByte(), m_threePartyService.GetByteLength() , m_threePartyService.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// GloballyUniqueID
//

H225_GloballyUniqueID::H225_GloballyUniqueID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_OctetString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 16, 16);
}


H225_GloballyUniqueID & H225_GloballyUniqueID::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H225_GloballyUniqueID & H225_GloballyUniqueID::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H225_GloballyUniqueID & H225_GloballyUniqueID::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H225_GloballyUniqueID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_GloballyUniqueID::Class()), PInvalidCast);
#endif
  return new H225_GloballyUniqueID(*this);
}

char* H225_GloballyUniqueID::getValue( void ) const
{
	unsigned char* pguid = (unsigned char* ) PASN_OctetString::getValue();
	char* result = new char[ 37 ];
	result[0] = '\0';

  sprintf( result, "%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X", 
										pguid[0], pguid[1], pguid[2], pguid[3], pguid[4], 
										pguid[5], pguid[6], pguid[7], pguid[8], 
										pguid[9], pguid[10], pguid[11], pguid[12], 
										pguid[13], pguid[14], pguid[15] );

	delete pguid;
	return result;
}

//
// ConferenceIdentifier
//

H225_ConferenceIdentifier::H225_ConferenceIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : H225_GloballyUniqueID(tag, tagClass)
{
}


H225_ConferenceIdentifier & H225_ConferenceIdentifier::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H225_ConferenceIdentifier & H225_ConferenceIdentifier::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H225_ConferenceIdentifier & H225_ConferenceIdentifier::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H225_ConferenceIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ConferenceIdentifier::Class()), PInvalidCast);
#endif
  return new H225_ConferenceIdentifier(*this);
}


//
// RequestSeqNum
//

H225_RequestSeqNum::H225_RequestSeqNum(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


H225_RequestSeqNum & H225_RequestSeqNum::operator=(int v)
{
  SetValue(v);
  return *this;
}


H225_RequestSeqNum & H225_RequestSeqNum::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H225_RequestSeqNum::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_RequestSeqNum::Class()), PInvalidCast);
#endif
  return new H225_RequestSeqNum(*this);
}


//
// GatekeeperIdentifier
//

H225_GatekeeperIdentifier::H225_GatekeeperIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_BMPString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 128);
}


H225_GatekeeperIdentifier & H225_GatekeeperIdentifier::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H225_GatekeeperIdentifier & H225_GatekeeperIdentifier::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


PObject * H225_GatekeeperIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_GatekeeperIdentifier::Class()), PInvalidCast);
#endif
  return new H225_GatekeeperIdentifier(*this);
}


//
// BandWidth
//

H225_BandWidth::H225_BandWidth(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


H225_BandWidth & H225_BandWidth::operator=(int v)
{
  SetValue(v);
  return *this;
}


H225_BandWidth & H225_BandWidth::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H225_BandWidth::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_BandWidth::Class()), PInvalidCast);
#endif
  return new H225_BandWidth(*this);
}


//
// CallReferenceValue
//

H225_CallReferenceValue::H225_CallReferenceValue(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


H225_CallReferenceValue & H225_CallReferenceValue::operator=(int v)
{
  SetValue(v);
  return *this;
}


H225_CallReferenceValue & H225_CallReferenceValue::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H225_CallReferenceValue::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_CallReferenceValue::Class()), PInvalidCast);
#endif
  return new H225_CallReferenceValue(*this);
}


//
// EndpointIdentifier
//

H225_EndpointIdentifier::H225_EndpointIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_BMPString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 128);
}


H225_EndpointIdentifier & H225_EndpointIdentifier::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H225_EndpointIdentifier & H225_EndpointIdentifier::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


PObject * H225_EndpointIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_EndpointIdentifier::Class()), PInvalidCast);
#endif
  return new H225_EndpointIdentifier(*this);
}


//
// ProtocolIdentifier
//

H225_ProtocolIdentifier::H225_ProtocolIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_ObjectId(tag, tagClass)
{
}


PObject * H225_ProtocolIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ProtocolIdentifier::Class()), PInvalidCast);
#endif
  return new H225_ProtocolIdentifier(*this);
}


//
// TimeToLive
//

H225_TimeToLive::H225_TimeToLive(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
}


H225_TimeToLive & H225_TimeToLive::operator=(int v)
{
  SetValue(v);
  return *this;
}


H225_TimeToLive & H225_TimeToLive::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H225_TimeToLive::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_TimeToLive::Class()), PInvalidCast);
#endif
  return new H225_TimeToLive(*this);
}


//
// CallIdentifier
//

H225_CallIdentifier::H225_CallIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_CallIdentifier::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "guid = " << setprecision(indent) << m_guid << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_CallIdentifier::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_CallIdentifier::Class()), PInvalidCast);
#endif
  const H225_CallIdentifier & other = (const H225_CallIdentifier &)obj;

  Comparison result;

  if ((result = m_guid.Compare(other.m_guid)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_CallIdentifier::GetDataLength() const
{
  return m_guid.GetObjectLength();
}


BOOL H225_CallIdentifier::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_guid.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_CallIdentifier::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_guid.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_guid.Encode(strm);
}


PObject * H225_CallIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_CallIdentifier::Class()), PInvalidCast);
#endif
  return new H225_CallIdentifier(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_CallIdentifier::preShowEthereal( void )
{
  m_guid.preShowEthereal( );
}

PString H225_CallIdentifier::getSummary( void ) 
{
  return PString( "CallIdentifier" );
}

void H225_CallIdentifier::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pguid = m_guid.getValue();
  proto_tree_add_string( tree, hCont->h225_0.hf_h225_CallIdentifier_guid, tvb, offset + m_guid.GetStartByte(), m_guid.GetByteLength() , pguid );
  delete[] pguid;

}
#endif  //USE_FOR_ETHEREAL

//
// EncryptIntAlg
//

H225_EncryptIntAlg::H225_EncryptIntAlg(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "isoAlgorithm "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_EncryptIntAlg::operator H225_NonStandardParameter &() const
#else
H225_EncryptIntAlg::operator H225_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


H225_EncryptIntAlg::operator const H225_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


BOOL H225_EncryptIntAlg::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H225_NonStandardParameter();
      return TRUE;
    case e_isoAlgorithm :
      choice = new PASN_ObjectId();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_EncryptIntAlg::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_EncryptIntAlg::Class()), PInvalidCast);
#endif
  return new H225_EncryptIntAlg(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_EncryptIntAlg::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H225_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_isoAlgorithm :
        ( ( PASN_ObjectId * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_EncryptIntAlg::getSummary( void ) 
{
  return PString( "EncryptIntAlg" );
}

void H225_EncryptIntAlg::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "isoAlgorithm" ) == 0 ) {
      char* pstring = ( ( PASN_ObjectId* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_EncryptIntAlg_isoAlgorithm, tvb, offset + ( ( PASN_ObjectId* ) choice) ->GetStartByte(), ( ( PASN_ObjectId* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h225_0.ett_h225_EncryptIntAlg_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// NonIsoIntegrityMechanism
//

H225_NonIsoIntegrityMechanism::H225_NonIsoIntegrityMechanism(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "hMAC_MD5 "
        "hMAC_iso10118_2_s "
        "hMAC_iso10118_2_l "
        "hMAC_iso10118_3 "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_NonIsoIntegrityMechanism::operator H225_EncryptIntAlg &() const
#else
H225_NonIsoIntegrityMechanism::operator H225_EncryptIntAlg &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_EncryptIntAlg::Class()), PInvalidCast);
#endif
  return *(H225_EncryptIntAlg *)choice;
}


H225_NonIsoIntegrityMechanism::operator const H225_EncryptIntAlg &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_EncryptIntAlg::Class()), PInvalidCast);
#endif
  return *(H225_EncryptIntAlg *)choice;
}


BOOL H225_NonIsoIntegrityMechanism::CreateObject()
{
  switch (tag) {
    case e_hMAC_MD5 :
      choice = new PASN_Null();
      return TRUE;
    case e_hMAC_iso10118_2_s :
    case e_hMAC_iso10118_2_l :
      choice = new H225_EncryptIntAlg();
      return TRUE;
    case e_hMAC_iso10118_3 :
      choice = new PASN_ObjectId();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_NonIsoIntegrityMechanism::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_NonIsoIntegrityMechanism::Class()), PInvalidCast);
#endif
  return new H225_NonIsoIntegrityMechanism(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_NonIsoIntegrityMechanism::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_hMAC_MD5 :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_hMAC_iso10118_2_s :
        ( ( H225_EncryptIntAlg * ) choice )->preShowEthereal();
        break;
      case e_hMAC_iso10118_2_l :
        ( ( H225_EncryptIntAlg * ) choice )->preShowEthereal();
        break;
      case e_hMAC_iso10118_3 :
        ( ( PASN_ObjectId * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_NonIsoIntegrityMechanism::getSummary( void ) 
{
  return PString( "NonIsoIntegrityMechanism" );
}

void H225_NonIsoIntegrityMechanism::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "hMAC_MD5" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_NonIsoIntegrityMechanism_hMAC_MD5, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "hMAC_iso10118_3" ) == 0 ) {
      char* pstring = ( ( PASN_ObjectId* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_NonIsoIntegrityMechanism_hMAC_iso10118_3, tvb, offset + ( ( PASN_ObjectId* ) choice) ->GetStartByte(), ( ( PASN_ObjectId* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h225_0.ett_h225_NonIsoIntegrityMechanism_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// IntegrityMechanism
//

H225_IntegrityMechanism::H225_IntegrityMechanism(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "nonStandard "
        "digSig "
        "iso9797 "
        "nonIsoIM "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_IntegrityMechanism::operator H225_NonStandardParameter &() const
#else
H225_IntegrityMechanism::operator H225_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


H225_IntegrityMechanism::operator const H225_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_IntegrityMechanism::operator H225_NonIsoIntegrityMechanism &() const
#else
H225_IntegrityMechanism::operator H225_NonIsoIntegrityMechanism &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonIsoIntegrityMechanism::Class()), PInvalidCast);
#endif
  return *(H225_NonIsoIntegrityMechanism *)choice;
}


H225_IntegrityMechanism::operator const H225_NonIsoIntegrityMechanism &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonIsoIntegrityMechanism::Class()), PInvalidCast);
#endif
  return *(H225_NonIsoIntegrityMechanism *)choice;
}


BOOL H225_IntegrityMechanism::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H225_NonStandardParameter();
      return TRUE;
    case e_digSig :
      choice = new PASN_Null();
      return TRUE;
    case e_iso9797 :
      choice = new PASN_ObjectId();
      return TRUE;
    case e_nonIsoIM :
      choice = new H225_NonIsoIntegrityMechanism();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_IntegrityMechanism::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_IntegrityMechanism::Class()), PInvalidCast);
#endif
  return new H225_IntegrityMechanism(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_IntegrityMechanism::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_nonStandard :
        ( ( H225_NonStandardParameter * ) choice )->preShowEthereal();
        break;
      case e_digSig :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_iso9797 :
        ( ( PASN_ObjectId * ) choice )->preShowEthereal();
        break;
      case e_nonIsoIM :
        ( ( H225_NonIsoIntegrityMechanism * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_IntegrityMechanism::getSummary( void ) 
{
  return PString( "IntegrityMechanism" );
}

void H225_IntegrityMechanism::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "digSig" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_IntegrityMechanism_digSig, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "iso9797" ) == 0 ) {
      char* pstring = ( ( PASN_ObjectId* ) choice) ->getValue();
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_IntegrityMechanism_iso9797, tvb, offset + ( ( PASN_ObjectId* ) choice) ->GetStartByte(), ( ( PASN_ObjectId* ) choice) ->GetByteLength(), pstring );
      delete[] pstring;
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h225_0.ett_h225_IntegrityMechanism_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ICV
//

H225_ICV::H225_ICV(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_ICV::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "algorithmOID = " << setprecision(indent) << m_algorithmOID << '\n';
  strm << setw(indent+6) << "icv = " << setprecision(indent) << m_icv << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_ICV::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_ICV::Class()), PInvalidCast);
#endif
  const H225_ICV & other = (const H225_ICV &)obj;

  Comparison result;

  if ((result = m_algorithmOID.Compare(other.m_algorithmOID)) != EqualTo)
    return result;
  if ((result = m_icv.Compare(other.m_icv)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_ICV::GetDataLength() const
{
  return m_algorithmOID.GetObjectLength() +
         m_icv.GetObjectLength();
}


BOOL H225_ICV::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_algorithmOID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_icv.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_ICV::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_algorithmOID.Encode(strm);
  m_icv.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_algorithmOID.Encode(strm);
  m_icv.Encode(strm);
}


PObject * H225_ICV::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ICV::Class()), PInvalidCast);
#endif
  return new H225_ICV(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ICV::preShowEthereal( void )
{
  m_algorithmOID.preShowEthereal( );
  m_icv.preShowEthereal( );
}

PString H225_ICV::getSummary( void ) 
{
  return PString( "ICV" );
}

void H225_ICV::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* palgorithmOID = m_algorithmOID.getValue();
  proto_tree_add_string( tree, hCont->h225_0.hf_h225_ICV_algorithmOID, tvb, offset + m_algorithmOID.GetStartByte(), m_algorithmOID.GetByteLength() , palgorithmOID );
  delete[] palgorithmOID;

  char* picv = m_icv.getValue();
  proto_tree_add_string( tree, hCont->h225_0.hf_h225_ICV_icv, tvb, offset + m_icv.GetStartByte(), m_icv.GetByteLength() , picv );
  delete[] picv;

}
#endif  //USE_FOR_ETHEREAL

//
// FastStartToken
//

H225_FastStartToken::H225_FastStartToken(unsigned tag, PASN_Object::TagClass tagClass)
  : H235_ClearToken(tag, tagClass)
{
  IncludeOptionalField(e_generalID);
  IncludeOptionalField(e_dhkey);
  IncludeOptionalField(e_timeStamp);
}


PObject * H225_FastStartToken::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_FastStartToken::Class()), PInvalidCast);
#endif
  return new H225_FastStartToken(*this);
}


//
// CryptoH323Token
//

H225_CryptoH323Token::H225_CryptoH323Token(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 8, TRUE
#ifndef PASN_NOPRINTON
      , "cryptoEPPwdHash "
        "cryptoGKPwdHash "
        "cryptoEPPwdEncr "
        "cryptoGKPwdEncr "
        "cryptoEPCert "
        "cryptoGKCert "
        "cryptoFastStart "
        "nestedcryptoToken "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_CryptoH323Token::operator H225_CryptoH323Token_cryptoEPPwdHash &() const
#else
H225_CryptoH323Token::operator H225_CryptoH323Token_cryptoEPPwdHash &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_CryptoH323Token_cryptoEPPwdHash::Class()), PInvalidCast);
#endif
  return *(H225_CryptoH323Token_cryptoEPPwdHash *)choice;
}


H225_CryptoH323Token::operator const H225_CryptoH323Token_cryptoEPPwdHash &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_CryptoH323Token_cryptoEPPwdHash::Class()), PInvalidCast);
#endif
  return *(H225_CryptoH323Token_cryptoEPPwdHash *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_CryptoH323Token::operator H225_CryptoH323Token_cryptoGKPwdHash &() const
#else
H225_CryptoH323Token::operator H225_CryptoH323Token_cryptoGKPwdHash &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_CryptoH323Token_cryptoGKPwdHash::Class()), PInvalidCast);
#endif
  return *(H225_CryptoH323Token_cryptoGKPwdHash *)choice;
}


H225_CryptoH323Token::operator const H225_CryptoH323Token_cryptoGKPwdHash &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_CryptoH323Token_cryptoGKPwdHash::Class()), PInvalidCast);
#endif
  return *(H225_CryptoH323Token_cryptoGKPwdHash *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_CryptoH323Token::operator H235_ENCRYPTED<H235_EncodedPwdCertToken> &() const
#else
H225_CryptoH323Token::operator H235_ENCRYPTED<H235_EncodedPwdCertToken> &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_ENCRYPTED<H235_EncodedPwdCertToken>::Class()), PInvalidCast);
#endif
  return *(H235_ENCRYPTED<H235_EncodedPwdCertToken> *)choice;
}


H225_CryptoH323Token::operator const H235_ENCRYPTED<H235_EncodedPwdCertToken> &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_ENCRYPTED<H235_EncodedPwdCertToken>::Class()), PInvalidCast);
#endif
  return *(H235_ENCRYPTED<H235_EncodedPwdCertToken> *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_CryptoH323Token::operator H235_SIGNED<H235_EncodedPwdCertToken> &() const
#else
H225_CryptoH323Token::operator H235_SIGNED<H235_EncodedPwdCertToken> &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_SIGNED<H235_EncodedPwdCertToken>::Class()), PInvalidCast);
#endif
  return *(H235_SIGNED<H235_EncodedPwdCertToken> *)choice;
}


H225_CryptoH323Token::operator const H235_SIGNED<H235_EncodedPwdCertToken> &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_SIGNED<H235_EncodedPwdCertToken>::Class()), PInvalidCast);
#endif
  return *(H235_SIGNED<H235_EncodedPwdCertToken> *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_CryptoH323Token::operator H235_SIGNED<H225_EncodedFastStartToken> &() const
#else
H225_CryptoH323Token::operator H235_SIGNED<H225_EncodedFastStartToken> &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_SIGNED<H225_EncodedFastStartToken>::Class()), PInvalidCast);
#endif
  return *(H235_SIGNED<H225_EncodedFastStartToken> *)choice;
}


H225_CryptoH323Token::operator const H235_SIGNED<H225_EncodedFastStartToken> &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_SIGNED<H225_EncodedFastStartToken>::Class()), PInvalidCast);
#endif
  return *(H235_SIGNED<H225_EncodedFastStartToken> *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_CryptoH323Token::operator H235_CryptoToken &() const
#else
H225_CryptoH323Token::operator H235_CryptoToken &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_CryptoToken::Class()), PInvalidCast);
#endif
  return *(H235_CryptoToken *)choice;
}


H225_CryptoH323Token::operator const H235_CryptoToken &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H235_CryptoToken::Class()), PInvalidCast);
#endif
  return *(H235_CryptoToken *)choice;
}


BOOL H225_CryptoH323Token::CreateObject()
{
  switch (tag) {
    case e_cryptoEPPwdHash :
      choice = new H225_CryptoH323Token_cryptoEPPwdHash();
      return TRUE;
    case e_cryptoGKPwdHash :
      choice = new H225_CryptoH323Token_cryptoGKPwdHash();
      return TRUE;
    case e_cryptoEPPwdEncr :
    case e_cryptoGKPwdEncr :
      choice = new H235_ENCRYPTED<H235_EncodedPwdCertToken>();
      return TRUE;
    case e_cryptoEPCert :
    case e_cryptoGKCert :
      choice = new H235_SIGNED<H235_EncodedPwdCertToken>();
      return TRUE;
    case e_cryptoFastStart :
      choice = new H235_SIGNED<H225_EncodedFastStartToken>();
      return TRUE;
    case e_nestedcryptoToken :
      choice = new H235_CryptoToken();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_CryptoH323Token::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_CryptoH323Token::Class()), PInvalidCast);
#endif
  return new H225_CryptoH323Token(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_CryptoH323Token::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_cryptoEPPwdHash :
        ( ( H225_CryptoH323Token_cryptoEPPwdHash * ) choice )->preShowEthereal();
        break;
      case e_cryptoGKPwdHash :
        ( ( H225_CryptoH323Token_cryptoGKPwdHash * ) choice )->preShowEthereal();
        break;
      case e_cryptoEPPwdEncr :
        ( ( H235_ENCRYPTED<H235_EncodedPwdCertToken> * ) choice )->preShowEthereal();
        break;
      case e_cryptoGKPwdEncr :
        ( ( H235_ENCRYPTED<H235_EncodedPwdCertToken> * ) choice )->preShowEthereal();
        break;
      case e_cryptoEPCert :
        ( ( H235_SIGNED<H235_EncodedPwdCertToken> * ) choice )->preShowEthereal();
        break;
      case e_cryptoGKCert :
        ( ( H235_SIGNED<H235_EncodedPwdCertToken> * ) choice )->preShowEthereal();
        break;
      case e_cryptoFastStart :
        ( ( H235_SIGNED<H225_EncodedFastStartToken> * ) choice )->preShowEthereal();
        break;
      case e_nestedcryptoToken :
        ( ( H235_CryptoToken * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_CryptoH323Token::getSummary( void ) 
{
  return PString( "CryptoH323Token" );
}

void H225_CryptoH323Token::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* The class H235_ENCRYPTED of which the choice type
     * cryptoEPPwdEncr is an instantation of, is defined
     * outside the current ASN.1 file, therefore it's not
     * known what type it is. A non-terminal is presumed
     */
    /* The class H235_ENCRYPTED of which the choice type
     * cryptoGKPwdEncr is an instantation of, is defined
     * outside the current ASN.1 file, therefore it's not
     * known what type it is. A non-terminal is presumed
     */
    /* The class H235_SIGNED of which the choice type
     * cryptoEPCert is an instantation of, is defined
     * outside the current ASN.1 file, therefore it's not
     * known what type it is. A non-terminal is presumed
     */
    /* The class H235_SIGNED of which the choice type
     * cryptoGKCert is an instantation of, is defined
     * outside the current ASN.1 file, therefore it's not
     * known what type it is. A non-terminal is presumed
     */
    /* The class H235_SIGNED of which the choice type
     * cryptoFastStart is an instantation of, is defined
     * outside the current ASN.1 file, therefore it's not
     * known what type it is. A non-terminal is presumed
     */
    /* The class H235_CryptoToken of which the choice type
     * nestedcryptoToken is an instantation of, is defined
     * outside the current ASN.1 file, therefore it's not
     * known what type it is. A non-terminal is presumed
     */
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h225_0.ett_h225_CryptoH323Token_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// RasMessage
//

H225_RasMessage::H225_RasMessage(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 25, TRUE
#ifndef PASN_NOPRINTON
      , "gatekeeperRequest "
        "gatekeeperConfirm "
        "gatekeeperReject "
        "registrationRequest "
        "registrationConfirm "
        "registrationReject "
        "unregistrationRequest "
        "unregistrationConfirm "
        "unregistrationReject "
        "admissionRequest "
        "admissionConfirm "
        "admissionReject "
        "bandwidthRequest "
        "bandwidthConfirm "
        "bandwidthReject "
        "disengageRequest "
        "disengageConfirm "
        "disengageReject "
        "locationRequest "
        "locationConfirm "
        "locationReject "
        "infoRequest "
        "infoRequestResponse "
        "nonStandardMessage "
        "unknownMessageResponse "
        "requestInProgress "
        "resourcesAvailableIndicate "
        "resourcesAvailableConfirm "
        "infoRequestAck "
        "infoRequestNak "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_GatekeeperRequest &() const
#else
H225_RasMessage::operator H225_GatekeeperRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_GatekeeperRequest::Class()), PInvalidCast);
#endif
  return *(H225_GatekeeperRequest *)choice;
}


H225_RasMessage::operator const H225_GatekeeperRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_GatekeeperRequest::Class()), PInvalidCast);
#endif
  return *(H225_GatekeeperRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_GatekeeperConfirm &() const
#else
H225_RasMessage::operator H225_GatekeeperConfirm &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_GatekeeperConfirm::Class()), PInvalidCast);
#endif
  return *(H225_GatekeeperConfirm *)choice;
}


H225_RasMessage::operator const H225_GatekeeperConfirm &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_GatekeeperConfirm::Class()), PInvalidCast);
#endif
  return *(H225_GatekeeperConfirm *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_GatekeeperReject &() const
#else
H225_RasMessage::operator H225_GatekeeperReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_GatekeeperReject::Class()), PInvalidCast);
#endif
  return *(H225_GatekeeperReject *)choice;
}


H225_RasMessage::operator const H225_GatekeeperReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_GatekeeperReject::Class()), PInvalidCast);
#endif
  return *(H225_GatekeeperReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_RegistrationRequest &() const
#else
H225_RasMessage::operator H225_RegistrationRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_RegistrationRequest::Class()), PInvalidCast);
#endif
  return *(H225_RegistrationRequest *)choice;
}


H225_RasMessage::operator const H225_RegistrationRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_RegistrationRequest::Class()), PInvalidCast);
#endif
  return *(H225_RegistrationRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_RegistrationConfirm &() const
#else
H225_RasMessage::operator H225_RegistrationConfirm &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_RegistrationConfirm::Class()), PInvalidCast);
#endif
  return *(H225_RegistrationConfirm *)choice;
}


H225_RasMessage::operator const H225_RegistrationConfirm &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_RegistrationConfirm::Class()), PInvalidCast);
#endif
  return *(H225_RegistrationConfirm *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_RegistrationReject &() const
#else
H225_RasMessage::operator H225_RegistrationReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_RegistrationReject::Class()), PInvalidCast);
#endif
  return *(H225_RegistrationReject *)choice;
}


H225_RasMessage::operator const H225_RegistrationReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_RegistrationReject::Class()), PInvalidCast);
#endif
  return *(H225_RegistrationReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_UnregistrationRequest &() const
#else
H225_RasMessage::operator H225_UnregistrationRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_UnregistrationRequest::Class()), PInvalidCast);
#endif
  return *(H225_UnregistrationRequest *)choice;
}


H225_RasMessage::operator const H225_UnregistrationRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_UnregistrationRequest::Class()), PInvalidCast);
#endif
  return *(H225_UnregistrationRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_UnregistrationConfirm &() const
#else
H225_RasMessage::operator H225_UnregistrationConfirm &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_UnregistrationConfirm::Class()), PInvalidCast);
#endif
  return *(H225_UnregistrationConfirm *)choice;
}


H225_RasMessage::operator const H225_UnregistrationConfirm &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_UnregistrationConfirm::Class()), PInvalidCast);
#endif
  return *(H225_UnregistrationConfirm *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_UnregistrationReject &() const
#else
H225_RasMessage::operator H225_UnregistrationReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_UnregistrationReject::Class()), PInvalidCast);
#endif
  return *(H225_UnregistrationReject *)choice;
}


H225_RasMessage::operator const H225_UnregistrationReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_UnregistrationReject::Class()), PInvalidCast);
#endif
  return *(H225_UnregistrationReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_AdmissionRequest &() const
#else
H225_RasMessage::operator H225_AdmissionRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_AdmissionRequest::Class()), PInvalidCast);
#endif
  return *(H225_AdmissionRequest *)choice;
}


H225_RasMessage::operator const H225_AdmissionRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_AdmissionRequest::Class()), PInvalidCast);
#endif
  return *(H225_AdmissionRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_AdmissionConfirm &() const
#else
H225_RasMessage::operator H225_AdmissionConfirm &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_AdmissionConfirm::Class()), PInvalidCast);
#endif
  return *(H225_AdmissionConfirm *)choice;
}


H225_RasMessage::operator const H225_AdmissionConfirm &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_AdmissionConfirm::Class()), PInvalidCast);
#endif
  return *(H225_AdmissionConfirm *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_AdmissionReject &() const
#else
H225_RasMessage::operator H225_AdmissionReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_AdmissionReject::Class()), PInvalidCast);
#endif
  return *(H225_AdmissionReject *)choice;
}


H225_RasMessage::operator const H225_AdmissionReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_AdmissionReject::Class()), PInvalidCast);
#endif
  return *(H225_AdmissionReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_BandwidthRequest &() const
#else
H225_RasMessage::operator H225_BandwidthRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_BandwidthRequest::Class()), PInvalidCast);
#endif
  return *(H225_BandwidthRequest *)choice;
}


H225_RasMessage::operator const H225_BandwidthRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_BandwidthRequest::Class()), PInvalidCast);
#endif
  return *(H225_BandwidthRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_BandwidthConfirm &() const
#else
H225_RasMessage::operator H225_BandwidthConfirm &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_BandwidthConfirm::Class()), PInvalidCast);
#endif
  return *(H225_BandwidthConfirm *)choice;
}


H225_RasMessage::operator const H225_BandwidthConfirm &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_BandwidthConfirm::Class()), PInvalidCast);
#endif
  return *(H225_BandwidthConfirm *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_BandwidthReject &() const
#else
H225_RasMessage::operator H225_BandwidthReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_BandwidthReject::Class()), PInvalidCast);
#endif
  return *(H225_BandwidthReject *)choice;
}


H225_RasMessage::operator const H225_BandwidthReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_BandwidthReject::Class()), PInvalidCast);
#endif
  return *(H225_BandwidthReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_DisengageRequest &() const
#else
H225_RasMessage::operator H225_DisengageRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_DisengageRequest::Class()), PInvalidCast);
#endif
  return *(H225_DisengageRequest *)choice;
}


H225_RasMessage::operator const H225_DisengageRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_DisengageRequest::Class()), PInvalidCast);
#endif
  return *(H225_DisengageRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_DisengageConfirm &() const
#else
H225_RasMessage::operator H225_DisengageConfirm &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_DisengageConfirm::Class()), PInvalidCast);
#endif
  return *(H225_DisengageConfirm *)choice;
}


H225_RasMessage::operator const H225_DisengageConfirm &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_DisengageConfirm::Class()), PInvalidCast);
#endif
  return *(H225_DisengageConfirm *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_DisengageReject &() const
#else
H225_RasMessage::operator H225_DisengageReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_DisengageReject::Class()), PInvalidCast);
#endif
  return *(H225_DisengageReject *)choice;
}


H225_RasMessage::operator const H225_DisengageReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_DisengageReject::Class()), PInvalidCast);
#endif
  return *(H225_DisengageReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_LocationRequest &() const
#else
H225_RasMessage::operator H225_LocationRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_LocationRequest::Class()), PInvalidCast);
#endif
  return *(H225_LocationRequest *)choice;
}


H225_RasMessage::operator const H225_LocationRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_LocationRequest::Class()), PInvalidCast);
#endif
  return *(H225_LocationRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_LocationConfirm &() const
#else
H225_RasMessage::operator H225_LocationConfirm &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_LocationConfirm::Class()), PInvalidCast);
#endif
  return *(H225_LocationConfirm *)choice;
}


H225_RasMessage::operator const H225_LocationConfirm &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_LocationConfirm::Class()), PInvalidCast);
#endif
  return *(H225_LocationConfirm *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_LocationReject &() const
#else
H225_RasMessage::operator H225_LocationReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_LocationReject::Class()), PInvalidCast);
#endif
  return *(H225_LocationReject *)choice;
}


H225_RasMessage::operator const H225_LocationReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_LocationReject::Class()), PInvalidCast);
#endif
  return *(H225_LocationReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_InfoRequest &() const
#else
H225_RasMessage::operator H225_InfoRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_InfoRequest::Class()), PInvalidCast);
#endif
  return *(H225_InfoRequest *)choice;
}


H225_RasMessage::operator const H225_InfoRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_InfoRequest::Class()), PInvalidCast);
#endif
  return *(H225_InfoRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_InfoRequestResponse &() const
#else
H225_RasMessage::operator H225_InfoRequestResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_InfoRequestResponse::Class()), PInvalidCast);
#endif
  return *(H225_InfoRequestResponse *)choice;
}


H225_RasMessage::operator const H225_InfoRequestResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_InfoRequestResponse::Class()), PInvalidCast);
#endif
  return *(H225_InfoRequestResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_NonStandardMessage &() const
#else
H225_RasMessage::operator H225_NonStandardMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardMessage::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardMessage *)choice;
}


H225_RasMessage::operator const H225_NonStandardMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_NonStandardMessage::Class()), PInvalidCast);
#endif
  return *(H225_NonStandardMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_UnknownMessageResponse &() const
#else
H225_RasMessage::operator H225_UnknownMessageResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_UnknownMessageResponse::Class()), PInvalidCast);
#endif
  return *(H225_UnknownMessageResponse *)choice;
}


H225_RasMessage::operator const H225_UnknownMessageResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_UnknownMessageResponse::Class()), PInvalidCast);
#endif
  return *(H225_UnknownMessageResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_RequestInProgress &() const
#else
H225_RasMessage::operator H225_RequestInProgress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_RequestInProgress::Class()), PInvalidCast);
#endif
  return *(H225_RequestInProgress *)choice;
}


H225_RasMessage::operator const H225_RequestInProgress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_RequestInProgress::Class()), PInvalidCast);
#endif
  return *(H225_RequestInProgress *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_ResourcesAvailableIndicate &() const
#else
H225_RasMessage::operator H225_ResourcesAvailableIndicate &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_ResourcesAvailableIndicate::Class()), PInvalidCast);
#endif
  return *(H225_ResourcesAvailableIndicate *)choice;
}


H225_RasMessage::operator const H225_ResourcesAvailableIndicate &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_ResourcesAvailableIndicate::Class()), PInvalidCast);
#endif
  return *(H225_ResourcesAvailableIndicate *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_ResourcesAvailableConfirm &() const
#else
H225_RasMessage::operator H225_ResourcesAvailableConfirm &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_ResourcesAvailableConfirm::Class()), PInvalidCast);
#endif
  return *(H225_ResourcesAvailableConfirm *)choice;
}


H225_RasMessage::operator const H225_ResourcesAvailableConfirm &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_ResourcesAvailableConfirm::Class()), PInvalidCast);
#endif
  return *(H225_ResourcesAvailableConfirm *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_InfoRequestAck &() const
#else
H225_RasMessage::operator H225_InfoRequestAck &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_InfoRequestAck::Class()), PInvalidCast);
#endif
  return *(H225_InfoRequestAck *)choice;
}


H225_RasMessage::operator const H225_InfoRequestAck &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_InfoRequestAck::Class()), PInvalidCast);
#endif
  return *(H225_InfoRequestAck *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RasMessage::operator H225_InfoRequestNak &() const
#else
H225_RasMessage::operator H225_InfoRequestNak &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_InfoRequestNak::Class()), PInvalidCast);
#endif
  return *(H225_InfoRequestNak *)choice;
}


H225_RasMessage::operator const H225_InfoRequestNak &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_InfoRequestNak::Class()), PInvalidCast);
#endif
  return *(H225_InfoRequestNak *)choice;
}


BOOL H225_RasMessage::CreateObject()
{
  switch (tag) {
    case e_gatekeeperRequest :
      choice = new H225_GatekeeperRequest();
      return TRUE;
    case e_gatekeeperConfirm :
      choice = new H225_GatekeeperConfirm();
      return TRUE;
    case e_gatekeeperReject :
      choice = new H225_GatekeeperReject();
      return TRUE;
    case e_registrationRequest :
      choice = new H225_RegistrationRequest();
      return TRUE;
    case e_registrationConfirm :
      choice = new H225_RegistrationConfirm();
      return TRUE;
    case e_registrationReject :
      choice = new H225_RegistrationReject();
      return TRUE;
    case e_unregistrationRequest :
      choice = new H225_UnregistrationRequest();
      return TRUE;
    case e_unregistrationConfirm :
      choice = new H225_UnregistrationConfirm();
      return TRUE;
    case e_unregistrationReject :
      choice = new H225_UnregistrationReject();
      return TRUE;
    case e_admissionRequest :
      choice = new H225_AdmissionRequest();
      return TRUE;
    case e_admissionConfirm :
      choice = new H225_AdmissionConfirm();
      return TRUE;
    case e_admissionReject :
      choice = new H225_AdmissionReject();
      return TRUE;
    case e_bandwidthRequest :
      choice = new H225_BandwidthRequest();
      return TRUE;
    case e_bandwidthConfirm :
      choice = new H225_BandwidthConfirm();
      return TRUE;
    case e_bandwidthReject :
      choice = new H225_BandwidthReject();
      return TRUE;
    case e_disengageRequest :
      choice = new H225_DisengageRequest();
      return TRUE;
    case e_disengageConfirm :
      choice = new H225_DisengageConfirm();
      return TRUE;
    case e_disengageReject :
      choice = new H225_DisengageReject();
      return TRUE;
    case e_locationRequest :
      choice = new H225_LocationRequest();
      return TRUE;
    case e_locationConfirm :
      choice = new H225_LocationConfirm();
      return TRUE;
    case e_locationReject :
      choice = new H225_LocationReject();
      return TRUE;
    case e_infoRequest :
      choice = new H225_InfoRequest();
      return TRUE;
    case e_infoRequestResponse :
      choice = new H225_InfoRequestResponse();
      return TRUE;
    case e_nonStandardMessage :
      choice = new H225_NonStandardMessage();
      return TRUE;
    case e_unknownMessageResponse :
      choice = new H225_UnknownMessageResponse();
      return TRUE;
    case e_requestInProgress :
      choice = new H225_RequestInProgress();
      return TRUE;
    case e_resourcesAvailableIndicate :
      choice = new H225_ResourcesAvailableIndicate();
      return TRUE;
    case e_resourcesAvailableConfirm :
      choice = new H225_ResourcesAvailableConfirm();
      return TRUE;
    case e_infoRequestAck :
      choice = new H225_InfoRequestAck();
      return TRUE;
    case e_infoRequestNak :
      choice = new H225_InfoRequestNak();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_RasMessage::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_RasMessage::Class()), PInvalidCast);
#endif
  return new H225_RasMessage(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_RasMessage::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_gatekeeperRequest :
        ( ( H225_GatekeeperRequest * ) choice )->preShowEthereal();
        break;
      case e_gatekeeperConfirm :
        ( ( H225_GatekeeperConfirm * ) choice )->preShowEthereal();
        break;
      case e_gatekeeperReject :
        ( ( H225_GatekeeperReject * ) choice )->preShowEthereal();
        break;
      case e_registrationRequest :
        ( ( H225_RegistrationRequest * ) choice )->preShowEthereal();
        break;
      case e_registrationConfirm :
        ( ( H225_RegistrationConfirm * ) choice )->preShowEthereal();
        break;
      case e_registrationReject :
        ( ( H225_RegistrationReject * ) choice )->preShowEthereal();
        break;
      case e_unregistrationRequest :
        ( ( H225_UnregistrationRequest * ) choice )->preShowEthereal();
        break;
      case e_unregistrationConfirm :
        ( ( H225_UnregistrationConfirm * ) choice )->preShowEthereal();
        break;
      case e_unregistrationReject :
        ( ( H225_UnregistrationReject * ) choice )->preShowEthereal();
        break;
      case e_admissionRequest :
        ( ( H225_AdmissionRequest * ) choice )->preShowEthereal();
        break;
      case e_admissionConfirm :
        ( ( H225_AdmissionConfirm * ) choice )->preShowEthereal();
        break;
      case e_admissionReject :
        ( ( H225_AdmissionReject * ) choice )->preShowEthereal();
        break;
      case e_bandwidthRequest :
        ( ( H225_BandwidthRequest * ) choice )->preShowEthereal();
        break;
      case e_bandwidthConfirm :
        ( ( H225_BandwidthConfirm * ) choice )->preShowEthereal();
        break;
      case e_bandwidthReject :
        ( ( H225_BandwidthReject * ) choice )->preShowEthereal();
        break;
      case e_disengageRequest :
        ( ( H225_DisengageRequest * ) choice )->preShowEthereal();
        break;
      case e_disengageConfirm :
        ( ( H225_DisengageConfirm * ) choice )->preShowEthereal();
        break;
      case e_disengageReject :
        ( ( H225_DisengageReject * ) choice )->preShowEthereal();
        break;
      case e_locationRequest :
        ( ( H225_LocationRequest * ) choice )->preShowEthereal();
        break;
      case e_locationConfirm :
        ( ( H225_LocationConfirm * ) choice )->preShowEthereal();
        break;
      case e_locationReject :
        ( ( H225_LocationReject * ) choice )->preShowEthereal();
        break;
      case e_infoRequest :
        ( ( H225_InfoRequest * ) choice )->preShowEthereal();
        break;
      case e_infoRequestResponse :
        ( ( H225_InfoRequestResponse * ) choice )->preShowEthereal();
        break;
      case e_nonStandardMessage :
        ( ( H225_NonStandardMessage * ) choice )->preShowEthereal();
        break;
      case e_unknownMessageResponse :
        ( ( H225_UnknownMessageResponse * ) choice )->preShowEthereal();
        break;
      case e_requestInProgress :
        ( ( H225_RequestInProgress * ) choice )->preShowEthereal();
        break;
      case e_resourcesAvailableIndicate :
        ( ( H225_ResourcesAvailableIndicate * ) choice )->preShowEthereal();
        break;
      case e_resourcesAvailableConfirm :
        ( ( H225_ResourcesAvailableConfirm * ) choice )->preShowEthereal();
        break;
      case e_infoRequestAck :
        ( ( H225_InfoRequestAck * ) choice )->preShowEthereal();
        break;
      case e_infoRequestNak :
        ( ( H225_InfoRequestNak * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_RasMessage::getSummary( void ) 
{
	if ( choice != NULL )
		return choice->getSummary();
	else
		return PString( "RasMessage" );
}

void H225_RasMessage::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h225_0.ett_h225_RasMessage_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// GatekeeperRejectReason
//

H225_GatekeeperRejectReason::H225_GatekeeperRejectReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "resourceUnavailable "
        "terminalExcluded "
        "invalidRevision "
        "undefinedReason "
        "securityDenial "
#endif
    )
{
}


BOOL H225_GatekeeperRejectReason::CreateObject()
{
  switch (tag) {
    case e_resourceUnavailable :
    case e_terminalExcluded :
    case e_invalidRevision :
    case e_undefinedReason :
    case e_securityDenial :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_GatekeeperRejectReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_GatekeeperRejectReason::Class()), PInvalidCast);
#endif
  return new H225_GatekeeperRejectReason(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_GatekeeperRejectReason::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_resourceUnavailable :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_terminalExcluded :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_invalidRevision :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_undefinedReason :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_securityDenial :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_GatekeeperRejectReason::getSummary( void ) 
{
  return PString( "GatekeeperRejectReason" );
}

void H225_GatekeeperRejectReason::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "resourceUnavailable" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_GatekeeperRejectReason_resourceUnavailable, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "terminalExcluded" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_GatekeeperRejectReason_terminalExcluded, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "invalidRevision" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_GatekeeperRejectReason_invalidRevision, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "undefinedReason" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_GatekeeperRejectReason_undefinedReason, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "securityDenial" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_GatekeeperRejectReason_securityDenial, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// RegistrationRejectReason
//

H225_RegistrationRejectReason::H225_RegistrationRejectReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 8, TRUE
#ifndef PASN_NOPRINTON
      , "discoveryRequired "
        "invalidRevision "
        "invalidCallSignalAddress "
        "invalidRASAddress "
        "duplicateAlias "
        "invalidTerminalType "
        "undefinedReason "
        "transportNotSupported "
        "transportQOSNotSupported "
        "resourceUnavailable "
        "invalidAlias "
        "securityDenial "
        "fullRegistrationRequired "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_RegistrationRejectReason::operator H225_ArrayOf_AliasAddress &() const
#else
H225_RegistrationRejectReason::operator H225_ArrayOf_AliasAddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_ArrayOf_AliasAddress::Class()), PInvalidCast);
#endif
  return *(H225_ArrayOf_AliasAddress *)choice;
}


H225_RegistrationRejectReason::operator const H225_ArrayOf_AliasAddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_ArrayOf_AliasAddress::Class()), PInvalidCast);
#endif
  return *(H225_ArrayOf_AliasAddress *)choice;
}


BOOL H225_RegistrationRejectReason::CreateObject()
{
  switch (tag) {
    case e_discoveryRequired :
    case e_invalidRevision :
    case e_invalidCallSignalAddress :
    case e_invalidRASAddress :
    case e_invalidTerminalType :
    case e_undefinedReason :
    case e_transportNotSupported :
    case e_transportQOSNotSupported :
    case e_resourceUnavailable :
    case e_invalidAlias :
    case e_securityDenial :
    case e_fullRegistrationRequired :
      choice = new PASN_Null();
      return TRUE;
    case e_duplicateAlias :
      choice = new H225_ArrayOf_AliasAddress();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_RegistrationRejectReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_RegistrationRejectReason::Class()), PInvalidCast);
#endif
  return new H225_RegistrationRejectReason(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_RegistrationRejectReason::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_discoveryRequired :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_invalidRevision :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_invalidCallSignalAddress :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_invalidRASAddress :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_duplicateAlias :
        ( ( H225_ArrayOf_AliasAddress * ) choice )->preShowEthereal();
        break;
      case e_invalidTerminalType :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_undefinedReason :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_transportNotSupported :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_transportQOSNotSupported :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_resourceUnavailable :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_invalidAlias :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_securityDenial :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_fullRegistrationRequired :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_RegistrationRejectReason::getSummary( void ) 
{
  return PString( "RegistrationRejectReason" );
}

void H225_RegistrationRejectReason::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "discoveryRequired" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_RegistrationRejectReason_discoveryRequired, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "invalidRevision" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_RegistrationRejectReason_invalidRevision, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "invalidCallSignalAddress" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_RegistrationRejectReason_invalidCallSignalAddress, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "invalidRASAddress" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_RegistrationRejectReason_invalidRASAddress, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "invalidTerminalType" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_RegistrationRejectReason_invalidTerminalType, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "undefinedReason" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_RegistrationRejectReason_undefinedReason, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "transportNotSupported" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_RegistrationRejectReason_transportNotSupported, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "transportQOSNotSupported" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_RegistrationRejectReason_transportQOSNotSupported, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "resourceUnavailable" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_RegistrationRejectReason_resourceUnavailable, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "invalidAlias" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_RegistrationRejectReason_invalidAlias, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "securityDenial" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_RegistrationRejectReason_securityDenial, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "fullRegistrationRequired" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_RegistrationRejectReason_fullRegistrationRequired, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h225_0.ett_h225_RegistrationRejectReason_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// UnregRequestReason
//

H225_UnregRequestReason::H225_UnregRequestReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "reregistrationRequired "
        "ttlExpired "
        "securityDenial "
        "undefinedReason "
#endif
    )
{
}


BOOL H225_UnregRequestReason::CreateObject()
{
  switch (tag) {
    case e_reregistrationRequired :
    case e_ttlExpired :
    case e_securityDenial :
    case e_undefinedReason :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_UnregRequestReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_UnregRequestReason::Class()), PInvalidCast);
#endif
  return new H225_UnregRequestReason(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_UnregRequestReason::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_reregistrationRequired :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_ttlExpired :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_securityDenial :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_undefinedReason :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_UnregRequestReason::getSummary( void ) 
{
  return PString( "UnregRequestReason" );
}

void H225_UnregRequestReason::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "reregistrationRequired" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_UnregRequestReason_reregistrationRequired, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "ttlExpired" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_UnregRequestReason_ttlExpired, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "securityDenial" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_UnregRequestReason_securityDenial, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "undefinedReason" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_UnregRequestReason_undefinedReason, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// UnregRejectReason
//

H225_UnregRejectReason::H225_UnregRejectReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "notCurrentlyRegistered "
        "callInProgress "
        "undefinedReason "
        "permissionDenied "
        "securityDenial "
#endif
    )
{
}


BOOL H225_UnregRejectReason::CreateObject()
{
  switch (tag) {
    case e_notCurrentlyRegistered :
    case e_callInProgress :
    case e_undefinedReason :
    case e_permissionDenied :
    case e_securityDenial :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_UnregRejectReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_UnregRejectReason::Class()), PInvalidCast);
#endif
  return new H225_UnregRejectReason(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_UnregRejectReason::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_notCurrentlyRegistered :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_callInProgress :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_undefinedReason :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_permissionDenied :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_securityDenial :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_UnregRejectReason::getSummary( void ) 
{
  return PString( "UnregRejectReason" );
}

void H225_UnregRejectReason::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "notCurrentlyRegistered" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_UnregRejectReason_notCurrentlyRegistered, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "callInProgress" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_UnregRejectReason_callInProgress, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "undefinedReason" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_UnregRejectReason_undefinedReason, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "permissionDenied" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_UnregRejectReason_permissionDenied, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "securityDenial" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_UnregRejectReason_securityDenial, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// CallType
//

H225_CallType::H225_CallType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "pointToPoint "
        "oneToN "
        "nToOne "
        "nToN "
#endif
    )
{
}


BOOL H225_CallType::CreateObject()
{
  switch (tag) {
    case e_pointToPoint :
    case e_oneToN :
    case e_nToOne :
    case e_nToN :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_CallType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_CallType::Class()), PInvalidCast);
#endif
  return new H225_CallType(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_CallType::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_pointToPoint :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_oneToN :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_nToOne :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_nToN :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_CallType::getSummary( void ) 
{
  return PString( "CallType" );
}

void H225_CallType::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "pointToPoint" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_CallType_pointToPoint, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "oneToN" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_CallType_oneToN, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "nToOne" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_CallType_nToOne, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "nToN" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_CallType_nToN, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// CallModel
//

H225_CallModel::H225_CallModel(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "direct "
        "gatekeeperRouted "
#endif
    )
{
}


BOOL H225_CallModel::CreateObject()
{
  switch (tag) {
    case e_direct :
    case e_gatekeeperRouted :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_CallModel::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_CallModel::Class()), PInvalidCast);
#endif
  return new H225_CallModel(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_CallModel::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_direct :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_gatekeeperRouted :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_CallModel::getSummary( void ) 
{
  return PString( "CallModel" );
}

void H225_CallModel::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "direct" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_CallModel_direct, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "gatekeeperRouted" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_CallModel_gatekeeperRouted, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// TransportQOS
//

H225_TransportQOS::H225_TransportQOS(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "endpointControlled "
        "gatekeeperControlled "
        "noControl "
#endif
    )
{
}


BOOL H225_TransportQOS::CreateObject()
{
  switch (tag) {
    case e_endpointControlled :
    case e_gatekeeperControlled :
    case e_noControl :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_TransportQOS::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_TransportQOS::Class()), PInvalidCast);
#endif
  return new H225_TransportQOS(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_TransportQOS::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_endpointControlled :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_gatekeeperControlled :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_noControl :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_TransportQOS::getSummary( void ) 
{
  return PString( "TransportQOS" );
}

void H225_TransportQOS::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "endpointControlled" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_TransportQOS_endpointControlled, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "gatekeeperControlled" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_TransportQOS_gatekeeperControlled, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "noControl" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_TransportQOS_noControl, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// UUIEsRequested
//

H225_UUIEsRequested::H225_UUIEsRequested(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_UUIEsRequested::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+8) << "setup = " << setprecision(indent) << m_setup << '\n';
  strm << setw(indent+17) << "callProceeding = " << setprecision(indent) << m_callProceeding << '\n';
  strm << setw(indent+10) << "connect = " << setprecision(indent) << m_connect << '\n';
  strm << setw(indent+11) << "alerting = " << setprecision(indent) << m_alerting << '\n';
  strm << setw(indent+14) << "information = " << setprecision(indent) << m_information << '\n';
  strm << setw(indent+18) << "releaseComplete = " << setprecision(indent) << m_releaseComplete << '\n';
  strm << setw(indent+11) << "facility = " << setprecision(indent) << m_facility << '\n';
  strm << setw(indent+11) << "progress = " << setprecision(indent) << m_progress << '\n';
  strm << setw(indent+8) << "empty = " << setprecision(indent) << m_empty << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_UUIEsRequested::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_UUIEsRequested::Class()), PInvalidCast);
#endif
  const H225_UUIEsRequested & other = (const H225_UUIEsRequested &)obj;

  Comparison result;

  if ((result = m_setup.Compare(other.m_setup)) != EqualTo)
    return result;
  if ((result = m_callProceeding.Compare(other.m_callProceeding)) != EqualTo)
    return result;
  if ((result = m_connect.Compare(other.m_connect)) != EqualTo)
    return result;
  if ((result = m_alerting.Compare(other.m_alerting)) != EqualTo)
    return result;
  if ((result = m_information.Compare(other.m_information)) != EqualTo)
    return result;
  if ((result = m_releaseComplete.Compare(other.m_releaseComplete)) != EqualTo)
    return result;
  if ((result = m_facility.Compare(other.m_facility)) != EqualTo)
    return result;
  if ((result = m_progress.Compare(other.m_progress)) != EqualTo)
    return result;
  if ((result = m_empty.Compare(other.m_empty)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_UUIEsRequested::GetDataLength() const
{
  return m_setup.GetObjectLength() +
         m_callProceeding.GetObjectLength() +
         m_connect.GetObjectLength() +
         m_alerting.GetObjectLength() +
         m_information.GetObjectLength() +
         m_releaseComplete.GetObjectLength() +
         m_facility.GetObjectLength() +
         m_progress.GetObjectLength() +
         m_empty.GetObjectLength();
}


BOOL H225_UUIEsRequested::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_setup.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callProceeding.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_connect.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_alerting.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_information.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_releaseComplete.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_facility.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_progress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_empty.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_UUIEsRequested::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_setup.Encode(strm);
  m_callProceeding.Encode(strm);
  m_connect.Encode(strm);
  m_alerting.Encode(strm);
  m_information.Encode(strm);
  m_releaseComplete.Encode(strm);
  m_facility.Encode(strm);
  m_progress.Encode(strm);
  m_empty.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_setup.Encode(strm);
  m_callProceeding.Encode(strm);
  m_connect.Encode(strm);
  m_alerting.Encode(strm);
  m_information.Encode(strm);
  m_releaseComplete.Encode(strm);
  m_facility.Encode(strm);
  m_progress.Encode(strm);
  m_empty.Encode(strm);
}


PObject * H225_UUIEsRequested::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_UUIEsRequested::Class()), PInvalidCast);
#endif
  return new H225_UUIEsRequested(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_UUIEsRequested::preShowEthereal( void )
{
  m_setup.preShowEthereal( );
  m_callProceeding.preShowEthereal( );
  m_connect.preShowEthereal( );
  m_alerting.preShowEthereal( );
  m_information.preShowEthereal( );
  m_releaseComplete.preShowEthereal( );
  m_facility.preShowEthereal( );
  m_progress.preShowEthereal( );
  m_empty.preShowEthereal( );
}

PString H225_UUIEsRequested::getSummary( void ) 
{
  return PString( "UUIEsRequested" );
}

void H225_UUIEsRequested::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_UUIEsRequested_setup, tvb, offset + m_setup.GetStartByte(), m_setup.GetByteLength() , m_setup.GetValue() );

  proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_UUIEsRequested_callProceeding, tvb, offset + m_callProceeding.GetStartByte(), m_callProceeding.GetByteLength() , m_callProceeding.GetValue() );

  proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_UUIEsRequested_connect, tvb, offset + m_connect.GetStartByte(), m_connect.GetByteLength() , m_connect.GetValue() );

  proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_UUIEsRequested_alerting, tvb, offset + m_alerting.GetStartByte(), m_alerting.GetByteLength() , m_alerting.GetValue() );

  proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_UUIEsRequested_information, tvb, offset + m_information.GetStartByte(), m_information.GetByteLength() , m_information.GetValue() );

  proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_UUIEsRequested_releaseComplete, tvb, offset + m_releaseComplete.GetStartByte(), m_releaseComplete.GetByteLength() , m_releaseComplete.GetValue() );

  proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_UUIEsRequested_facility, tvb, offset + m_facility.GetStartByte(), m_facility.GetByteLength() , m_facility.GetValue() );

  proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_UUIEsRequested_progress, tvb, offset + m_progress.GetStartByte(), m_progress.GetByteLength() , m_progress.GetValue() );

  proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_UUIEsRequested_empty, tvb, offset + m_empty.GetStartByte(), m_empty.GetByteLength() , m_empty.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// AdmissionRejectReason
//

H225_AdmissionRejectReason::H225_AdmissionRejectReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 8, TRUE
#ifndef PASN_NOPRINTON
      , "calledPartyNotRegistered "
        "invalidPermission "
        "requestDenied "
        "undefinedReason "
        "callerNotRegistered "
        "routeCallToGatekeeper "
        "invalidEndpointIdentifier "
        "resourceUnavailable "
        "securityDenial "
        "qosControlNotSupported "
        "incompleteAddress "
        "routeCallToSCN "
        "aliasesInconsistent "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_AdmissionRejectReason::operator H225_ArrayOf_PartyNumber &() const
#else
H225_AdmissionRejectReason::operator H225_ArrayOf_PartyNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_ArrayOf_PartyNumber::Class()), PInvalidCast);
#endif
  return *(H225_ArrayOf_PartyNumber *)choice;
}


H225_AdmissionRejectReason::operator const H225_ArrayOf_PartyNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_ArrayOf_PartyNumber::Class()), PInvalidCast);
#endif
  return *(H225_ArrayOf_PartyNumber *)choice;
}


BOOL H225_AdmissionRejectReason::CreateObject()
{
  switch (tag) {
    case e_calledPartyNotRegistered :
    case e_invalidPermission :
    case e_requestDenied :
    case e_undefinedReason :
    case e_callerNotRegistered :
    case e_routeCallToGatekeeper :
    case e_invalidEndpointIdentifier :
    case e_resourceUnavailable :
    case e_securityDenial :
    case e_qosControlNotSupported :
    case e_incompleteAddress :
    case e_aliasesInconsistent :
      choice = new PASN_Null();
      return TRUE;
    case e_routeCallToSCN :
      choice = new H225_ArrayOf_PartyNumber();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_AdmissionRejectReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_AdmissionRejectReason::Class()), PInvalidCast);
#endif
  return new H225_AdmissionRejectReason(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_AdmissionRejectReason::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_calledPartyNotRegistered :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_invalidPermission :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_requestDenied :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_undefinedReason :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_callerNotRegistered :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_routeCallToGatekeeper :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_invalidEndpointIdentifier :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_resourceUnavailable :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_securityDenial :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_qosControlNotSupported :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_incompleteAddress :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_routeCallToSCN :
        ( ( H225_ArrayOf_PartyNumber * ) choice )->preShowEthereal();
        break;
      case e_aliasesInconsistent :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_AdmissionRejectReason::getSummary( void ) 
{
  return PString( "AdmissionRejectReason" );
}

void H225_AdmissionRejectReason::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "calledPartyNotRegistered" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_AdmissionRejectReason_calledPartyNotRegistered, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "invalidPermission" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_AdmissionRejectReason_invalidPermission, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "requestDenied" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_AdmissionRejectReason_requestDenied, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "undefinedReason" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_AdmissionRejectReason_undefinedReason, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "callerNotRegistered" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_AdmissionRejectReason_callerNotRegistered, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "routeCallToGatekeeper" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_AdmissionRejectReason_routeCallToGatekeeper, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "invalidEndpointIdentifier" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_AdmissionRejectReason_invalidEndpointIdentifier, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "resourceUnavailable" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_AdmissionRejectReason_resourceUnavailable, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "securityDenial" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_AdmissionRejectReason_securityDenial, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "qosControlNotSupported" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_AdmissionRejectReason_qosControlNotSupported, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "incompleteAddress" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_AdmissionRejectReason_incompleteAddress, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "aliasesInconsistent" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_AdmissionRejectReason_aliasesInconsistent, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h225_0.ett_h225_AdmissionRejectReason_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// BandRejectReason
//

H225_BandRejectReason::H225_BandRejectReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 6, TRUE
#ifndef PASN_NOPRINTON
      , "notBound "
        "invalidConferenceID "
        "invalidPermission "
        "insufficientResources "
        "invalidRevision "
        "undefinedReason "
        "securityDenial "
#endif
    )
{
}


BOOL H225_BandRejectReason::CreateObject()
{
  switch (tag) {
    case e_notBound :
    case e_invalidConferenceID :
    case e_invalidPermission :
    case e_insufficientResources :
    case e_invalidRevision :
    case e_undefinedReason :
    case e_securityDenial :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_BandRejectReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_BandRejectReason::Class()), PInvalidCast);
#endif
  return new H225_BandRejectReason(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_BandRejectReason::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_notBound :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_invalidConferenceID :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_invalidPermission :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_insufficientResources :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_invalidRevision :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_undefinedReason :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_securityDenial :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_BandRejectReason::getSummary( void ) 
{
  return PString( "BandRejectReason" );
}

void H225_BandRejectReason::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "notBound" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_BandRejectReason_notBound, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "invalidConferenceID" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_BandRejectReason_invalidConferenceID, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "invalidPermission" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_BandRejectReason_invalidPermission, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "insufficientResources" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_BandRejectReason_insufficientResources, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "invalidRevision" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_BandRejectReason_invalidRevision, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "undefinedReason" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_BandRejectReason_undefinedReason, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "securityDenial" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_BandRejectReason_securityDenial, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// LocationRejectReason
//

H225_LocationRejectReason::H225_LocationRejectReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
      , "notRegistered "
        "invalidPermission "
        "requestDenied "
        "undefinedReason "
        "securityDenial "
        "aliasesInconsistent "
        "routeCallToSCN "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_LocationRejectReason::operator H225_ArrayOf_PartyNumber &() const
#else
H225_LocationRejectReason::operator H225_ArrayOf_PartyNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_ArrayOf_PartyNumber::Class()), PInvalidCast);
#endif
  return *(H225_ArrayOf_PartyNumber *)choice;
}


H225_LocationRejectReason::operator const H225_ArrayOf_PartyNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_ArrayOf_PartyNumber::Class()), PInvalidCast);
#endif
  return *(H225_ArrayOf_PartyNumber *)choice;
}


BOOL H225_LocationRejectReason::CreateObject()
{
  switch (tag) {
    case e_notRegistered :
    case e_invalidPermission :
    case e_requestDenied :
    case e_undefinedReason :
    case e_securityDenial :
    case e_aliasesInconsistent :
      choice = new PASN_Null();
      return TRUE;
    case e_routeCallToSCN :
      choice = new H225_ArrayOf_PartyNumber();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_LocationRejectReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_LocationRejectReason::Class()), PInvalidCast);
#endif
  return new H225_LocationRejectReason(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_LocationRejectReason::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_notRegistered :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_invalidPermission :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_requestDenied :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_undefinedReason :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_securityDenial :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_aliasesInconsistent :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_routeCallToSCN :
        ( ( H225_ArrayOf_PartyNumber * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_LocationRejectReason::getSummary( void ) 
{
  return PString( "LocationRejectReason" );
}

void H225_LocationRejectReason::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "notRegistered" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_LocationRejectReason_notRegistered, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "invalidPermission" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_LocationRejectReason_invalidPermission, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "requestDenied" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_LocationRejectReason_requestDenied, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "undefinedReason" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_LocationRejectReason_undefinedReason, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "securityDenial" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_LocationRejectReason_securityDenial, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "aliasesInconsistent" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_LocationRejectReason_aliasesInconsistent, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h225_0.ett_h225_LocationRejectReason_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// DisengageReason
//

H225_DisengageReason::H225_DisengageReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "forcedDrop "
        "normalDrop "
        "undefinedReason "
#endif
    )
{
}


BOOL H225_DisengageReason::CreateObject()
{
  switch (tag) {
    case e_forcedDrop :
    case e_normalDrop :
    case e_undefinedReason :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_DisengageReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_DisengageReason::Class()), PInvalidCast);
#endif
  return new H225_DisengageReason(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_DisengageReason::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_forcedDrop :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_normalDrop :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_undefinedReason :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_DisengageReason::getSummary( void ) 
{
  return PString( "DisengageReason" );
}

void H225_DisengageReason::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "forcedDrop" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_DisengageReason_forcedDrop, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "normalDrop" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_DisengageReason_normalDrop, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "undefinedReason" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_DisengageReason_undefinedReason, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// DisengageRejectReason
//

H225_DisengageRejectReason::H225_DisengageRejectReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "notRegistered "
        "requestToDropOther "
        "securityDenial "
#endif
    )
{
}


BOOL H225_DisengageRejectReason::CreateObject()
{
  switch (tag) {
    case e_notRegistered :
    case e_requestToDropOther :
    case e_securityDenial :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_DisengageRejectReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_DisengageRejectReason::Class()), PInvalidCast);
#endif
  return new H225_DisengageRejectReason(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_DisengageRejectReason::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_notRegistered :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_requestToDropOther :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_securityDenial :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_DisengageRejectReason::getSummary( void ) 
{
  return PString( "DisengageRejectReason" );
}

void H225_DisengageRejectReason::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "notRegistered" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_DisengageRejectReason_notRegistered, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "requestToDropOther" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_DisengageRejectReason_requestToDropOther, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "securityDenial" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_DisengageRejectReason_securityDenial, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// TransportChannelInfo
//

H225_TransportChannelInfo::H225_TransportChannelInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_TransportChannelInfo::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_sendAddress))
    strm << setw(indent+14) << "sendAddress = " << setprecision(indent) << m_sendAddress << '\n';
  if (HasOptionalField(e_recvAddress))
    strm << setw(indent+14) << "recvAddress = " << setprecision(indent) << m_recvAddress << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_TransportChannelInfo::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_TransportChannelInfo::Class()), PInvalidCast);
#endif
  const H225_TransportChannelInfo & other = (const H225_TransportChannelInfo &)obj;

  Comparison result;

  if ((result = m_sendAddress.Compare(other.m_sendAddress)) != EqualTo)
    return result;
  if ((result = m_recvAddress.Compare(other.m_recvAddress)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_TransportChannelInfo::GetDataLength() const
{
  return m_sendAddress.GetObjectLength() +
         m_recvAddress.GetObjectLength();
}


BOOL H225_TransportChannelInfo::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_sendAddress ) && !m_sendAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_recvAddress ) && !m_recvAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_TransportChannelInfo::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_sendAddress))
    m_sendAddress.Encode(strm);
  if (HasOptionalField(e_recvAddress))
    m_recvAddress.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_sendAddress))
    m_sendAddress.Encode(strm);
  if (HasOptionalField(e_recvAddress))
    m_recvAddress.Encode(strm);
}


PObject * H225_TransportChannelInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_TransportChannelInfo::Class()), PInvalidCast);
#endif
  return new H225_TransportChannelInfo(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_TransportChannelInfo::preShowEthereal( void )
{
  if ( HasOptionalField( e_sendAddress ) ) 
      m_sendAddress.preShowEthereal( );
  if ( HasOptionalField( e_recvAddress ) ) 
      m_recvAddress.preShowEthereal( );
}

PString H225_TransportChannelInfo::getSummary( void ) 
{
  return PString( "TransportChannelInfo" );
}

void H225_TransportChannelInfo::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_sendAddress ) ) {
    proto_tree *sendAddress_tree = (proto_tree*) NULL;
    proto_item *sendAddress_ti = (proto_item*) NULL;
    sendAddress_ti = proto_tree_add_text( tree, tvb, offset + m_sendAddress.GetStartByte(), m_sendAddress.GetByteLength(), "sendAddress (%s)", ( const char* ) m_sendAddress.GetTagName() );
    sendAddress_tree = proto_item_add_subtree( sendAddress_ti, hCont->h225_0.ett_h225_TransportChannelInfo_sendAddress );
    m_sendAddress.showEthereal( sendAddress_tree, tvb, offset );
  }

  if ( HasOptionalField( e_recvAddress ) ) {
    proto_tree *recvAddress_tree = (proto_tree*) NULL;
    proto_item *recvAddress_ti = (proto_item*) NULL;
    recvAddress_ti = proto_tree_add_text( tree, tvb, offset + m_recvAddress.GetStartByte(), m_recvAddress.GetByteLength(), "recvAddress (%s)", ( const char* ) m_recvAddress.GetTagName() );
    recvAddress_tree = proto_item_add_subtree( recvAddress_ti, hCont->h225_0.ett_h225_TransportChannelInfo_recvAddress );
    m_recvAddress.showEthereal( recvAddress_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// InfoRequestNakReason
//

H225_InfoRequestNakReason::H225_InfoRequestNakReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "notRegistered "
        "securityDenial "
        "undefinedReason "
#endif
    )
{
}


BOOL H225_InfoRequestNakReason::CreateObject()
{
  switch (tag) {
    case e_notRegistered :
    case e_securityDenial :
    case e_undefinedReason :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_InfoRequestNakReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_InfoRequestNakReason::Class()), PInvalidCast);
#endif
  return new H225_InfoRequestNakReason(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_InfoRequestNakReason::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_notRegistered :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_securityDenial :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_undefinedReason :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_InfoRequestNakReason::getSummary( void ) 
{
  return PString( "InfoRequestNakReason" );
}

void H225_InfoRequestNakReason::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "notRegistered" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_InfoRequestNakReason_notRegistered, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "securityDenial" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_InfoRequestNakReason_securityDenial, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "undefinedReason" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_InfoRequestNakReason_undefinedReason, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// H323-UserInformation_user-data
//

H225_H323_UserInformation_user_data::H225_H323_UserInformation_user_data(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_protocol_discriminator.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
  m_user_information.SetConstraints(PASN_Object::FixedConstraint, 1, 131);
}


#ifndef PASN_NOPRINTON
void H225_H323_UserInformation_user_data::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+25) << "protocol_discriminator = " << setprecision(indent) << m_protocol_discriminator << '\n';
  strm << setw(indent+19) << "user_information = " << setprecision(indent) << m_user_information << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_H323_UserInformation_user_data::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_H323_UserInformation_user_data::Class()), PInvalidCast);
#endif
  const H225_H323_UserInformation_user_data & other = (const H225_H323_UserInformation_user_data &)obj;

  Comparison result;

  if ((result = m_protocol_discriminator.Compare(other.m_protocol_discriminator)) != EqualTo)
    return result;
  if ((result = m_user_information.Compare(other.m_user_information)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_H323_UserInformation_user_data::GetDataLength() const
{
  return m_protocol_discriminator.GetObjectLength() +
         m_user_information.GetObjectLength();
}


BOOL H225_H323_UserInformation_user_data::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_protocol_discriminator.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_user_information.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_H323_UserInformation_user_data::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protocol_discriminator.Encode(strm);
  m_user_information.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_protocol_discriminator.Encode(strm);
  m_user_information.Encode(strm);
}


PObject * H225_H323_UserInformation_user_data::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_H323_UserInformation_user_data::Class()), PInvalidCast);
#endif
  return new H225_H323_UserInformation_user_data(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_H323_UserInformation_user_data::preShowEthereal( void )
{
  m_protocol_discriminator.preShowEthereal( );
  m_user_information.preShowEthereal( );
}

PString H225_H323_UserInformation_user_data::getSummary( void ) 
{
  return PString( "H323-UserInformation_user-data" );
}

void H225_H323_UserInformation_user_data::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_0.hf_h225_H323_UserInformation_user_data_protocol_discriminator, tvb, offset + m_protocol_discriminator.GetStartByte(), m_protocol_discriminator.GetByteLength() , m_protocol_discriminator.GetValue() );

  char* puser_information = m_user_information.getValue();
  proto_tree_add_string( tree, hCont->h225_0.hf_h225_H323_UserInformation_user_data_user_information, tvb, offset + m_user_information.GetStartByte(), m_user_information.GetByteLength() , puser_information );
  delete[] puser_information;

}
#endif  //USE_FOR_ETHEREAL

//
// H323-UU-PDU_h323-message-body
//

H225_H323_UU_PDU_h323_message_body::H225_H323_UU_PDU_h323_message_body(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 7, TRUE
#ifndef PASN_NOPRINTON
      , "setup "
        "callProceeding "
        "connect "
        "alerting "
        "information "
        "releaseComplete "
        "facility "
        "progress "
        "empty "
#endif
    )
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_H323_UU_PDU_h323_message_body::operator H225_Setup_UUIE &() const
#else
H225_H323_UU_PDU_h323_message_body::operator H225_Setup_UUIE &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_Setup_UUIE::Class()), PInvalidCast);
#endif
  return *(H225_Setup_UUIE *)choice;
}


H225_H323_UU_PDU_h323_message_body::operator const H225_Setup_UUIE &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_Setup_UUIE::Class()), PInvalidCast);
#endif
  return *(H225_Setup_UUIE *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_H323_UU_PDU_h323_message_body::operator H225_CallProceeding_UUIE &() const
#else
H225_H323_UU_PDU_h323_message_body::operator H225_CallProceeding_UUIE &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_CallProceeding_UUIE::Class()), PInvalidCast);
#endif
  return *(H225_CallProceeding_UUIE *)choice;
}


H225_H323_UU_PDU_h323_message_body::operator const H225_CallProceeding_UUIE &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_CallProceeding_UUIE::Class()), PInvalidCast);
#endif
  return *(H225_CallProceeding_UUIE *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_H323_UU_PDU_h323_message_body::operator H225_Connect_UUIE &() const
#else
H225_H323_UU_PDU_h323_message_body::operator H225_Connect_UUIE &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_Connect_UUIE::Class()), PInvalidCast);
#endif
  return *(H225_Connect_UUIE *)choice;
}


H225_H323_UU_PDU_h323_message_body::operator const H225_Connect_UUIE &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_Connect_UUIE::Class()), PInvalidCast);
#endif
  return *(H225_Connect_UUIE *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_H323_UU_PDU_h323_message_body::operator H225_Alerting_UUIE &() const
#else
H225_H323_UU_PDU_h323_message_body::operator H225_Alerting_UUIE &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_Alerting_UUIE::Class()), PInvalidCast);
#endif
  return *(H225_Alerting_UUIE *)choice;
}


H225_H323_UU_PDU_h323_message_body::operator const H225_Alerting_UUIE &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_Alerting_UUIE::Class()), PInvalidCast);
#endif
  return *(H225_Alerting_UUIE *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_H323_UU_PDU_h323_message_body::operator H225_Information_UUIE &() const
#else
H225_H323_UU_PDU_h323_message_body::operator H225_Information_UUIE &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_Information_UUIE::Class()), PInvalidCast);
#endif
  return *(H225_Information_UUIE *)choice;
}


H225_H323_UU_PDU_h323_message_body::operator const H225_Information_UUIE &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_Information_UUIE::Class()), PInvalidCast);
#endif
  return *(H225_Information_UUIE *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_H323_UU_PDU_h323_message_body::operator H225_ReleaseComplete_UUIE &() const
#else
H225_H323_UU_PDU_h323_message_body::operator H225_ReleaseComplete_UUIE &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_ReleaseComplete_UUIE::Class()), PInvalidCast);
#endif
  return *(H225_ReleaseComplete_UUIE *)choice;
}


H225_H323_UU_PDU_h323_message_body::operator const H225_ReleaseComplete_UUIE &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_ReleaseComplete_UUIE::Class()), PInvalidCast);
#endif
  return *(H225_ReleaseComplete_UUIE *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_H323_UU_PDU_h323_message_body::operator H225_Facility_UUIE &() const
#else
H225_H323_UU_PDU_h323_message_body::operator H225_Facility_UUIE &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_Facility_UUIE::Class()), PInvalidCast);
#endif
  return *(H225_Facility_UUIE *)choice;
}


H225_H323_UU_PDU_h323_message_body::operator const H225_Facility_UUIE &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_Facility_UUIE::Class()), PInvalidCast);
#endif
  return *(H225_Facility_UUIE *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H225_H323_UU_PDU_h323_message_body::operator H225_Progress_UUIE &() const
#else
H225_H323_UU_PDU_h323_message_body::operator H225_Progress_UUIE &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_Progress_UUIE::Class()), PInvalidCast);
#endif
  return *(H225_Progress_UUIE *)choice;
}


H225_H323_UU_PDU_h323_message_body::operator const H225_Progress_UUIE &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PAssertNULL(choice)->IsDescendant(H225_Progress_UUIE::Class()), PInvalidCast);
#endif
  return *(H225_Progress_UUIE *)choice;
}


BOOL H225_H323_UU_PDU_h323_message_body::CreateObject()
{
  switch (tag) {
    case e_setup :
      choice = new H225_Setup_UUIE();
      return TRUE;
    case e_callProceeding :
      choice = new H225_CallProceeding_UUIE();
      return TRUE;
    case e_connect :
      choice = new H225_Connect_UUIE();
      return TRUE;
    case e_alerting :
      choice = new H225_Alerting_UUIE();
      return TRUE;
    case e_information :
      choice = new H225_Information_UUIE();
      return TRUE;
    case e_releaseComplete :
      choice = new H225_ReleaseComplete_UUIE();
      return TRUE;
    case e_facility :
      choice = new H225_Facility_UUIE();
      return TRUE;
    case e_progress :
      choice = new H225_Progress_UUIE();
      return TRUE;
    case e_empty :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_H323_UU_PDU_h323_message_body::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_H323_UU_PDU_h323_message_body::Class()), PInvalidCast);
#endif
  return new H225_H323_UU_PDU_h323_message_body(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_H323_UU_PDU_h323_message_body::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_setup :
        ( ( H225_Setup_UUIE * ) choice )->preShowEthereal();
        break;
      case e_callProceeding :
        ( ( H225_CallProceeding_UUIE * ) choice )->preShowEthereal();
        break;
      case e_connect :
        ( ( H225_Connect_UUIE * ) choice )->preShowEthereal();
        break;
      case e_alerting :
        ( ( H225_Alerting_UUIE * ) choice )->preShowEthereal();
        break;
      case e_information :
        ( ( H225_Information_UUIE * ) choice )->preShowEthereal();
        break;
      case e_releaseComplete :
        ( ( H225_ReleaseComplete_UUIE * ) choice )->preShowEthereal();
        break;
      case e_facility :
        ( ( H225_Facility_UUIE * ) choice )->preShowEthereal();
        break;
      case e_progress :
        ( ( H225_Progress_UUIE * ) choice )->preShowEthereal();
        break;
      case e_empty :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_H323_UU_PDU_h323_message_body::getSummary( void ) 
{
	if ( choice != NULL )
		return choice->getSummary();
	else 
		return PString( "H323-UU-PDU_h323-message-body" );
}

void H225_H323_UU_PDU_h323_message_body::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "empty" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_H323_UU_PDU_h323_message_body_empty, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    /* In case there's a choice type that's a non-terminal, create
     * a subtree and let the choice type display itself
     */
    proto_tree * ptree = (proto_tree*) NULL;
    proto_item * pti = (proto_item*) NULL;
    pti = proto_tree_add_text( tree, tvb, offset + choice->GetStartByte(), choice->GetByteLength(), (const char*) GetTagName() );
    ptree = proto_item_add_subtree( pti, hCont->h225_0.ett_h225_H323_UU_PDU_h323_message_body_choice );
    choice->showEthereal( ptree, tvb, offset );
  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_PASN_OctetString
//

H225_ArrayOf_PASN_OctetString::H225_ArrayOf_PASN_OctetString(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_PASN_OctetString::CreateObject() const
{
  return new PASN_OctetString;
}


PASN_OctetString & H225_ArrayOf_PASN_OctetString::operator[](PINDEX i) const
{
  return (PASN_OctetString &)array[i];
}


PObject * H225_ArrayOf_PASN_OctetString::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_PASN_OctetString::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_PASN_OctetString(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ArrayOf_PASN_OctetString::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (PASN_OctetString& ) array[i] ).preShowEthereal();
  }
}

PString H225_ArrayOf_PASN_OctetString::getSummary( void ) 
{
  return PString( "ArrayOf_PASN_OctetString" );
}

void H225_ArrayOf_PASN_OctetString::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  for (int i=0; i < array.GetSize(); i++ ) {
    char* pstring = ( ( PASN_OctetString & ) array[i] ).getValue();
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_ArrayOf_PASN_OctetString_array, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), pstring );
    delete[] pstring;
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_NonStandardParameter
//

H225_ArrayOf_NonStandardParameter::H225_ArrayOf_NonStandardParameter(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_NonStandardParameter::CreateObject() const
{
  return new H225_NonStandardParameter;
}


H225_NonStandardParameter & H225_ArrayOf_NonStandardParameter::operator[](PINDEX i) const
{
  return (H225_NonStandardParameter &)array[i];
}


PObject * H225_ArrayOf_NonStandardParameter::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_NonStandardParameter::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_NonStandardParameter(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ArrayOf_NonStandardParameter::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H225_NonStandardParameter& ) array[i] ).preShowEthereal();
  }
}

PString H225_ArrayOf_NonStandardParameter::getSummary( void ) 
{
  return PString( "ArrayOf_NonStandardParameter" );
}

void H225_ArrayOf_NonStandardParameter::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_NonStandardParameter_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_NonStandardParameter_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_NonStandardParameter_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (NonStandardParameter)", i );
    ArrayOf_NonStandardParameter_tree = proto_item_add_subtree( ArrayOf_NonStandardParameter_ti, hCont->h225_0.ett_h225_ArrayOf_NonStandardParameter );
    array[i].showEthereal( ArrayOf_NonStandardParameter_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_ClearToken
//

H225_ArrayOf_ClearToken::H225_ArrayOf_ClearToken(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_ClearToken::CreateObject() const
{
  return new H235_ClearToken;
}


H235_ClearToken & H225_ArrayOf_ClearToken::operator[](PINDEX i) const
{
  return (H235_ClearToken &)array[i];
}


PObject * H225_ArrayOf_ClearToken::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_ClearToken::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_ClearToken(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ArrayOf_ClearToken::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H235_ClearToken& ) array[i] ).preShowEthereal();
  }
}

PString H225_ArrayOf_ClearToken::getSummary( void ) 
{
  return PString( "ArrayOf_ClearToken" );
}

void H225_ArrayOf_ClearToken::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_ClearToken_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_ClearToken_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_ClearToken_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (H235-ClearToken)", i );
    ArrayOf_ClearToken_tree = proto_item_add_subtree( ArrayOf_ClearToken_ti, hCont->h225_0.ett_h225_ArrayOf_ClearToken );
    array[i].showEthereal( ArrayOf_ClearToken_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_CryptoH323Token
//

H225_ArrayOf_CryptoH323Token::H225_ArrayOf_CryptoH323Token(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_CryptoH323Token::CreateObject() const
{
  return new H225_CryptoH323Token;
}


H225_CryptoH323Token & H225_ArrayOf_CryptoH323Token::operator[](PINDEX i) const
{
  return (H225_CryptoH323Token &)array[i];
}


PObject * H225_ArrayOf_CryptoH323Token::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_CryptoH323Token::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_CryptoH323Token(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ArrayOf_CryptoH323Token::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H225_CryptoH323Token& ) array[i] ).preShowEthereal();
  }
}

PString H225_ArrayOf_CryptoH323Token::getSummary( void ) 
{
  return PString( "ArrayOf_CryptoH323Token" );
}

void H225_ArrayOf_CryptoH323Token::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_CryptoH323Token_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_CryptoH323Token_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_CryptoH323Token_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (%s)", i, (const char*) ( ( PASN_Choice* ) &( array[i] ) )->GetTagName() );
    ArrayOf_CryptoH323Token_tree = proto_item_add_subtree( ArrayOf_CryptoH323Token_ti, hCont->h225_0.ett_h225_ArrayOf_CryptoH323Token );
    array[i].showEthereal( ArrayOf_CryptoH323Token_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_AliasAddress
//

H225_ArrayOf_AliasAddress::H225_ArrayOf_AliasAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_AliasAddress::CreateObject() const
{
  return new H225_AliasAddress;
}


H225_AliasAddress & H225_ArrayOf_AliasAddress::operator[](PINDEX i) const
{
  return (H225_AliasAddress &)array[i];
}


PObject * H225_ArrayOf_AliasAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_AliasAddress::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_AliasAddress(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ArrayOf_AliasAddress::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H225_AliasAddress& ) array[i] ).preShowEthereal();
  }
}

PString H225_ArrayOf_AliasAddress::getSummary( void ) 
{
  return PString( "ArrayOf_AliasAddress" );
}

void H225_ArrayOf_AliasAddress::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_AliasAddress_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_AliasAddress_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_AliasAddress_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (%s)", i, (const char*) ( ( PASN_Choice* ) &( array[i] ) )->GetTagName() );
    ArrayOf_AliasAddress_tree = proto_item_add_subtree( ArrayOf_AliasAddress_ti, hCont->h225_0.ett_h225_ArrayOf_AliasAddress );
    array[i].showEthereal( ArrayOf_AliasAddress_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// Connect-UUIE_language
//

H225_Connect_UUIE_language::H225_Connect_UUIE_language(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_Connect_UUIE_language::CreateObject() const
{
  PASN_IA5String * obj = new PASN_IA5String;
  obj->SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  return obj;
}


PASN_IA5String & H225_Connect_UUIE_language::operator[](PINDEX i) const
{
  return (PASN_IA5String &)array[i];
}


PObject * H225_Connect_UUIE_language::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_Connect_UUIE_language::Class()), PInvalidCast);
#endif
  return new H225_Connect_UUIE_language(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_Connect_UUIE_language::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (PASN_IA5String& ) array[i] ).preShowEthereal();
  }
}

PString H225_Connect_UUIE_language::getSummary( void ) 
{
  return PString( "Connect-UUIE_language" );
}

void H225_Connect_UUIE_language::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  for (int i=0; i < array.GetSize(); i++ ) {
    char* pstring = ( ( PASN_IA5String & ) array[i] ).getValue();
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_Connect_UUIE_language_array, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), pstring );
    delete[] pstring;
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_CallReferenceValue
//

H225_ArrayOf_CallReferenceValue::H225_ArrayOf_CallReferenceValue(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_CallReferenceValue::CreateObject() const
{
  return new H225_CallReferenceValue;
}


H225_CallReferenceValue & H225_ArrayOf_CallReferenceValue::operator[](PINDEX i) const
{
  return (H225_CallReferenceValue &)array[i];
}


PObject * H225_ArrayOf_CallReferenceValue::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_CallReferenceValue::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_CallReferenceValue(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ArrayOf_CallReferenceValue::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H225_CallReferenceValue& ) array[i] ).preShowEthereal();
  }
}

PString H225_ArrayOf_CallReferenceValue::getSummary( void ) 
{
  return PString( "ArrayOf_CallReferenceValue" );
}

void H225_ArrayOf_CallReferenceValue::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  for (int i=0; i < array.GetSize(); i++ ) {
    proto_tree_add_uint( tree, hCont->h225_0.hf_h225_ArrayOf_CallReferenceValue_array, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), ( (PASN_Integer& ) array[i] ).GetValue() );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// Setup-UUIE_conferenceGoal
//

H225_Setup_UUIE_conferenceGoal::H225_Setup_UUIE_conferenceGoal(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
      , "create "
        "join "
        "invite "
        "capability_negotiation "
        "callIndependentSupplementaryService "
#endif
    )
{
}


BOOL H225_Setup_UUIE_conferenceGoal::CreateObject()
{
  switch (tag) {
    case e_create :
    case e_join :
    case e_invite :
    case e_capability_negotiation :
    case e_callIndependentSupplementaryService :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_Setup_UUIE_conferenceGoal::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_Setup_UUIE_conferenceGoal::Class()), PInvalidCast);
#endif
  return new H225_Setup_UUIE_conferenceGoal(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_Setup_UUIE_conferenceGoal::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_create :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_join :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_invite :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_capability_negotiation :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_callIndependentSupplementaryService :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_Setup_UUIE_conferenceGoal::getSummary( void ) 
{
  return PString( "Setup-UUIE_conferenceGoal" );
}

void H225_Setup_UUIE_conferenceGoal::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "create" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_Setup_UUIE_conferenceGoal_create, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "join" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_Setup_UUIE_conferenceGoal_join, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "invite" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_Setup_UUIE_conferenceGoal_invite, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "capability_negotiation" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_Setup_UUIE_conferenceGoal_capability_negotiation, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "callIndependentSupplementaryService" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_Setup_UUIE_conferenceGoal_callIndependentSupplementaryService, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_H245Security
//

H225_ArrayOf_H245Security::H225_ArrayOf_H245Security(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_H245Security::CreateObject() const
{
  return new H225_H245Security;
}


H225_H245Security & H225_ArrayOf_H245Security::operator[](PINDEX i) const
{
  return (H225_H245Security &)array[i];
}


PObject * H225_ArrayOf_H245Security::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_H245Security::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_H245Security(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ArrayOf_H245Security::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H225_H245Security& ) array[i] ).preShowEthereal();
  }
}

PString H225_ArrayOf_H245Security::getSummary( void ) 
{
  return PString( "ArrayOf_H245Security" );
}

void H225_ArrayOf_H245Security::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_H245Security_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_H245Security_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_H245Security_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (%s)", i, (const char*) ( ( PASN_Choice* ) &( array[i] ) )->GetTagName() );
    ArrayOf_H245Security_tree = proto_item_add_subtree( ArrayOf_H245Security_ti, hCont->h225_0.ett_h225_ArrayOf_H245Security );
    array[i].showEthereal( ArrayOf_H245Security_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// Setup-UUIE_connectionParameters
//

H225_Setup_UUIE_connectionParameters::H225_Setup_UUIE_connectionParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_numberOfScnConnections.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H225_Setup_UUIE_connectionParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "connectionType = " << setprecision(indent) << m_connectionType << '\n';
  strm << setw(indent+25) << "numberOfScnConnections = " << setprecision(indent) << m_numberOfScnConnections << '\n';
  strm << setw(indent+24) << "connectionAggregation = " << setprecision(indent) << m_connectionAggregation << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_Setup_UUIE_connectionParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_Setup_UUIE_connectionParameters::Class()), PInvalidCast);
#endif
  const H225_Setup_UUIE_connectionParameters & other = (const H225_Setup_UUIE_connectionParameters &)obj;

  Comparison result;

  if ((result = m_connectionType.Compare(other.m_connectionType)) != EqualTo)
    return result;
  if ((result = m_numberOfScnConnections.Compare(other.m_numberOfScnConnections)) != EqualTo)
    return result;
  if ((result = m_connectionAggregation.Compare(other.m_connectionAggregation)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_Setup_UUIE_connectionParameters::GetDataLength() const
{
  return m_connectionType.GetObjectLength() +
         m_numberOfScnConnections.GetObjectLength() +
         m_connectionAggregation.GetObjectLength();
}


BOOL H225_Setup_UUIE_connectionParameters::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_connectionType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_numberOfScnConnections.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_connectionAggregation.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_Setup_UUIE_connectionParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_connectionType.Encode(strm);
  m_numberOfScnConnections.Encode(strm);
  m_connectionAggregation.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_connectionType.Encode(strm);
  m_numberOfScnConnections.Encode(strm);
  m_connectionAggregation.Encode(strm);
}


PObject * H225_Setup_UUIE_connectionParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_Setup_UUIE_connectionParameters::Class()), PInvalidCast);
#endif
  return new H225_Setup_UUIE_connectionParameters(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_Setup_UUIE_connectionParameters::preShowEthereal( void )
{
  m_connectionType.preShowEthereal( );
  m_numberOfScnConnections.preShowEthereal( );
  m_connectionAggregation.preShowEthereal( );
}

PString H225_Setup_UUIE_connectionParameters::getSummary( void ) 
{
  return PString( "Setup-UUIE_connectionParameters" );
}

void H225_Setup_UUIE_connectionParameters::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *connectionType_tree = (proto_tree*) NULL;
  proto_item *connectionType_ti = (proto_item*) NULL;
  connectionType_ti = proto_tree_add_text( tree, tvb, offset + m_connectionType.GetStartByte(), m_connectionType.GetByteLength(), "connectionType (%s)", ( const char* ) m_connectionType.GetTagName() );
  connectionType_tree = proto_item_add_subtree( connectionType_ti, hCont->h225_0.ett_h225_Setup_UUIE_connectionParameters_connectionType );

  m_connectionType.showEthereal( connectionType_tree, tvb, offset );

  proto_tree_add_uint( tree, hCont->h225_0.hf_h225_Setup_UUIE_connectionParameters_numberOfScnConnections, tvb, offset + m_numberOfScnConnections.GetStartByte(), m_numberOfScnConnections.GetByteLength() , m_numberOfScnConnections.GetValue() );

  proto_tree *connectionAggregation_tree = (proto_tree*) NULL;
  proto_item *connectionAggregation_ti = (proto_item*) NULL;
  connectionAggregation_ti = proto_tree_add_text( tree, tvb, offset + m_connectionAggregation.GetStartByte(), m_connectionAggregation.GetByteLength(), "connectionAggregation (%s)", ( const char* ) m_connectionAggregation.GetTagName() );
  connectionAggregation_tree = proto_item_add_subtree( connectionAggregation_ti, hCont->h225_0.ett_h225_Setup_UUIE_connectionParameters_connectionAggregation );

  m_connectionAggregation.showEthereal( connectionAggregation_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// Setup-UUIE_language
//

H225_Setup_UUIE_language::H225_Setup_UUIE_language(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_Setup_UUIE_language::CreateObject() const
{
  PASN_IA5String * obj = new PASN_IA5String;
  obj->SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  return obj;
}


PASN_IA5String & H225_Setup_UUIE_language::operator[](PINDEX i) const
{
  return (PASN_IA5String &)array[i];
}


PObject * H225_Setup_UUIE_language::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_Setup_UUIE_language::Class()), PInvalidCast);
#endif
  return new H225_Setup_UUIE_language(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_Setup_UUIE_language::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (PASN_IA5String& ) array[i] ).preShowEthereal();
  }
}

PString H225_Setup_UUIE_language::getSummary( void ) 
{
  return PString( "Setup-UUIE_language" );
}

void H225_Setup_UUIE_language::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  for (int i=0; i < array.GetSize(); i++ ) {
    char* pstring = ( ( PASN_IA5String & ) array[i] ).getValue();
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_Setup_UUIE_language_array, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), pstring );
    delete[] pstring;
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_ConferenceList
//

H225_ArrayOf_ConferenceList::H225_ArrayOf_ConferenceList(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_ConferenceList::CreateObject() const
{
  return new H225_ConferenceList;
}


H225_ConferenceList & H225_ArrayOf_ConferenceList::operator[](PINDEX i) const
{
  return (H225_ConferenceList &)array[i];
}


PObject * H225_ArrayOf_ConferenceList::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_ConferenceList::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_ConferenceList(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ArrayOf_ConferenceList::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H225_ConferenceList& ) array[i] ).preShowEthereal();
  }
}

PString H225_ArrayOf_ConferenceList::getSummary( void ) 
{
  return PString( "ArrayOf_ConferenceList" );
}

void H225_ArrayOf_ConferenceList::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_ConferenceList_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_ConferenceList_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_ConferenceList_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (ConferenceList)", i );
    ArrayOf_ConferenceList_tree = proto_item_add_subtree( ArrayOf_ConferenceList_ti, hCont->h225_0.ett_h225_ArrayOf_ConferenceList );
    array[i].showEthereal( ArrayOf_ConferenceList_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// TransportAddress_ipAddress
//

H225_TransportAddress_ipAddress::H225_TransportAddress_ipAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
  m_ip.SetConstraints(PASN_Object::FixedConstraint, 4, 4);
  m_port.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H225_TransportAddress_ipAddress::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+5) << "ip = " << setprecision(indent) << m_ip << '\n';
  strm << setw(indent+7) << "port = " << setprecision(indent) << m_port << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_TransportAddress_ipAddress::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_TransportAddress_ipAddress::Class()), PInvalidCast);
#endif
  const H225_TransportAddress_ipAddress & other = (const H225_TransportAddress_ipAddress &)obj;

  Comparison result;

  if ((result = m_ip.Compare(other.m_ip)) != EqualTo)
    return result;
  if ((result = m_port.Compare(other.m_port)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_TransportAddress_ipAddress::GetDataLength() const
{
  return m_ip.GetObjectLength() +
         m_port.GetObjectLength();
}


BOOL H225_TransportAddress_ipAddress::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_ip.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_port.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_TransportAddress_ipAddress::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_ip.Encode(strm);
  m_port.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_ip.Encode(strm);
  m_port.Encode(strm);
}


PObject * H225_TransportAddress_ipAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_TransportAddress_ipAddress::Class()), PInvalidCast);
#endif
  return new H225_TransportAddress_ipAddress(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_TransportAddress_ipAddress::preShowEthereal( void )
{
  m_ip.preShowEthereal( );
  m_port.preShowEthereal( );
}

PString H225_TransportAddress_ipAddress::getSummary( void ) 
{
  return PString( "TransportAddress_ipAddress" );
}

void H225_TransportAddress_ipAddress::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pip = m_ip.getValue();
  proto_tree_add_ipv4( tree, hCont->h225_0.hf_h225_TransportAddress_ipAddress_ip, tvb, offset + m_ip.GetStartByte(), m_ip.GetByteLength() , (guint32) pletohl( pip ) );
  delete[] pip;

  proto_tree_add_uint( tree, hCont->h225_0.hf_h225_TransportAddress_ipAddress_port, tvb, offset + m_port.GetStartByte(), m_port.GetByteLength() , m_port.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// TransportAddress_ipxAddress
//

H225_TransportAddress_ipxAddress::H225_TransportAddress_ipxAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
  m_node.SetConstraints(PASN_Object::FixedConstraint, 6, 6);
  m_netnum.SetConstraints(PASN_Object::FixedConstraint, 4, 4);
  m_port.SetConstraints(PASN_Object::FixedConstraint, 2, 2);
}


#ifndef PASN_NOPRINTON
void H225_TransportAddress_ipxAddress::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "node = " << setprecision(indent) << m_node << '\n';
  strm << setw(indent+9) << "netnum = " << setprecision(indent) << m_netnum << '\n';
  strm << setw(indent+7) << "port = " << setprecision(indent) << m_port << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_TransportAddress_ipxAddress::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_TransportAddress_ipxAddress::Class()), PInvalidCast);
#endif
  const H225_TransportAddress_ipxAddress & other = (const H225_TransportAddress_ipxAddress &)obj;

  Comparison result;

  if ((result = m_node.Compare(other.m_node)) != EqualTo)
    return result;
  if ((result = m_netnum.Compare(other.m_netnum)) != EqualTo)
    return result;
  if ((result = m_port.Compare(other.m_port)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_TransportAddress_ipxAddress::GetDataLength() const
{
  return m_node.GetObjectLength() +
         m_netnum.GetObjectLength() +
         m_port.GetObjectLength();
}


BOOL H225_TransportAddress_ipxAddress::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_node.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_netnum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_port.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_TransportAddress_ipxAddress::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_node.Encode(strm);
  m_netnum.Encode(strm);
  m_port.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_node.Encode(strm);
  m_netnum.Encode(strm);
  m_port.Encode(strm);
}


PObject * H225_TransportAddress_ipxAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_TransportAddress_ipxAddress::Class()), PInvalidCast);
#endif
  return new H225_TransportAddress_ipxAddress(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_TransportAddress_ipxAddress::preShowEthereal( void )
{
  m_node.preShowEthereal( );
  m_netnum.preShowEthereal( );
  m_port.preShowEthereal( );
}

PString H225_TransportAddress_ipxAddress::getSummary( void ) 
{
  return PString( "TransportAddress_ipxAddress" );
}

void H225_TransportAddress_ipxAddress::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pnode = m_node.getValue();
  proto_tree_add_string( tree, hCont->h225_0.hf_h225_TransportAddress_ipxAddress_node, tvb, offset + m_node.GetStartByte(), m_node.GetByteLength() , pnode );
  delete[] pnode;

  char* pnetnum = m_netnum.getValue();
  proto_tree_add_string( tree, hCont->h225_0.hf_h225_TransportAddress_ipxAddress_netnum, tvb, offset + m_netnum.GetStartByte(), m_netnum.GetByteLength() , pnetnum );
  delete[] pnetnum;

  char* pport = m_port.getValue();
  proto_tree_add_string( tree, hCont->h225_0.hf_h225_TransportAddress_ipxAddress_port, tvb, offset + m_port.GetStartByte(), m_port.GetByteLength() , pport );
  delete[] pport;

}
#endif  //USE_FOR_ETHEREAL

//
// TransportAddress_ip6Address
//

H225_TransportAddress_ip6Address::H225_TransportAddress_ip6Address(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_ip.SetConstraints(PASN_Object::FixedConstraint, 16, 16);
  m_port.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H225_TransportAddress_ip6Address::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+5) << "ip = " << setprecision(indent) << m_ip << '\n';
  strm << setw(indent+7) << "port = " << setprecision(indent) << m_port << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_TransportAddress_ip6Address::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_TransportAddress_ip6Address::Class()), PInvalidCast);
#endif
  const H225_TransportAddress_ip6Address & other = (const H225_TransportAddress_ip6Address &)obj;

  Comparison result;

  if ((result = m_ip.Compare(other.m_ip)) != EqualTo)
    return result;
  if ((result = m_port.Compare(other.m_port)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_TransportAddress_ip6Address::GetDataLength() const
{
  return m_ip.GetObjectLength() +
         m_port.GetObjectLength();
}


BOOL H225_TransportAddress_ip6Address::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_ip.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_port.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_TransportAddress_ip6Address::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_ip.Encode(strm);
  m_port.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_ip.Encode(strm);
  m_port.Encode(strm);
}


PObject * H225_TransportAddress_ip6Address::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_TransportAddress_ip6Address::Class()), PInvalidCast);
#endif
  return new H225_TransportAddress_ip6Address(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_TransportAddress_ip6Address::preShowEthereal( void )
{
  m_ip.preShowEthereal( );
  m_port.preShowEthereal( );
}

PString H225_TransportAddress_ip6Address::getSummary( void ) 
{
  return PString( "TransportAddress_ip6Address" );
}

void H225_TransportAddress_ip6Address::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pip = m_ip.getValue();
  proto_tree_add_string( tree, hCont->h225_0.hf_h225_TransportAddress_ip6Address_ip, tvb, offset + m_ip.GetStartByte(), m_ip.GetByteLength() , pip );
  delete[] pip;

  proto_tree_add_uint( tree, hCont->h225_0.hf_h225_TransportAddress_ip6Address_port, tvb, offset + m_port.GetStartByte(), m_port.GetByteLength() , m_port.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// ArrayOf_SupportedProtocols
//

H225_ArrayOf_SupportedProtocols::H225_ArrayOf_SupportedProtocols(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_SupportedProtocols::CreateObject() const
{
  return new H225_SupportedProtocols;
}


H225_SupportedProtocols & H225_ArrayOf_SupportedProtocols::operator[](PINDEX i) const
{
  return (H225_SupportedProtocols &)array[i];
}


PObject * H225_ArrayOf_SupportedProtocols::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_SupportedProtocols::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_SupportedProtocols(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ArrayOf_SupportedProtocols::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H225_SupportedProtocols& ) array[i] ).preShowEthereal();
  }
}

PString H225_ArrayOf_SupportedProtocols::getSummary( void ) 
{
  return PString( "ArrayOf_SupportedProtocols" );
}

void H225_ArrayOf_SupportedProtocols::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_SupportedProtocols_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_SupportedProtocols_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_SupportedProtocols_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (%s)", i, (const char*) ( ( PASN_Choice* ) &( array[i] ) )->GetTagName() );
    ArrayOf_SupportedProtocols_tree = proto_item_add_subtree( ArrayOf_SupportedProtocols_ti, hCont->h225_0.ett_h225_ArrayOf_SupportedProtocols );
    array[i].showEthereal( ArrayOf_SupportedProtocols_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_DataRate
//

H225_ArrayOf_DataRate::H225_ArrayOf_DataRate(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_DataRate::CreateObject() const
{
  return new H225_DataRate;
}


H225_DataRate & H225_ArrayOf_DataRate::operator[](PINDEX i) const
{
  return (H225_DataRate &)array[i];
}


PObject * H225_ArrayOf_DataRate::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_DataRate::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_DataRate(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ArrayOf_DataRate::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H225_DataRate& ) array[i] ).preShowEthereal();
  }
}

PString H225_ArrayOf_DataRate::getSummary( void ) 
{
  return PString( "ArrayOf_DataRate" );
}

void H225_ArrayOf_DataRate::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_DataRate_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_DataRate_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_DataRate_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (DataRate)", i );
    ArrayOf_DataRate_tree = proto_item_add_subtree( ArrayOf_DataRate_ti, hCont->h225_0.ett_h225_ArrayOf_DataRate );
    array[i].showEthereal( ArrayOf_DataRate_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_SupportedPrefix
//

H225_ArrayOf_SupportedPrefix::H225_ArrayOf_SupportedPrefix(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_SupportedPrefix::CreateObject() const
{
  return new H225_SupportedPrefix;
}


H225_SupportedPrefix & H225_ArrayOf_SupportedPrefix::operator[](PINDEX i) const
{
  return (H225_SupportedPrefix &)array[i];
}


PObject * H225_ArrayOf_SupportedPrefix::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_SupportedPrefix::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_SupportedPrefix(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ArrayOf_SupportedPrefix::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H225_SupportedPrefix& ) array[i] ).preShowEthereal();
  }
}

PString H225_ArrayOf_SupportedPrefix::getSummary( void ) 
{
  return PString( "ArrayOf_SupportedPrefix" );
}

void H225_ArrayOf_SupportedPrefix::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_SupportedPrefix_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_SupportedPrefix_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_SupportedPrefix_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (SupportedPrefix)", i );
    ArrayOf_SupportedPrefix_tree = proto_item_add_subtree( ArrayOf_SupportedPrefix_ti, hCont->h225_0.ett_h225_ArrayOf_SupportedPrefix );
    array[i].showEthereal( ArrayOf_SupportedPrefix_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_TransportAddress
//

H225_ArrayOf_TransportAddress::H225_ArrayOf_TransportAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_TransportAddress::CreateObject() const
{
  return new H225_TransportAddress;
}


H225_TransportAddress & H225_ArrayOf_TransportAddress::operator[](PINDEX i) const
{
  return (H225_TransportAddress &)array[i];
}


PObject * H225_ArrayOf_TransportAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_TransportAddress::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_TransportAddress(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ArrayOf_TransportAddress::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H225_TransportAddress& ) array[i] ).preShowEthereal();
  }
}

PString H225_ArrayOf_TransportAddress::getSummary( void ) 
{
  return PString( "ArrayOf_TransportAddress" );
}

void H225_ArrayOf_TransportAddress::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_TransportAddress_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_TransportAddress_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_TransportAddress_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (%s)", i, (const char*) ( ( PASN_Choice* ) &( array[i] ) )->GetTagName() );
    ArrayOf_TransportAddress_tree = proto_item_add_subtree( ArrayOf_TransportAddress_ti, hCont->h225_0.ett_h225_ArrayOf_TransportAddress );
    array[i].showEthereal( ArrayOf_TransportAddress_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_AlternateGK
//

H225_ArrayOf_AlternateGK::H225_ArrayOf_AlternateGK(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_AlternateGK::CreateObject() const
{
  return new H225_AlternateGK;
}


H225_AlternateGK & H225_ArrayOf_AlternateGK::operator[](PINDEX i) const
{
  return (H225_AlternateGK &)array[i];
}


PObject * H225_ArrayOf_AlternateGK::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_AlternateGK::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_AlternateGK(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ArrayOf_AlternateGK::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H225_AlternateGK& ) array[i] ).preShowEthereal();
  }
}

PString H225_ArrayOf_AlternateGK::getSummary( void ) 
{
  return PString( "ArrayOf_AlternateGK" );
}

void H225_ArrayOf_AlternateGK::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_AlternateGK_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_AlternateGK_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_AlternateGK_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (AlternateGK)", i );
    ArrayOf_AlternateGK_tree = proto_item_add_subtree( ArrayOf_AlternateGK_ti, hCont->h225_0.ett_h225_ArrayOf_AlternateGK );
    array[i].showEthereal( ArrayOf_AlternateGK_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// CryptoH323Token_cryptoEPPwdHash
//

H225_CryptoH323Token_cryptoEPPwdHash::H225_CryptoH323Token_cryptoEPPwdHash(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_CryptoH323Token_cryptoEPPwdHash::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+8) << "alias = " << setprecision(indent) << m_alias << '\n';
  strm << setw(indent+12) << "timeStamp = " << setprecision(indent) << m_timeStamp << '\n';
  strm << setw(indent+8) << "token = " << setprecision(indent) << m_token << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_CryptoH323Token_cryptoEPPwdHash::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_CryptoH323Token_cryptoEPPwdHash::Class()), PInvalidCast);
#endif
  const H225_CryptoH323Token_cryptoEPPwdHash & other = (const H225_CryptoH323Token_cryptoEPPwdHash &)obj;

  Comparison result;

  if ((result = m_alias.Compare(other.m_alias)) != EqualTo)
    return result;
  if ((result = m_timeStamp.Compare(other.m_timeStamp)) != EqualTo)
    return result;
  if ((result = m_token.Compare(other.m_token)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_CryptoH323Token_cryptoEPPwdHash::GetDataLength() const
{
  return m_alias.GetObjectLength() +
         m_timeStamp.GetObjectLength() +
         m_token.GetObjectLength();
}


BOOL H225_CryptoH323Token_cryptoEPPwdHash::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_alias.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_timeStamp.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_token.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_CryptoH323Token_cryptoEPPwdHash::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_alias.Encode(strm);
  m_timeStamp.Encode(strm);
  m_token.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_alias.Encode(strm);
  m_timeStamp.Encode(strm);
  m_token.Encode(strm);
}


PObject * H225_CryptoH323Token_cryptoEPPwdHash::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_CryptoH323Token_cryptoEPPwdHash::Class()), PInvalidCast);
#endif
  return new H225_CryptoH323Token_cryptoEPPwdHash(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_CryptoH323Token_cryptoEPPwdHash::preShowEthereal( void )
{
  m_alias.preShowEthereal( );
  m_timeStamp.preShowEthereal( );
  m_token.preShowEthereal( );
}

PString H225_CryptoH323Token_cryptoEPPwdHash::getSummary( void ) 
{
  return PString( "CryptoH323Token_cryptoEPPwdHash" );
}

void H225_CryptoH323Token_cryptoEPPwdHash::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *alias_tree = (proto_tree*) NULL;
  proto_item *alias_ti = (proto_item*) NULL;
  alias_ti = proto_tree_add_text( tree, tvb, offset + m_alias.GetStartByte(), m_alias.GetByteLength(), "alias (%s)", ( const char* ) m_alias.GetTagName() );
  alias_tree = proto_item_add_subtree( alias_ti, hCont->h225_0.ett_h225_CryptoH323Token_cryptoEPPwdHash_alias );

  m_alias.showEthereal( alias_tree, tvb, offset );

  /* This member is defined outside the current ASN.1 file, 
   * therefore it's not known what type it is. The safest
   * solution is to add another subtree and let the class handle itself
   */
  proto_tree *timeStamp_tree = (proto_tree*) NULL;
  proto_item *timeStamp_ti = (proto_item*) NULL;
  timeStamp_ti = proto_tree_add_text( tree, tvb, offset + m_timeStamp.GetStartByte(), m_timeStamp.GetByteLength(), "timeStamp (H235-TimeStamp)" );
  timeStamp_tree = proto_item_add_subtree( timeStamp_ti, hCont->h225_0.ett_h225_CryptoH323Token_cryptoEPPwdHash_timeStamp );

  m_timeStamp.showEthereal( timeStamp_tree, tvb, offset );

  /* This member is defined outside the current ASN.1 file, 
   * therefore it's not known what type it is. The safest
   * solution is to add another subtree and let the class handle itself
   */
  proto_tree *token_tree = (proto_tree*) NULL;
  proto_item *token_ti = (proto_item*) NULL;
  token_ti = proto_tree_add_text( tree, tvb, offset + m_token.GetStartByte(), m_token.GetByteLength(), "token (H235-HASHED<H235-EncodedPwdCertToken>)" );
  token_tree = proto_item_add_subtree( token_ti, hCont->h225_0.ett_h225_CryptoH323Token_cryptoEPPwdHash_token );

  m_token.showEthereal( token_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// CryptoH323Token_cryptoGKPwdHash
//

H225_CryptoH323Token_cryptoGKPwdHash::H225_CryptoH323Token_cryptoGKPwdHash(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_CryptoH323Token_cryptoGKPwdHash::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "gatekeeperId = " << setprecision(indent) << m_gatekeeperId << '\n';
  strm << setw(indent+12) << "timeStamp = " << setprecision(indent) << m_timeStamp << '\n';
  strm << setw(indent+8) << "token = " << setprecision(indent) << m_token << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_CryptoH323Token_cryptoGKPwdHash::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_CryptoH323Token_cryptoGKPwdHash::Class()), PInvalidCast);
#endif
  const H225_CryptoH323Token_cryptoGKPwdHash & other = (const H225_CryptoH323Token_cryptoGKPwdHash &)obj;

  Comparison result;

  if ((result = m_gatekeeperId.Compare(other.m_gatekeeperId)) != EqualTo)
    return result;
  if ((result = m_timeStamp.Compare(other.m_timeStamp)) != EqualTo)
    return result;
  if ((result = m_token.Compare(other.m_token)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_CryptoH323Token_cryptoGKPwdHash::GetDataLength() const
{
  return m_gatekeeperId.GetObjectLength() +
         m_timeStamp.GetObjectLength() +
         m_token.GetObjectLength();
}


BOOL H225_CryptoH323Token_cryptoGKPwdHash::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_gatekeeperId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_timeStamp.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_token.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_CryptoH323Token_cryptoGKPwdHash::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_gatekeeperId.Encode(strm);
  m_timeStamp.Encode(strm);
  m_token.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_gatekeeperId.Encode(strm);
  m_timeStamp.Encode(strm);
  m_token.Encode(strm);
}


PObject * H225_CryptoH323Token_cryptoGKPwdHash::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_CryptoH323Token_cryptoGKPwdHash::Class()), PInvalidCast);
#endif
  return new H225_CryptoH323Token_cryptoGKPwdHash(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_CryptoH323Token_cryptoGKPwdHash::preShowEthereal( void )
{
  m_gatekeeperId.preShowEthereal( );
  m_timeStamp.preShowEthereal( );
  m_token.preShowEthereal( );
}

PString H225_CryptoH323Token_cryptoGKPwdHash::getSummary( void ) 
{
  return PString( "CryptoH323Token_cryptoGKPwdHash" );
}

void H225_CryptoH323Token_cryptoGKPwdHash::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pgatekeeperId = m_gatekeeperId.getValue();
  proto_tree_add_string( tree, hCont->h225_0.hf_h225_CryptoH323Token_cryptoGKPwdHash_gatekeeperId, tvb, offset + m_gatekeeperId.GetStartByte(), m_gatekeeperId.GetByteLength() , pgatekeeperId );
  delete[] pgatekeeperId;

  /* This member is defined outside the current ASN.1 file, 
   * therefore it's not known what type it is. The safest
   * solution is to add another subtree and let the class handle itself
   */
  proto_tree *timeStamp_tree = (proto_tree*) NULL;
  proto_item *timeStamp_ti = (proto_item*) NULL;
  timeStamp_ti = proto_tree_add_text( tree, tvb, offset + m_timeStamp.GetStartByte(), m_timeStamp.GetByteLength(), "timeStamp (H235-TimeStamp)" );
  timeStamp_tree = proto_item_add_subtree( timeStamp_ti, hCont->h225_0.ett_h225_CryptoH323Token_cryptoGKPwdHash_timeStamp );

  m_timeStamp.showEthereal( timeStamp_tree, tvb, offset );

  /* This member is defined outside the current ASN.1 file, 
   * therefore it's not known what type it is. The safest
   * solution is to add another subtree and let the class handle itself
   */
  proto_tree *token_tree = (proto_tree*) NULL;
  proto_item *token_ti = (proto_item*) NULL;
  token_ti = proto_tree_add_text( tree, tvb, offset + m_token.GetStartByte(), m_token.GetByteLength(), "token (H235-HASHED<H235-EncodedPwdCertToken>)" );
  token_tree = proto_item_add_subtree( token_ti, hCont->h225_0.ett_h225_CryptoH323Token_cryptoGKPwdHash_token );

  m_token.showEthereal( token_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// ArrayOf_Endpoint
//

H225_ArrayOf_Endpoint::H225_ArrayOf_Endpoint(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_Endpoint::CreateObject() const
{
  return new H225_Endpoint;
}


H225_Endpoint & H225_ArrayOf_Endpoint::operator[](PINDEX i) const
{
  return (H225_Endpoint &)array[i];
}


PObject * H225_ArrayOf_Endpoint::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_Endpoint::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_Endpoint(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ArrayOf_Endpoint::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H225_Endpoint& ) array[i] ).preShowEthereal();
  }
}

PString H225_ArrayOf_Endpoint::getSummary( void ) 
{
  return PString( "ArrayOf_Endpoint" );
}

void H225_ArrayOf_Endpoint::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_Endpoint_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_Endpoint_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_Endpoint_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (Endpoint)", i );
    ArrayOf_Endpoint_tree = proto_item_add_subtree( ArrayOf_Endpoint_ti, hCont->h225_0.ett_h225_ArrayOf_Endpoint );
    array[i].showEthereal( ArrayOf_Endpoint_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_AuthenticationMechanism
//

H225_ArrayOf_AuthenticationMechanism::H225_ArrayOf_AuthenticationMechanism(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_AuthenticationMechanism::CreateObject() const
{
  return new H235_AuthenticationMechanism;
}


H235_AuthenticationMechanism & H225_ArrayOf_AuthenticationMechanism::operator[](PINDEX i) const
{
  return (H235_AuthenticationMechanism &)array[i];
}


PObject * H225_ArrayOf_AuthenticationMechanism::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_AuthenticationMechanism::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_AuthenticationMechanism(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ArrayOf_AuthenticationMechanism::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H235_AuthenticationMechanism& ) array[i] ).preShowEthereal();
  }
}

PString H225_ArrayOf_AuthenticationMechanism::getSummary( void ) 
{
  return PString( "ArrayOf_AuthenticationMechanism" );
}

void H225_ArrayOf_AuthenticationMechanism::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_AuthenticationMechanism_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_AuthenticationMechanism_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_AuthenticationMechanism_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (H235-AuthenticationMechanism)", i );
    ArrayOf_AuthenticationMechanism_tree = proto_item_add_subtree( ArrayOf_AuthenticationMechanism_ti, hCont->h225_0.ett_h225_ArrayOf_AuthenticationMechanism );
    array[i].showEthereal( ArrayOf_AuthenticationMechanism_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_PASN_ObjectId
//

H225_ArrayOf_PASN_ObjectId::H225_ArrayOf_PASN_ObjectId(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_PASN_ObjectId::CreateObject() const
{
  return new PASN_ObjectId;
}


PASN_ObjectId & H225_ArrayOf_PASN_ObjectId::operator[](PINDEX i) const
{
  return (PASN_ObjectId &)array[i];
}


PObject * H225_ArrayOf_PASN_ObjectId::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_PASN_ObjectId::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_PASN_ObjectId(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ArrayOf_PASN_ObjectId::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (PASN_ObjectId& ) array[i] ).preShowEthereal();
  }
}

PString H225_ArrayOf_PASN_ObjectId::getSummary( void ) 
{
  return PString( "ArrayOf_PASN_ObjectId" );
}

void H225_ArrayOf_PASN_ObjectId::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  for (int i=0; i < array.GetSize(); i++ ) {
    char* pstring = ( ( PASN_ObjectId & ) array[i] ).getValue();
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_ArrayOf_PASN_ObjectId_array, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), pstring );
    delete[] pstring;
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_IntegrityMechanism
//

H225_ArrayOf_IntegrityMechanism::H225_ArrayOf_IntegrityMechanism(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_IntegrityMechanism::CreateObject() const
{
  return new H225_IntegrityMechanism;
}


H225_IntegrityMechanism & H225_ArrayOf_IntegrityMechanism::operator[](PINDEX i) const
{
  return (H225_IntegrityMechanism &)array[i];
}


PObject * H225_ArrayOf_IntegrityMechanism::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_IntegrityMechanism::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_IntegrityMechanism(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ArrayOf_IntegrityMechanism::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H225_IntegrityMechanism& ) array[i] ).preShowEthereal();
  }
}

PString H225_ArrayOf_IntegrityMechanism::getSummary( void ) 
{
  return PString( "ArrayOf_IntegrityMechanism" );
}

void H225_ArrayOf_IntegrityMechanism::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_IntegrityMechanism_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_IntegrityMechanism_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_IntegrityMechanism_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (%s)", i, (const char*) ( ( PASN_Choice* ) &( array[i] ) )->GetTagName() );
    ArrayOf_IntegrityMechanism_tree = proto_item_add_subtree( ArrayOf_IntegrityMechanism_ti, hCont->h225_0.ett_h225_ArrayOf_IntegrityMechanism );
    array[i].showEthereal( ArrayOf_IntegrityMechanism_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// AdmissionConfirm_language
//

H225_AdmissionConfirm_language::H225_AdmissionConfirm_language(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_AdmissionConfirm_language::CreateObject() const
{
  PASN_IA5String * obj = new PASN_IA5String;
  obj->SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  return obj;
}


PASN_IA5String & H225_AdmissionConfirm_language::operator[](PINDEX i) const
{
  return (PASN_IA5String &)array[i];
}


PObject * H225_AdmissionConfirm_language::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_AdmissionConfirm_language::Class()), PInvalidCast);
#endif
  return new H225_AdmissionConfirm_language(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_AdmissionConfirm_language::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (PASN_IA5String& ) array[i] ).preShowEthereal();
  }
}

PString H225_AdmissionConfirm_language::getSummary( void ) 
{
  return PString( "AdmissionConfirm_language" );
}

void H225_AdmissionConfirm_language::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  for (int i=0; i < array.GetSize(); i++ ) {
    char* pstring = ( ( PASN_IA5String & ) array[i] ).getValue();
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_AdmissionConfirm_language_array, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), pstring );
    delete[] pstring;
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_PartyNumber
//

H225_ArrayOf_PartyNumber::H225_ArrayOf_PartyNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_PartyNumber::CreateObject() const
{
  return new H225_PartyNumber;
}


H225_PartyNumber & H225_ArrayOf_PartyNumber::operator[](PINDEX i) const
{
  return (H225_PartyNumber &)array[i];
}


PObject * H225_ArrayOf_PartyNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_PartyNumber::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_PartyNumber(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ArrayOf_PartyNumber::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H225_PartyNumber& ) array[i] ).preShowEthereal();
  }
}

PString H225_ArrayOf_PartyNumber::getSummary( void ) 
{
  return PString( "ArrayOf_PartyNumber" );
}

void H225_ArrayOf_PartyNumber::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_PartyNumber_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_PartyNumber_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_PartyNumber_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (%s)", i, (const char*) ( ( PASN_Choice* ) &( array[i] ) )->GetTagName() );
    ArrayOf_PartyNumber_tree = proto_item_add_subtree( ArrayOf_PartyNumber_ti, hCont->h225_0.ett_h225_ArrayOf_PartyNumber );
    array[i].showEthereal( ArrayOf_PartyNumber_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// InfoRequestResponse_perCallInfo
//

H225_InfoRequestResponse_perCallInfo::H225_InfoRequestResponse_perCallInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_InfoRequestResponse_perCallInfo::CreateObject() const
{
  return new H225_InfoRequestResponse_perCallInfo_subtype;
}


H225_InfoRequestResponse_perCallInfo_subtype & H225_InfoRequestResponse_perCallInfo::operator[](PINDEX i) const
{
  return (H225_InfoRequestResponse_perCallInfo_subtype &)array[i];
}


PObject * H225_InfoRequestResponse_perCallInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_InfoRequestResponse_perCallInfo::Class()), PInvalidCast);
#endif
  return new H225_InfoRequestResponse_perCallInfo(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_InfoRequestResponse_perCallInfo::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H225_InfoRequestResponse_perCallInfo_subtype& ) array[i] ).preShowEthereal();
  }
}

PString H225_InfoRequestResponse_perCallInfo::getSummary( void ) 
{
  return PString( "InfoRequestResponse_perCallInfo" );
}

void H225_InfoRequestResponse_perCallInfo::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *InfoRequestResponse_perCallInfo_tree = (proto_tree*) NULL;
  proto_item *InfoRequestResponse_perCallInfo_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    InfoRequestResponse_perCallInfo_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (InfoRequestResponse-perCallInfo-subtype)", i );
    InfoRequestResponse_perCallInfo_tree = proto_item_add_subtree( InfoRequestResponse_perCallInfo_ti, hCont->h225_0.ett_h225_InfoRequestResponse_perCallInfo );
    array[i].showEthereal( InfoRequestResponse_perCallInfo_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// RTPSession_associatedSessionIds
//

H225_RTPSession_associatedSessionIds::H225_RTPSession_associatedSessionIds(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_RTPSession_associatedSessionIds::CreateObject() const
{
  PASN_Integer * obj = new PASN_Integer;
  obj->SetConstraints(PASN_Object::FixedConstraint, 1, 255);
  return obj;
}


PASN_Integer & H225_RTPSession_associatedSessionIds::operator[](PINDEX i) const
{
  return (PASN_Integer &)array[i];
}


PObject * H225_RTPSession_associatedSessionIds::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_RTPSession_associatedSessionIds::Class()), PInvalidCast);
#endif
  return new H225_RTPSession_associatedSessionIds(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_RTPSession_associatedSessionIds::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (PASN_Integer& ) array[i] ).preShowEthereal();
  }
}

PString H225_RTPSession_associatedSessionIds::getSummary( void ) 
{
  return PString( "RTPSession_associatedSessionIds" );
}

void H225_RTPSession_associatedSessionIds::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  for (int i=0; i < array.GetSize(); i++ ) {
    proto_tree_add_uint( tree, hCont->h225_0.hf_h225_RTPSession_associatedSessionIds_array, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), ( (PASN_Integer& ) array[i] ).GetValue() );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// TransportAddress_ipSourceRoute_route
//

H225_TransportAddress_ipSourceRoute_route::H225_TransportAddress_ipSourceRoute_route(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_TransportAddress_ipSourceRoute_route::CreateObject() const
{
  PASN_OctetString * obj = new PASN_OctetString;
  obj->SetConstraints(PASN_Object::FixedConstraint, 4, 4);
  return obj;
}


PASN_OctetString & H225_TransportAddress_ipSourceRoute_route::operator[](PINDEX i) const
{
  return (PASN_OctetString &)array[i];
}


PObject * H225_TransportAddress_ipSourceRoute_route::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_TransportAddress_ipSourceRoute_route::Class()), PInvalidCast);
#endif
  return new H225_TransportAddress_ipSourceRoute_route(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_TransportAddress_ipSourceRoute_route::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (PASN_OctetString& ) array[i] ).preShowEthereal();
  }
}

PString H225_TransportAddress_ipSourceRoute_route::getSummary( void ) 
{
  return PString( "TransportAddress_ipSourceRoute_route" );
}

void H225_TransportAddress_ipSourceRoute_route::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  for (int i=0; i < array.GetSize(); i++ ) {
    char* pstring = ( ( PASN_OctetString & ) array[i] ).getValue();
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_TransportAddress_ipSourceRoute_route_array, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), pstring );
    delete[] pstring;
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// TransportAddress_ipSourceRoute_routing
//

H225_TransportAddress_ipSourceRoute_routing::H225_TransportAddress_ipSourceRoute_routing(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
      , "strict "
        "loose "
#endif
    )
{
}


BOOL H225_TransportAddress_ipSourceRoute_routing::CreateObject()
{
  switch (tag) {
    case e_strict :
    case e_loose :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = ( PASN_Object * ) NULL;
  return FALSE;
}


PObject * H225_TransportAddress_ipSourceRoute_routing::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_TransportAddress_ipSourceRoute_routing::Class()), PInvalidCast);
#endif
  return new H225_TransportAddress_ipSourceRoute_routing(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_TransportAddress_ipSourceRoute_routing::preShowEthereal( void )
{
  if ( choice != NULL ) {
    switch( tag ) {
      case e_strict :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      case e_loose :
        ( ( PASN_Null * ) choice )->preShowEthereal();
        break;
      default:
        break;
    } // switch
  } //if
}

PString H225_TransportAddress_ipSourceRoute_routing::getSummary( void ) 
{
  return PString( "TransportAddress_ipSourceRoute_routing" );
}

void H225_TransportAddress_ipSourceRoute_routing::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( choice != NULL ) {
    if ( strcmp( GetTagName(), "strict" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_TransportAddress_ipSourceRoute_routing_strict, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

    if ( strcmp( GetTagName(), "loose" ) == 0 ) {
      proto_tree_add_string( tree, hCont->h225_0.hf_h225_TransportAddress_ipSourceRoute_routing_loose, tvb, offset + ( ( PASN_Null* ) choice) ->GetStartByte(), ( ( PASN_Null* ) choice) ->GetByteLength(), (const char*) GetTagName() );
      return;
    }

  }
  else {
    proto_tree_add_text( tree, tvb, GetStartByte(), GetByteLength(), (const char*) ( GetTagName() + " <null pointer>" ) );
  }
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_RTPSession
//

H225_ArrayOf_RTPSession::H225_ArrayOf_RTPSession(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_RTPSession::CreateObject() const
{
  return new H225_RTPSession;
}


H225_RTPSession & H225_ArrayOf_RTPSession::operator[](PINDEX i) const
{
  return (H225_RTPSession &)array[i];
}


PObject * H225_ArrayOf_RTPSession::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_RTPSession::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_RTPSession(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ArrayOf_RTPSession::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H225_RTPSession& ) array[i] ).preShowEthereal();
  }
}

PString H225_ArrayOf_RTPSession::getSummary( void ) 
{
  return PString( "ArrayOf_RTPSession" );
}

void H225_ArrayOf_RTPSession::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_RTPSession_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_RTPSession_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_RTPSession_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (RTPSession)", i );
    ArrayOf_RTPSession_tree = proto_item_add_subtree( ArrayOf_RTPSession_ti, hCont->h225_0.ett_h225_ArrayOf_RTPSession );
    array[i].showEthereal( ArrayOf_RTPSession_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_TransportChannelInfo
//

H225_ArrayOf_TransportChannelInfo::H225_ArrayOf_TransportChannelInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_TransportChannelInfo::CreateObject() const
{
  return new H225_TransportChannelInfo;
}


H225_TransportChannelInfo & H225_ArrayOf_TransportChannelInfo::operator[](PINDEX i) const
{
  return (H225_TransportChannelInfo &)array[i];
}


PObject * H225_ArrayOf_TransportChannelInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_TransportChannelInfo::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_TransportChannelInfo(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ArrayOf_TransportChannelInfo::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H225_TransportChannelInfo& ) array[i] ).preShowEthereal();
  }
}

PString H225_ArrayOf_TransportChannelInfo::getSummary( void ) 
{
  return PString( "ArrayOf_TransportChannelInfo" );
}

void H225_ArrayOf_TransportChannelInfo::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *ArrayOf_TransportChannelInfo_tree = (proto_tree*) NULL;
  proto_item *ArrayOf_TransportChannelInfo_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    ArrayOf_TransportChannelInfo_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (TransportChannelInfo)", i );
    ArrayOf_TransportChannelInfo_tree = proto_item_add_subtree( ArrayOf_TransportChannelInfo_ti, hCont->h225_0.ett_h225_ArrayOf_TransportChannelInfo );
    array[i].showEthereal( ArrayOf_TransportChannelInfo_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// ArrayOf_ConferenceIdentifier
//

H225_ArrayOf_ConferenceIdentifier::H225_ArrayOf_ConferenceIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_ConferenceIdentifier::CreateObject() const
{
  return new H225_ConferenceIdentifier;
}


H225_ConferenceIdentifier & H225_ArrayOf_ConferenceIdentifier::operator[](PINDEX i) const
{
  return (H225_ConferenceIdentifier &)array[i];
}


PObject * H225_ArrayOf_ConferenceIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_ConferenceIdentifier::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_ConferenceIdentifier(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ArrayOf_ConferenceIdentifier::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H225_ConferenceIdentifier& ) array[i] ).preShowEthereal();
  }
}

PString H225_ArrayOf_ConferenceIdentifier::getSummary( void ) 
{
  return PString( "ArrayOf_ConferenceIdentifier" );
}

void H225_ArrayOf_ConferenceIdentifier::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  for (int i=0; i < array.GetSize(); i++ ) {
    char* pstring = ( ( PASN_OctetString & ) array[i] ).getValue();
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_ArrayOf_ConferenceIdentifier_array, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), pstring );
    delete[] pstring;
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// InfoRequestResponse_perCallInfo_subtype_pdu
//

H225_InfoRequestResponse_perCallInfo_subtype_pdu::H225_InfoRequestResponse_perCallInfo_subtype_pdu(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_InfoRequestResponse_perCallInfo_subtype_pdu::CreateObject() const
{
  return new H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype;
}


H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype & H225_InfoRequestResponse_perCallInfo_subtype_pdu::operator[](PINDEX i) const
{
  return (H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype &)array[i];
}


PObject * H225_InfoRequestResponse_perCallInfo_subtype_pdu::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_InfoRequestResponse_perCallInfo_subtype_pdu::Class()), PInvalidCast);
#endif
  return new H225_InfoRequestResponse_perCallInfo_subtype_pdu(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_InfoRequestResponse_perCallInfo_subtype_pdu::preShowEthereal( void )
{
  for (int i = 0; i < array.GetSize(); i++) {
    ( (H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype& ) array[i] ).preShowEthereal();
  }
}

PString H225_InfoRequestResponse_perCallInfo_subtype_pdu::getSummary( void ) 
{
  return PString( "InfoRequestResponse_perCallInfo_subtype_pdu" );
}

void H225_InfoRequestResponse_perCallInfo_subtype_pdu::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *InfoRequestResponse_perCallInfo_subtype_pdu_tree = (proto_tree*) NULL;
  proto_item *InfoRequestResponse_perCallInfo_subtype_pdu_ti = (proto_item*) NULL;

  for (int i=0; i < array.GetSize(); i++ ) {
    InfoRequestResponse_perCallInfo_subtype_pdu_ti = proto_tree_add_text( tree, tvb, offset + array[i].GetStartByte(), array[i].GetByteLength(), "Item %d (InfoRequestResponse-perCallInfo-subtype-pdu-subtype)", i );
    InfoRequestResponse_perCallInfo_subtype_pdu_tree = proto_item_add_subtree( InfoRequestResponse_perCallInfo_subtype_pdu_ti, hCont->h225_0.ett_h225_InfoRequestResponse_perCallInfo_subtype_pdu );
    array[i].showEthereal( InfoRequestResponse_perCallInfo_subtype_pdu_tree, tvb, offset );
  }
  if ( array.GetSize() == 0 ) proto_tree_add_text( tree, tvb, offset + GetStartByte(), GetByteLength(), "<empty>" );
}
#endif //USE_FOR_ETHEREAL

//
// Information-UUIE
//

H225_Information_UUIE::H225_Information_UUIE(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 5)
{
  IncludeOptionalField(e_callIdentifier);
}


#ifndef PASN_NOPRINTON
void H225_Information_UUIE::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_fastStart))
    strm << setw(indent+12) << "fastStart = " << setprecision(indent) << m_fastStart << '\n';
  if (HasOptionalField(e_fastConnectRefused))
    strm << setw(indent+21) << "fastConnectRefused = " << setprecision(indent) << m_fastConnectRefused << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_Information_UUIE::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_Information_UUIE::Class()), PInvalidCast);
#endif
  const H225_Information_UUIE & other = (const H225_Information_UUIE &)obj;

  Comparison result;

  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_Information_UUIE::GetDataLength() const
{
  return m_protocolIdentifier.GetObjectLength();
}


BOOL H225_Information_UUIE::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_protocolIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_callIdentifier, m_callIdentifier ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_fastStart, m_fastStart ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_fastConnectRefused, m_fastConnectRefused ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_Information_UUIE::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protocolIdentifier.Encode(strm);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_fastStart, m_fastStart);
  KnownExtensionEncode(strm, e_fastConnectRefused, m_fastConnectRefused);

  UnknownExtensionsEncode(strm);
  m_protocolIdentifier.Encode(strm);
}


PObject * H225_Information_UUIE::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_Information_UUIE::Class()), PInvalidCast);
#endif
  return new H225_Information_UUIE(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_Information_UUIE::preShowEthereal( void )
{
  m_protocolIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_callIdentifier ) ) 
      m_callIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_fastStart ) ) 
      m_fastStart.preShowEthereal( );
  if ( HasOptionalField( e_fastConnectRefused ) ) 
      m_fastConnectRefused.preShowEthereal( );
}

PString H225_Information_UUIE::getSummary( void ) 
{
  return PString( "Information-UUIE" );
}

void H225_Information_UUIE::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pprotocolIdentifier = m_protocolIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h225_0.hf_h225_Information_UUIE_protocolIdentifier, tvb, offset + m_protocolIdentifier.GetStartByte(), m_protocolIdentifier.GetByteLength() , pprotocolIdentifier );
  delete[] pprotocolIdentifier;

  if ( HasOptionalField( e_callIdentifier ) ) {
    proto_tree *callIdentifier_tree = (proto_tree*) NULL;
    proto_item *callIdentifier_ti = (proto_item*) NULL;
    callIdentifier_ti = proto_tree_add_text( tree, tvb, offset + m_callIdentifier.GetStartByte(), m_callIdentifier.GetByteLength(), "callIdentifier (CallIdentifier)" );
    callIdentifier_tree = proto_item_add_subtree( callIdentifier_ti, hCont->h225_0.ett_h225_Information_UUIE_callIdentifier );
    m_callIdentifier.showEthereal( callIdentifier_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_0.ett_h225_Information_UUIE_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_0.ett_h225_Information_UUIE_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_fastStart ) ) {
    offset++;
    for( int i=0; i < m_fastStart.GetSize(); i++ )
    {
      PPER_Stream per = m_fastStart[ i ].GetValue();

      H245_OpenLogicalChannel olc;
      if ( olc.Decode( per ) )
      {
        proto_tree *fastStart_tree = (proto_tree*) NULL;
        proto_item *fastStart_ti = (proto_item*) NULL;
        fastStart_ti = proto_tree_add_text( tree, tvb, offset + m_fastStart[i].GetStartByte(), m_fastStart[i].GetByteLength(), "fastStart %d %s", i, (const unsigned char*) olc.getSummary() );
        fastStart_tree = proto_item_add_subtree( fastStart_ti, hCont->h225_0.ett_h225_Information_UUIE_fastStart );
        olc.showEthereal( fastStart_tree, tvb, offset + m_fastStart[i].GetStartByte() );
      }
      else
      {
        proto_tree_add_text( tree, tvb, offset + m_fastStart[i].GetStartByte(), m_fastStart.GetByteLength(), "Unable to decode fastStart element %d", i );
      }
    }
  }

  if ( HasOptionalField( e_fastConnectRefused ) ) {
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_Information_UUIE_fastConnectRefused, tvb, offset + m_fastConnectRefused.GetStartByte(), m_fastConnectRefused.GetByteLength() , "fastConnectRefused: \"NULL\"" );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// ReleaseComplete-UUIE
//

H225_ReleaseComplete_UUIE::H225_ReleaseComplete_UUIE(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 6)
{
  IncludeOptionalField(e_callIdentifier);
}


#ifndef PASN_NOPRINTON
void H225_ReleaseComplete_UUIE::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_reason))
    strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_busyAddress))
    strm << setw(indent+14) << "busyAddress = " << setprecision(indent) << m_busyAddress << '\n';
  if (HasOptionalField(e_presentationIndicator))
    strm << setw(indent+24) << "presentationIndicator = " << setprecision(indent) << m_presentationIndicator << '\n';
  if (HasOptionalField(e_screeningIndicator))
    strm << setw(indent+21) << "screeningIndicator = " << setprecision(indent) << m_screeningIndicator << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_ReleaseComplete_UUIE::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_ReleaseComplete_UUIE::Class()), PInvalidCast);
#endif
  const H225_ReleaseComplete_UUIE & other = (const H225_ReleaseComplete_UUIE &)obj;

  Comparison result;

  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_reason.Compare(other.m_reason)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_ReleaseComplete_UUIE::GetDataLength() const
{
  return m_protocolIdentifier.GetObjectLength() +
         m_reason.GetObjectLength();
}


BOOL H225_ReleaseComplete_UUIE::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_protocolIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_reason ) && !m_reason.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_callIdentifier, m_callIdentifier ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_busyAddress, m_busyAddress ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_presentationIndicator, m_presentationIndicator ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_screeningIndicator, m_screeningIndicator ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_ReleaseComplete_UUIE::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_reason))
    m_reason.Encode(strm);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_busyAddress, m_busyAddress);
  KnownExtensionEncode(strm, e_presentationIndicator, m_presentationIndicator);
  KnownExtensionEncode(strm, e_screeningIndicator, m_screeningIndicator);

  UnknownExtensionsEncode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_reason))
    m_reason.Encode(strm);
}


PObject * H225_ReleaseComplete_UUIE::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ReleaseComplete_UUIE::Class()), PInvalidCast);
#endif
  return new H225_ReleaseComplete_UUIE(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ReleaseComplete_UUIE::preShowEthereal( void )
{
  m_protocolIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_reason ) ) 
      m_reason.preShowEthereal( );
  if ( HasOptionalField( e_callIdentifier ) ) 
      m_callIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_busyAddress ) ) 
      m_busyAddress.preShowEthereal( );
  if ( HasOptionalField( e_presentationIndicator ) ) 
      m_presentationIndicator.preShowEthereal( );
  if ( HasOptionalField( e_screeningIndicator ) ) 
      m_screeningIndicator.preShowEthereal( );
}

PString H225_ReleaseComplete_UUIE::getSummary( void ) 
{
  return PString( "ReleaseComplete-UUIE" );
}

void H225_ReleaseComplete_UUIE::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pprotocolIdentifier = m_protocolIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h225_0.hf_h225_ReleaseComplete_UUIE_protocolIdentifier, tvb, offset + m_protocolIdentifier.GetStartByte(), m_protocolIdentifier.GetByteLength() , pprotocolIdentifier );
  delete[] pprotocolIdentifier;

  if ( HasOptionalField( e_reason ) ) {
    proto_tree *reason_tree = (proto_tree*) NULL;
    proto_item *reason_ti = (proto_item*) NULL;
    reason_ti = proto_tree_add_text( tree, tvb, offset + m_reason.GetStartByte(), m_reason.GetByteLength(), "reason (%s)", ( const char* ) m_reason.GetTagName() );
    reason_tree = proto_item_add_subtree( reason_ti, hCont->h225_0.ett_h225_ReleaseComplete_UUIE_reason );
    m_reason.showEthereal( reason_tree, tvb, offset );
  }

  if ( HasOptionalField( e_callIdentifier ) ) {
    proto_tree *callIdentifier_tree = (proto_tree*) NULL;
    proto_item *callIdentifier_ti = (proto_item*) NULL;
    callIdentifier_ti = proto_tree_add_text( tree, tvb, offset + m_callIdentifier.GetStartByte(), m_callIdentifier.GetByteLength(), "callIdentifier (CallIdentifier)" );
    callIdentifier_tree = proto_item_add_subtree( callIdentifier_ti, hCont->h225_0.ett_h225_ReleaseComplete_UUIE_callIdentifier );
    m_callIdentifier.showEthereal( callIdentifier_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_0.ett_h225_ReleaseComplete_UUIE_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_0.ett_h225_ReleaseComplete_UUIE_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_busyAddress ) ) {
    proto_tree *busyAddress_tree = (proto_tree*) NULL;
    proto_item *busyAddress_ti = (proto_item*) NULL;
    busyAddress_ti = proto_tree_add_text( tree, tvb, offset + m_busyAddress.GetStartByte(), m_busyAddress.GetByteLength(), "busyAddress (AliasAddress)" );
    busyAddress_tree = proto_item_add_subtree( busyAddress_ti, hCont->h225_0.ett_h225_ReleaseComplete_UUIE_busyAddress );
    m_busyAddress.showEthereal( busyAddress_tree, tvb, offset );
  }

  if ( HasOptionalField( e_presentationIndicator ) ) {
    proto_tree *presentationIndicator_tree = (proto_tree*) NULL;
    proto_item *presentationIndicator_ti = (proto_item*) NULL;
    presentationIndicator_ti = proto_tree_add_text( tree, tvb, offset + m_presentationIndicator.GetStartByte(), m_presentationIndicator.GetByteLength(), "presentationIndicator (%s)", ( const char* ) m_presentationIndicator.GetTagName() );
    presentationIndicator_tree = proto_item_add_subtree( presentationIndicator_ti, hCont->h225_0.ett_h225_ReleaseComplete_UUIE_presentationIndicator );
    m_presentationIndicator.showEthereal( presentationIndicator_tree, tvb, offset );
  }

  if ( HasOptionalField( e_screeningIndicator ) ) {
    char* pscreeningIndicator = m_screeningIndicator.getValue();
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_ReleaseComplete_UUIE_screeningIndicator, tvb, offset + m_screeningIndicator.GetStartByte(), m_screeningIndicator.GetByteLength() , pscreeningIndicator );
    delete[] pscreeningIndicator;
  }

}
#endif  //USE_FOR_ETHEREAL

//
// Facility-UUIE
//

H225_Facility_UUIE::H225_Facility_UUIE(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 11)
{
  IncludeOptionalField(e_callIdentifier);
  IncludeOptionalField(e_multipleCalls);
  IncludeOptionalField(e_maintainConnection);
}


#ifndef PASN_NOPRINTON
void H225_Facility_UUIE::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_alternativeAddress))
    strm << setw(indent+21) << "alternativeAddress = " << setprecision(indent) << m_alternativeAddress << '\n';
  if (HasOptionalField(e_alternativeAliasAddress))
    strm << setw(indent+26) << "alternativeAliasAddress = " << setprecision(indent) << m_alternativeAliasAddress << '\n';
  if (HasOptionalField(e_conferenceID))
    strm << setw(indent+15) << "conferenceID = " << setprecision(indent) << m_conferenceID << '\n';
  strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_destExtraCallInfo))
    strm << setw(indent+20) << "destExtraCallInfo = " << setprecision(indent) << m_destExtraCallInfo << '\n';
  if (HasOptionalField(e_remoteExtensionAddress))
    strm << setw(indent+25) << "remoteExtensionAddress = " << setprecision(indent) << m_remoteExtensionAddress << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_conferences))
    strm << setw(indent+14) << "conferences = " << setprecision(indent) << m_conferences << '\n';
  if (HasOptionalField(e_h245Address))
    strm << setw(indent+14) << "h245Address = " << setprecision(indent) << m_h245Address << '\n';
  if (HasOptionalField(e_fastStart))
    strm << setw(indent+12) << "fastStart = " << setprecision(indent) << m_fastStart << '\n';
  if (HasOptionalField(e_multipleCalls))
    strm << setw(indent+16) << "multipleCalls = " << setprecision(indent) << m_multipleCalls << '\n';
  if (HasOptionalField(e_maintainConnection))
    strm << setw(indent+21) << "maintainConnection = " << setprecision(indent) << m_maintainConnection << '\n';
  if (HasOptionalField(e_fastConnectRefused))
    strm << setw(indent+21) << "fastConnectRefused = " << setprecision(indent) << m_fastConnectRefused << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_Facility_UUIE::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_Facility_UUIE::Class()), PInvalidCast);
#endif
  const H225_Facility_UUIE & other = (const H225_Facility_UUIE &)obj;

  Comparison result;

  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_alternativeAddress.Compare(other.m_alternativeAddress)) != EqualTo)
    return result;
  if ((result = m_alternativeAliasAddress.Compare(other.m_alternativeAliasAddress)) != EqualTo)
    return result;
  if ((result = m_conferenceID.Compare(other.m_conferenceID)) != EqualTo)
    return result;
  if ((result = m_reason.Compare(other.m_reason)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_Facility_UUIE::GetDataLength() const
{
  return m_protocolIdentifier.GetObjectLength() +
         m_alternativeAddress.GetObjectLength() +
         m_alternativeAliasAddress.GetObjectLength() +
         m_conferenceID.GetObjectLength() +
         m_reason.GetObjectLength();
}


BOOL H225_Facility_UUIE::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_protocolIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_alternativeAddress ) && !m_alternativeAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_alternativeAliasAddress ) && !m_alternativeAliasAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_conferenceID ) && !m_conferenceID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_reason.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_callIdentifier, m_callIdentifier ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_destExtraCallInfo, m_destExtraCallInfo ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_remoteExtensionAddress, m_remoteExtensionAddress ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_conferences, m_conferences ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_h245Address, m_h245Address ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_fastStart, m_fastStart ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_multipleCalls, m_multipleCalls ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_maintainConnection, m_maintainConnection ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_fastConnectRefused, m_fastConnectRefused ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_Facility_UUIE::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_alternativeAddress))
    m_alternativeAddress.Encode(strm);
  if (HasOptionalField(e_alternativeAliasAddress))
    m_alternativeAliasAddress.Encode(strm);
  if (HasOptionalField(e_conferenceID))
    m_conferenceID.Encode(strm);
  m_reason.Encode(strm);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_destExtraCallInfo, m_destExtraCallInfo);
  KnownExtensionEncode(strm, e_remoteExtensionAddress, m_remoteExtensionAddress);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_conferences, m_conferences);
  KnownExtensionEncode(strm, e_h245Address, m_h245Address);
  KnownExtensionEncode(strm, e_fastStart, m_fastStart);
  KnownExtensionEncode(strm, e_multipleCalls, m_multipleCalls);
  KnownExtensionEncode(strm, e_maintainConnection, m_maintainConnection);
  KnownExtensionEncode(strm, e_fastConnectRefused, m_fastConnectRefused);

  UnknownExtensionsEncode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_alternativeAddress))
    m_alternativeAddress.Encode(strm);
  if (HasOptionalField(e_alternativeAliasAddress))
    m_alternativeAliasAddress.Encode(strm);
  if (HasOptionalField(e_conferenceID))
    m_conferenceID.Encode(strm);
  m_reason.Encode(strm);
}


PObject * H225_Facility_UUIE::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_Facility_UUIE::Class()), PInvalidCast);
#endif
  return new H225_Facility_UUIE(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_Facility_UUIE::preShowEthereal( void )
{
  m_protocolIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_alternativeAddress ) ) 
      m_alternativeAddress.preShowEthereal( );
  if ( HasOptionalField( e_alternativeAliasAddress ) ) 
      m_alternativeAliasAddress.preShowEthereal( );
  if ( HasOptionalField( e_conferenceID ) ) 
      m_conferenceID.preShowEthereal( );
  m_reason.preShowEthereal( );
  if ( HasOptionalField( e_callIdentifier ) ) 
      m_callIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_destExtraCallInfo ) ) 
      m_destExtraCallInfo.preShowEthereal( );
  if ( HasOptionalField( e_remoteExtensionAddress ) ) 
      m_remoteExtensionAddress.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_conferences ) ) 
      m_conferences.preShowEthereal( );
  if ( HasOptionalField( e_h245Address ) ) {
    m_h245Address.preShowEthereal( );

  	if ( m_h245Address.GetTagName() == "ipAddress" ) {
			H225_TransportAddress_ipAddress tmpAddr = (H225_TransportAddress_ipAddress) m_h245Address;
			//h245_add_address( (unsigned char*) tmpAddr.m_ip.GetPointer(), tmpAddr.m_port );
      address src_addr;
      conversation_t* pconv = ( conversation_t* ) NULL;
      
      src_addr.type = AT_IPv4;
      src_addr.len = 4;
      src_addr.data = (unsigned char*) tmpAddr.m_ip.GetPointer();
      
      pconv = conversation_new( &src_addr, &src_addr, PT_TCP, tmpAddr.m_port , 0, NO_ADDR2 + NO_PORT2 );
      
      conversation_set_dissector( pconv, find_dissector( "h245" ) );

		}
  }
  if ( HasOptionalField( e_fastStart ) ) 
      m_fastStart.preShowEthereal( );
  if ( HasOptionalField( e_multipleCalls ) ) 
      m_multipleCalls.preShowEthereal( );
  if ( HasOptionalField( e_maintainConnection ) ) 
      m_maintainConnection.preShowEthereal( );
  if ( HasOptionalField( e_fastConnectRefused ) ) 
      m_fastConnectRefused.preShowEthereal( );
}

PString H225_Facility_UUIE::getSummary( void ) 
{
  return PString( "Facility-UUIE" );
}

void H225_Facility_UUIE::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pprotocolIdentifier = m_protocolIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h225_0.hf_h225_Facility_UUIE_protocolIdentifier, tvb, offset + m_protocolIdentifier.GetStartByte(), m_protocolIdentifier.GetByteLength() , pprotocolIdentifier );
  delete[] pprotocolIdentifier;

  if ( HasOptionalField( e_alternativeAddress ) ) {
    proto_tree *alternativeAddress_tree = (proto_tree*) NULL;
    proto_item *alternativeAddress_ti = (proto_item*) NULL;
    alternativeAddress_ti = proto_tree_add_text( tree, tvb, offset + m_alternativeAddress.GetStartByte(), m_alternativeAddress.GetByteLength(), "alternativeAddress (%s)", ( const char* ) m_alternativeAddress.GetTagName() );
    alternativeAddress_tree = proto_item_add_subtree( alternativeAddress_ti, hCont->h225_0.ett_h225_Facility_UUIE_alternativeAddress );
    m_alternativeAddress.showEthereal( alternativeAddress_tree, tvb, offset );
  }

  if ( HasOptionalField( e_alternativeAliasAddress ) ) {
    proto_tree *alternativeAliasAddress_tree = (proto_tree*) NULL;
    proto_item *alternativeAliasAddress_ti = (proto_item*) NULL;
    alternativeAliasAddress_ti = proto_tree_add_text( tree, tvb, offset + m_alternativeAliasAddress.GetStartByte(), m_alternativeAliasAddress.GetByteLength(), "alternativeAliasAddress (AliasAddress)" );
    alternativeAliasAddress_tree = proto_item_add_subtree( alternativeAliasAddress_ti, hCont->h225_0.ett_h225_Facility_UUIE_alternativeAliasAddress );
    m_alternativeAliasAddress.showEthereal( alternativeAliasAddress_tree, tvb, offset );
  }

  if ( HasOptionalField( e_conferenceID ) ) {
    char* pconferenceID = m_conferenceID.getValue();
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_Facility_UUIE_conferenceID, tvb, offset + m_conferenceID.GetStartByte(), m_conferenceID.GetByteLength() , pconferenceID );
    delete[] pconferenceID;
  }

  proto_tree *reason_tree = (proto_tree*) NULL;
  proto_item *reason_ti = (proto_item*) NULL;
  reason_ti = proto_tree_add_text( tree, tvb, offset + m_reason.GetStartByte(), m_reason.GetByteLength(), "reason (%s)", ( const char* ) m_reason.GetTagName() );
  reason_tree = proto_item_add_subtree( reason_ti, hCont->h225_0.ett_h225_Facility_UUIE_reason );

  m_reason.showEthereal( reason_tree, tvb, offset );

  if ( HasOptionalField( e_callIdentifier ) ) {
    proto_tree *callIdentifier_tree = (proto_tree*) NULL;
    proto_item *callIdentifier_ti = (proto_item*) NULL;
    callIdentifier_ti = proto_tree_add_text( tree, tvb, offset + m_callIdentifier.GetStartByte(), m_callIdentifier.GetByteLength(), "callIdentifier (CallIdentifier)" );
    callIdentifier_tree = proto_item_add_subtree( callIdentifier_ti, hCont->h225_0.ett_h225_Facility_UUIE_callIdentifier );
    m_callIdentifier.showEthereal( callIdentifier_tree, tvb, offset );
  }

  if ( HasOptionalField( e_destExtraCallInfo ) ) {
    proto_tree *destExtraCallInfo_tree = (proto_tree*) NULL;
    proto_item *destExtraCallInfo_ti = (proto_item*) NULL;
    destExtraCallInfo_ti = proto_tree_add_text( tree, tvb, offset + m_destExtraCallInfo.GetStartByte(), m_destExtraCallInfo.GetByteLength(), "destExtraCallInfo (AliasAddress)" );
    destExtraCallInfo_tree = proto_item_add_subtree( destExtraCallInfo_ti, hCont->h225_0.ett_h225_Facility_UUIE_destExtraCallInfo );
    m_destExtraCallInfo.showEthereal( destExtraCallInfo_tree, tvb, offset );
  }

  if ( HasOptionalField( e_remoteExtensionAddress ) ) {
    proto_tree *remoteExtensionAddress_tree = (proto_tree*) NULL;
    proto_item *remoteExtensionAddress_ti = (proto_item*) NULL;
    remoteExtensionAddress_ti = proto_tree_add_text( tree, tvb, offset + m_remoteExtensionAddress.GetStartByte(), m_remoteExtensionAddress.GetByteLength(), "remoteExtensionAddress (%s)", ( const char* ) m_remoteExtensionAddress.GetTagName() );
    remoteExtensionAddress_tree = proto_item_add_subtree( remoteExtensionAddress_ti, hCont->h225_0.ett_h225_Facility_UUIE_remoteExtensionAddress );
    m_remoteExtensionAddress.showEthereal( remoteExtensionAddress_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_0.ett_h225_Facility_UUIE_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_0.ett_h225_Facility_UUIE_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_conferences ) ) {
    proto_tree *conferences_tree = (proto_tree*) NULL;
    proto_item *conferences_ti = (proto_item*) NULL;
    conferences_ti = proto_tree_add_text( tree, tvb, offset + m_conferences.GetStartByte(), m_conferences.GetByteLength(), "conferences (ConferenceList)" );
    conferences_tree = proto_item_add_subtree( conferences_ti, hCont->h225_0.ett_h225_Facility_UUIE_conferences );
    m_conferences.showEthereal( conferences_tree, tvb, offset );
  }

  if ( HasOptionalField( e_h245Address ) ) {
    proto_tree *h245Address_tree = (proto_tree*) NULL;
    proto_item *h245Address_ti = (proto_item*) NULL;
    h245Address_ti = proto_tree_add_text( tree, tvb, offset + m_h245Address.GetStartByte(), m_h245Address.GetByteLength(), "h245Address (%s)", ( const char* ) m_h245Address.GetTagName() );
    h245Address_tree = proto_item_add_subtree( h245Address_ti, hCont->h225_0.ett_h225_Facility_UUIE_h245Address );
    m_h245Address.showEthereal( h245Address_tree, tvb, offset );
  }

  if ( HasOptionalField( e_fastStart ) ) {
    offset++;
    for( int i=0; i < m_fastStart.GetSize(); i++ )
    {
      PPER_Stream per = m_fastStart[ i ].GetValue();

      H245_OpenLogicalChannel olc;
      if ( olc.Decode( per ) )
      {
        proto_tree *fastStart_tree = (proto_tree*) NULL;
        proto_item *fastStart_ti = (proto_item*) NULL;
        fastStart_ti = proto_tree_add_text( tree, tvb, offset + m_fastStart[i].GetStartByte(), m_fastStart[i].GetByteLength(), "fastStart %d %s", i, (const unsigned char*) olc.getSummary() );
        fastStart_tree = proto_item_add_subtree( fastStart_ti, hCont->h225_0.ett_h225_Information_UUIE_fastStart );
        olc.showEthereal( fastStart_tree, tvb, offset + m_fastStart[i].GetStartByte() );
      }
      else
      {
        proto_tree_add_text( tree, tvb, offset + m_fastStart[i].GetStartByte(), m_fastStart.GetByteLength(), "Unable to decode fastStart element %d", i );
      }
    }
  }

  if ( HasOptionalField( e_multipleCalls ) ) {
    proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_Facility_UUIE_multipleCalls, tvb, offset + m_multipleCalls.GetStartByte(), m_multipleCalls.GetByteLength() , m_multipleCalls.GetValue() );
  }

  if ( HasOptionalField( e_maintainConnection ) ) {
    proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_Facility_UUIE_maintainConnection, tvb, offset + m_maintainConnection.GetStartByte(), m_maintainConnection.GetByteLength() , m_maintainConnection.GetValue() );
  }

  if ( HasOptionalField( e_fastConnectRefused ) ) {
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_Facility_UUIE_fastConnectRefused, tvb, offset + m_fastConnectRefused.GetStartByte(), m_fastConnectRefused.GetByteLength() , "fastConnectRefused: \"NULL\"" );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CallLinkage
//

H225_CallLinkage::H225_CallLinkage(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_CallLinkage::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_globalCallId))
    strm << setw(indent+15) << "globalCallId = " << setprecision(indent) << m_globalCallId << '\n';
  if (HasOptionalField(e_threadId))
    strm << setw(indent+11) << "threadId = " << setprecision(indent) << m_threadId << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_CallLinkage::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_CallLinkage::Class()), PInvalidCast);
#endif
  const H225_CallLinkage & other = (const H225_CallLinkage &)obj;

  Comparison result;

  if ((result = m_globalCallId.Compare(other.m_globalCallId)) != EqualTo)
    return result;
  if ((result = m_threadId.Compare(other.m_threadId)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_CallLinkage::GetDataLength() const
{
  return m_globalCallId.GetObjectLength() +
         m_threadId.GetObjectLength();
}


BOOL H225_CallLinkage::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_globalCallId ) && !m_globalCallId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_threadId ) && !m_threadId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_CallLinkage::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_globalCallId))
    m_globalCallId.Encode(strm);
  if (HasOptionalField(e_threadId))
    m_threadId.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_globalCallId))
    m_globalCallId.Encode(strm);
  if (HasOptionalField(e_threadId))
    m_threadId.Encode(strm);
}


PObject * H225_CallLinkage::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_CallLinkage::Class()), PInvalidCast);
#endif
  return new H225_CallLinkage(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_CallLinkage::preShowEthereal( void )
{
  if ( HasOptionalField( e_globalCallId ) ) 
      m_globalCallId.preShowEthereal( );
  if ( HasOptionalField( e_threadId ) ) 
      m_threadId.preShowEthereal( );
}

PString H225_CallLinkage::getSummary( void ) 
{
  return PString( "CallLinkage" );
}

void H225_CallLinkage::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_globalCallId ) ) {
    char* pglobalCallId = m_globalCallId.getValue();
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_CallLinkage_globalCallId, tvb, offset + m_globalCallId.GetStartByte(), m_globalCallId.GetByteLength() , pglobalCallId );
    delete[] pglobalCallId;
  }

  if ( HasOptionalField( e_threadId ) ) {
    char* pthreadId = m_threadId.getValue();
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_CallLinkage_threadId, tvb, offset + m_threadId.GetStartByte(), m_threadId.GetByteLength() , pthreadId );
    delete[] pthreadId;
  }

}
#endif  //USE_FOR_ETHEREAL

//
// VendorIdentifier
//

H225_VendorIdentifier::H225_VendorIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_productId.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
  m_versionId.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H225_VendorIdentifier::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "vendor = " << setprecision(indent) << m_vendor << '\n';
  if (HasOptionalField(e_productId))
    strm << setw(indent+12) << "productId = " << setprecision(indent) << m_productId << '\n';
  if (HasOptionalField(e_versionId))
    strm << setw(indent+12) << "versionId = " << setprecision(indent) << m_versionId << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_VendorIdentifier::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_VendorIdentifier::Class()), PInvalidCast);
#endif
  const H225_VendorIdentifier & other = (const H225_VendorIdentifier &)obj;

  Comparison result;

  if ((result = m_vendor.Compare(other.m_vendor)) != EqualTo)
    return result;
  if ((result = m_productId.Compare(other.m_productId)) != EqualTo)
    return result;
  if ((result = m_versionId.Compare(other.m_versionId)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_VendorIdentifier::GetDataLength() const
{
  return m_vendor.GetObjectLength() +
         m_productId.GetObjectLength() +
         m_versionId.GetObjectLength();
}


BOOL H225_VendorIdentifier::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_vendor.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_productId ) && !m_productId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_versionId ) && !m_versionId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_VendorIdentifier::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_vendor.Encode(strm);
  if (HasOptionalField(e_productId))
    m_productId.Encode(strm);
  if (HasOptionalField(e_versionId))
    m_versionId.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_vendor.Encode(strm);
  if (HasOptionalField(e_productId))
    m_productId.Encode(strm);
  if (HasOptionalField(e_versionId))
    m_versionId.Encode(strm);
}


PObject * H225_VendorIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_VendorIdentifier::Class()), PInvalidCast);
#endif
  return new H225_VendorIdentifier(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_VendorIdentifier::preShowEthereal( void )
{
  m_vendor.preShowEthereal( );
  if ( HasOptionalField( e_productId ) ) 
      m_productId.preShowEthereal( );
  if ( HasOptionalField( e_versionId ) ) 
      m_versionId.preShowEthereal( );
}

PString H225_VendorIdentifier::getSummary( void ) 
{
  return PString( "VendorIdentifier" );
}

void H225_VendorIdentifier::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *vendor_tree = (proto_tree*) NULL;
  proto_item *vendor_ti = (proto_item*) NULL;
  vendor_ti = proto_tree_add_text( tree, tvb, offset + m_vendor.GetStartByte(), m_vendor.GetByteLength(), "vendor (H221NonStandard)" );
  vendor_tree = proto_item_add_subtree( vendor_ti, hCont->h225_0.ett_h225_VendorIdentifier_vendor );

  m_vendor.showEthereal( vendor_tree, tvb, offset );

  if ( HasOptionalField( e_productId ) ) {
    char* pproductId = m_productId.getValue();
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_VendorIdentifier_productId, tvb, offset + m_productId.GetStartByte(), m_productId.GetByteLength() , pproductId );
    delete[] pproductId;
  }

  if ( HasOptionalField( e_versionId ) ) {
    char* pversionId = m_versionId.getValue();
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_VendorIdentifier_versionId, tvb, offset + m_versionId.GetStartByte(), m_versionId.GetByteLength() , pversionId );
    delete[] pversionId;
  }

}
#endif  //USE_FOR_ETHEREAL

//
// NonStandardParameter
//

H225_NonStandardParameter::H225_NonStandardParameter(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_NonStandardParameter::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "nonStandardIdentifier = " << setprecision(indent) << m_nonStandardIdentifier << '\n';
  strm << setw(indent+7) << "data = " << setprecision(indent) << m_data << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_NonStandardParameter::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  const H225_NonStandardParameter & other = (const H225_NonStandardParameter &)obj;

  Comparison result;

  if ((result = m_nonStandardIdentifier.Compare(other.m_nonStandardIdentifier)) != EqualTo)
    return result;
  if ((result = m_data.Compare(other.m_data)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_NonStandardParameter::GetDataLength() const
{
  return m_nonStandardIdentifier.GetObjectLength() +
         m_data.GetObjectLength();
}


BOOL H225_NonStandardParameter::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_nonStandardIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_data.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_NonStandardParameter::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nonStandardIdentifier.Encode(strm);
  m_data.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_nonStandardIdentifier.Encode(strm);
  m_data.Encode(strm);
}


PObject * H225_NonStandardParameter::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return new H225_NonStandardParameter(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_NonStandardParameter::preShowEthereal( void )
{
  m_nonStandardIdentifier.preShowEthereal( );
  m_data.preShowEthereal( );
}

PString H225_NonStandardParameter::getSummary( void ) 
{
  return PString( "NonStandardParameter" );
}

void H225_NonStandardParameter::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *nonStandardIdentifier_tree = (proto_tree*) NULL;
  proto_item *nonStandardIdentifier_ti = (proto_item*) NULL;
  nonStandardIdentifier_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardIdentifier.GetStartByte(), m_nonStandardIdentifier.GetByteLength(), "nonStandardIdentifier (%s)", ( const char* ) m_nonStandardIdentifier.GetTagName() );
  nonStandardIdentifier_tree = proto_item_add_subtree( nonStandardIdentifier_ti, hCont->h225_0.ett_h225_NonStandardParameter_nonStandardIdentifier );

  m_nonStandardIdentifier.showEthereal( nonStandardIdentifier_tree, tvb, offset );

  char* pdata = m_data.getValue();
  proto_tree_add_string( tree, hCont->h225_0.hf_h225_NonStandardParameter_data, tvb, offset + m_data.GetStartByte(), m_data.GetByteLength() , pdata );
  delete[] pdata;

}
#endif  //USE_FOR_ETHEREAL

//
// PublicPartyNumber
//

H225_PublicPartyNumber::H225_PublicPartyNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_PublicPartyNumber::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "publicTypeOfNumber = " << setprecision(indent) << m_publicTypeOfNumber << '\n';
  strm << setw(indent+21) << "publicNumberDigits = " << setprecision(indent) << m_publicNumberDigits << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_PublicPartyNumber::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_PublicPartyNumber::Class()), PInvalidCast);
#endif
  const H225_PublicPartyNumber & other = (const H225_PublicPartyNumber &)obj;

  Comparison result;

  if ((result = m_publicTypeOfNumber.Compare(other.m_publicTypeOfNumber)) != EqualTo)
    return result;
  if ((result = m_publicNumberDigits.Compare(other.m_publicNumberDigits)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_PublicPartyNumber::GetDataLength() const
{
  return m_publicTypeOfNumber.GetObjectLength() +
         m_publicNumberDigits.GetObjectLength();
}


BOOL H225_PublicPartyNumber::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_publicTypeOfNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_publicNumberDigits.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_PublicPartyNumber::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_publicTypeOfNumber.Encode(strm);
  m_publicNumberDigits.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_publicTypeOfNumber.Encode(strm);
  m_publicNumberDigits.Encode(strm);
}


PObject * H225_PublicPartyNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_PublicPartyNumber::Class()), PInvalidCast);
#endif
  return new H225_PublicPartyNumber(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_PublicPartyNumber::preShowEthereal( void )
{
  m_publicTypeOfNumber.preShowEthereal( );
  m_publicNumberDigits.preShowEthereal( );
}

PString H225_PublicPartyNumber::getSummary( void ) 
{
  return PString( "PublicPartyNumber" );
}

void H225_PublicPartyNumber::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *publicTypeOfNumber_tree = (proto_tree*) NULL;
  proto_item *publicTypeOfNumber_ti = (proto_item*) NULL;
  publicTypeOfNumber_ti = proto_tree_add_text( tree, tvb, offset + m_publicTypeOfNumber.GetStartByte(), m_publicTypeOfNumber.GetByteLength(), "publicTypeOfNumber (%s)", ( const char* ) m_publicTypeOfNumber.GetTagName() );
  publicTypeOfNumber_tree = proto_item_add_subtree( publicTypeOfNumber_ti, hCont->h225_0.ett_h225_PublicPartyNumber_publicTypeOfNumber );

  m_publicTypeOfNumber.showEthereal( publicTypeOfNumber_tree, tvb, offset );

  char* ppublicNumberDigits = m_publicNumberDigits.getValue();
  proto_tree_add_string( tree, hCont->h225_0.hf_h225_PublicPartyNumber_publicNumberDigits, tvb, offset + m_publicNumberDigits.GetStartByte(), m_publicNumberDigits.GetByteLength() , ppublicNumberDigits );
  delete[] ppublicNumberDigits;

}
#endif  //USE_FOR_ETHEREAL

//
// PrivatePartyNumber
//

H225_PrivatePartyNumber::H225_PrivatePartyNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_PrivatePartyNumber::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "privateTypeOfNumber = " << setprecision(indent) << m_privateTypeOfNumber << '\n';
  strm << setw(indent+22) << "privateNumberDigits = " << setprecision(indent) << m_privateNumberDigits << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_PrivatePartyNumber::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_PrivatePartyNumber::Class()), PInvalidCast);
#endif
  const H225_PrivatePartyNumber & other = (const H225_PrivatePartyNumber &)obj;

  Comparison result;

  if ((result = m_privateTypeOfNumber.Compare(other.m_privateTypeOfNumber)) != EqualTo)
    return result;
  if ((result = m_privateNumberDigits.Compare(other.m_privateNumberDigits)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_PrivatePartyNumber::GetDataLength() const
{
  return m_privateTypeOfNumber.GetObjectLength() +
         m_privateNumberDigits.GetObjectLength();
}


BOOL H225_PrivatePartyNumber::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_privateTypeOfNumber.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_privateNumberDigits.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_PrivatePartyNumber::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_privateTypeOfNumber.Encode(strm);
  m_privateNumberDigits.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_privateTypeOfNumber.Encode(strm);
  m_privateNumberDigits.Encode(strm);
}


PObject * H225_PrivatePartyNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_PrivatePartyNumber::Class()), PInvalidCast);
#endif
  return new H225_PrivatePartyNumber(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_PrivatePartyNumber::preShowEthereal( void )
{
  m_privateTypeOfNumber.preShowEthereal( );
  m_privateNumberDigits.preShowEthereal( );
}

PString H225_PrivatePartyNumber::getSummary( void ) 
{
  return PString( "PrivatePartyNumber" );
}

void H225_PrivatePartyNumber::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *privateTypeOfNumber_tree = (proto_tree*) NULL;
  proto_item *privateTypeOfNumber_ti = (proto_item*) NULL;
  privateTypeOfNumber_ti = proto_tree_add_text( tree, tvb, offset + m_privateTypeOfNumber.GetStartByte(), m_privateTypeOfNumber.GetByteLength(), "privateTypeOfNumber (%s)", ( const char* ) m_privateTypeOfNumber.GetTagName() );
  privateTypeOfNumber_tree = proto_item_add_subtree( privateTypeOfNumber_ti, hCont->h225_0.ett_h225_PrivatePartyNumber_privateTypeOfNumber );

  m_privateTypeOfNumber.showEthereal( privateTypeOfNumber_tree, tvb, offset );

  char* pprivateNumberDigits = m_privateNumberDigits.getValue();
  proto_tree_add_string( tree, hCont->h225_0.hf_h225_PrivatePartyNumber_privateNumberDigits, tvb, offset + m_privateNumberDigits.GetStartByte(), m_privateNumberDigits.GetByteLength() , pprivateNumberDigits );
  delete[] pprivateNumberDigits;

}
#endif  //USE_FOR_ETHEREAL

//
// AlternateTransportAddresses
//

H225_AlternateTransportAddresses::H225_AlternateTransportAddresses(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_AlternateTransportAddresses::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_annexE))
    strm << setw(indent+9) << "annexE = " << setprecision(indent) << m_annexE << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_AlternateTransportAddresses::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_AlternateTransportAddresses::Class()), PInvalidCast);
#endif
  const H225_AlternateTransportAddresses & other = (const H225_AlternateTransportAddresses &)obj;

  Comparison result;

  if ((result = m_annexE.Compare(other.m_annexE)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_AlternateTransportAddresses::GetDataLength() const
{
  return m_annexE.GetObjectLength();
}


BOOL H225_AlternateTransportAddresses::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_annexE ) && !m_annexE.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_AlternateTransportAddresses::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_annexE))
    m_annexE.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_annexE))
    m_annexE.Encode(strm);
}


PObject * H225_AlternateTransportAddresses::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_AlternateTransportAddresses::Class()), PInvalidCast);
#endif
  return new H225_AlternateTransportAddresses(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_AlternateTransportAddresses::preShowEthereal( void )
{
  if ( HasOptionalField( e_annexE ) ) 
      m_annexE.preShowEthereal( );
}

PString H225_AlternateTransportAddresses::getSummary( void ) 
{
  return PString( "AlternateTransportAddresses" );
}

void H225_AlternateTransportAddresses::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_annexE ) ) {
    proto_tree *annexE_tree = (proto_tree*) NULL;
    proto_item *annexE_ti = (proto_item*) NULL;
    annexE_ti = proto_tree_add_text( tree, tvb, offset + m_annexE.GetStartByte(), m_annexE.GetByteLength(), "annexE (TransportAddress)" );
    annexE_tree = proto_item_add_subtree( annexE_ti, hCont->h225_0.ett_h225_AlternateTransportAddresses_annexE );
    m_annexE.showEthereal( annexE_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// AlternateGK
//

H225_AlternateGK::H225_AlternateGK(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_priority.SetConstraints(PASN_Object::FixedConstraint, 0, 127);
}


#ifndef PASN_NOPRINTON
void H225_AlternateGK::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "rasAddress = " << setprecision(indent) << m_rasAddress << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  strm << setw(indent+17) << "needToRegister = " << setprecision(indent) << m_needToRegister << '\n';
  strm << setw(indent+11) << "priority = " << setprecision(indent) << m_priority << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_AlternateGK::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_AlternateGK::Class()), PInvalidCast);
#endif
  const H225_AlternateGK & other = (const H225_AlternateGK &)obj;

  Comparison result;

  if ((result = m_rasAddress.Compare(other.m_rasAddress)) != EqualTo)
    return result;
  if ((result = m_gatekeeperIdentifier.Compare(other.m_gatekeeperIdentifier)) != EqualTo)
    return result;
  if ((result = m_needToRegister.Compare(other.m_needToRegister)) != EqualTo)
    return result;
  if ((result = m_priority.Compare(other.m_priority)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_AlternateGK::GetDataLength() const
{
  return m_rasAddress.GetObjectLength() +
         m_gatekeeperIdentifier.GetObjectLength() +
         m_needToRegister.GetObjectLength() +
         m_priority.GetObjectLength();
}


BOOL H225_AlternateGK::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_rasAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_gatekeeperIdentifier ) && !m_gatekeeperIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_needToRegister.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_priority.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_AlternateGK::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_rasAddress.Encode(strm);
  if (HasOptionalField(e_gatekeeperIdentifier))
    m_gatekeeperIdentifier.Encode(strm);
  m_needToRegister.Encode(strm);
  m_priority.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_rasAddress.Encode(strm);
  if (HasOptionalField(e_gatekeeperIdentifier))
    m_gatekeeperIdentifier.Encode(strm);
  m_needToRegister.Encode(strm);
  m_priority.Encode(strm);
}


PObject * H225_AlternateGK::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_AlternateGK::Class()), PInvalidCast);
#endif
  return new H225_AlternateGK(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_AlternateGK::preShowEthereal( void )
{
  m_rasAddress.preShowEthereal( );
  if ( HasOptionalField( e_gatekeeperIdentifier ) ) 
      m_gatekeeperIdentifier.preShowEthereal( );
  m_needToRegister.preShowEthereal( );
  m_priority.preShowEthereal( );
}

PString H225_AlternateGK::getSummary( void ) 
{
  return PString( "AlternateGK" );
}

void H225_AlternateGK::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *rasAddress_tree = (proto_tree*) NULL;
  proto_item *rasAddress_ti = (proto_item*) NULL;
  rasAddress_ti = proto_tree_add_text( tree, tvb, offset + m_rasAddress.GetStartByte(), m_rasAddress.GetByteLength(), "rasAddress (%s)", ( const char* ) m_rasAddress.GetTagName() );
  rasAddress_tree = proto_item_add_subtree( rasAddress_ti, hCont->h225_0.ett_h225_AlternateGK_rasAddress );

  m_rasAddress.showEthereal( rasAddress_tree, tvb, offset );

  if ( HasOptionalField( e_gatekeeperIdentifier ) ) {
    char* pgatekeeperIdentifier = m_gatekeeperIdentifier.getValue();
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_AlternateGK_gatekeeperIdentifier, tvb, offset + m_gatekeeperIdentifier.GetStartByte(), m_gatekeeperIdentifier.GetByteLength() , pgatekeeperIdentifier );
    delete[] pgatekeeperIdentifier;
  }

  proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_AlternateGK_needToRegister, tvb, offset + m_needToRegister.GetStartByte(), m_needToRegister.GetByteLength() , m_needToRegister.GetValue() );

  proto_tree_add_uint( tree, hCont->h225_0.hf_h225_AlternateGK_priority, tvb, offset + m_priority.GetStartByte(), m_priority.GetByteLength() , m_priority.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// AltGKInfo
//

H225_AltGKInfo::H225_AltGKInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_AltGKInfo::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "alternateGatekeeper = " << setprecision(indent) << m_alternateGatekeeper << '\n';
  strm << setw(indent+19) << "altGKisPermanent = " << setprecision(indent) << m_altGKisPermanent << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_AltGKInfo::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_AltGKInfo::Class()), PInvalidCast);
#endif
  const H225_AltGKInfo & other = (const H225_AltGKInfo &)obj;

  Comparison result;

  if ((result = m_alternateGatekeeper.Compare(other.m_alternateGatekeeper)) != EqualTo)
    return result;
  if ((result = m_altGKisPermanent.Compare(other.m_altGKisPermanent)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_AltGKInfo::GetDataLength() const
{
  return m_alternateGatekeeper.GetObjectLength() +
         m_altGKisPermanent.GetObjectLength();
}


BOOL H225_AltGKInfo::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_alternateGatekeeper.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_altGKisPermanent.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_AltGKInfo::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_alternateGatekeeper.Encode(strm);
  m_altGKisPermanent.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_alternateGatekeeper.Encode(strm);
  m_altGKisPermanent.Encode(strm);
}


PObject * H225_AltGKInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_AltGKInfo::Class()), PInvalidCast);
#endif
  return new H225_AltGKInfo(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_AltGKInfo::preShowEthereal( void )
{
  m_alternateGatekeeper.preShowEthereal( );
  m_altGKisPermanent.preShowEthereal( );
}

PString H225_AltGKInfo::getSummary( void ) 
{
  return PString( "AltGKInfo" );
}

void H225_AltGKInfo::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *alternateGatekeeper_tree = (proto_tree*) NULL;
  proto_item *alternateGatekeeper_ti = (proto_item*) NULL;
  alternateGatekeeper_ti = proto_tree_add_text( tree, tvb, offset + m_alternateGatekeeper.GetStartByte(), m_alternateGatekeeper.GetByteLength(), "alternateGatekeeper (AlternateGK)" );
  alternateGatekeeper_tree = proto_item_add_subtree( alternateGatekeeper_ti, hCont->h225_0.ett_h225_AltGKInfo_alternateGatekeeper );

  m_alternateGatekeeper.showEthereal( alternateGatekeeper_tree, tvb, offset );

  proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_AltGKInfo_altGKisPermanent, tvb, offset + m_altGKisPermanent.GetStartByte(), m_altGKisPermanent.GetByteLength() , m_altGKisPermanent.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// SecurityCapabilities
//

H225_SecurityCapabilities::H225_SecurityCapabilities(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_SecurityCapabilities::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandard))
    strm << setw(indent+14) << "nonStandard = " << setprecision(indent) << m_nonStandard << '\n';
  strm << setw(indent+13) << "encryption = " << setprecision(indent) << m_encryption << '\n';
  strm << setw(indent+16) << "authenticaton = " << setprecision(indent) << m_authenticaton << '\n';
  strm << setw(indent+12) << "integrity = " << setprecision(indent) << m_integrity << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_SecurityCapabilities::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_SecurityCapabilities::Class()), PInvalidCast);
#endif
  const H225_SecurityCapabilities & other = (const H225_SecurityCapabilities &)obj;

  Comparison result;

  if ((result = m_nonStandard.Compare(other.m_nonStandard)) != EqualTo)
    return result;
  if ((result = m_encryption.Compare(other.m_encryption)) != EqualTo)
    return result;
  if ((result = m_authenticaton.Compare(other.m_authenticaton)) != EqualTo)
    return result;
  if ((result = m_integrity.Compare(other.m_integrity)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_SecurityCapabilities::GetDataLength() const
{
  return m_nonStandard.GetObjectLength() +
         m_encryption.GetObjectLength() +
         m_authenticaton.GetObjectLength() +
         m_integrity.GetObjectLength();
}


BOOL H225_SecurityCapabilities::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandard ) && !m_nonStandard.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_encryption.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_authenticaton.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_integrity.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_SecurityCapabilities::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
  m_encryption.Encode(strm);
  m_authenticaton.Encode(strm);
  m_integrity.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
  m_encryption.Encode(strm);
  m_authenticaton.Encode(strm);
  m_integrity.Encode(strm);
}


PObject * H225_SecurityCapabilities::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_SecurityCapabilities::Class()), PInvalidCast);
#endif
  return new H225_SecurityCapabilities(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_SecurityCapabilities::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandard ) ) 
      m_nonStandard.preShowEthereal( );
  m_encryption.preShowEthereal( );
  m_authenticaton.preShowEthereal( );
  m_integrity.preShowEthereal( );
}

PString H225_SecurityCapabilities::getSummary( void ) 
{
  return PString( "SecurityCapabilities" );
}

void H225_SecurityCapabilities::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandard ) ) {
    proto_tree *nonStandard_tree = (proto_tree*) NULL;
    proto_item *nonStandard_ti = (proto_item*) NULL;
    nonStandard_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandard.GetStartByte(), m_nonStandard.GetByteLength(), "nonStandard (NonStandardParameter)" );
    nonStandard_tree = proto_item_add_subtree( nonStandard_ti, hCont->h225_0.ett_h225_SecurityCapabilities_nonStandard );
    m_nonStandard.showEthereal( nonStandard_tree, tvb, offset );
  }

  proto_tree *encryption_tree = (proto_tree*) NULL;
  proto_item *encryption_ti = (proto_item*) NULL;
  encryption_ti = proto_tree_add_text( tree, tvb, offset + m_encryption.GetStartByte(), m_encryption.GetByteLength(), "encryption (%s)", ( const char* ) m_encryption.GetTagName() );
  encryption_tree = proto_item_add_subtree( encryption_ti, hCont->h225_0.ett_h225_SecurityCapabilities_encryption );

  m_encryption.showEthereal( encryption_tree, tvb, offset );

  proto_tree *authenticaton_tree = (proto_tree*) NULL;
  proto_item *authenticaton_ti = (proto_item*) NULL;
  authenticaton_ti = proto_tree_add_text( tree, tvb, offset + m_authenticaton.GetStartByte(), m_authenticaton.GetByteLength(), "authenticaton (%s)", ( const char* ) m_authenticaton.GetTagName() );
  authenticaton_tree = proto_item_add_subtree( authenticaton_ti, hCont->h225_0.ett_h225_SecurityCapabilities_authenticaton );

  m_authenticaton.showEthereal( authenticaton_tree, tvb, offset );

  proto_tree *integrity_tree = (proto_tree*) NULL;
  proto_item *integrity_ti = (proto_item*) NULL;
  integrity_ti = proto_tree_add_text( tree, tvb, offset + m_integrity.GetStartByte(), m_integrity.GetByteLength(), "integrity (%s)", ( const char* ) m_integrity.GetTagName() );
  integrity_tree = proto_item_add_subtree( integrity_ti, hCont->h225_0.ett_h225_SecurityCapabilities_integrity );

  m_integrity.showEthereal( integrity_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// QseriesOptions
//

H225_QseriesOptions::H225_QseriesOptions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_QseriesOptions::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "q932Full = " << setprecision(indent) << m_q932Full << '\n';
  strm << setw(indent+11) << "q951Full = " << setprecision(indent) << m_q951Full << '\n';
  strm << setw(indent+11) << "q952Full = " << setprecision(indent) << m_q952Full << '\n';
  strm << setw(indent+11) << "q953Full = " << setprecision(indent) << m_q953Full << '\n';
  strm << setw(indent+11) << "q955Full = " << setprecision(indent) << m_q955Full << '\n';
  strm << setw(indent+11) << "q956Full = " << setprecision(indent) << m_q956Full << '\n';
  strm << setw(indent+11) << "q957Full = " << setprecision(indent) << m_q957Full << '\n';
  strm << setw(indent+11) << "q954Info = " << setprecision(indent) << m_q954Info << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_QseriesOptions::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_QseriesOptions::Class()), PInvalidCast);
#endif
  const H225_QseriesOptions & other = (const H225_QseriesOptions &)obj;

  Comparison result;

  if ((result = m_q932Full.Compare(other.m_q932Full)) != EqualTo)
    return result;
  if ((result = m_q951Full.Compare(other.m_q951Full)) != EqualTo)
    return result;
  if ((result = m_q952Full.Compare(other.m_q952Full)) != EqualTo)
    return result;
  if ((result = m_q953Full.Compare(other.m_q953Full)) != EqualTo)
    return result;
  if ((result = m_q955Full.Compare(other.m_q955Full)) != EqualTo)
    return result;
  if ((result = m_q956Full.Compare(other.m_q956Full)) != EqualTo)
    return result;
  if ((result = m_q957Full.Compare(other.m_q957Full)) != EqualTo)
    return result;
  if ((result = m_q954Info.Compare(other.m_q954Info)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_QseriesOptions::GetDataLength() const
{
  return m_q932Full.GetObjectLength() +
         m_q951Full.GetObjectLength() +
         m_q952Full.GetObjectLength() +
         m_q953Full.GetObjectLength() +
         m_q955Full.GetObjectLength() +
         m_q956Full.GetObjectLength() +
         m_q957Full.GetObjectLength() +
         m_q954Info.GetObjectLength();
}


BOOL H225_QseriesOptions::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_q932Full.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_q951Full.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_q952Full.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_q953Full.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_q955Full.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_q956Full.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_q957Full.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_q954Info.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_QseriesOptions::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_q932Full.Encode(strm);
  m_q951Full.Encode(strm);
  m_q952Full.Encode(strm);
  m_q953Full.Encode(strm);
  m_q955Full.Encode(strm);
  m_q956Full.Encode(strm);
  m_q957Full.Encode(strm);
  m_q954Info.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_q932Full.Encode(strm);
  m_q951Full.Encode(strm);
  m_q952Full.Encode(strm);
  m_q953Full.Encode(strm);
  m_q955Full.Encode(strm);
  m_q956Full.Encode(strm);
  m_q957Full.Encode(strm);
  m_q954Info.Encode(strm);
}


PObject * H225_QseriesOptions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_QseriesOptions::Class()), PInvalidCast);
#endif
  return new H225_QseriesOptions(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_QseriesOptions::preShowEthereal( void )
{
  m_q932Full.preShowEthereal( );
  m_q951Full.preShowEthereal( );
  m_q952Full.preShowEthereal( );
  m_q953Full.preShowEthereal( );
  m_q955Full.preShowEthereal( );
  m_q956Full.preShowEthereal( );
  m_q957Full.preShowEthereal( );
  m_q954Info.preShowEthereal( );
}

PString H225_QseriesOptions::getSummary( void ) 
{
  return PString( "QseriesOptions" );
}

void H225_QseriesOptions::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_QseriesOptions_q932Full, tvb, offset + m_q932Full.GetStartByte(), m_q932Full.GetByteLength() , m_q932Full.GetValue() );

  proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_QseriesOptions_q951Full, tvb, offset + m_q951Full.GetStartByte(), m_q951Full.GetByteLength() , m_q951Full.GetValue() );

  proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_QseriesOptions_q952Full, tvb, offset + m_q952Full.GetStartByte(), m_q952Full.GetByteLength() , m_q952Full.GetValue() );

  proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_QseriesOptions_q953Full, tvb, offset + m_q953Full.GetStartByte(), m_q953Full.GetByteLength() , m_q953Full.GetValue() );

  proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_QseriesOptions_q955Full, tvb, offset + m_q955Full.GetStartByte(), m_q955Full.GetByteLength() , m_q955Full.GetValue() );

  proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_QseriesOptions_q956Full, tvb, offset + m_q956Full.GetStartByte(), m_q956Full.GetByteLength() , m_q956Full.GetValue() );

  proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_QseriesOptions_q957Full, tvb, offset + m_q957Full.GetStartByte(), m_q957Full.GetByteLength() , m_q957Full.GetValue() );

  proto_tree *q954Info_tree = (proto_tree*) NULL;
  proto_item *q954Info_ti = (proto_item*) NULL;
  q954Info_ti = proto_tree_add_text( tree, tvb, offset + m_q954Info.GetStartByte(), m_q954Info.GetByteLength(), "q954Info (Q954Details)" );
  q954Info_tree = proto_item_add_subtree( q954Info_ti, hCont->h225_0.ett_h225_QseriesOptions_q954Info );

  m_q954Info.showEthereal( q954Info_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// DataRate
//

H225_DataRate::H225_DataRate(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_channelMultiplier.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H225_DataRate::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+14) << "channelRate = " << setprecision(indent) << m_channelRate << '\n';
  if (HasOptionalField(e_channelMultiplier))
    strm << setw(indent+20) << "channelMultiplier = " << setprecision(indent) << m_channelMultiplier << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_DataRate::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_DataRate::Class()), PInvalidCast);
#endif
  const H225_DataRate & other = (const H225_DataRate &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_channelRate.Compare(other.m_channelRate)) != EqualTo)
    return result;
  if ((result = m_channelMultiplier.Compare(other.m_channelMultiplier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_DataRate::GetDataLength() const
{
  return m_nonStandardData.GetObjectLength() +
         m_channelRate.GetObjectLength() +
         m_channelMultiplier.GetObjectLength();
}


BOOL H225_DataRate::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_channelRate.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_channelMultiplier ) && !m_channelMultiplier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_DataRate::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_channelRate.Encode(strm);
  if (HasOptionalField(e_channelMultiplier))
    m_channelMultiplier.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_channelRate.Encode(strm);
  if (HasOptionalField(e_channelMultiplier))
    m_channelMultiplier.Encode(strm);
}


PObject * H225_DataRate::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_DataRate::Class()), PInvalidCast);
#endif
  return new H225_DataRate(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_DataRate::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  m_channelRate.preShowEthereal( );
  if ( HasOptionalField( e_channelMultiplier ) ) 
      m_channelMultiplier.preShowEthereal( );
}

PString H225_DataRate::getSummary( void ) 
{
  return PString( "DataRate" );
}

void H225_DataRate::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_0.ett_h225_DataRate_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  proto_tree_add_uint( tree, hCont->h225_0.hf_h225_DataRate_channelRate, tvb, offset + m_channelRate.GetStartByte(), m_channelRate.GetByteLength() , m_channelRate.GetValue() );

  if ( HasOptionalField( e_channelMultiplier ) ) {
    proto_tree_add_uint( tree, hCont->h225_0.hf_h225_DataRate_channelMultiplier, tvb, offset + m_channelMultiplier.GetStartByte(), m_channelMultiplier.GetByteLength() , m_channelMultiplier.GetValue() );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// SupportedPrefix
//

H225_SupportedPrefix::H225_SupportedPrefix(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_SupportedPrefix::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+9) << "prefix = " << setprecision(indent) << m_prefix << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_SupportedPrefix::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_SupportedPrefix::Class()), PInvalidCast);
#endif
  const H225_SupportedPrefix & other = (const H225_SupportedPrefix &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_prefix.Compare(other.m_prefix)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_SupportedPrefix::GetDataLength() const
{
  return m_nonStandardData.GetObjectLength() +
         m_prefix.GetObjectLength();
}


BOOL H225_SupportedPrefix::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_prefix.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_SupportedPrefix::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_prefix.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_prefix.Encode(strm);
}


PObject * H225_SupportedPrefix::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_SupportedPrefix::Class()), PInvalidCast);
#endif
  return new H225_SupportedPrefix(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_SupportedPrefix::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  m_prefix.preShowEthereal( );
}

PString H225_SupportedPrefix::getSummary( void ) 
{
  return PString( "SupportedPrefix" );
}

void H225_SupportedPrefix::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_0.ett_h225_SupportedPrefix_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  proto_tree *prefix_tree = (proto_tree*) NULL;
  proto_item *prefix_ti = (proto_item*) NULL;
  prefix_ti = proto_tree_add_text( tree, tvb, offset + m_prefix.GetStartByte(), m_prefix.GetByteLength(), "prefix (%s)", ( const char* ) m_prefix.GetTagName() );
  prefix_tree = proto_item_add_subtree( prefix_ti, hCont->h225_0.ett_h225_SupportedPrefix_prefix );

  m_prefix.showEthereal( prefix_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// GatekeeperConfirm
//

H225_GatekeeperConfirm::H225_GatekeeperConfirm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 7)
{
}


#ifndef PASN_NOPRINTON
void H225_GatekeeperConfirm::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  strm << setw(indent+13) << "rasAddress = " << setprecision(indent) << m_rasAddress << '\n';
  if (HasOptionalField(e_alternateGatekeeper))
    strm << setw(indent+22) << "alternateGatekeeper = " << setprecision(indent) << m_alternateGatekeeper << '\n';
  if (HasOptionalField(e_authenticationMode))
    strm << setw(indent+21) << "authenticationMode = " << setprecision(indent) << m_authenticationMode << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_algorithmOID))
    strm << setw(indent+15) << "algorithmOID = " << setprecision(indent) << m_algorithmOID << '\n';
  if (HasOptionalField(e_integrity))
    strm << setw(indent+12) << "integrity = " << setprecision(indent) << m_integrity << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_GatekeeperConfirm::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_GatekeeperConfirm::Class()), PInvalidCast);
#endif
  const H225_GatekeeperConfirm & other = (const H225_GatekeeperConfirm &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_gatekeeperIdentifier.Compare(other.m_gatekeeperIdentifier)) != EqualTo)
    return result;
  if ((result = m_rasAddress.Compare(other.m_rasAddress)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_GatekeeperConfirm::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_protocolIdentifier.GetObjectLength() +
         m_nonStandardData.GetObjectLength() +
         m_gatekeeperIdentifier.GetObjectLength() +
         m_rasAddress.GetObjectLength();
}


BOOL H225_GatekeeperConfirm::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_protocolIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_gatekeeperIdentifier ) && !m_gatekeeperIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_rasAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_alternateGatekeeper, m_alternateGatekeeper ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_authenticationMode, m_authenticationMode ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_algorithmOID, m_algorithmOID ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrity, m_integrity ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_GatekeeperConfirm::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_gatekeeperIdentifier))
    m_gatekeeperIdentifier.Encode(strm);
  m_rasAddress.Encode(strm);
  KnownExtensionEncode(strm, e_alternateGatekeeper, m_alternateGatekeeper);
  KnownExtensionEncode(strm, e_authenticationMode, m_authenticationMode);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_algorithmOID, m_algorithmOID);
  KnownExtensionEncode(strm, e_integrity, m_integrity);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_gatekeeperIdentifier))
    m_gatekeeperIdentifier.Encode(strm);
  m_rasAddress.Encode(strm);
}


PObject * H225_GatekeeperConfirm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_GatekeeperConfirm::Class()), PInvalidCast);
#endif
  return new H225_GatekeeperConfirm(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_GatekeeperConfirm::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  m_protocolIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_gatekeeperIdentifier ) ) 
      m_gatekeeperIdentifier.preShowEthereal( );
  m_rasAddress.preShowEthereal( );
  if ( HasOptionalField( e_alternateGatekeeper ) ) 
      m_alternateGatekeeper.preShowEthereal( );
  if ( HasOptionalField( e_authenticationMode ) ) 
      m_authenticationMode.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_algorithmOID ) ) 
      m_algorithmOID.preShowEthereal( );
  if ( HasOptionalField( e_integrity ) ) 
      m_integrity.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
}

PString H225_GatekeeperConfirm::getSummary( void ) 
{
  return PString( "GatekeeperConfirm" );
}

void H225_GatekeeperConfirm::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_0.hf_h225_GatekeeperConfirm_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  char* pprotocolIdentifier = m_protocolIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h225_0.hf_h225_GatekeeperConfirm_protocolIdentifier, tvb, offset + m_protocolIdentifier.GetStartByte(), m_protocolIdentifier.GetByteLength() , pprotocolIdentifier );
  delete[] pprotocolIdentifier;

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_0.ett_h225_GatekeeperConfirm_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_gatekeeperIdentifier ) ) {
    char* pgatekeeperIdentifier = m_gatekeeperIdentifier.getValue();
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_GatekeeperConfirm_gatekeeperIdentifier, tvb, offset + m_gatekeeperIdentifier.GetStartByte(), m_gatekeeperIdentifier.GetByteLength() , pgatekeeperIdentifier );
    delete[] pgatekeeperIdentifier;
  }

  proto_tree *rasAddress_tree = (proto_tree*) NULL;
  proto_item *rasAddress_ti = (proto_item*) NULL;
  rasAddress_ti = proto_tree_add_text( tree, tvb, offset + m_rasAddress.GetStartByte(), m_rasAddress.GetByteLength(), "rasAddress (%s)", ( const char* ) m_rasAddress.GetTagName() );
  rasAddress_tree = proto_item_add_subtree( rasAddress_ti, hCont->h225_0.ett_h225_GatekeeperConfirm_rasAddress );

  m_rasAddress.showEthereal( rasAddress_tree, tvb, offset );

  if ( HasOptionalField( e_alternateGatekeeper ) ) {
    proto_tree *alternateGatekeeper_tree = (proto_tree*) NULL;
    proto_item *alternateGatekeeper_ti = (proto_item*) NULL;
    alternateGatekeeper_ti = proto_tree_add_text( tree, tvb, offset + m_alternateGatekeeper.GetStartByte(), m_alternateGatekeeper.GetByteLength(), "alternateGatekeeper (AlternateGK)" );
    alternateGatekeeper_tree = proto_item_add_subtree( alternateGatekeeper_ti, hCont->h225_0.ett_h225_GatekeeperConfirm_alternateGatekeeper );
    m_alternateGatekeeper.showEthereal( alternateGatekeeper_tree, tvb, offset );
  }

  /* This member is defined outside the current ASN.1 file, 
   * therefore it's not known what type it is. The safest
   * solution is to add another subtree and let the class handle itself
   */
  if ( HasOptionalField( e_authenticationMode ) ) {
    proto_tree *authenticationMode_tree = (proto_tree*) NULL;
    proto_item *authenticationMode_ti = (proto_item*) NULL;
    authenticationMode_ti = proto_tree_add_text( tree, tvb, offset + m_authenticationMode.GetStartByte(), m_authenticationMode.GetByteLength(), "authenticationMode (H235-AuthenticationMechanism)" );
    authenticationMode_tree = proto_item_add_subtree( authenticationMode_ti, hCont->h225_0.ett_h225_GatekeeperConfirm_authenticationMode );
    m_authenticationMode.showEthereal( authenticationMode_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_0.ett_h225_GatekeeperConfirm_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_0.ett_h225_GatekeeperConfirm_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_algorithmOID ) ) {
    char* palgorithmOID = m_algorithmOID.getValue();
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_GatekeeperConfirm_algorithmOID, tvb, offset + m_algorithmOID.GetStartByte(), m_algorithmOID.GetByteLength() , palgorithmOID );
    delete[] palgorithmOID;
  }

  if ( HasOptionalField( e_integrity ) ) {
    proto_tree *integrity_tree = (proto_tree*) NULL;
    proto_item *integrity_ti = (proto_item*) NULL;
    integrity_ti = proto_tree_add_text( tree, tvb, offset + m_integrity.GetStartByte(), m_integrity.GetByteLength(), "integrity (IntegrityMechanism)" );
    integrity_tree = proto_item_add_subtree( integrity_ti, hCont->h225_0.ett_h225_GatekeeperConfirm_integrity );
    m_integrity.showEthereal( integrity_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_0.ett_h225_GatekeeperConfirm_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// GatekeeperReject
//

H225_GatekeeperReject::H225_GatekeeperReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 4)
{
}


#ifndef PASN_NOPRINTON
void H225_GatekeeperReject::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  strm << setw(indent+15) << "rejectReason = " << setprecision(indent) << m_rejectReason << '\n';
  if (HasOptionalField(e_altGKInfo))
    strm << setw(indent+12) << "altGKInfo = " << setprecision(indent) << m_altGKInfo << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_GatekeeperReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_GatekeeperReject::Class()), PInvalidCast);
#endif
  const H225_GatekeeperReject & other = (const H225_GatekeeperReject &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_gatekeeperIdentifier.Compare(other.m_gatekeeperIdentifier)) != EqualTo)
    return result;
  if ((result = m_rejectReason.Compare(other.m_rejectReason)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_GatekeeperReject::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_protocolIdentifier.GetObjectLength() +
         m_nonStandardData.GetObjectLength() +
         m_gatekeeperIdentifier.GetObjectLength() +
         m_rejectReason.GetObjectLength();
}


BOOL H225_GatekeeperReject::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_protocolIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_gatekeeperIdentifier ) && !m_gatekeeperIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_rejectReason.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_altGKInfo, m_altGKInfo ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_GatekeeperReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_gatekeeperIdentifier))
    m_gatekeeperIdentifier.Encode(strm);
  m_rejectReason.Encode(strm);
  KnownExtensionEncode(strm, e_altGKInfo, m_altGKInfo);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_gatekeeperIdentifier))
    m_gatekeeperIdentifier.Encode(strm);
  m_rejectReason.Encode(strm);
}


PObject * H225_GatekeeperReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_GatekeeperReject::Class()), PInvalidCast);
#endif
  return new H225_GatekeeperReject(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_GatekeeperReject::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  m_protocolIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_gatekeeperIdentifier ) ) 
      m_gatekeeperIdentifier.preShowEthereal( );
  m_rejectReason.preShowEthereal( );
  if ( HasOptionalField( e_altGKInfo ) ) 
      m_altGKInfo.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
}

PString H225_GatekeeperReject::getSummary( void ) 
{
  return PString( "GatekeeperReject" );
}

void H225_GatekeeperReject::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_0.hf_h225_GatekeeperReject_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  char* pprotocolIdentifier = m_protocolIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h225_0.hf_h225_GatekeeperReject_protocolIdentifier, tvb, offset + m_protocolIdentifier.GetStartByte(), m_protocolIdentifier.GetByteLength() , pprotocolIdentifier );
  delete[] pprotocolIdentifier;

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_0.ett_h225_GatekeeperReject_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_gatekeeperIdentifier ) ) {
    char* pgatekeeperIdentifier = m_gatekeeperIdentifier.getValue();
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_GatekeeperReject_gatekeeperIdentifier, tvb, offset + m_gatekeeperIdentifier.GetStartByte(), m_gatekeeperIdentifier.GetByteLength() , pgatekeeperIdentifier );
    delete[] pgatekeeperIdentifier;
  }

  proto_tree *rejectReason_tree = (proto_tree*) NULL;
  proto_item *rejectReason_ti = (proto_item*) NULL;
  rejectReason_ti = proto_tree_add_text( tree, tvb, offset + m_rejectReason.GetStartByte(), m_rejectReason.GetByteLength(), "rejectReason (%s)", ( const char* ) m_rejectReason.GetTagName() );
  rejectReason_tree = proto_item_add_subtree( rejectReason_ti, hCont->h225_0.ett_h225_GatekeeperReject_rejectReason );

  m_rejectReason.showEthereal( rejectReason_tree, tvb, offset );

  if ( HasOptionalField( e_altGKInfo ) ) {
    proto_tree *altGKInfo_tree = (proto_tree*) NULL;
    proto_item *altGKInfo_ti = (proto_item*) NULL;
    altGKInfo_ti = proto_tree_add_text( tree, tvb, offset + m_altGKInfo.GetStartByte(), m_altGKInfo.GetByteLength(), "altGKInfo (AltGKInfo)" );
    altGKInfo_tree = proto_item_add_subtree( altGKInfo_ti, hCont->h225_0.ett_h225_GatekeeperReject_altGKInfo );
    m_altGKInfo.showEthereal( altGKInfo_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_0.ett_h225_GatekeeperReject_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_0.ett_h225_GatekeeperReject_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_0.ett_h225_GatekeeperReject_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// RegistrationReject
//

H225_RegistrationReject::H225_RegistrationReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 4)
{
}


#ifndef PASN_NOPRINTON
void H225_RegistrationReject::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+15) << "rejectReason = " << setprecision(indent) << m_rejectReason << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  if (HasOptionalField(e_altGKInfo))
    strm << setw(indent+12) << "altGKInfo = " << setprecision(indent) << m_altGKInfo << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_RegistrationReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_RegistrationReject::Class()), PInvalidCast);
#endif
  const H225_RegistrationReject & other = (const H225_RegistrationReject &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_rejectReason.Compare(other.m_rejectReason)) != EqualTo)
    return result;
  if ((result = m_gatekeeperIdentifier.Compare(other.m_gatekeeperIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_RegistrationReject::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_protocolIdentifier.GetObjectLength() +
         m_nonStandardData.GetObjectLength() +
         m_rejectReason.GetObjectLength() +
         m_gatekeeperIdentifier.GetObjectLength();
}


BOOL H225_RegistrationReject::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_protocolIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_rejectReason.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_gatekeeperIdentifier ) && !m_gatekeeperIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_altGKInfo, m_altGKInfo ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_RegistrationReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_rejectReason.Encode(strm);
  if (HasOptionalField(e_gatekeeperIdentifier))
    m_gatekeeperIdentifier.Encode(strm);
  KnownExtensionEncode(strm, e_altGKInfo, m_altGKInfo);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_rejectReason.Encode(strm);
  if (HasOptionalField(e_gatekeeperIdentifier))
    m_gatekeeperIdentifier.Encode(strm);
}


PObject * H225_RegistrationReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_RegistrationReject::Class()), PInvalidCast);
#endif
  return new H225_RegistrationReject(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_RegistrationReject::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  m_protocolIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  m_rejectReason.preShowEthereal( );
  if ( HasOptionalField( e_gatekeeperIdentifier ) ) 
      m_gatekeeperIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_altGKInfo ) ) 
      m_altGKInfo.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
}

PString H225_RegistrationReject::getSummary( void ) 
{
  return PString( "RegistrationReject" );
}

void H225_RegistrationReject::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_0.hf_h225_RegistrationReject_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  char* pprotocolIdentifier = m_protocolIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h225_0.hf_h225_RegistrationReject_protocolIdentifier, tvb, offset + m_protocolIdentifier.GetStartByte(), m_protocolIdentifier.GetByteLength() , pprotocolIdentifier );
  delete[] pprotocolIdentifier;

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_0.ett_h225_RegistrationReject_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  proto_tree *rejectReason_tree = (proto_tree*) NULL;
  proto_item *rejectReason_ti = (proto_item*) NULL;
  rejectReason_ti = proto_tree_add_text( tree, tvb, offset + m_rejectReason.GetStartByte(), m_rejectReason.GetByteLength(), "rejectReason (%s)", ( const char* ) m_rejectReason.GetTagName() );
  rejectReason_tree = proto_item_add_subtree( rejectReason_ti, hCont->h225_0.ett_h225_RegistrationReject_rejectReason );

  m_rejectReason.showEthereal( rejectReason_tree, tvb, offset );

  if ( HasOptionalField( e_gatekeeperIdentifier ) ) {
    char* pgatekeeperIdentifier = m_gatekeeperIdentifier.getValue();
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_RegistrationReject_gatekeeperIdentifier, tvb, offset + m_gatekeeperIdentifier.GetStartByte(), m_gatekeeperIdentifier.GetByteLength() , pgatekeeperIdentifier );
    delete[] pgatekeeperIdentifier;
  }

  if ( HasOptionalField( e_altGKInfo ) ) {
    proto_tree *altGKInfo_tree = (proto_tree*) NULL;
    proto_item *altGKInfo_ti = (proto_item*) NULL;
    altGKInfo_ti = proto_tree_add_text( tree, tvb, offset + m_altGKInfo.GetStartByte(), m_altGKInfo.GetByteLength(), "altGKInfo (AltGKInfo)" );
    altGKInfo_tree = proto_item_add_subtree( altGKInfo_ti, hCont->h225_0.ett_h225_RegistrationReject_altGKInfo );
    m_altGKInfo.showEthereal( altGKInfo_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_0.ett_h225_RegistrationReject_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_0.ett_h225_RegistrationReject_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_0.ett_h225_RegistrationReject_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// UnregistrationRequest
//

H225_UnregistrationRequest::H225_UnregistrationRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 6)
{
}


#ifndef PASN_NOPRINTON
void H225_UnregistrationRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+20) << "callSignalAddress = " << setprecision(indent) << m_callSignalAddress << '\n';
  if (HasOptionalField(e_endpointAlias))
    strm << setw(indent+16) << "endpointAlias = " << setprecision(indent) << m_endpointAlias << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_endpointIdentifier))
    strm << setw(indent+21) << "endpointIdentifier = " << setprecision(indent) << m_endpointIdentifier << '\n';
  if (HasOptionalField(e_alternateEndpoints))
    strm << setw(indent+21) << "alternateEndpoints = " << setprecision(indent) << m_alternateEndpoints << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_reason))
    strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_UnregistrationRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_UnregistrationRequest::Class()), PInvalidCast);
#endif
  const H225_UnregistrationRequest & other = (const H225_UnregistrationRequest &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_callSignalAddress.Compare(other.m_callSignalAddress)) != EqualTo)
    return result;
  if ((result = m_endpointAlias.Compare(other.m_endpointAlias)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_endpointIdentifier.Compare(other.m_endpointIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_UnregistrationRequest::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_callSignalAddress.GetObjectLength() +
         m_endpointAlias.GetObjectLength() +
         m_nonStandardData.GetObjectLength() +
         m_endpointIdentifier.GetObjectLength();
}


BOOL H225_UnregistrationRequest::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callSignalAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_endpointAlias ) && !m_endpointAlias.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_endpointIdentifier ) && !m_endpointIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_alternateEndpoints, m_alternateEndpoints ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_gatekeeperIdentifier, m_gatekeeperIdentifier ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_reason, m_reason ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_UnregistrationRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_callSignalAddress.Encode(strm);
  if (HasOptionalField(e_endpointAlias))
    m_endpointAlias.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_endpointIdentifier))
    m_endpointIdentifier.Encode(strm);
  KnownExtensionEncode(strm, e_alternateEndpoints, m_alternateEndpoints);
  KnownExtensionEncode(strm, e_gatekeeperIdentifier, m_gatekeeperIdentifier);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_reason, m_reason);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  m_callSignalAddress.Encode(strm);
  if (HasOptionalField(e_endpointAlias))
    m_endpointAlias.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_endpointIdentifier))
    m_endpointIdentifier.Encode(strm);
}


PObject * H225_UnregistrationRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_UnregistrationRequest::Class()), PInvalidCast);
#endif
  return new H225_UnregistrationRequest(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_UnregistrationRequest::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  m_callSignalAddress.preShowEthereal( );
  if ( HasOptionalField( e_endpointAlias ) ) 
      m_endpointAlias.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_endpointIdentifier ) ) 
      m_endpointIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_alternateEndpoints ) ) 
      m_alternateEndpoints.preShowEthereal( );
  if ( HasOptionalField( e_gatekeeperIdentifier ) ) 
      m_gatekeeperIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
  if ( HasOptionalField( e_reason ) ) 
      m_reason.preShowEthereal( );
}

PString H225_UnregistrationRequest::getSummary( void ) 
{
  return PString( "UnregistrationRequest" );
}

void H225_UnregistrationRequest::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_0.hf_h225_UnregistrationRequest_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  proto_tree *callSignalAddress_tree = (proto_tree*) NULL;
  proto_item *callSignalAddress_ti = (proto_item*) NULL;
  callSignalAddress_ti = proto_tree_add_text( tree, tvb, offset + m_callSignalAddress.GetStartByte(), m_callSignalAddress.GetByteLength(), "callSignalAddress (TransportAddress)" );
  callSignalAddress_tree = proto_item_add_subtree( callSignalAddress_ti, hCont->h225_0.ett_h225_UnregistrationRequest_callSignalAddress );

  m_callSignalAddress.showEthereal( callSignalAddress_tree, tvb, offset );

  if ( HasOptionalField( e_endpointAlias ) ) {
    proto_tree *endpointAlias_tree = (proto_tree*) NULL;
    proto_item *endpointAlias_ti = (proto_item*) NULL;
    endpointAlias_ti = proto_tree_add_text( tree, tvb, offset + m_endpointAlias.GetStartByte(), m_endpointAlias.GetByteLength(), "endpointAlias (AliasAddress)" );
    endpointAlias_tree = proto_item_add_subtree( endpointAlias_ti, hCont->h225_0.ett_h225_UnregistrationRequest_endpointAlias );
    m_endpointAlias.showEthereal( endpointAlias_tree, tvb, offset );
  }

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_0.ett_h225_UnregistrationRequest_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_endpointIdentifier ) ) {
    char* pendpointIdentifier = m_endpointIdentifier.getValue();
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_UnregistrationRequest_endpointIdentifier, tvb, offset + m_endpointIdentifier.GetStartByte(), m_endpointIdentifier.GetByteLength() , pendpointIdentifier );
    delete[] pendpointIdentifier;
  }

  if ( HasOptionalField( e_alternateEndpoints ) ) {
    proto_tree *alternateEndpoints_tree = (proto_tree*) NULL;
    proto_item *alternateEndpoints_ti = (proto_item*) NULL;
    alternateEndpoints_ti = proto_tree_add_text( tree, tvb, offset + m_alternateEndpoints.GetStartByte(), m_alternateEndpoints.GetByteLength(), "alternateEndpoints (Endpoint)" );
    alternateEndpoints_tree = proto_item_add_subtree( alternateEndpoints_ti, hCont->h225_0.ett_h225_UnregistrationRequest_alternateEndpoints );
    m_alternateEndpoints.showEthereal( alternateEndpoints_tree, tvb, offset );
  }

  if ( HasOptionalField( e_gatekeeperIdentifier ) ) {
    char* pgatekeeperIdentifier = m_gatekeeperIdentifier.getValue();
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_UnregistrationRequest_gatekeeperIdentifier, tvb, offset + m_gatekeeperIdentifier.GetStartByte(), m_gatekeeperIdentifier.GetByteLength() , pgatekeeperIdentifier );
    delete[] pgatekeeperIdentifier;
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_0.ett_h225_UnregistrationRequest_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_0.ett_h225_UnregistrationRequest_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_0.ett_h225_UnregistrationRequest_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

  if ( HasOptionalField( e_reason ) ) {
    proto_tree *reason_tree = (proto_tree*) NULL;
    proto_item *reason_ti = (proto_item*) NULL;
    reason_ti = proto_tree_add_text( tree, tvb, offset + m_reason.GetStartByte(), m_reason.GetByteLength(), "reason (%s)", ( const char* ) m_reason.GetTagName() );
    reason_tree = proto_item_add_subtree( reason_ti, hCont->h225_0.ett_h225_UnregistrationRequest_reason );
    m_reason.showEthereal( reason_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// UnregistrationConfirm
//

H225_UnregistrationConfirm::H225_UnregistrationConfirm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 3)
{
}


#ifndef PASN_NOPRINTON
void H225_UnregistrationConfirm::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_UnregistrationConfirm::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_UnregistrationConfirm::Class()), PInvalidCast);
#endif
  const H225_UnregistrationConfirm & other = (const H225_UnregistrationConfirm &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_UnregistrationConfirm::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_nonStandardData.GetObjectLength();
}


BOOL H225_UnregistrationConfirm::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_UnregistrationConfirm::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_UnregistrationConfirm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_UnregistrationConfirm::Class()), PInvalidCast);
#endif
  return new H225_UnregistrationConfirm(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_UnregistrationConfirm::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
}

PString H225_UnregistrationConfirm::getSummary( void ) 
{
  return PString( "UnregistrationConfirm" );
}

void H225_UnregistrationConfirm::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_0.hf_h225_UnregistrationConfirm_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_0.ett_h225_UnregistrationConfirm_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_0.ett_h225_UnregistrationConfirm_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_0.ett_h225_UnregistrationConfirm_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_0.ett_h225_UnregistrationConfirm_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// UnregistrationReject
//

H225_UnregistrationReject::H225_UnregistrationReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 4)
{
}


#ifndef PASN_NOPRINTON
void H225_UnregistrationReject::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+15) << "rejectReason = " << setprecision(indent) << m_rejectReason << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_altGKInfo))
    strm << setw(indent+12) << "altGKInfo = " << setprecision(indent) << m_altGKInfo << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_UnregistrationReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_UnregistrationReject::Class()), PInvalidCast);
#endif
  const H225_UnregistrationReject & other = (const H225_UnregistrationReject &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_rejectReason.Compare(other.m_rejectReason)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_UnregistrationReject::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_rejectReason.GetObjectLength() +
         m_nonStandardData.GetObjectLength();
}


BOOL H225_UnregistrationReject::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_rejectReason.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_altGKInfo, m_altGKInfo ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_UnregistrationReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_rejectReason.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_altGKInfo, m_altGKInfo);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  m_rejectReason.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_UnregistrationReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_UnregistrationReject::Class()), PInvalidCast);
#endif
  return new H225_UnregistrationReject(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_UnregistrationReject::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  m_rejectReason.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_altGKInfo ) ) 
      m_altGKInfo.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
}

PString H225_UnregistrationReject::getSummary( void ) 
{
  return PString( "UnregistrationReject" );
}

void H225_UnregistrationReject::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_0.hf_h225_UnregistrationReject_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  proto_tree *rejectReason_tree = (proto_tree*) NULL;
  proto_item *rejectReason_ti = (proto_item*) NULL;
  rejectReason_ti = proto_tree_add_text( tree, tvb, offset + m_rejectReason.GetStartByte(), m_rejectReason.GetByteLength(), "rejectReason (%s)", ( const char* ) m_rejectReason.GetTagName() );
  rejectReason_tree = proto_item_add_subtree( rejectReason_ti, hCont->h225_0.ett_h225_UnregistrationReject_rejectReason );

  m_rejectReason.showEthereal( rejectReason_tree, tvb, offset );

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_0.ett_h225_UnregistrationReject_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_altGKInfo ) ) {
    proto_tree *altGKInfo_tree = (proto_tree*) NULL;
    proto_item *altGKInfo_ti = (proto_item*) NULL;
    altGKInfo_ti = proto_tree_add_text( tree, tvb, offset + m_altGKInfo.GetStartByte(), m_altGKInfo.GetByteLength(), "altGKInfo (AltGKInfo)" );
    altGKInfo_tree = proto_item_add_subtree( altGKInfo_ti, hCont->h225_0.ett_h225_UnregistrationReject_altGKInfo );
    m_altGKInfo.showEthereal( altGKInfo_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_0.ett_h225_UnregistrationReject_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_0.ett_h225_UnregistrationReject_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_0.ett_h225_UnregistrationReject_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// AdmissionRequest
//

H225_AdmissionRequest::H225_AdmissionRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 7, TRUE, 11)
{
  IncludeOptionalField(e_canMapAlias);
  IncludeOptionalField(e_callIdentifier);
  IncludeOptionalField(e_willSupplyUUIEs);
}


#ifndef PASN_NOPRINTON
void H225_AdmissionRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+11) << "callType = " << setprecision(indent) << m_callType << '\n';
  if (HasOptionalField(e_callModel))
    strm << setw(indent+12) << "callModel = " << setprecision(indent) << m_callModel << '\n';
  strm << setw(indent+21) << "endpointIdentifier = " << setprecision(indent) << m_endpointIdentifier << '\n';
  if (HasOptionalField(e_destinationInfo))
    strm << setw(indent+18) << "destinationInfo = " << setprecision(indent) << m_destinationInfo << '\n';
  if (HasOptionalField(e_destCallSignalAddress))
    strm << setw(indent+24) << "destCallSignalAddress = " << setprecision(indent) << m_destCallSignalAddress << '\n';
  if (HasOptionalField(e_destExtraCallInfo))
    strm << setw(indent+20) << "destExtraCallInfo = " << setprecision(indent) << m_destExtraCallInfo << '\n';
  strm << setw(indent+10) << "srcInfo = " << setprecision(indent) << m_srcInfo << '\n';
  if (HasOptionalField(e_srcCallSignalAddress))
    strm << setw(indent+23) << "srcCallSignalAddress = " << setprecision(indent) << m_srcCallSignalAddress << '\n';
  strm << setw(indent+12) << "bandWidth = " << setprecision(indent) << m_bandWidth << '\n';
  strm << setw(indent+21) << "callReferenceValue = " << setprecision(indent) << m_callReferenceValue << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_callServices))
    strm << setw(indent+15) << "callServices = " << setprecision(indent) << m_callServices << '\n';
  strm << setw(indent+15) << "conferenceID = " << setprecision(indent) << m_conferenceID << '\n';
  strm << setw(indent+11) << "activeMC = " << setprecision(indent) << m_activeMC << '\n';
  strm << setw(indent+13) << "answerCall = " << setprecision(indent) << m_answerCall << '\n';
  if (HasOptionalField(e_canMapAlias))
    strm << setw(indent+14) << "canMapAlias = " << setprecision(indent) << m_canMapAlias << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_srcAlternatives))
    strm << setw(indent+18) << "srcAlternatives = " << setprecision(indent) << m_srcAlternatives << '\n';
  if (HasOptionalField(e_destAlternatives))
    strm << setw(indent+19) << "destAlternatives = " << setprecision(indent) << m_destAlternatives << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_transportQOS))
    strm << setw(indent+15) << "transportQOS = " << setprecision(indent) << m_transportQOS << '\n';
  if (HasOptionalField(e_willSupplyUUIEs))
    strm << setw(indent+18) << "willSupplyUUIEs = " << setprecision(indent) << m_willSupplyUUIEs << '\n';
  if (HasOptionalField(e_callLinkage))
    strm << setw(indent+14) << "callLinkage = " << setprecision(indent) << m_callLinkage << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_AdmissionRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_AdmissionRequest::Class()), PInvalidCast);
#endif
  const H225_AdmissionRequest & other = (const H225_AdmissionRequest &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_callType.Compare(other.m_callType)) != EqualTo)
    return result;
  if ((result = m_callModel.Compare(other.m_callModel)) != EqualTo)
    return result;
  if ((result = m_endpointIdentifier.Compare(other.m_endpointIdentifier)) != EqualTo)
    return result;
  if ((result = m_destinationInfo.Compare(other.m_destinationInfo)) != EqualTo)
    return result;
  if ((result = m_destCallSignalAddress.Compare(other.m_destCallSignalAddress)) != EqualTo)
    return result;
  if ((result = m_destExtraCallInfo.Compare(other.m_destExtraCallInfo)) != EqualTo)
    return result;
  if ((result = m_srcInfo.Compare(other.m_srcInfo)) != EqualTo)
    return result;
  if ((result = m_srcCallSignalAddress.Compare(other.m_srcCallSignalAddress)) != EqualTo)
    return result;
  if ((result = m_bandWidth.Compare(other.m_bandWidth)) != EqualTo)
    return result;
  if ((result = m_callReferenceValue.Compare(other.m_callReferenceValue)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_callServices.Compare(other.m_callServices)) != EqualTo)
    return result;
  if ((result = m_conferenceID.Compare(other.m_conferenceID)) != EqualTo)
    return result;
  if ((result = m_activeMC.Compare(other.m_activeMC)) != EqualTo)
    return result;
  if ((result = m_answerCall.Compare(other.m_answerCall)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_AdmissionRequest::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_callType.GetObjectLength() +
         m_callModel.GetObjectLength() +
         m_endpointIdentifier.GetObjectLength() +
         m_destinationInfo.GetObjectLength() +
         m_destCallSignalAddress.GetObjectLength() +
         m_destExtraCallInfo.GetObjectLength() +
         m_srcInfo.GetObjectLength() +
         m_srcCallSignalAddress.GetObjectLength() +
         m_bandWidth.GetObjectLength() +
         m_callReferenceValue.GetObjectLength() +
         m_nonStandardData.GetObjectLength() +
         m_callServices.GetObjectLength() +
         m_conferenceID.GetObjectLength() +
         m_activeMC.GetObjectLength() +
         m_answerCall.GetObjectLength();
}


BOOL H225_AdmissionRequest::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_callModel ) && !m_callModel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_endpointIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_destinationInfo ) && !m_destinationInfo.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_destCallSignalAddress ) && !m_destCallSignalAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_destExtraCallInfo ) && !m_destExtraCallInfo.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_srcInfo.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_srcCallSignalAddress ) && !m_srcCallSignalAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bandWidth.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callReferenceValue.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_callServices ) && !m_callServices.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_conferenceID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_activeMC.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_answerCall.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_canMapAlias, m_canMapAlias ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_callIdentifier, m_callIdentifier ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_srcAlternatives, m_srcAlternatives ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_destAlternatives, m_destAlternatives ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_gatekeeperIdentifier, m_gatekeeperIdentifier ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_transportQOS, m_transportQOS ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_willSupplyUUIEs, m_willSupplyUUIEs ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_callLinkage, m_callLinkage ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_AdmissionRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_callType.Encode(strm);
  if (HasOptionalField(e_callModel))
    m_callModel.Encode(strm);
  m_endpointIdentifier.Encode(strm);
  if (HasOptionalField(e_destinationInfo))
    m_destinationInfo.Encode(strm);
  if (HasOptionalField(e_destCallSignalAddress))
    m_destCallSignalAddress.Encode(strm);
  if (HasOptionalField(e_destExtraCallInfo))
    m_destExtraCallInfo.Encode(strm);
  m_srcInfo.Encode(strm);
  if (HasOptionalField(e_srcCallSignalAddress))
    m_srcCallSignalAddress.Encode(strm);
  m_bandWidth.Encode(strm);
  m_callReferenceValue.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_callServices))
    m_callServices.Encode(strm);
  m_conferenceID.Encode(strm);
  m_activeMC.Encode(strm);
  m_answerCall.Encode(strm);
  KnownExtensionEncode(strm, e_canMapAlias, m_canMapAlias);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_srcAlternatives, m_srcAlternatives);
  KnownExtensionEncode(strm, e_destAlternatives, m_destAlternatives);
  KnownExtensionEncode(strm, e_gatekeeperIdentifier, m_gatekeeperIdentifier);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_transportQOS, m_transportQOS);
  KnownExtensionEncode(strm, e_willSupplyUUIEs, m_willSupplyUUIEs);
  KnownExtensionEncode(strm, e_callLinkage, m_callLinkage);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  m_callType.Encode(strm);
  if (HasOptionalField(e_callModel))
    m_callModel.Encode(strm);
  m_endpointIdentifier.Encode(strm);
  if (HasOptionalField(e_destinationInfo))
    m_destinationInfo.Encode(strm);
  if (HasOptionalField(e_destCallSignalAddress))
    m_destCallSignalAddress.Encode(strm);
  if (HasOptionalField(e_destExtraCallInfo))
    m_destExtraCallInfo.Encode(strm);
  m_srcInfo.Encode(strm);
  if (HasOptionalField(e_srcCallSignalAddress))
    m_srcCallSignalAddress.Encode(strm);
  m_bandWidth.Encode(strm);
  m_callReferenceValue.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_callServices))
    m_callServices.Encode(strm);
  m_conferenceID.Encode(strm);
  m_activeMC.Encode(strm);
  m_answerCall.Encode(strm);
}


PObject * H225_AdmissionRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_AdmissionRequest::Class()), PInvalidCast);
#endif
  return new H225_AdmissionRequest(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_AdmissionRequest::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  m_callType.preShowEthereal( );
  if ( HasOptionalField( e_callModel ) ) 
      m_callModel.preShowEthereal( );
  m_endpointIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_destinationInfo ) ) 
      m_destinationInfo.preShowEthereal( );
  if ( HasOptionalField( e_destCallSignalAddress ) ) 
      m_destCallSignalAddress.preShowEthereal( );
  if ( HasOptionalField( e_destExtraCallInfo ) ) 
      m_destExtraCallInfo.preShowEthereal( );
  m_srcInfo.preShowEthereal( );
  if ( HasOptionalField( e_srcCallSignalAddress ) ) 
      m_srcCallSignalAddress.preShowEthereal( );
  m_bandWidth.preShowEthereal( );
  m_callReferenceValue.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_callServices ) ) 
      m_callServices.preShowEthereal( );
  m_conferenceID.preShowEthereal( );
  m_activeMC.preShowEthereal( );
  m_answerCall.preShowEthereal( );
  if ( HasOptionalField( e_canMapAlias ) ) 
      m_canMapAlias.preShowEthereal( );
  if ( HasOptionalField( e_callIdentifier ) ) 
      m_callIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_srcAlternatives ) ) 
      m_srcAlternatives.preShowEthereal( );
  if ( HasOptionalField( e_destAlternatives ) ) 
      m_destAlternatives.preShowEthereal( );
  if ( HasOptionalField( e_gatekeeperIdentifier ) ) 
      m_gatekeeperIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
  if ( HasOptionalField( e_transportQOS ) ) 
      m_transportQOS.preShowEthereal( );
  if ( HasOptionalField( e_willSupplyUUIEs ) ) 
      m_willSupplyUUIEs.preShowEthereal( );
  if ( HasOptionalField( e_callLinkage ) ) 
      m_callLinkage.preShowEthereal( );
}

PString H225_AdmissionRequest::getSummary( void ) 
{
  return PString( "AdmissionRequest" );
}

void H225_AdmissionRequest::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_0.hf_h225_AdmissionRequest_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  proto_tree *callType_tree = (proto_tree*) NULL;
  proto_item *callType_ti = (proto_item*) NULL;
  callType_ti = proto_tree_add_text( tree, tvb, offset + m_callType.GetStartByte(), m_callType.GetByteLength(), "callType (%s)", ( const char* ) m_callType.GetTagName() );
  callType_tree = proto_item_add_subtree( callType_ti, hCont->h225_0.ett_h225_AdmissionRequest_callType );

  m_callType.showEthereal( callType_tree, tvb, offset );

  if ( HasOptionalField( e_callModel ) ) {
    proto_tree *callModel_tree = (proto_tree*) NULL;
    proto_item *callModel_ti = (proto_item*) NULL;
    callModel_ti = proto_tree_add_text( tree, tvb, offset + m_callModel.GetStartByte(), m_callModel.GetByteLength(), "callModel (%s)", ( const char* ) m_callModel.GetTagName() );
    callModel_tree = proto_item_add_subtree( callModel_ti, hCont->h225_0.ett_h225_AdmissionRequest_callModel );
    m_callModel.showEthereal( callModel_tree, tvb, offset );
  }

  char* pendpointIdentifier = m_endpointIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h225_0.hf_h225_AdmissionRequest_endpointIdentifier, tvb, offset + m_endpointIdentifier.GetStartByte(), m_endpointIdentifier.GetByteLength() , pendpointIdentifier );
  delete[] pendpointIdentifier;

  if ( HasOptionalField( e_destinationInfo ) ) {
    proto_tree *destinationInfo_tree = (proto_tree*) NULL;
    proto_item *destinationInfo_ti = (proto_item*) NULL;
    destinationInfo_ti = proto_tree_add_text( tree, tvb, offset + m_destinationInfo.GetStartByte(), m_destinationInfo.GetByteLength(), "destinationInfo (AliasAddress)" );
    destinationInfo_tree = proto_item_add_subtree( destinationInfo_ti, hCont->h225_0.ett_h225_AdmissionRequest_destinationInfo );
    m_destinationInfo.showEthereal( destinationInfo_tree, tvb, offset );
  }

  if ( HasOptionalField( e_destCallSignalAddress ) ) {
    proto_tree *destCallSignalAddress_tree = (proto_tree*) NULL;
    proto_item *destCallSignalAddress_ti = (proto_item*) NULL;
    destCallSignalAddress_ti = proto_tree_add_text( tree, tvb, offset + m_destCallSignalAddress.GetStartByte(), m_destCallSignalAddress.GetByteLength(), "destCallSignalAddress (%s)", ( const char* ) m_destCallSignalAddress.GetTagName() );
    destCallSignalAddress_tree = proto_item_add_subtree( destCallSignalAddress_ti, hCont->h225_0.ett_h225_AdmissionRequest_destCallSignalAddress );
    m_destCallSignalAddress.showEthereal( destCallSignalAddress_tree, tvb, offset );
  }

  if ( HasOptionalField( e_destExtraCallInfo ) ) {
    proto_tree *destExtraCallInfo_tree = (proto_tree*) NULL;
    proto_item *destExtraCallInfo_ti = (proto_item*) NULL;
    destExtraCallInfo_ti = proto_tree_add_text( tree, tvb, offset + m_destExtraCallInfo.GetStartByte(), m_destExtraCallInfo.GetByteLength(), "destExtraCallInfo (AliasAddress)" );
    destExtraCallInfo_tree = proto_item_add_subtree( destExtraCallInfo_ti, hCont->h225_0.ett_h225_AdmissionRequest_destExtraCallInfo );
    m_destExtraCallInfo.showEthereal( destExtraCallInfo_tree, tvb, offset );
  }

  proto_tree *srcInfo_tree = (proto_tree*) NULL;
  proto_item *srcInfo_ti = (proto_item*) NULL;
  srcInfo_ti = proto_tree_add_text( tree, tvb, offset + m_srcInfo.GetStartByte(), m_srcInfo.GetByteLength(), "srcInfo (AliasAddress)" );
  srcInfo_tree = proto_item_add_subtree( srcInfo_ti, hCont->h225_0.ett_h225_AdmissionRequest_srcInfo );

  m_srcInfo.showEthereal( srcInfo_tree, tvb, offset );

  if ( HasOptionalField( e_srcCallSignalAddress ) ) {
    proto_tree *srcCallSignalAddress_tree = (proto_tree*) NULL;
    proto_item *srcCallSignalAddress_ti = (proto_item*) NULL;
    srcCallSignalAddress_ti = proto_tree_add_text( tree, tvb, offset + m_srcCallSignalAddress.GetStartByte(), m_srcCallSignalAddress.GetByteLength(), "srcCallSignalAddress (%s)", ( const char* ) m_srcCallSignalAddress.GetTagName() );
    srcCallSignalAddress_tree = proto_item_add_subtree( srcCallSignalAddress_ti, hCont->h225_0.ett_h225_AdmissionRequest_srcCallSignalAddress );
    m_srcCallSignalAddress.showEthereal( srcCallSignalAddress_tree, tvb, offset );
  }

  proto_tree_add_uint( tree, hCont->h225_0.hf_h225_AdmissionRequest_bandWidth, tvb, offset + m_bandWidth.GetStartByte(), m_bandWidth.GetByteLength() , m_bandWidth.GetValue() );

  proto_tree_add_uint( tree, hCont->h225_0.hf_h225_AdmissionRequest_callReferenceValue, tvb, offset + m_callReferenceValue.GetStartByte(), m_callReferenceValue.GetByteLength() , m_callReferenceValue.GetValue() );

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_0.ett_h225_AdmissionRequest_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_callServices ) ) {
    proto_tree *callServices_tree = (proto_tree*) NULL;
    proto_item *callServices_ti = (proto_item*) NULL;
    callServices_ti = proto_tree_add_text( tree, tvb, offset + m_callServices.GetStartByte(), m_callServices.GetByteLength(), "callServices (QseriesOptions)" );
    callServices_tree = proto_item_add_subtree( callServices_ti, hCont->h225_0.ett_h225_AdmissionRequest_callServices );
    m_callServices.showEthereal( callServices_tree, tvb, offset );
  }

  char* pconferenceID = m_conferenceID.getValue();
  proto_tree_add_string( tree, hCont->h225_0.hf_h225_AdmissionRequest_conferenceID, tvb, offset + m_conferenceID.GetStartByte(), m_conferenceID.GetByteLength() , pconferenceID );
  delete[] pconferenceID;

  proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_AdmissionRequest_activeMC, tvb, offset + m_activeMC.GetStartByte(), m_activeMC.GetByteLength() , m_activeMC.GetValue() );

  proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_AdmissionRequest_answerCall, tvb, offset + m_answerCall.GetStartByte(), m_answerCall.GetByteLength() , m_answerCall.GetValue() );

  if ( HasOptionalField( e_canMapAlias ) ) {
    proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_AdmissionRequest_canMapAlias, tvb, offset + m_canMapAlias.GetStartByte(), m_canMapAlias.GetByteLength() , m_canMapAlias.GetValue() );
  }

  if ( HasOptionalField( e_callIdentifier ) ) {
    proto_tree *callIdentifier_tree = (proto_tree*) NULL;
    proto_item *callIdentifier_ti = (proto_item*) NULL;
    callIdentifier_ti = proto_tree_add_text( tree, tvb, offset + m_callIdentifier.GetStartByte(), m_callIdentifier.GetByteLength(), "callIdentifier (CallIdentifier)" );
    callIdentifier_tree = proto_item_add_subtree( callIdentifier_ti, hCont->h225_0.ett_h225_AdmissionRequest_callIdentifier );
    m_callIdentifier.showEthereal( callIdentifier_tree, tvb, offset );
  }

  if ( HasOptionalField( e_srcAlternatives ) ) {
    proto_tree *srcAlternatives_tree = (proto_tree*) NULL;
    proto_item *srcAlternatives_ti = (proto_item*) NULL;
    srcAlternatives_ti = proto_tree_add_text( tree, tvb, offset + m_srcAlternatives.GetStartByte(), m_srcAlternatives.GetByteLength(), "srcAlternatives (Endpoint)" );
    srcAlternatives_tree = proto_item_add_subtree( srcAlternatives_ti, hCont->h225_0.ett_h225_AdmissionRequest_srcAlternatives );
    m_srcAlternatives.showEthereal( srcAlternatives_tree, tvb, offset );
  }

  if ( HasOptionalField( e_destAlternatives ) ) {
    proto_tree *destAlternatives_tree = (proto_tree*) NULL;
    proto_item *destAlternatives_ti = (proto_item*) NULL;
    destAlternatives_ti = proto_tree_add_text( tree, tvb, offset + m_destAlternatives.GetStartByte(), m_destAlternatives.GetByteLength(), "destAlternatives (Endpoint)" );
    destAlternatives_tree = proto_item_add_subtree( destAlternatives_ti, hCont->h225_0.ett_h225_AdmissionRequest_destAlternatives );
    m_destAlternatives.showEthereal( destAlternatives_tree, tvb, offset );
  }

  if ( HasOptionalField( e_gatekeeperIdentifier ) ) {
    char* pgatekeeperIdentifier = m_gatekeeperIdentifier.getValue();
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_AdmissionRequest_gatekeeperIdentifier, tvb, offset + m_gatekeeperIdentifier.GetStartByte(), m_gatekeeperIdentifier.GetByteLength() , pgatekeeperIdentifier );
    delete[] pgatekeeperIdentifier;
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_0.ett_h225_AdmissionRequest_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_0.ett_h225_AdmissionRequest_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_0.ett_h225_AdmissionRequest_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

  if ( HasOptionalField( e_transportQOS ) ) {
    proto_tree *transportQOS_tree = (proto_tree*) NULL;
    proto_item *transportQOS_ti = (proto_item*) NULL;
    transportQOS_ti = proto_tree_add_text( tree, tvb, offset + m_transportQOS.GetStartByte(), m_transportQOS.GetByteLength(), "transportQOS (%s)", ( const char* ) m_transportQOS.GetTagName() );
    transportQOS_tree = proto_item_add_subtree( transportQOS_ti, hCont->h225_0.ett_h225_AdmissionRequest_transportQOS );
    m_transportQOS.showEthereal( transportQOS_tree, tvb, offset );
  }

  if ( HasOptionalField( e_willSupplyUUIEs ) ) {
    proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_AdmissionRequest_willSupplyUUIEs, tvb, offset + m_willSupplyUUIEs.GetStartByte(), m_willSupplyUUIEs.GetByteLength() , m_willSupplyUUIEs.GetValue() );
  }

  if ( HasOptionalField( e_callLinkage ) ) {
    proto_tree *callLinkage_tree = (proto_tree*) NULL;
    proto_item *callLinkage_ti = (proto_item*) NULL;
    callLinkage_ti = proto_tree_add_text( tree, tvb, offset + m_callLinkage.GetStartByte(), m_callLinkage.GetByteLength(), "callLinkage (CallLinkage)" );
    callLinkage_tree = proto_item_add_subtree( callLinkage_ti, hCont->h225_0.ett_h225_AdmissionRequest_callLinkage );
    m_callLinkage.showEthereal( callLinkage_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// AdmissionReject
//

H225_AdmissionReject::H225_AdmissionReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 5)
{
}


#ifndef PASN_NOPRINTON
void H225_AdmissionReject::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+15) << "rejectReason = " << setprecision(indent) << m_rejectReason << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_altGKInfo))
    strm << setw(indent+12) << "altGKInfo = " << setprecision(indent) << m_altGKInfo << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_callSignalAddress))
    strm << setw(indent+20) << "callSignalAddress = " << setprecision(indent) << m_callSignalAddress << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_AdmissionReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_AdmissionReject::Class()), PInvalidCast);
#endif
  const H225_AdmissionReject & other = (const H225_AdmissionReject &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_rejectReason.Compare(other.m_rejectReason)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_AdmissionReject::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_rejectReason.GetObjectLength() +
         m_nonStandardData.GetObjectLength();
}


BOOL H225_AdmissionReject::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_rejectReason.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_altGKInfo, m_altGKInfo ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_callSignalAddress, m_callSignalAddress ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_AdmissionReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_rejectReason.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_altGKInfo, m_altGKInfo);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_callSignalAddress, m_callSignalAddress);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  m_rejectReason.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_AdmissionReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_AdmissionReject::Class()), PInvalidCast);
#endif
  return new H225_AdmissionReject(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_AdmissionReject::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  m_rejectReason.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_altGKInfo ) ) 
      m_altGKInfo.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_callSignalAddress ) ) 
      m_callSignalAddress.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
}

PString H225_AdmissionReject::getSummary( void ) 
{
  return PString( "AdmissionReject" );
}

void H225_AdmissionReject::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_0.hf_h225_AdmissionReject_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  proto_tree *rejectReason_tree = (proto_tree*) NULL;
  proto_item *rejectReason_ti = (proto_item*) NULL;
  rejectReason_ti = proto_tree_add_text( tree, tvb, offset + m_rejectReason.GetStartByte(), m_rejectReason.GetByteLength(), "rejectReason (%s)", ( const char* ) m_rejectReason.GetTagName() );
  rejectReason_tree = proto_item_add_subtree( rejectReason_ti, hCont->h225_0.ett_h225_AdmissionReject_rejectReason );

  m_rejectReason.showEthereal( rejectReason_tree, tvb, offset );

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_0.ett_h225_AdmissionReject_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_altGKInfo ) ) {
    proto_tree *altGKInfo_tree = (proto_tree*) NULL;
    proto_item *altGKInfo_ti = (proto_item*) NULL;
    altGKInfo_ti = proto_tree_add_text( tree, tvb, offset + m_altGKInfo.GetStartByte(), m_altGKInfo.GetByteLength(), "altGKInfo (AltGKInfo)" );
    altGKInfo_tree = proto_item_add_subtree( altGKInfo_ti, hCont->h225_0.ett_h225_AdmissionReject_altGKInfo );
    m_altGKInfo.showEthereal( altGKInfo_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_0.ett_h225_AdmissionReject_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_0.ett_h225_AdmissionReject_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_callSignalAddress ) ) {
    proto_tree *callSignalAddress_tree = (proto_tree*) NULL;
    proto_item *callSignalAddress_ti = (proto_item*) NULL;
    callSignalAddress_ti = proto_tree_add_text( tree, tvb, offset + m_callSignalAddress.GetStartByte(), m_callSignalAddress.GetByteLength(), "callSignalAddress (TransportAddress)" );
    callSignalAddress_tree = proto_item_add_subtree( callSignalAddress_ti, hCont->h225_0.ett_h225_AdmissionReject_callSignalAddress );
    m_callSignalAddress.showEthereal( callSignalAddress_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_0.ett_h225_AdmissionReject_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// BandwidthRequest
//

H225_BandwidthRequest::H225_BandwidthRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 7)
{
  IncludeOptionalField(e_callIdentifier);
  IncludeOptionalField(e_answeredCall);
}


#ifndef PASN_NOPRINTON
void H225_BandwidthRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+21) << "endpointIdentifier = " << setprecision(indent) << m_endpointIdentifier << '\n';
  strm << setw(indent+15) << "conferenceID = " << setprecision(indent) << m_conferenceID << '\n';
  strm << setw(indent+21) << "callReferenceValue = " << setprecision(indent) << m_callReferenceValue << '\n';
  if (HasOptionalField(e_callType))
    strm << setw(indent+11) << "callType = " << setprecision(indent) << m_callType << '\n';
  strm << setw(indent+12) << "bandWidth = " << setprecision(indent) << m_bandWidth << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_answeredCall))
    strm << setw(indent+15) << "answeredCall = " << setprecision(indent) << m_answeredCall << '\n';
  if (HasOptionalField(e_callLinkage))
    strm << setw(indent+14) << "callLinkage = " << setprecision(indent) << m_callLinkage << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_BandwidthRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_BandwidthRequest::Class()), PInvalidCast);
#endif
  const H225_BandwidthRequest & other = (const H225_BandwidthRequest &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_endpointIdentifier.Compare(other.m_endpointIdentifier)) != EqualTo)
    return result;
  if ((result = m_conferenceID.Compare(other.m_conferenceID)) != EqualTo)
    return result;
  if ((result = m_callReferenceValue.Compare(other.m_callReferenceValue)) != EqualTo)
    return result;
  if ((result = m_callType.Compare(other.m_callType)) != EqualTo)
    return result;
  if ((result = m_bandWidth.Compare(other.m_bandWidth)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_BandwidthRequest::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_endpointIdentifier.GetObjectLength() +
         m_conferenceID.GetObjectLength() +
         m_callReferenceValue.GetObjectLength() +
         m_callType.GetObjectLength() +
         m_bandWidth.GetObjectLength() +
         m_nonStandardData.GetObjectLength();
}


BOOL H225_BandwidthRequest::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_endpointIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_conferenceID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callReferenceValue.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_callType ) && !m_callType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bandWidth.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_callIdentifier, m_callIdentifier ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_gatekeeperIdentifier, m_gatekeeperIdentifier ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_answeredCall, m_answeredCall ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_callLinkage, m_callLinkage ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_BandwidthRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_endpointIdentifier.Encode(strm);
  m_conferenceID.Encode(strm);
  m_callReferenceValue.Encode(strm);
  if (HasOptionalField(e_callType))
    m_callType.Encode(strm);
  m_bandWidth.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_gatekeeperIdentifier, m_gatekeeperIdentifier);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_answeredCall, m_answeredCall);
  KnownExtensionEncode(strm, e_callLinkage, m_callLinkage);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  m_endpointIdentifier.Encode(strm);
  m_conferenceID.Encode(strm);
  m_callReferenceValue.Encode(strm);
  if (HasOptionalField(e_callType))
    m_callType.Encode(strm);
  m_bandWidth.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_BandwidthRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_BandwidthRequest::Class()), PInvalidCast);
#endif
  return new H225_BandwidthRequest(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_BandwidthRequest::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  m_endpointIdentifier.preShowEthereal( );
  m_conferenceID.preShowEthereal( );
  m_callReferenceValue.preShowEthereal( );
  if ( HasOptionalField( e_callType ) ) 
      m_callType.preShowEthereal( );
  m_bandWidth.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_callIdentifier ) ) 
      m_callIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_gatekeeperIdentifier ) ) 
      m_gatekeeperIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
  if ( HasOptionalField( e_answeredCall ) ) 
      m_answeredCall.preShowEthereal( );
  if ( HasOptionalField( e_callLinkage ) ) 
      m_callLinkage.preShowEthereal( );
}

PString H225_BandwidthRequest::getSummary( void ) 
{
  return PString( "BandwidthRequest" );
}

void H225_BandwidthRequest::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_0.hf_h225_BandwidthRequest_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  char* pendpointIdentifier = m_endpointIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h225_0.hf_h225_BandwidthRequest_endpointIdentifier, tvb, offset + m_endpointIdentifier.GetStartByte(), m_endpointIdentifier.GetByteLength() , pendpointIdentifier );
  delete[] pendpointIdentifier;

  char* pconferenceID = m_conferenceID.getValue();
  proto_tree_add_string( tree, hCont->h225_0.hf_h225_BandwidthRequest_conferenceID, tvb, offset + m_conferenceID.GetStartByte(), m_conferenceID.GetByteLength() , pconferenceID );
  delete[] pconferenceID;

  proto_tree_add_uint( tree, hCont->h225_0.hf_h225_BandwidthRequest_callReferenceValue, tvb, offset + m_callReferenceValue.GetStartByte(), m_callReferenceValue.GetByteLength() , m_callReferenceValue.GetValue() );

  if ( HasOptionalField( e_callType ) ) {
    proto_tree *callType_tree = (proto_tree*) NULL;
    proto_item *callType_ti = (proto_item*) NULL;
    callType_ti = proto_tree_add_text( tree, tvb, offset + m_callType.GetStartByte(), m_callType.GetByteLength(), "callType (%s)", ( const char* ) m_callType.GetTagName() );
    callType_tree = proto_item_add_subtree( callType_ti, hCont->h225_0.ett_h225_BandwidthRequest_callType );
    m_callType.showEthereal( callType_tree, tvb, offset );
  }

  proto_tree_add_uint( tree, hCont->h225_0.hf_h225_BandwidthRequest_bandWidth, tvb, offset + m_bandWidth.GetStartByte(), m_bandWidth.GetByteLength() , m_bandWidth.GetValue() );

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_0.ett_h225_BandwidthRequest_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_callIdentifier ) ) {
    proto_tree *callIdentifier_tree = (proto_tree*) NULL;
    proto_item *callIdentifier_ti = (proto_item*) NULL;
    callIdentifier_ti = proto_tree_add_text( tree, tvb, offset + m_callIdentifier.GetStartByte(), m_callIdentifier.GetByteLength(), "callIdentifier (CallIdentifier)" );
    callIdentifier_tree = proto_item_add_subtree( callIdentifier_ti, hCont->h225_0.ett_h225_BandwidthRequest_callIdentifier );
    m_callIdentifier.showEthereal( callIdentifier_tree, tvb, offset );
  }

  if ( HasOptionalField( e_gatekeeperIdentifier ) ) {
    char* pgatekeeperIdentifier = m_gatekeeperIdentifier.getValue();
    proto_tree_add_string( tree, hCont->h225_0.hf_h225_BandwidthRequest_gatekeeperIdentifier, tvb, offset + m_gatekeeperIdentifier.GetStartByte(), m_gatekeeperIdentifier.GetByteLength() , pgatekeeperIdentifier );
    delete[] pgatekeeperIdentifier;
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_0.ett_h225_BandwidthRequest_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_0.ett_h225_BandwidthRequest_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_0.ett_h225_BandwidthRequest_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

  if ( HasOptionalField( e_answeredCall ) ) {
    proto_tree_add_boolean( tree, hCont->h225_0.hf_h225_BandwidthRequest_answeredCall, tvb, offset + m_answeredCall.GetStartByte(), m_answeredCall.GetByteLength() , m_answeredCall.GetValue() );
  }

  if ( HasOptionalField( e_callLinkage ) ) {
    proto_tree *callLinkage_tree = (proto_tree*) NULL;
    proto_item *callLinkage_ti = (proto_item*) NULL;
    callLinkage_ti = proto_tree_add_text( tree, tvb, offset + m_callLinkage.GetStartByte(), m_callLinkage.GetByteLength(), "callLinkage (CallLinkage)" );
    callLinkage_tree = proto_item_add_subtree( callLinkage_ti, hCont->h225_0.ett_h225_BandwidthRequest_callLinkage );
    m_callLinkage.showEthereal( callLinkage_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// BandwidthConfirm
//

H225_BandwidthConfirm::H225_BandwidthConfirm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 3)
{
}


#ifndef PASN_NOPRINTON
void H225_BandwidthConfirm::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+12) << "bandWidth = " << setprecision(indent) << m_bandWidth << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_BandwidthConfirm::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_BandwidthConfirm::Class()), PInvalidCast);
#endif
  const H225_BandwidthConfirm & other = (const H225_BandwidthConfirm &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_bandWidth.Compare(other.m_bandWidth)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_BandwidthConfirm::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_bandWidth.GetObjectLength() +
         m_nonStandardData.GetObjectLength();
}


BOOL H225_BandwidthConfirm::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bandWidth.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_BandwidthConfirm::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_bandWidth.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  m_bandWidth.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_BandwidthConfirm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_BandwidthConfirm::Class()), PInvalidCast);
#endif
  return new H225_BandwidthConfirm(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_BandwidthConfirm::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  m_bandWidth.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
}

PString H225_BandwidthConfirm::getSummary( void ) 
{
  return PString( "BandwidthConfirm" );
}

void H225_BandwidthConfirm::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_0.hf_h225_BandwidthConfirm_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_BandwidthConfirm_bandWidth, tvb, offset + m_bandWidth.GetStartByte(), m_bandWidth.GetByteLength() , m_bandWidth.GetValue() );

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_BandwidthConfirm_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_BandwidthConfirm_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_BandwidthConfirm_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_1.ett_h225_BandwidthConfirm_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// BandwidthReject
//

H225_BandwidthReject::H225_BandwidthReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 4)
{
}


#ifndef PASN_NOPRINTON
void H225_BandwidthReject::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+15) << "rejectReason = " << setprecision(indent) << m_rejectReason << '\n';
  strm << setw(indent+19) << "allowedBandWidth = " << setprecision(indent) << m_allowedBandWidth << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_altGKInfo))
    strm << setw(indent+12) << "altGKInfo = " << setprecision(indent) << m_altGKInfo << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_BandwidthReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_BandwidthReject::Class()), PInvalidCast);
#endif
  const H225_BandwidthReject & other = (const H225_BandwidthReject &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_rejectReason.Compare(other.m_rejectReason)) != EqualTo)
    return result;
  if ((result = m_allowedBandWidth.Compare(other.m_allowedBandWidth)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_BandwidthReject::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_rejectReason.GetObjectLength() +
         m_allowedBandWidth.GetObjectLength() +
         m_nonStandardData.GetObjectLength();
}


BOOL H225_BandwidthReject::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_rejectReason.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_allowedBandWidth.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_altGKInfo, m_altGKInfo ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_BandwidthReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_rejectReason.Encode(strm);
  m_allowedBandWidth.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_altGKInfo, m_altGKInfo);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  m_rejectReason.Encode(strm);
  m_allowedBandWidth.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_BandwidthReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_BandwidthReject::Class()), PInvalidCast);
#endif
  return new H225_BandwidthReject(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_BandwidthReject::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  m_rejectReason.preShowEthereal( );
  m_allowedBandWidth.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_altGKInfo ) ) 
      m_altGKInfo.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
}

PString H225_BandwidthReject::getSummary( void ) 
{
  return PString( "BandwidthReject" );
}

void H225_BandwidthReject::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_BandwidthReject_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  proto_tree *rejectReason_tree = (proto_tree*) NULL;
  proto_item *rejectReason_ti = (proto_item*) NULL;
  rejectReason_ti = proto_tree_add_text( tree, tvb, offset + m_rejectReason.GetStartByte(), m_rejectReason.GetByteLength(), "rejectReason (%s)", ( const char* ) m_rejectReason.GetTagName() );
  rejectReason_tree = proto_item_add_subtree( rejectReason_ti, hCont->h225_1.ett_h225_BandwidthReject_rejectReason );

  m_rejectReason.showEthereal( rejectReason_tree, tvb, offset );

  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_BandwidthReject_allowedBandWidth, tvb, offset + m_allowedBandWidth.GetStartByte(), m_allowedBandWidth.GetByteLength() , m_allowedBandWidth.GetValue() );

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_BandwidthReject_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_altGKInfo ) ) {
    proto_tree *altGKInfo_tree = (proto_tree*) NULL;
    proto_item *altGKInfo_ti = (proto_item*) NULL;
    altGKInfo_ti = proto_tree_add_text( tree, tvb, offset + m_altGKInfo.GetStartByte(), m_altGKInfo.GetByteLength(), "altGKInfo (AltGKInfo)" );
    altGKInfo_tree = proto_item_add_subtree( altGKInfo_ti, hCont->h225_1.ett_h225_BandwidthReject_altGKInfo );
    m_altGKInfo.showEthereal( altGKInfo_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_BandwidthReject_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_BandwidthReject_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_1.ett_h225_BandwidthReject_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// LocationRequest
//

H225_LocationRequest::H225_LocationRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 6)
{
  IncludeOptionalField(e_canMapAlias);
}


#ifndef PASN_NOPRINTON
void H225_LocationRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  if (HasOptionalField(e_endpointIdentifier))
    strm << setw(indent+21) << "endpointIdentifier = " << setprecision(indent) << m_endpointIdentifier << '\n';
  strm << setw(indent+18) << "destinationInfo = " << setprecision(indent) << m_destinationInfo << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+15) << "replyAddress = " << setprecision(indent) << m_replyAddress << '\n';
  if (HasOptionalField(e_sourceInfo))
    strm << setw(indent+13) << "sourceInfo = " << setprecision(indent) << m_sourceInfo << '\n';
  if (HasOptionalField(e_canMapAlias))
    strm << setw(indent+14) << "canMapAlias = " << setprecision(indent) << m_canMapAlias << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_LocationRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_LocationRequest::Class()), PInvalidCast);
#endif
  const H225_LocationRequest & other = (const H225_LocationRequest &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_endpointIdentifier.Compare(other.m_endpointIdentifier)) != EqualTo)
    return result;
  if ((result = m_destinationInfo.Compare(other.m_destinationInfo)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_replyAddress.Compare(other.m_replyAddress)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_LocationRequest::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_endpointIdentifier.GetObjectLength() +
         m_destinationInfo.GetObjectLength() +
         m_nonStandardData.GetObjectLength() +
         m_replyAddress.GetObjectLength();
}


BOOL H225_LocationRequest::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_endpointIdentifier ) && !m_endpointIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_destinationInfo.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_replyAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_sourceInfo, m_sourceInfo ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_canMapAlias, m_canMapAlias ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_gatekeeperIdentifier, m_gatekeeperIdentifier ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_LocationRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  if (HasOptionalField(e_endpointIdentifier))
    m_endpointIdentifier.Encode(strm);
  m_destinationInfo.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_replyAddress.Encode(strm);
  KnownExtensionEncode(strm, e_sourceInfo, m_sourceInfo);
  KnownExtensionEncode(strm, e_canMapAlias, m_canMapAlias);
  KnownExtensionEncode(strm, e_gatekeeperIdentifier, m_gatekeeperIdentifier);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  if (HasOptionalField(e_endpointIdentifier))
    m_endpointIdentifier.Encode(strm);
  m_destinationInfo.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_replyAddress.Encode(strm);
}


PObject * H225_LocationRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_LocationRequest::Class()), PInvalidCast);
#endif
  return new H225_LocationRequest(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_LocationRequest::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  if ( HasOptionalField( e_endpointIdentifier ) ) 
      m_endpointIdentifier.preShowEthereal( );
  m_destinationInfo.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  m_replyAddress.preShowEthereal( );
  if ( HasOptionalField( e_sourceInfo ) ) 
      m_sourceInfo.preShowEthereal( );
  if ( HasOptionalField( e_canMapAlias ) ) 
      m_canMapAlias.preShowEthereal( );
  if ( HasOptionalField( e_gatekeeperIdentifier ) ) 
      m_gatekeeperIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
}

PString H225_LocationRequest::getSummary( void ) 
{
  return PString( "LocationRequest" );
}

void H225_LocationRequest::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_LocationRequest_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  if ( HasOptionalField( e_endpointIdentifier ) ) {
    char* pendpointIdentifier = m_endpointIdentifier.getValue();
    proto_tree_add_string( tree, hCont->h225_1.hf_h225_LocationRequest_endpointIdentifier, tvb, offset + m_endpointIdentifier.GetStartByte(), m_endpointIdentifier.GetByteLength() , pendpointIdentifier );
    delete[] pendpointIdentifier;
  }

  proto_tree *destinationInfo_tree = (proto_tree*) NULL;
  proto_item *destinationInfo_ti = (proto_item*) NULL;
  destinationInfo_ti = proto_tree_add_text( tree, tvb, offset + m_destinationInfo.GetStartByte(), m_destinationInfo.GetByteLength(), "destinationInfo (AliasAddress)" );
  destinationInfo_tree = proto_item_add_subtree( destinationInfo_ti, hCont->h225_1.ett_h225_LocationRequest_destinationInfo );

  m_destinationInfo.showEthereal( destinationInfo_tree, tvb, offset );

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_LocationRequest_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  proto_tree *replyAddress_tree = (proto_tree*) NULL;
  proto_item *replyAddress_ti = (proto_item*) NULL;
  replyAddress_ti = proto_tree_add_text( tree, tvb, offset + m_replyAddress.GetStartByte(), m_replyAddress.GetByteLength(), "replyAddress (%s)", ( const char* ) m_replyAddress.GetTagName() );
  replyAddress_tree = proto_item_add_subtree( replyAddress_ti, hCont->h225_1.ett_h225_LocationRequest_replyAddress );

  m_replyAddress.showEthereal( replyAddress_tree, tvb, offset );

  if ( HasOptionalField( e_sourceInfo ) ) {
    proto_tree *sourceInfo_tree = (proto_tree*) NULL;
    proto_item *sourceInfo_ti = (proto_item*) NULL;
    sourceInfo_ti = proto_tree_add_text( tree, tvb, offset + m_sourceInfo.GetStartByte(), m_sourceInfo.GetByteLength(), "sourceInfo (AliasAddress)" );
    sourceInfo_tree = proto_item_add_subtree( sourceInfo_ti, hCont->h225_1.ett_h225_LocationRequest_sourceInfo );
    m_sourceInfo.showEthereal( sourceInfo_tree, tvb, offset );
  }

  if ( HasOptionalField( e_canMapAlias ) ) {
    proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_LocationRequest_canMapAlias, tvb, offset + m_canMapAlias.GetStartByte(), m_canMapAlias.GetByteLength() , m_canMapAlias.GetValue() );
  }

  if ( HasOptionalField( e_gatekeeperIdentifier ) ) {
    char* pgatekeeperIdentifier = m_gatekeeperIdentifier.getValue();
    proto_tree_add_string( tree, hCont->h225_1.hf_h225_LocationRequest_gatekeeperIdentifier, tvb, offset + m_gatekeeperIdentifier.GetStartByte(), m_gatekeeperIdentifier.GetByteLength() , pgatekeeperIdentifier );
    delete[] pgatekeeperIdentifier;
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_LocationRequest_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_LocationRequest_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_1.ett_h225_LocationRequest_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// LocationReject
//

H225_LocationReject::H225_LocationReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 4)
{
}


#ifndef PASN_NOPRINTON
void H225_LocationReject::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+15) << "rejectReason = " << setprecision(indent) << m_rejectReason << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_altGKInfo))
    strm << setw(indent+12) << "altGKInfo = " << setprecision(indent) << m_altGKInfo << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_LocationReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_LocationReject::Class()), PInvalidCast);
#endif
  const H225_LocationReject & other = (const H225_LocationReject &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_rejectReason.Compare(other.m_rejectReason)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_LocationReject::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_rejectReason.GetObjectLength() +
         m_nonStandardData.GetObjectLength();
}


BOOL H225_LocationReject::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_rejectReason.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_altGKInfo, m_altGKInfo ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_LocationReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_rejectReason.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_altGKInfo, m_altGKInfo);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  m_rejectReason.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_LocationReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_LocationReject::Class()), PInvalidCast);
#endif
  return new H225_LocationReject(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_LocationReject::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  m_rejectReason.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_altGKInfo ) ) 
      m_altGKInfo.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
}

PString H225_LocationReject::getSummary( void ) 
{
  return PString( "LocationReject" );
}

void H225_LocationReject::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_LocationReject_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  proto_tree *rejectReason_tree = (proto_tree*) NULL;
  proto_item *rejectReason_ti = (proto_item*) NULL;
  rejectReason_ti = proto_tree_add_text( tree, tvb, offset + m_rejectReason.GetStartByte(), m_rejectReason.GetByteLength(), "rejectReason (%s)", ( const char* ) m_rejectReason.GetTagName() );
  rejectReason_tree = proto_item_add_subtree( rejectReason_ti, hCont->h225_1.ett_h225_LocationReject_rejectReason );

  m_rejectReason.showEthereal( rejectReason_tree, tvb, offset );

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_LocationReject_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_altGKInfo ) ) {
    proto_tree *altGKInfo_tree = (proto_tree*) NULL;
    proto_item *altGKInfo_ti = (proto_item*) NULL;
    altGKInfo_ti = proto_tree_add_text( tree, tvb, offset + m_altGKInfo.GetStartByte(), m_altGKInfo.GetByteLength(), "altGKInfo (AltGKInfo)" );
    altGKInfo_tree = proto_item_add_subtree( altGKInfo_ti, hCont->h225_1.ett_h225_LocationReject_altGKInfo );
    m_altGKInfo.showEthereal( altGKInfo_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_LocationReject_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_LocationReject_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_1.ett_h225_LocationReject_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// DisengageRequest
//

H225_DisengageRequest::H225_DisengageRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 7)
{
  IncludeOptionalField(e_callIdentifier);
  IncludeOptionalField(e_answeredCall);
}


#ifndef PASN_NOPRINTON
void H225_DisengageRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+21) << "endpointIdentifier = " << setprecision(indent) << m_endpointIdentifier << '\n';
  strm << setw(indent+15) << "conferenceID = " << setprecision(indent) << m_conferenceID << '\n';
  strm << setw(indent+21) << "callReferenceValue = " << setprecision(indent) << m_callReferenceValue << '\n';
  strm << setw(indent+18) << "disengageReason = " << setprecision(indent) << m_disengageReason << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_answeredCall))
    strm << setw(indent+15) << "answeredCall = " << setprecision(indent) << m_answeredCall << '\n';
  if (HasOptionalField(e_callLinkage))
    strm << setw(indent+14) << "callLinkage = " << setprecision(indent) << m_callLinkage << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_DisengageRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_DisengageRequest::Class()), PInvalidCast);
#endif
  const H225_DisengageRequest & other = (const H225_DisengageRequest &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_endpointIdentifier.Compare(other.m_endpointIdentifier)) != EqualTo)
    return result;
  if ((result = m_conferenceID.Compare(other.m_conferenceID)) != EqualTo)
    return result;
  if ((result = m_callReferenceValue.Compare(other.m_callReferenceValue)) != EqualTo)
    return result;
  if ((result = m_disengageReason.Compare(other.m_disengageReason)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_DisengageRequest::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_endpointIdentifier.GetObjectLength() +
         m_conferenceID.GetObjectLength() +
         m_callReferenceValue.GetObjectLength() +
         m_disengageReason.GetObjectLength() +
         m_nonStandardData.GetObjectLength();
}


BOOL H225_DisengageRequest::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_endpointIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_conferenceID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callReferenceValue.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_disengageReason.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_callIdentifier, m_callIdentifier ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_gatekeeperIdentifier, m_gatekeeperIdentifier ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_answeredCall, m_answeredCall ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_callLinkage, m_callLinkage ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_DisengageRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_endpointIdentifier.Encode(strm);
  m_conferenceID.Encode(strm);
  m_callReferenceValue.Encode(strm);
  m_disengageReason.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_gatekeeperIdentifier, m_gatekeeperIdentifier);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_answeredCall, m_answeredCall);
  KnownExtensionEncode(strm, e_callLinkage, m_callLinkage);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  m_endpointIdentifier.Encode(strm);
  m_conferenceID.Encode(strm);
  m_callReferenceValue.Encode(strm);
  m_disengageReason.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_DisengageRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_DisengageRequest::Class()), PInvalidCast);
#endif
  return new H225_DisengageRequest(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_DisengageRequest::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  m_endpointIdentifier.preShowEthereal( );
  m_conferenceID.preShowEthereal( );
  m_callReferenceValue.preShowEthereal( );
  m_disengageReason.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_callIdentifier ) ) 
      m_callIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_gatekeeperIdentifier ) ) 
      m_gatekeeperIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
  if ( HasOptionalField( e_answeredCall ) ) 
      m_answeredCall.preShowEthereal( );
  if ( HasOptionalField( e_callLinkage ) ) 
      m_callLinkage.preShowEthereal( );
}

PString H225_DisengageRequest::getSummary( void ) 
{
  return PString( "DisengageRequest" );
}

void H225_DisengageRequest::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_DisengageRequest_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  char* pendpointIdentifier = m_endpointIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h225_1.hf_h225_DisengageRequest_endpointIdentifier, tvb, offset + m_endpointIdentifier.GetStartByte(), m_endpointIdentifier.GetByteLength() , pendpointIdentifier );
  delete[] pendpointIdentifier;

  char* pconferenceID = m_conferenceID.getValue();
  proto_tree_add_string( tree, hCont->h225_1.hf_h225_DisengageRequest_conferenceID, tvb, offset + m_conferenceID.GetStartByte(), m_conferenceID.GetByteLength() , pconferenceID );
  delete[] pconferenceID;

  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_DisengageRequest_callReferenceValue, tvb, offset + m_callReferenceValue.GetStartByte(), m_callReferenceValue.GetByteLength() , m_callReferenceValue.GetValue() );

  proto_tree *disengageReason_tree = (proto_tree*) NULL;
  proto_item *disengageReason_ti = (proto_item*) NULL;
  disengageReason_ti = proto_tree_add_text( tree, tvb, offset + m_disengageReason.GetStartByte(), m_disengageReason.GetByteLength(), "disengageReason (%s)", ( const char* ) m_disengageReason.GetTagName() );
  disengageReason_tree = proto_item_add_subtree( disengageReason_ti, hCont->h225_1.ett_h225_DisengageRequest_disengageReason );

  m_disengageReason.showEthereal( disengageReason_tree, tvb, offset );

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_DisengageRequest_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_callIdentifier ) ) {
    proto_tree *callIdentifier_tree = (proto_tree*) NULL;
    proto_item *callIdentifier_ti = (proto_item*) NULL;
    callIdentifier_ti = proto_tree_add_text( tree, tvb, offset + m_callIdentifier.GetStartByte(), m_callIdentifier.GetByteLength(), "callIdentifier (CallIdentifier)" );
    callIdentifier_tree = proto_item_add_subtree( callIdentifier_ti, hCont->h225_1.ett_h225_DisengageRequest_callIdentifier );
    m_callIdentifier.showEthereal( callIdentifier_tree, tvb, offset );
  }

  if ( HasOptionalField( e_gatekeeperIdentifier ) ) {
    char* pgatekeeperIdentifier = m_gatekeeperIdentifier.getValue();
    proto_tree_add_string( tree, hCont->h225_1.hf_h225_DisengageRequest_gatekeeperIdentifier, tvb, offset + m_gatekeeperIdentifier.GetStartByte(), m_gatekeeperIdentifier.GetByteLength() , pgatekeeperIdentifier );
    delete[] pgatekeeperIdentifier;
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_DisengageRequest_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_DisengageRequest_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_1.ett_h225_DisengageRequest_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

  if ( HasOptionalField( e_answeredCall ) ) {
    proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_DisengageRequest_answeredCall, tvb, offset + m_answeredCall.GetStartByte(), m_answeredCall.GetByteLength() , m_answeredCall.GetValue() );
  }

  if ( HasOptionalField( e_callLinkage ) ) {
    proto_tree *callLinkage_tree = (proto_tree*) NULL;
    proto_item *callLinkage_ti = (proto_item*) NULL;
    callLinkage_ti = proto_tree_add_text( tree, tvb, offset + m_callLinkage.GetStartByte(), m_callLinkage.GetByteLength(), "callLinkage (CallLinkage)" );
    callLinkage_tree = proto_item_add_subtree( callLinkage_ti, hCont->h225_1.ett_h225_DisengageRequest_callLinkage );
    m_callLinkage.showEthereal( callLinkage_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// DisengageConfirm
//

H225_DisengageConfirm::H225_DisengageConfirm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 3)
{
}


#ifndef PASN_NOPRINTON
void H225_DisengageConfirm::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_DisengageConfirm::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_DisengageConfirm::Class()), PInvalidCast);
#endif
  const H225_DisengageConfirm & other = (const H225_DisengageConfirm &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_DisengageConfirm::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_nonStandardData.GetObjectLength();
}


BOOL H225_DisengageConfirm::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_DisengageConfirm::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_DisengageConfirm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_DisengageConfirm::Class()), PInvalidCast);
#endif
  return new H225_DisengageConfirm(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_DisengageConfirm::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
}

PString H225_DisengageConfirm::getSummary( void ) 
{
  return PString( "DisengageConfirm" );
}

void H225_DisengageConfirm::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_DisengageConfirm_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_DisengageConfirm_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_DisengageConfirm_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_DisengageConfirm_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_1.ett_h225_DisengageConfirm_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// DisengageReject
//

H225_DisengageReject::H225_DisengageReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 4)
{
}


#ifndef PASN_NOPRINTON
void H225_DisengageReject::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+15) << "rejectReason = " << setprecision(indent) << m_rejectReason << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_altGKInfo))
    strm << setw(indent+12) << "altGKInfo = " << setprecision(indent) << m_altGKInfo << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_DisengageReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_DisengageReject::Class()), PInvalidCast);
#endif
  const H225_DisengageReject & other = (const H225_DisengageReject &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_rejectReason.Compare(other.m_rejectReason)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_DisengageReject::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_rejectReason.GetObjectLength() +
         m_nonStandardData.GetObjectLength();
}


BOOL H225_DisengageReject::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_rejectReason.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_altGKInfo, m_altGKInfo ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_DisengageReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_rejectReason.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_altGKInfo, m_altGKInfo);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  m_rejectReason.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_DisengageReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_DisengageReject::Class()), PInvalidCast);
#endif
  return new H225_DisengageReject(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_DisengageReject::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  m_rejectReason.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_altGKInfo ) ) 
      m_altGKInfo.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
}

PString H225_DisengageReject::getSummary( void ) 
{
  return PString( "DisengageReject" );
}

void H225_DisengageReject::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_DisengageReject_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  proto_tree *rejectReason_tree = (proto_tree*) NULL;
  proto_item *rejectReason_ti = (proto_item*) NULL;
  rejectReason_ti = proto_tree_add_text( tree, tvb, offset + m_rejectReason.GetStartByte(), m_rejectReason.GetByteLength(), "rejectReason (%s)", ( const char* ) m_rejectReason.GetTagName() );
  rejectReason_tree = proto_item_add_subtree( rejectReason_ti, hCont->h225_1.ett_h225_DisengageReject_rejectReason );

  m_rejectReason.showEthereal( rejectReason_tree, tvb, offset );

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_DisengageReject_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_altGKInfo ) ) {
    proto_tree *altGKInfo_tree = (proto_tree*) NULL;
    proto_item *altGKInfo_ti = (proto_item*) NULL;
    altGKInfo_ti = proto_tree_add_text( tree, tvb, offset + m_altGKInfo.GetStartByte(), m_altGKInfo.GetByteLength(), "altGKInfo (AltGKInfo)" );
    altGKInfo_tree = proto_item_add_subtree( altGKInfo_ti, hCont->h225_1.ett_h225_DisengageReject_altGKInfo );
    m_altGKInfo.showEthereal( altGKInfo_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_DisengageReject_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_DisengageReject_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_1.ett_h225_DisengageReject_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// InfoRequest
//

H225_InfoRequest::H225_InfoRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 6)
{
  IncludeOptionalField(e_callIdentifier);
}


#ifndef PASN_NOPRINTON
void H225_InfoRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+21) << "callReferenceValue = " << setprecision(indent) << m_callReferenceValue << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_replyAddress))
    strm << setw(indent+15) << "replyAddress = " << setprecision(indent) << m_replyAddress << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_uuiesRequested))
    strm << setw(indent+17) << "uuiesRequested = " << setprecision(indent) << m_uuiesRequested << '\n';
  if (HasOptionalField(e_callLinkage))
    strm << setw(indent+14) << "callLinkage = " << setprecision(indent) << m_callLinkage << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_InfoRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_InfoRequest::Class()), PInvalidCast);
#endif
  const H225_InfoRequest & other = (const H225_InfoRequest &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_callReferenceValue.Compare(other.m_callReferenceValue)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_replyAddress.Compare(other.m_replyAddress)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_InfoRequest::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_callReferenceValue.GetObjectLength() +
         m_nonStandardData.GetObjectLength() +
         m_replyAddress.GetObjectLength();
}


BOOL H225_InfoRequest::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callReferenceValue.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_replyAddress ) && !m_replyAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_callIdentifier, m_callIdentifier ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_uuiesRequested, m_uuiesRequested ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_callLinkage, m_callLinkage ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_InfoRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_callReferenceValue.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_replyAddress))
    m_replyAddress.Encode(strm);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_uuiesRequested, m_uuiesRequested);
  KnownExtensionEncode(strm, e_callLinkage, m_callLinkage);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  m_callReferenceValue.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_replyAddress))
    m_replyAddress.Encode(strm);
}


PObject * H225_InfoRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_InfoRequest::Class()), PInvalidCast);
#endif
  return new H225_InfoRequest(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_InfoRequest::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  m_callReferenceValue.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_replyAddress ) ) 
      m_replyAddress.preShowEthereal( );
  if ( HasOptionalField( e_callIdentifier ) ) 
      m_callIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
  if ( HasOptionalField( e_uuiesRequested ) ) 
      m_uuiesRequested.preShowEthereal( );
  if ( HasOptionalField( e_callLinkage ) ) 
      m_callLinkage.preShowEthereal( );
}

PString H225_InfoRequest::getSummary( void ) 
{
  return PString( "InfoRequest" );
}

void H225_InfoRequest::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_InfoRequest_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_InfoRequest_callReferenceValue, tvb, offset + m_callReferenceValue.GetStartByte(), m_callReferenceValue.GetByteLength() , m_callReferenceValue.GetValue() );

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_InfoRequest_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_replyAddress ) ) {
    proto_tree *replyAddress_tree = (proto_tree*) NULL;
    proto_item *replyAddress_ti = (proto_item*) NULL;
    replyAddress_ti = proto_tree_add_text( tree, tvb, offset + m_replyAddress.GetStartByte(), m_replyAddress.GetByteLength(), "replyAddress (%s)", ( const char* ) m_replyAddress.GetTagName() );
    replyAddress_tree = proto_item_add_subtree( replyAddress_ti, hCont->h225_1.ett_h225_InfoRequest_replyAddress );
    m_replyAddress.showEthereal( replyAddress_tree, tvb, offset );
  }

  if ( HasOptionalField( e_callIdentifier ) ) {
    proto_tree *callIdentifier_tree = (proto_tree*) NULL;
    proto_item *callIdentifier_ti = (proto_item*) NULL;
    callIdentifier_ti = proto_tree_add_text( tree, tvb, offset + m_callIdentifier.GetStartByte(), m_callIdentifier.GetByteLength(), "callIdentifier (CallIdentifier)" );
    callIdentifier_tree = proto_item_add_subtree( callIdentifier_ti, hCont->h225_1.ett_h225_InfoRequest_callIdentifier );
    m_callIdentifier.showEthereal( callIdentifier_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_InfoRequest_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_InfoRequest_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_1.ett_h225_InfoRequest_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

  if ( HasOptionalField( e_uuiesRequested ) ) {
    proto_tree *uuiesRequested_tree = (proto_tree*) NULL;
    proto_item *uuiesRequested_ti = (proto_item*) NULL;
    uuiesRequested_ti = proto_tree_add_text( tree, tvb, offset + m_uuiesRequested.GetStartByte(), m_uuiesRequested.GetByteLength(), "uuiesRequested (UUIEsRequested)" );
    uuiesRequested_tree = proto_item_add_subtree( uuiesRequested_ti, hCont->h225_1.ett_h225_InfoRequest_uuiesRequested );
    m_uuiesRequested.showEthereal( uuiesRequested_tree, tvb, offset );
  }

  if ( HasOptionalField( e_callLinkage ) ) {
    proto_tree *callLinkage_tree = (proto_tree*) NULL;
    proto_item *callLinkage_ti = (proto_item*) NULL;
    callLinkage_ti = proto_tree_add_text( tree, tvb, offset + m_callLinkage.GetStartByte(), m_callLinkage.GetByteLength(), "callLinkage (CallLinkage)" );
    callLinkage_tree = proto_item_add_subtree( callLinkage_ti, hCont->h225_1.ett_h225_InfoRequest_callLinkage );
    m_callLinkage.showEthereal( callLinkage_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// RTPSession
//

H225_RTPSession::H225_RTPSession(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_ssrc.SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
  m_sessionId.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
}


#ifndef PASN_NOPRINTON
void H225_RTPSession::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "rtpAddress = " << setprecision(indent) << m_rtpAddress << '\n';
  strm << setw(indent+14) << "rtcpAddress = " << setprecision(indent) << m_rtcpAddress << '\n';
  strm << setw(indent+8) << "cname = " << setprecision(indent) << m_cname << '\n';
  strm << setw(indent+7) << "ssrc = " << setprecision(indent) << m_ssrc << '\n';
  strm << setw(indent+12) << "sessionId = " << setprecision(indent) << m_sessionId << '\n';
  strm << setw(indent+23) << "associatedSessionIds = " << setprecision(indent) << m_associatedSessionIds << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_RTPSession::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_RTPSession::Class()), PInvalidCast);
#endif
  const H225_RTPSession & other = (const H225_RTPSession &)obj;

  Comparison result;

  if ((result = m_rtpAddress.Compare(other.m_rtpAddress)) != EqualTo)
    return result;
  if ((result = m_rtcpAddress.Compare(other.m_rtcpAddress)) != EqualTo)
    return result;
  if ((result = m_cname.Compare(other.m_cname)) != EqualTo)
    return result;
  if ((result = m_ssrc.Compare(other.m_ssrc)) != EqualTo)
    return result;
  if ((result = m_sessionId.Compare(other.m_sessionId)) != EqualTo)
    return result;
  if ((result = m_associatedSessionIds.Compare(other.m_associatedSessionIds)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_RTPSession::GetDataLength() const
{
  return m_rtpAddress.GetObjectLength() +
         m_rtcpAddress.GetObjectLength() +
         m_cname.GetObjectLength() +
         m_ssrc.GetObjectLength() +
         m_sessionId.GetObjectLength() +
         m_associatedSessionIds.GetObjectLength();
}


BOOL H225_RTPSession::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_rtpAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_rtcpAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_cname.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_ssrc.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sessionId.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_associatedSessionIds.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_RTPSession::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_rtpAddress.Encode(strm);
  m_rtcpAddress.Encode(strm);
  m_cname.Encode(strm);
  m_ssrc.Encode(strm);
  m_sessionId.Encode(strm);
  m_associatedSessionIds.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_rtpAddress.Encode(strm);
  m_rtcpAddress.Encode(strm);
  m_cname.Encode(strm);
  m_ssrc.Encode(strm);
  m_sessionId.Encode(strm);
  m_associatedSessionIds.Encode(strm);
}


PObject * H225_RTPSession::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_RTPSession::Class()), PInvalidCast);
#endif
  return new H225_RTPSession(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_RTPSession::preShowEthereal( void )
{
  m_rtpAddress.preShowEthereal( );
  m_rtcpAddress.preShowEthereal( );
  m_cname.preShowEthereal( );
  m_ssrc.preShowEthereal( );
  m_sessionId.preShowEthereal( );
  m_associatedSessionIds.preShowEthereal( );
}

PString H225_RTPSession::getSummary( void ) 
{
  return PString( "RTPSession" );
}

void H225_RTPSession::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *rtpAddress_tree = (proto_tree*) NULL;
  proto_item *rtpAddress_ti = (proto_item*) NULL;
  rtpAddress_ti = proto_tree_add_text( tree, tvb, offset + m_rtpAddress.GetStartByte(), m_rtpAddress.GetByteLength(), "rtpAddress (TransportChannelInfo)" );
  rtpAddress_tree = proto_item_add_subtree( rtpAddress_ti, hCont->h225_1.ett_h225_RTPSession_rtpAddress );

  m_rtpAddress.showEthereal( rtpAddress_tree, tvb, offset );

  proto_tree *rtcpAddress_tree = (proto_tree*) NULL;
  proto_item *rtcpAddress_ti = (proto_item*) NULL;
  rtcpAddress_ti = proto_tree_add_text( tree, tvb, offset + m_rtcpAddress.GetStartByte(), m_rtcpAddress.GetByteLength(), "rtcpAddress (TransportChannelInfo)" );
  rtcpAddress_tree = proto_item_add_subtree( rtcpAddress_ti, hCont->h225_1.ett_h225_RTPSession_rtcpAddress );

  m_rtcpAddress.showEthereal( rtcpAddress_tree, tvb, offset );

  char* pcname = m_cname.getValue();
  proto_tree_add_string( tree, hCont->h225_1.hf_h225_RTPSession_cname, tvb, offset + m_cname.GetStartByte(), m_cname.GetByteLength() , pcname );
  delete[] pcname;

  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_RTPSession_ssrc, tvb, offset + m_ssrc.GetStartByte(), m_ssrc.GetByteLength() , m_ssrc.GetValue() );

  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_RTPSession_sessionId, tvb, offset + m_sessionId.GetStartByte(), m_sessionId.GetByteLength() , m_sessionId.GetValue() );

  proto_tree *associatedSessionIds_tree = (proto_tree*) NULL;
  proto_item *associatedSessionIds_ti = (proto_item*) NULL;
  associatedSessionIds_ti = proto_tree_add_text( tree, tvb, offset + m_associatedSessionIds.GetStartByte(), m_associatedSessionIds.GetByteLength(), "associatedSessionIds (RTPSession-associatedSessionIds)" );
  associatedSessionIds_tree = proto_item_add_subtree( associatedSessionIds_ti, hCont->h225_1.ett_h225_RTPSession_associatedSessionIds );

  m_associatedSessionIds.showEthereal( associatedSessionIds_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// InfoRequestAck
//

H225_InfoRequestAck::H225_InfoRequestAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 4, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_InfoRequestAck::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_InfoRequestAck::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_InfoRequestAck::Class()), PInvalidCast);
#endif
  const H225_InfoRequestAck & other = (const H225_InfoRequestAck &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;
  if ((result = m_integrityCheckValue.Compare(other.m_integrityCheckValue)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_InfoRequestAck::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_nonStandardData.GetObjectLength() +
         m_tokens.GetObjectLength() +
         m_cryptoTokens.GetObjectLength() +
         m_integrityCheckValue.GetObjectLength();
}


BOOL H225_InfoRequestAck::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_tokens ) && !m_tokens.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_cryptoTokens ) && !m_cryptoTokens.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_integrityCheckValue ) && !m_integrityCheckValue.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_InfoRequestAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_integrityCheckValue))
    m_integrityCheckValue.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_integrityCheckValue))
    m_integrityCheckValue.Encode(strm);
}


PObject * H225_InfoRequestAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_InfoRequestAck::Class()), PInvalidCast);
#endif
  return new H225_InfoRequestAck(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_InfoRequestAck::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
}

PString H225_InfoRequestAck::getSummary( void ) 
{
  return PString( "InfoRequestAck" );
}

void H225_InfoRequestAck::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_InfoRequestAck_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_InfoRequestAck_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_InfoRequestAck_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_InfoRequestAck_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_1.ett_h225_InfoRequestAck_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// InfoRequestNak
//

H225_InfoRequestNak::H225_InfoRequestNak(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 5, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_InfoRequestNak::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+12) << "nakReason = " << setprecision(indent) << m_nakReason << '\n';
  if (HasOptionalField(e_altGKInfo))
    strm << setw(indent+12) << "altGKInfo = " << setprecision(indent) << m_altGKInfo << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_InfoRequestNak::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_InfoRequestNak::Class()), PInvalidCast);
#endif
  const H225_InfoRequestNak & other = (const H225_InfoRequestNak &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_nakReason.Compare(other.m_nakReason)) != EqualTo)
    return result;
  if ((result = m_altGKInfo.Compare(other.m_altGKInfo)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;
  if ((result = m_integrityCheckValue.Compare(other.m_integrityCheckValue)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_InfoRequestNak::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_nonStandardData.GetObjectLength() +
         m_nakReason.GetObjectLength() +
         m_altGKInfo.GetObjectLength() +
         m_tokens.GetObjectLength() +
         m_cryptoTokens.GetObjectLength() +
         m_integrityCheckValue.GetObjectLength();
}


BOOL H225_InfoRequestNak::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_nakReason.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_altGKInfo ) && !m_altGKInfo.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_tokens ) && !m_tokens.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_cryptoTokens ) && !m_cryptoTokens.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_integrityCheckValue ) && !m_integrityCheckValue.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_InfoRequestNak::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_nakReason.Encode(strm);
  if (HasOptionalField(e_altGKInfo))
    m_altGKInfo.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_integrityCheckValue))
    m_integrityCheckValue.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_nakReason.Encode(strm);
  if (HasOptionalField(e_altGKInfo))
    m_altGKInfo.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_integrityCheckValue))
    m_integrityCheckValue.Encode(strm);
}


PObject * H225_InfoRequestNak::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_InfoRequestNak::Class()), PInvalidCast);
#endif
  return new H225_InfoRequestNak(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_InfoRequestNak::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  m_nakReason.preShowEthereal( );
  if ( HasOptionalField( e_altGKInfo ) ) 
      m_altGKInfo.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
}

PString H225_InfoRequestNak::getSummary( void ) 
{
  return PString( "InfoRequestNak" );
}

void H225_InfoRequestNak::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_InfoRequestNak_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_InfoRequestNak_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  proto_tree *nakReason_tree = (proto_tree*) NULL;
  proto_item *nakReason_ti = (proto_item*) NULL;
  nakReason_ti = proto_tree_add_text( tree, tvb, offset + m_nakReason.GetStartByte(), m_nakReason.GetByteLength(), "nakReason (%s)", ( const char* ) m_nakReason.GetTagName() );
  nakReason_tree = proto_item_add_subtree( nakReason_ti, hCont->h225_1.ett_h225_InfoRequestNak_nakReason );

  m_nakReason.showEthereal( nakReason_tree, tvb, offset );

  if ( HasOptionalField( e_altGKInfo ) ) {
    proto_tree *altGKInfo_tree = (proto_tree*) NULL;
    proto_item *altGKInfo_ti = (proto_item*) NULL;
    altGKInfo_ti = proto_tree_add_text( tree, tvb, offset + m_altGKInfo.GetStartByte(), m_altGKInfo.GetByteLength(), "altGKInfo (AltGKInfo)" );
    altGKInfo_tree = proto_item_add_subtree( altGKInfo_ti, hCont->h225_1.ett_h225_InfoRequestNak_altGKInfo );
    m_altGKInfo.showEthereal( altGKInfo_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_InfoRequestNak_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_InfoRequestNak_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_1.ett_h225_InfoRequestNak_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// NonStandardMessage
//

H225_NonStandardMessage::H225_NonStandardMessage(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 3)
{
}


#ifndef PASN_NOPRINTON
void H225_NonStandardMessage::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_NonStandardMessage::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_NonStandardMessage::Class()), PInvalidCast);
#endif
  const H225_NonStandardMessage & other = (const H225_NonStandardMessage &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_NonStandardMessage::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_nonStandardData.GetObjectLength();
}


BOOL H225_NonStandardMessage::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_NonStandardMessage::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  m_nonStandardData.Encode(strm);
}


PObject * H225_NonStandardMessage::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_NonStandardMessage::Class()), PInvalidCast);
#endif
  return new H225_NonStandardMessage(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_NonStandardMessage::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
}

PString H225_NonStandardMessage::getSummary( void ) 
{
  return PString( "NonStandardMessage" );
}

void H225_NonStandardMessage::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_NonStandardMessage_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  proto_tree *nonStandardData_tree = (proto_tree*) NULL;
  proto_item *nonStandardData_ti = (proto_item*) NULL;
  nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
  nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_NonStandardMessage_nonStandardData );

  m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_NonStandardMessage_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_NonStandardMessage_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_1.ett_h225_NonStandardMessage_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// UnknownMessageResponse
//

H225_UnknownMessageResponse::H225_UnknownMessageResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 3)
{
}


#ifndef PASN_NOPRINTON
void H225_UnknownMessageResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_UnknownMessageResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_UnknownMessageResponse::Class()), PInvalidCast);
#endif
  const H225_UnknownMessageResponse & other = (const H225_UnknownMessageResponse &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_UnknownMessageResponse::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength();
}


BOOL H225_UnknownMessageResponse::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_UnknownMessageResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
}


PObject * H225_UnknownMessageResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_UnknownMessageResponse::Class()), PInvalidCast);
#endif
  return new H225_UnknownMessageResponse(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_UnknownMessageResponse::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
}

PString H225_UnknownMessageResponse::getSummary( void ) 
{
  return PString( "UnknownMessageResponse" );
}

void H225_UnknownMessageResponse::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_UnknownMessageResponse_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_UnknownMessageResponse_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_UnknownMessageResponse_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_1.ett_h225_UnknownMessageResponse_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// RequestInProgress
//

H225_RequestInProgress::H225_RequestInProgress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 4, TRUE, 0)
{
  m_delay.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H225_RequestInProgress::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  strm << setw(indent+8) << "delay = " << setprecision(indent) << m_delay << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_RequestInProgress::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_RequestInProgress::Class()), PInvalidCast);
#endif
  const H225_RequestInProgress & other = (const H225_RequestInProgress &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;
  if ((result = m_integrityCheckValue.Compare(other.m_integrityCheckValue)) != EqualTo)
    return result;
  if ((result = m_delay.Compare(other.m_delay)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_RequestInProgress::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_nonStandardData.GetObjectLength() +
         m_tokens.GetObjectLength() +
         m_cryptoTokens.GetObjectLength() +
         m_integrityCheckValue.GetObjectLength() +
         m_delay.GetObjectLength();
}


BOOL H225_RequestInProgress::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_tokens ) && !m_tokens.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_cryptoTokens ) && !m_cryptoTokens.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_integrityCheckValue ) && !m_integrityCheckValue.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_delay.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_RequestInProgress::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_integrityCheckValue))
    m_integrityCheckValue.Encode(strm);
  m_delay.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_integrityCheckValue))
    m_integrityCheckValue.Encode(strm);
  m_delay.Encode(strm);
}


PObject * H225_RequestInProgress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_RequestInProgress::Class()), PInvalidCast);
#endif
  return new H225_RequestInProgress(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_RequestInProgress::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
  m_delay.preShowEthereal( );
}

PString H225_RequestInProgress::getSummary( void ) 
{
  return PString( "RequestInProgress" );
}

void H225_RequestInProgress::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_RequestInProgress_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_RequestInProgress_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_RequestInProgress_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_RequestInProgress_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_1.ett_h225_RequestInProgress_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_RequestInProgress_delay, tvb, offset + m_delay.GetStartByte(), m_delay.GetByteLength() , m_delay.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// ResourcesAvailableIndicate
//

H225_ResourcesAvailableIndicate::H225_ResourcesAvailableIndicate(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 4, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_ResourcesAvailableIndicate::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+21) << "endpointIdentifier = " << setprecision(indent) << m_endpointIdentifier << '\n';
  strm << setw(indent+12) << "protocols = " << setprecision(indent) << m_protocols << '\n';
  strm << setw(indent+23) << "almostOutOfResources = " << setprecision(indent) << m_almostOutOfResources << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_ResourcesAvailableIndicate::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_ResourcesAvailableIndicate::Class()), PInvalidCast);
#endif
  const H225_ResourcesAvailableIndicate & other = (const H225_ResourcesAvailableIndicate &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_endpointIdentifier.Compare(other.m_endpointIdentifier)) != EqualTo)
    return result;
  if ((result = m_protocols.Compare(other.m_protocols)) != EqualTo)
    return result;
  if ((result = m_almostOutOfResources.Compare(other.m_almostOutOfResources)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;
  if ((result = m_integrityCheckValue.Compare(other.m_integrityCheckValue)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_ResourcesAvailableIndicate::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_protocolIdentifier.GetObjectLength() +
         m_nonStandardData.GetObjectLength() +
         m_endpointIdentifier.GetObjectLength() +
         m_protocols.GetObjectLength() +
         m_almostOutOfResources.GetObjectLength() +
         m_tokens.GetObjectLength() +
         m_cryptoTokens.GetObjectLength() +
         m_integrityCheckValue.GetObjectLength();
}


BOOL H225_ResourcesAvailableIndicate::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_protocolIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_endpointIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_protocols.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_almostOutOfResources.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_tokens ) && !m_tokens.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_cryptoTokens ) && !m_cryptoTokens.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_integrityCheckValue ) && !m_integrityCheckValue.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_ResourcesAvailableIndicate::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_endpointIdentifier.Encode(strm);
  m_protocols.Encode(strm);
  m_almostOutOfResources.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_integrityCheckValue))
    m_integrityCheckValue.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_endpointIdentifier.Encode(strm);
  m_protocols.Encode(strm);
  m_almostOutOfResources.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_integrityCheckValue))
    m_integrityCheckValue.Encode(strm);
}


PObject * H225_ResourcesAvailableIndicate::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ResourcesAvailableIndicate::Class()), PInvalidCast);
#endif
  return new H225_ResourcesAvailableIndicate(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ResourcesAvailableIndicate::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  m_protocolIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  m_endpointIdentifier.preShowEthereal( );
  m_protocols.preShowEthereal( );
  m_almostOutOfResources.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
}

PString H225_ResourcesAvailableIndicate::getSummary( void ) 
{
  return PString( "ResourcesAvailableIndicate" );
}

void H225_ResourcesAvailableIndicate::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_ResourcesAvailableIndicate_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  char* pprotocolIdentifier = m_protocolIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h225_1.hf_h225_ResourcesAvailableIndicate_protocolIdentifier, tvb, offset + m_protocolIdentifier.GetStartByte(), m_protocolIdentifier.GetByteLength() , pprotocolIdentifier );
  delete[] pprotocolIdentifier;

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_ResourcesAvailableIndicate_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  char* pendpointIdentifier = m_endpointIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h225_1.hf_h225_ResourcesAvailableIndicate_endpointIdentifier, tvb, offset + m_endpointIdentifier.GetStartByte(), m_endpointIdentifier.GetByteLength() , pendpointIdentifier );
  delete[] pendpointIdentifier;

  proto_tree *protocols_tree = (proto_tree*) NULL;
  proto_item *protocols_ti = (proto_item*) NULL;
  protocols_ti = proto_tree_add_text( tree, tvb, offset + m_protocols.GetStartByte(), m_protocols.GetByteLength(), "protocols (SupportedProtocols)" );
  protocols_tree = proto_item_add_subtree( protocols_ti, hCont->h225_1.ett_h225_ResourcesAvailableIndicate_protocols );

  m_protocols.showEthereal( protocols_tree, tvb, offset );

  proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_ResourcesAvailableIndicate_almostOutOfResources, tvb, offset + m_almostOutOfResources.GetStartByte(), m_almostOutOfResources.GetByteLength() , m_almostOutOfResources.GetValue() );

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_ResourcesAvailableIndicate_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_ResourcesAvailableIndicate_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_1.ett_h225_ResourcesAvailableIndicate_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// ResourcesAvailableConfirm
//

H225_ResourcesAvailableConfirm::H225_ResourcesAvailableConfirm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 4, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_ResourcesAvailableConfirm::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_ResourcesAvailableConfirm::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_ResourcesAvailableConfirm::Class()), PInvalidCast);
#endif
  const H225_ResourcesAvailableConfirm & other = (const H225_ResourcesAvailableConfirm &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;
  if ((result = m_integrityCheckValue.Compare(other.m_integrityCheckValue)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_ResourcesAvailableConfirm::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_protocolIdentifier.GetObjectLength() +
         m_nonStandardData.GetObjectLength() +
         m_tokens.GetObjectLength() +
         m_cryptoTokens.GetObjectLength() +
         m_integrityCheckValue.GetObjectLength();
}


BOOL H225_ResourcesAvailableConfirm::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_protocolIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_tokens ) && !m_tokens.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_cryptoTokens ) && !m_cryptoTokens.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_integrityCheckValue ) && !m_integrityCheckValue.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_ResourcesAvailableConfirm::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_integrityCheckValue))
    m_integrityCheckValue.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_integrityCheckValue))
    m_integrityCheckValue.Encode(strm);
}


PObject * H225_ResourcesAvailableConfirm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ResourcesAvailableConfirm::Class()), PInvalidCast);
#endif
  return new H225_ResourcesAvailableConfirm(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ResourcesAvailableConfirm::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  m_protocolIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
}

PString H225_ResourcesAvailableConfirm::getSummary( void ) 
{
  return PString( "ResourcesAvailableConfirm" );
}

void H225_ResourcesAvailableConfirm::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_ResourcesAvailableConfirm_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  char* pprotocolIdentifier = m_protocolIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h225_1.hf_h225_ResourcesAvailableConfirm_protocolIdentifier, tvb, offset + m_protocolIdentifier.GetStartByte(), m_protocolIdentifier.GetByteLength() , pprotocolIdentifier );
  delete[] pprotocolIdentifier;

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_ResourcesAvailableConfirm_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_ResourcesAvailableConfirm_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_ResourcesAvailableConfirm_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_1.ett_h225_ResourcesAvailableConfirm_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// TransportAddress_ipSourceRoute
//

H225_TransportAddress_ipSourceRoute::H225_TransportAddress_ipSourceRoute(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_ip.SetConstraints(PASN_Object::FixedConstraint, 4, 4);
  m_port.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H225_TransportAddress_ipSourceRoute::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+5) << "ip = " << setprecision(indent) << m_ip << '\n';
  strm << setw(indent+7) << "port = " << setprecision(indent) << m_port << '\n';
  strm << setw(indent+8) << "route = " << setprecision(indent) << m_route << '\n';
  strm << setw(indent+10) << "routing = " << setprecision(indent) << m_routing << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_TransportAddress_ipSourceRoute::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_TransportAddress_ipSourceRoute::Class()), PInvalidCast);
#endif
  const H225_TransportAddress_ipSourceRoute & other = (const H225_TransportAddress_ipSourceRoute &)obj;

  Comparison result;

  if ((result = m_ip.Compare(other.m_ip)) != EqualTo)
    return result;
  if ((result = m_port.Compare(other.m_port)) != EqualTo)
    return result;
  if ((result = m_route.Compare(other.m_route)) != EqualTo)
    return result;
  if ((result = m_routing.Compare(other.m_routing)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_TransportAddress_ipSourceRoute::GetDataLength() const
{
  return m_ip.GetObjectLength() +
         m_port.GetObjectLength() +
         m_route.GetObjectLength() +
         m_routing.GetObjectLength();
}


BOOL H225_TransportAddress_ipSourceRoute::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_ip.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_port.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_route.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_routing.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_TransportAddress_ipSourceRoute::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_ip.Encode(strm);
  m_port.Encode(strm);
  m_route.Encode(strm);
  m_routing.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_ip.Encode(strm);
  m_port.Encode(strm);
  m_route.Encode(strm);
  m_routing.Encode(strm);
}


PObject * H225_TransportAddress_ipSourceRoute::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_TransportAddress_ipSourceRoute::Class()), PInvalidCast);
#endif
  return new H225_TransportAddress_ipSourceRoute(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_TransportAddress_ipSourceRoute::preShowEthereal( void )
{
  m_ip.preShowEthereal( );
  m_port.preShowEthereal( );
  m_route.preShowEthereal( );
  m_routing.preShowEthereal( );
}

PString H225_TransportAddress_ipSourceRoute::getSummary( void ) 
{
  return PString( "TransportAddress_ipSourceRoute" );
}

void H225_TransportAddress_ipSourceRoute::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pip = m_ip.getValue();
  proto_tree_add_string( tree, hCont->h225_1.hf_h225_TransportAddress_ipSourceRoute_ip, tvb, offset + m_ip.GetStartByte(), m_ip.GetByteLength() , pip );
  delete[] pip;

  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_TransportAddress_ipSourceRoute_port, tvb, offset + m_port.GetStartByte(), m_port.GetByteLength() , m_port.GetValue() );

  proto_tree *route_tree = (proto_tree*) NULL;
  proto_item *route_ti = (proto_item*) NULL;
  route_ti = proto_tree_add_text( tree, tvb, offset + m_route.GetStartByte(), m_route.GetByteLength(), "route (TransportAddress-ipSourceRoute-route)" );
  route_tree = proto_item_add_subtree( route_ti, hCont->h225_1.ett_h225_TransportAddress_ipSourceRoute_route );

  m_route.showEthereal( route_tree, tvb, offset );

  proto_tree *routing_tree = (proto_tree*) NULL;
  proto_item *routing_ti = (proto_item*) NULL;
  routing_ti = proto_tree_add_text( tree, tvb, offset + m_routing.GetStartByte(), m_routing.GetByteLength(), "routing (%s)", ( const char* ) m_routing.GetTagName() );
  routing_tree = proto_item_add_subtree( routing_ti, hCont->h225_1.ett_h225_TransportAddress_ipSourceRoute_routing );

  m_routing.showEthereal( routing_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// RegistrationConfirm_preGrantedARQ
//

H225_RegistrationConfirm_preGrantedARQ::H225_RegistrationConfirm_preGrantedARQ(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 4)
{
  m_irrFrequencyInCall.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H225_RegistrationConfirm_preGrantedARQ::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "makeCall = " << setprecision(indent) << m_makeCall << '\n';
  strm << setw(indent+35) << "useGKCallSignalAddressToMakeCall = " << setprecision(indent) << m_useGKCallSignalAddressToMakeCall << '\n';
  strm << setw(indent+13) << "answerCall = " << setprecision(indent) << m_answerCall << '\n';
  strm << setw(indent+33) << "useGKCallSignalAddressToAnswer = " << setprecision(indent) << m_useGKCallSignalAddressToAnswer << '\n';
  if (HasOptionalField(e_irrFrequencyInCall))
    strm << setw(indent+21) << "irrFrequencyInCall = " << setprecision(indent) << m_irrFrequencyInCall << '\n';
  if (HasOptionalField(e_totalBandwidthRestriction))
    strm << setw(indent+28) << "totalBandwidthRestriction = " << setprecision(indent) << m_totalBandwidthRestriction << '\n';
  if (HasOptionalField(e_alternateTransportAddresses))
    strm << setw(indent+30) << "alternateTransportAddresses = " << setprecision(indent) << m_alternateTransportAddresses << '\n';
  if (HasOptionalField(e_useSpecifiedTransport))
    strm << setw(indent+24) << "useSpecifiedTransport = " << setprecision(indent) << m_useSpecifiedTransport << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_RegistrationConfirm_preGrantedARQ::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_RegistrationConfirm_preGrantedARQ::Class()), PInvalidCast);
#endif
  const H225_RegistrationConfirm_preGrantedARQ & other = (const H225_RegistrationConfirm_preGrantedARQ &)obj;

  Comparison result;

  if ((result = m_makeCall.Compare(other.m_makeCall)) != EqualTo)
    return result;
  if ((result = m_useGKCallSignalAddressToMakeCall.Compare(other.m_useGKCallSignalAddressToMakeCall)) != EqualTo)
    return result;
  if ((result = m_answerCall.Compare(other.m_answerCall)) != EqualTo)
    return result;
  if ((result = m_useGKCallSignalAddressToAnswer.Compare(other.m_useGKCallSignalAddressToAnswer)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_RegistrationConfirm_preGrantedARQ::GetDataLength() const
{
  return m_makeCall.GetObjectLength() +
         m_useGKCallSignalAddressToMakeCall.GetObjectLength() +
         m_answerCall.GetObjectLength() +
         m_useGKCallSignalAddressToAnswer.GetObjectLength();
}


BOOL H225_RegistrationConfirm_preGrantedARQ::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_makeCall.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_useGKCallSignalAddressToMakeCall.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_answerCall.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_useGKCallSignalAddressToAnswer.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_irrFrequencyInCall, m_irrFrequencyInCall ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_totalBandwidthRestriction, m_totalBandwidthRestriction ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_alternateTransportAddresses, m_alternateTransportAddresses ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_useSpecifiedTransport, m_useSpecifiedTransport ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_RegistrationConfirm_preGrantedARQ::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_makeCall.Encode(strm);
  m_useGKCallSignalAddressToMakeCall.Encode(strm);
  m_answerCall.Encode(strm);
  m_useGKCallSignalAddressToAnswer.Encode(strm);
  KnownExtensionEncode(strm, e_irrFrequencyInCall, m_irrFrequencyInCall);
  KnownExtensionEncode(strm, e_totalBandwidthRestriction, m_totalBandwidthRestriction);
  KnownExtensionEncode(strm, e_alternateTransportAddresses, m_alternateTransportAddresses);
  KnownExtensionEncode(strm, e_useSpecifiedTransport, m_useSpecifiedTransport);

  UnknownExtensionsEncode(strm);
  m_makeCall.Encode(strm);
  m_useGKCallSignalAddressToMakeCall.Encode(strm);
  m_answerCall.Encode(strm);
  m_useGKCallSignalAddressToAnswer.Encode(strm);
}


PObject * H225_RegistrationConfirm_preGrantedARQ::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_RegistrationConfirm_preGrantedARQ::Class()), PInvalidCast);
#endif
  return new H225_RegistrationConfirm_preGrantedARQ(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_RegistrationConfirm_preGrantedARQ::preShowEthereal( void )
{
  m_makeCall.preShowEthereal( );
  m_useGKCallSignalAddressToMakeCall.preShowEthereal( );
  m_answerCall.preShowEthereal( );
  m_useGKCallSignalAddressToAnswer.preShowEthereal( );
  if ( HasOptionalField( e_irrFrequencyInCall ) ) 
      m_irrFrequencyInCall.preShowEthereal( );
  if ( HasOptionalField( e_totalBandwidthRestriction ) ) 
      m_totalBandwidthRestriction.preShowEthereal( );
  if ( HasOptionalField( e_alternateTransportAddresses ) ) 
      m_alternateTransportAddresses.preShowEthereal( );
  if ( HasOptionalField( e_useSpecifiedTransport ) ) 
      m_useSpecifiedTransport.preShowEthereal( );
}

PString H225_RegistrationConfirm_preGrantedARQ::getSummary( void ) 
{
  return PString( "RegistrationConfirm_preGrantedARQ" );
}

void H225_RegistrationConfirm_preGrantedARQ::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_RegistrationConfirm_preGrantedARQ_makeCall, tvb, offset + m_makeCall.GetStartByte(), m_makeCall.GetByteLength() , m_makeCall.GetValue() );

  proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_RegistrationConfirm_preGrantedARQ_useGKCallSignalAddressToMakeCall, tvb, offset + m_useGKCallSignalAddressToMakeCall.GetStartByte(), m_useGKCallSignalAddressToMakeCall.GetByteLength() , m_useGKCallSignalAddressToMakeCall.GetValue() );

  proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_RegistrationConfirm_preGrantedARQ_answerCall, tvb, offset + m_answerCall.GetStartByte(), m_answerCall.GetByteLength() , m_answerCall.GetValue() );

  proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_RegistrationConfirm_preGrantedARQ_useGKCallSignalAddressToAnswer, tvb, offset + m_useGKCallSignalAddressToAnswer.GetStartByte(), m_useGKCallSignalAddressToAnswer.GetByteLength() , m_useGKCallSignalAddressToAnswer.GetValue() );

  if ( HasOptionalField( e_irrFrequencyInCall ) ) {
    proto_tree_add_uint( tree, hCont->h225_1.hf_h225_RegistrationConfirm_preGrantedARQ_irrFrequencyInCall, tvb, offset + m_irrFrequencyInCall.GetStartByte(), m_irrFrequencyInCall.GetByteLength() , m_irrFrequencyInCall.GetValue() );
  }

  if ( HasOptionalField( e_totalBandwidthRestriction ) ) {
    proto_tree_add_uint( tree, hCont->h225_1.hf_h225_RegistrationConfirm_preGrantedARQ_totalBandwidthRestriction, tvb, offset + m_totalBandwidthRestriction.GetStartByte(), m_totalBandwidthRestriction.GetByteLength() , m_totalBandwidthRestriction.GetValue() );
  }

  if ( HasOptionalField( e_alternateTransportAddresses ) ) {
    proto_tree *alternateTransportAddresses_tree = (proto_tree*) NULL;
    proto_item *alternateTransportAddresses_ti = (proto_item*) NULL;
    alternateTransportAddresses_ti = proto_tree_add_text( tree, tvb, offset + m_alternateTransportAddresses.GetStartByte(), m_alternateTransportAddresses.GetByteLength(), "alternateTransportAddresses (AlternateTransportAddresses)" );
    alternateTransportAddresses_tree = proto_item_add_subtree( alternateTransportAddresses_ti, hCont->h225_1.ett_h225_RegistrationConfirm_preGrantedARQ_alternateTransportAddresses );
    m_alternateTransportAddresses.showEthereal( alternateTransportAddresses_tree, tvb, offset );
  }

  if ( HasOptionalField( e_useSpecifiedTransport ) ) {
    proto_tree *useSpecifiedTransport_tree = (proto_tree*) NULL;
    proto_item *useSpecifiedTransport_ti = (proto_item*) NULL;
    useSpecifiedTransport_ti = proto_tree_add_text( tree, tvb, offset + m_useSpecifiedTransport.GetStartByte(), m_useSpecifiedTransport.GetByteLength(), "useSpecifiedTransport (%s)", ( const char* ) m_useSpecifiedTransport.GetTagName() );
    useSpecifiedTransport_tree = proto_item_add_subtree( useSpecifiedTransport_ti, hCont->h225_1.ett_h225_RegistrationConfirm_preGrantedARQ_useSpecifiedTransport );
    m_useSpecifiedTransport.showEthereal( useSpecifiedTransport_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// InfoRequestResponse_perCallInfo_subtype
//

H225_InfoRequestResponse_perCallInfo_subtype::H225_InfoRequestResponse_perCallInfo_subtype(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 5, TRUE, 6)
{
  IncludeOptionalField(e_callIdentifier);
  IncludeOptionalField(e_substituteConfIDs);
}


#ifndef PASN_NOPRINTON
void H225_InfoRequestResponse_perCallInfo_subtype::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+21) << "callReferenceValue = " << setprecision(indent) << m_callReferenceValue << '\n';
  strm << setw(indent+15) << "conferenceID = " << setprecision(indent) << m_conferenceID << '\n';
  if (HasOptionalField(e_originator))
    strm << setw(indent+13) << "originator = " << setprecision(indent) << m_originator << '\n';
  if (HasOptionalField(e_audio))
    strm << setw(indent+8) << "audio = " << setprecision(indent) << m_audio << '\n';
  if (HasOptionalField(e_video))
    strm << setw(indent+8) << "video = " << setprecision(indent) << m_video << '\n';
  if (HasOptionalField(e_data))
    strm << setw(indent+7) << "data = " << setprecision(indent) << m_data << '\n';
  strm << setw(indent+7) << "h245 = " << setprecision(indent) << m_h245 << '\n';
  strm << setw(indent+16) << "callSignaling = " << setprecision(indent) << m_callSignaling << '\n';
  strm << setw(indent+11) << "callType = " << setprecision(indent) << m_callType << '\n';
  strm << setw(indent+12) << "bandWidth = " << setprecision(indent) << m_bandWidth << '\n';
  strm << setw(indent+12) << "callModel = " << setprecision(indent) << m_callModel << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_substituteConfIDs))
    strm << setw(indent+20) << "substituteConfIDs = " << setprecision(indent) << m_substituteConfIDs << '\n';
  if (HasOptionalField(e_pdu))
    strm << setw(indent+6) << "pdu = " << setprecision(indent) << m_pdu << '\n';
  if (HasOptionalField(e_callLinkage))
    strm << setw(indent+14) << "callLinkage = " << setprecision(indent) << m_callLinkage << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_InfoRequestResponse_perCallInfo_subtype::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_InfoRequestResponse_perCallInfo_subtype::Class()), PInvalidCast);
#endif
  const H225_InfoRequestResponse_perCallInfo_subtype & other = (const H225_InfoRequestResponse_perCallInfo_subtype &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_callReferenceValue.Compare(other.m_callReferenceValue)) != EqualTo)
    return result;
  if ((result = m_conferenceID.Compare(other.m_conferenceID)) != EqualTo)
    return result;
  if ((result = m_originator.Compare(other.m_originator)) != EqualTo)
    return result;
  if ((result = m_audio.Compare(other.m_audio)) != EqualTo)
    return result;
  if ((result = m_video.Compare(other.m_video)) != EqualTo)
    return result;
  if ((result = m_data.Compare(other.m_data)) != EqualTo)
    return result;
  if ((result = m_h245.Compare(other.m_h245)) != EqualTo)
    return result;
  if ((result = m_callSignaling.Compare(other.m_callSignaling)) != EqualTo)
    return result;
  if ((result = m_callType.Compare(other.m_callType)) != EqualTo)
    return result;
  if ((result = m_bandWidth.Compare(other.m_bandWidth)) != EqualTo)
    return result;
  if ((result = m_callModel.Compare(other.m_callModel)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_InfoRequestResponse_perCallInfo_subtype::GetDataLength() const
{
  return m_nonStandardData.GetObjectLength() +
         m_callReferenceValue.GetObjectLength() +
         m_conferenceID.GetObjectLength() +
         m_originator.GetObjectLength() +
         m_audio.GetObjectLength() +
         m_video.GetObjectLength() +
         m_data.GetObjectLength() +
         m_h245.GetObjectLength() +
         m_callSignaling.GetObjectLength() +
         m_callType.GetObjectLength() +
         m_bandWidth.GetObjectLength() +
         m_callModel.GetObjectLength();
}


BOOL H225_InfoRequestResponse_perCallInfo_subtype::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callReferenceValue.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_conferenceID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_originator ) && !m_originator.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_audio ) && !m_audio.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_video ) && !m_video.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_data ) && !m_data.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_h245.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callSignaling.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bandWidth.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callModel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_callIdentifier, m_callIdentifier ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_substituteConfIDs, m_substituteConfIDs ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_pdu, m_pdu ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_callLinkage, m_callLinkage ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_InfoRequestResponse_perCallInfo_subtype::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_callReferenceValue.Encode(strm);
  m_conferenceID.Encode(strm);
  if (HasOptionalField(e_originator))
    m_originator.Encode(strm);
  if (HasOptionalField(e_audio))
    m_audio.Encode(strm);
  if (HasOptionalField(e_video))
    m_video.Encode(strm);
  if (HasOptionalField(e_data))
    m_data.Encode(strm);
  m_h245.Encode(strm);
  m_callSignaling.Encode(strm);
  m_callType.Encode(strm);
  m_bandWidth.Encode(strm);
  m_callModel.Encode(strm);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_substituteConfIDs, m_substituteConfIDs);
  KnownExtensionEncode(strm, e_pdu, m_pdu);
  KnownExtensionEncode(strm, e_callLinkage, m_callLinkage);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_callReferenceValue.Encode(strm);
  m_conferenceID.Encode(strm);
  if (HasOptionalField(e_originator))
    m_originator.Encode(strm);
  if (HasOptionalField(e_audio))
    m_audio.Encode(strm);
  if (HasOptionalField(e_video))
    m_video.Encode(strm);
  if (HasOptionalField(e_data))
    m_data.Encode(strm);
  m_h245.Encode(strm);
  m_callSignaling.Encode(strm);
  m_callType.Encode(strm);
  m_bandWidth.Encode(strm);
  m_callModel.Encode(strm);
}


PObject * H225_InfoRequestResponse_perCallInfo_subtype::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_InfoRequestResponse_perCallInfo_subtype::Class()), PInvalidCast);
#endif
  return new H225_InfoRequestResponse_perCallInfo_subtype(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_InfoRequestResponse_perCallInfo_subtype::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  m_callReferenceValue.preShowEthereal( );
  m_conferenceID.preShowEthereal( );
  if ( HasOptionalField( e_originator ) ) 
      m_originator.preShowEthereal( );
  if ( HasOptionalField( e_audio ) ) 
      m_audio.preShowEthereal( );
  if ( HasOptionalField( e_video ) ) 
      m_video.preShowEthereal( );
  if ( HasOptionalField( e_data ) ) 
      m_data.preShowEthereal( );
  m_h245.preShowEthereal( );
  m_callSignaling.preShowEthereal( );
  m_callType.preShowEthereal( );
  m_bandWidth.preShowEthereal( );
  m_callModel.preShowEthereal( );
  if ( HasOptionalField( e_callIdentifier ) ) 
      m_callIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_substituteConfIDs ) ) 
      m_substituteConfIDs.preShowEthereal( );
  if ( HasOptionalField( e_pdu ) ) 
      m_pdu.preShowEthereal( );
  if ( HasOptionalField( e_callLinkage ) ) 
      m_callLinkage.preShowEthereal( );
}

PString H225_InfoRequestResponse_perCallInfo_subtype::getSummary( void ) 
{
  return PString( "InfoRequestResponse_perCallInfo_subtype" );
}

void H225_InfoRequestResponse_perCallInfo_subtype::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_InfoRequestResponse_perCallInfo_subtype_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_InfoRequestResponse_perCallInfo_subtype_callReferenceValue, tvb, offset + m_callReferenceValue.GetStartByte(), m_callReferenceValue.GetByteLength() , m_callReferenceValue.GetValue() );

  char* pconferenceID = m_conferenceID.getValue();
  proto_tree_add_string( tree, hCont->h225_1.hf_h225_InfoRequestResponse_perCallInfo_subtype_conferenceID, tvb, offset + m_conferenceID.GetStartByte(), m_conferenceID.GetByteLength() , pconferenceID );
  delete[] pconferenceID;

  if ( HasOptionalField( e_originator ) ) {
    proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_InfoRequestResponse_perCallInfo_subtype_originator, tvb, offset + m_originator.GetStartByte(), m_originator.GetByteLength() , m_originator.GetValue() );
  }

  if ( HasOptionalField( e_audio ) ) {
    proto_tree *audio_tree = (proto_tree*) NULL;
    proto_item *audio_ti = (proto_item*) NULL;
    audio_ti = proto_tree_add_text( tree, tvb, offset + m_audio.GetStartByte(), m_audio.GetByteLength(), "audio (RTPSession)" );
    audio_tree = proto_item_add_subtree( audio_ti, hCont->h225_1.ett_h225_InfoRequestResponse_perCallInfo_subtype_audio );
    m_audio.showEthereal( audio_tree, tvb, offset );
  }

  if ( HasOptionalField( e_video ) ) {
    proto_tree *video_tree = (proto_tree*) NULL;
    proto_item *video_ti = (proto_item*) NULL;
    video_ti = proto_tree_add_text( tree, tvb, offset + m_video.GetStartByte(), m_video.GetByteLength(), "video (RTPSession)" );
    video_tree = proto_item_add_subtree( video_ti, hCont->h225_1.ett_h225_InfoRequestResponse_perCallInfo_subtype_video );
    m_video.showEthereal( video_tree, tvb, offset );
  }

  if ( HasOptionalField( e_data ) ) {
    proto_tree *data_tree = (proto_tree*) NULL;
    proto_item *data_ti = (proto_item*) NULL;
    data_ti = proto_tree_add_text( tree, tvb, offset + m_data.GetStartByte(), m_data.GetByteLength(), "data (TransportChannelInfo)" );
    data_tree = proto_item_add_subtree( data_ti, hCont->h225_1.ett_h225_InfoRequestResponse_perCallInfo_subtype_data );
    m_data.showEthereal( data_tree, tvb, offset );
  }

  proto_tree *h245_tree = (proto_tree*) NULL;
  proto_item *h245_ti = (proto_item*) NULL;
  h245_ti = proto_tree_add_text( tree, tvb, offset + m_h245.GetStartByte(), m_h245.GetByteLength(), "h245 (TransportChannelInfo)" );
  h245_tree = proto_item_add_subtree( h245_ti, hCont->h225_1.ett_h225_InfoRequestResponse_perCallInfo_subtype_h245 );

  m_h245.showEthereal( h245_tree, tvb, offset );

  proto_tree *callSignaling_tree = (proto_tree*) NULL;
  proto_item *callSignaling_ti = (proto_item*) NULL;
  callSignaling_ti = proto_tree_add_text( tree, tvb, offset + m_callSignaling.GetStartByte(), m_callSignaling.GetByteLength(), "callSignaling (TransportChannelInfo)" );
  callSignaling_tree = proto_item_add_subtree( callSignaling_ti, hCont->h225_1.ett_h225_InfoRequestResponse_perCallInfo_subtype_callSignaling );

  m_callSignaling.showEthereal( callSignaling_tree, tvb, offset );

  proto_tree *callType_tree = (proto_tree*) NULL;
  proto_item *callType_ti = (proto_item*) NULL;
  callType_ti = proto_tree_add_text( tree, tvb, offset + m_callType.GetStartByte(), m_callType.GetByteLength(), "callType (%s)", ( const char* ) m_callType.GetTagName() );
  callType_tree = proto_item_add_subtree( callType_ti, hCont->h225_1.ett_h225_InfoRequestResponse_perCallInfo_subtype_callType );

  m_callType.showEthereal( callType_tree, tvb, offset );

  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_InfoRequestResponse_perCallInfo_subtype_bandWidth, tvb, offset + m_bandWidth.GetStartByte(), m_bandWidth.GetByteLength() , m_bandWidth.GetValue() );

  proto_tree *callModel_tree = (proto_tree*) NULL;
  proto_item *callModel_ti = (proto_item*) NULL;
  callModel_ti = proto_tree_add_text( tree, tvb, offset + m_callModel.GetStartByte(), m_callModel.GetByteLength(), "callModel (%s)", ( const char* ) m_callModel.GetTagName() );
  callModel_tree = proto_item_add_subtree( callModel_ti, hCont->h225_1.ett_h225_InfoRequestResponse_perCallInfo_subtype_callModel );

  m_callModel.showEthereal( callModel_tree, tvb, offset );

  if ( HasOptionalField( e_callIdentifier ) ) {
    proto_tree *callIdentifier_tree = (proto_tree*) NULL;
    proto_item *callIdentifier_ti = (proto_item*) NULL;
    callIdentifier_ti = proto_tree_add_text( tree, tvb, offset + m_callIdentifier.GetStartByte(), m_callIdentifier.GetByteLength(), "callIdentifier (CallIdentifier)" );
    callIdentifier_tree = proto_item_add_subtree( callIdentifier_ti, hCont->h225_1.ett_h225_InfoRequestResponse_perCallInfo_subtype_callIdentifier );
    m_callIdentifier.showEthereal( callIdentifier_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_InfoRequestResponse_perCallInfo_subtype_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_InfoRequestResponse_perCallInfo_subtype_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_substituteConfIDs ) ) {
    proto_tree *substituteConfIDs_tree = (proto_tree*) NULL;
    proto_item *substituteConfIDs_ti = (proto_item*) NULL;
    substituteConfIDs_ti = proto_tree_add_text( tree, tvb, offset + m_substituteConfIDs.GetStartByte(), m_substituteConfIDs.GetByteLength(), "substituteConfIDs (ConferenceIdentifier)" );
    substituteConfIDs_tree = proto_item_add_subtree( substituteConfIDs_ti, hCont->h225_1.ett_h225_InfoRequestResponse_perCallInfo_subtype_substituteConfIDs );
    m_substituteConfIDs.showEthereal( substituteConfIDs_tree, tvb, offset );
  }

  if ( HasOptionalField( e_pdu ) ) {
    proto_tree *pdu_tree = (proto_tree*) NULL;
    proto_item *pdu_ti = (proto_item*) NULL;
    pdu_ti = proto_tree_add_text( tree, tvb, offset + m_pdu.GetStartByte(), m_pdu.GetByteLength(), "pdu (InfoRequestResponse-perCallInfo-subtype-pdu)" );
    pdu_tree = proto_item_add_subtree( pdu_ti, hCont->h225_1.ett_h225_InfoRequestResponse_perCallInfo_subtype_pdu );
    m_pdu.showEthereal( pdu_tree, tvb, offset );
  }

  if ( HasOptionalField( e_callLinkage ) ) {
    proto_tree *callLinkage_tree = (proto_tree*) NULL;
    proto_item *callLinkage_ti = (proto_item*) NULL;
    callLinkage_ti = proto_tree_add_text( tree, tvb, offset + m_callLinkage.GetStartByte(), m_callLinkage.GetByteLength(), "callLinkage (CallLinkage)" );
    callLinkage_tree = proto_item_add_subtree( callLinkage_ti, hCont->h225_1.ett_h225_InfoRequestResponse_perCallInfo_subtype_callLinkage );
    m_callLinkage.showEthereal( callLinkage_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// H323-UU-PDU
//

H225_H323_UU_PDU::H225_H323_UU_PDU(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 5)
{
  IncludeOptionalField(e_h245Tunneling);
}


#ifndef PASN_NOPRINTON
void H225_H323_UU_PDU::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+20) << "h323_message_body = " << setprecision(indent) << m_h323_message_body << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_h4501SupplementaryService))
    strm << setw(indent+28) << "h4501SupplementaryService = " << setprecision(indent) << m_h4501SupplementaryService << '\n';
  if (HasOptionalField(e_h245Tunneling))
    strm << setw(indent+16) << "h245Tunneling = " << setprecision(indent) << m_h245Tunneling << '\n';
  if (HasOptionalField(e_h245Control))
    strm << setw(indent+14) << "h245Control = " << setprecision(indent) << m_h245Control << '\n';
  if (HasOptionalField(e_nonStandardControl))
    strm << setw(indent+21) << "nonStandardControl = " << setprecision(indent) << m_nonStandardControl << '\n';
  if (HasOptionalField(e_callLinkage))
    strm << setw(indent+14) << "callLinkage = " << setprecision(indent) << m_callLinkage << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_H323_UU_PDU::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_H323_UU_PDU::Class()), PInvalidCast);
#endif
  const H225_H323_UU_PDU & other = (const H225_H323_UU_PDU &)obj;

  Comparison result;

  if ((result = m_h323_message_body.Compare(other.m_h323_message_body)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_H323_UU_PDU::GetDataLength() const
{
  return m_h323_message_body.GetObjectLength() +
         m_nonStandardData.GetObjectLength();
}


BOOL H225_H323_UU_PDU::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_h323_message_body.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_h4501SupplementaryService, m_h4501SupplementaryService ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_h245Tunneling, m_h245Tunneling ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_h245Control, m_h245Control ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_nonStandardControl, m_nonStandardControl ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_callLinkage, m_callLinkage ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_H323_UU_PDU::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_h323_message_body.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_h4501SupplementaryService, m_h4501SupplementaryService);
  KnownExtensionEncode(strm, e_h245Tunneling, m_h245Tunneling);
  KnownExtensionEncode(strm, e_h245Control, m_h245Control);
  KnownExtensionEncode(strm, e_nonStandardControl, m_nonStandardControl);
  KnownExtensionEncode(strm, e_callLinkage, m_callLinkage);

  UnknownExtensionsEncode(strm);
  m_h323_message_body.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_H323_UU_PDU::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_H323_UU_PDU::Class()), PInvalidCast);
#endif
  return new H225_H323_UU_PDU(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_H323_UU_PDU::preShowEthereal( void )
{
  m_h323_message_body.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_h4501SupplementaryService ) ) 
      m_h4501SupplementaryService.preShowEthereal( );
  if ( HasOptionalField( e_h245Tunneling ) ) 
      m_h245Tunneling.preShowEthereal( );
  if ( HasOptionalField( e_h245Control ) ) 
      m_h245Control.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardControl ) ) 
      m_nonStandardControl.preShowEthereal( );
  if ( HasOptionalField( e_callLinkage ) ) 
      m_callLinkage.preShowEthereal( );
}

PString H225_H323_UU_PDU::getSummary( void ) 
{
  return m_h323_message_body.getSummary();
}

void H225_H323_UU_PDU::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *h323_message_body_tree = (proto_tree*) NULL;
  proto_item *h323_message_body_ti = (proto_item*) NULL;
  h323_message_body_ti = proto_tree_add_text( tree, tvb, offset + m_h323_message_body.GetStartByte(), m_h323_message_body.GetByteLength(), "h323_message_body (%s)", ( const char* ) m_h323_message_body.GetTagName() );
  h323_message_body_tree = proto_item_add_subtree( h323_message_body_ti, hCont->h225_1.ett_h225_H323_UU_PDU_h323_message_body );

  m_h323_message_body.showEthereal( h323_message_body_tree, tvb, offset );

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_H323_UU_PDU_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  //if ( HasOptionalField( e_h4501SupplementaryService ) ) {
  //  proto_tree *h4501SupplementaryService_tree = (proto_tree*) NULL;
  //  proto_item *h4501SupplementaryService_ti = (proto_item*) NULL;
  //  h4501SupplementaryService_ti = proto_tree_add_text( tree, tvb, offset + m_h4501SupplementaryService.GetStartByte(), m_h4501SupplementaryService.GetByteLength(), "h4501SupplementaryService (OctetString)" );
  //  h4501SupplementaryService_tree = proto_item_add_subtree( h4501SupplementaryService_ti, hCont->h225_1.ett_h225_H323_UU_PDU_h4501SupplementaryService );
  //  m_h4501SupplementaryService.showEthereal( h4501SupplementaryService_tree, tvb, offset );
  //}
  if ( HasOptionalField( e_h4501SupplementaryService ) ) {
    offset++;
    for( int i=0; i < m_h4501SupplementaryService.GetSize(); i++ )
    {
      PPER_Stream per = m_h4501SupplementaryService[ i ].GetValue();

      H450_SupplementaryService supserv;
      if ( supserv.Decode( per ) )
      {
        proto_tree *fastStart_tree = (proto_tree*) NULL;
        proto_item *fastStart_ti = (proto_item*) NULL;
        fastStart_ti = proto_tree_add_text( tree, tvb, offset + m_h4501SupplementaryService[i].GetStartByte(), m_h4501SupplementaryService[i].GetByteLength(), "h4501SupplementaryService %d %s", i, (const unsigned char*) supserv.getSummary() );
        fastStart_tree = proto_item_add_subtree( fastStart_ti, hCont->h225_0.ett_h225_Information_UUIE_fastStart );
        supserv.showEthereal( fastStart_tree, tvb, offset + m_h4501SupplementaryService[i].GetStartByte() );
      }
      else
      {
        proto_tree_add_text( tree, tvb, offset + m_h4501SupplementaryService[i].GetStartByte(), m_h4501SupplementaryService.GetByteLength(), "Unable to decode h4501SupplementaryService element %d", i );
      }
    }
  }

  if ( HasOptionalField( e_h245Tunneling ) ) {
    proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_H323_UU_PDU_h245Tunneling, tvb, offset + m_h245Tunneling.GetStartByte(), m_h245Tunneling.GetByteLength() , m_h245Tunneling.GetValue() );
  }

  if ( HasOptionalField( e_h245Control ) ) {
    for( int i=0; i < m_h245Control.GetSize(); i++ )
    {
      PPER_Stream per = m_h245Control[ i ].GetValue();
      H245_MultimediaSystemControlMessage message;

      if ( message.Decode( per ) )
      {
        proto_tree *h245Control_tree = (proto_tree*) NULL;
        proto_item *h245Control_ti = (proto_item*) NULL;
        h245Control_ti = proto_tree_add_text( tree, tvb, offset + m_h245Control[i].GetStartByte(), m_h245Control[i].GetByteLength(), "h245Control %d: %s", i, (const unsigned char*) message.getSummary() );
        h245Control_tree = proto_item_add_subtree( h245Control_ti, hCont->h225_1.ett_h225_H323_UU_PDU_h245Control );
        message.showEthereal( h245Control_tree, tvb, offset + m_h245Control[i].GetStartByte() );
      }
      else
      {
        proto_tree_add_text( tree, tvb, offset + m_h245Control[i].GetStartByte(), m_h245Control.GetByteLength(), "Unable to decode h245Control element %d", i );
      }
    }
  }

  /*
  if ( HasOptionalField( e_h245Control ) ) {
    proto_tree *h245Control_tree = (proto_tree*) NULL;
    proto_item *h245Control_ti = (proto_item*) NULL;
    h245Control_ti = proto_tree_add_text( tree, tvb, offset + m_h245Control.GetStartByte(), m_h245Control.GetByteLength(), "h245Control (OctetString)" );
    h245Control_tree = proto_item_add_subtree( h245Control_ti, hCont->h225_1.ett_h225_H323_UU_PDU_h245Control );
    m_h245Control.showEthereal( h245Control_tree, tvb, offset );
  }
  */
  
  if ( HasOptionalField( e_nonStandardControl ) ) {
    proto_tree *nonStandardControl_tree = (proto_tree*) NULL;
    proto_item *nonStandardControl_ti = (proto_item*) NULL;
    nonStandardControl_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardControl.GetStartByte(), m_nonStandardControl.GetByteLength(), "nonStandardControl (NonStandardParameter)" );
    nonStandardControl_tree = proto_item_add_subtree( nonStandardControl_ti, hCont->h225_1.ett_h225_H323_UU_PDU_nonStandardControl );
    m_nonStandardControl.showEthereal( nonStandardControl_tree, tvb, offset );
  }

  if ( HasOptionalField( e_callLinkage ) ) {
    proto_tree *callLinkage_tree = (proto_tree*) NULL;
    proto_item *callLinkage_ti = (proto_item*) NULL;
    callLinkage_ti = proto_tree_add_text( tree, tvb, offset + m_callLinkage.GetStartByte(), m_callLinkage.GetByteLength(), "callLinkage (CallLinkage)" );
    callLinkage_tree = proto_item_add_subtree( callLinkage_ti, hCont->h225_1.ett_h225_H323_UU_PDU_callLinkage );
    m_callLinkage.showEthereal( callLinkage_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// ConferenceList
//

H225_ConferenceList::H225_ConferenceList(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_ConferenceList::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_conferenceID))
    strm << setw(indent+15) << "conferenceID = " << setprecision(indent) << m_conferenceID << '\n';
  if (HasOptionalField(e_conferenceAlias))
    strm << setw(indent+18) << "conferenceAlias = " << setprecision(indent) << m_conferenceAlias << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_ConferenceList::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_ConferenceList::Class()), PInvalidCast);
#endif
  const H225_ConferenceList & other = (const H225_ConferenceList &)obj;

  Comparison result;

  if ((result = m_conferenceID.Compare(other.m_conferenceID)) != EqualTo)
    return result;
  if ((result = m_conferenceAlias.Compare(other.m_conferenceAlias)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_ConferenceList::GetDataLength() const
{
  return m_conferenceID.GetObjectLength() +
         m_conferenceAlias.GetObjectLength() +
         m_nonStandardData.GetObjectLength();
}


BOOL H225_ConferenceList::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_conferenceID ) && !m_conferenceID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_conferenceAlias ) && !m_conferenceAlias.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_ConferenceList::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_conferenceID))
    m_conferenceID.Encode(strm);
  if (HasOptionalField(e_conferenceAlias))
    m_conferenceAlias.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_conferenceID))
    m_conferenceID.Encode(strm);
  if (HasOptionalField(e_conferenceAlias))
    m_conferenceAlias.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_ConferenceList::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ConferenceList::Class()), PInvalidCast);
#endif
  return new H225_ConferenceList(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_ConferenceList::preShowEthereal( void )
{
  if ( HasOptionalField( e_conferenceID ) ) 
      m_conferenceID.preShowEthereal( );
  if ( HasOptionalField( e_conferenceAlias ) ) 
      m_conferenceAlias.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
}

PString H225_ConferenceList::getSummary( void ) 
{
  return PString( "ConferenceList" );
}

void H225_ConferenceList::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_conferenceID ) ) {
    char* pconferenceID = m_conferenceID.getValue();
    proto_tree_add_string( tree, hCont->h225_1.hf_h225_ConferenceList_conferenceID, tvb, offset + m_conferenceID.GetStartByte(), m_conferenceID.GetByteLength() , pconferenceID );
    delete[] pconferenceID;
  }

  if ( HasOptionalField( e_conferenceAlias ) ) {
    proto_tree *conferenceAlias_tree = (proto_tree*) NULL;
    proto_item *conferenceAlias_ti = (proto_item*) NULL;
    conferenceAlias_ti = proto_tree_add_text( tree, tvb, offset + m_conferenceAlias.GetStartByte(), m_conferenceAlias.GetByteLength(), "conferenceAlias (%s)", ( const char* ) m_conferenceAlias.GetTagName() );
    conferenceAlias_tree = proto_item_add_subtree( conferenceAlias_ti, hCont->h225_1.ett_h225_ConferenceList_conferenceAlias );
    m_conferenceAlias.showEthereal( conferenceAlias_tree, tvb, offset );
  }

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_ConferenceList_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// GatewayInfo
//

H225_GatewayInfo::H225_GatewayInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_GatewayInfo::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_protocol))
    strm << setw(indent+11) << "protocol = " << setprecision(indent) << m_protocol << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_GatewayInfo::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_GatewayInfo::Class()), PInvalidCast);
#endif
  const H225_GatewayInfo & other = (const H225_GatewayInfo &)obj;

  Comparison result;

  if ((result = m_protocol.Compare(other.m_protocol)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_GatewayInfo::GetDataLength() const
{
  return m_protocol.GetObjectLength() +
         m_nonStandardData.GetObjectLength();
}


BOOL H225_GatewayInfo::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_protocol ) && !m_protocol.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_GatewayInfo::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_protocol))
    m_protocol.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_protocol))
    m_protocol.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_GatewayInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_GatewayInfo::Class()), PInvalidCast);
#endif
  return new H225_GatewayInfo(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_GatewayInfo::preShowEthereal( void )
{
  if ( HasOptionalField( e_protocol ) ) 
      m_protocol.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
}

PString H225_GatewayInfo::getSummary( void ) 
{
  return PString( "GatewayInfo" );
}

void H225_GatewayInfo::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_protocol ) ) {
    proto_tree *protocol_tree = (proto_tree*) NULL;
    proto_item *protocol_ti = (proto_item*) NULL;
    protocol_ti = proto_tree_add_text( tree, tvb, offset + m_protocol.GetStartByte(), m_protocol.GetByteLength(), "protocol (SupportedProtocols)" );
    protocol_tree = proto_item_add_subtree( protocol_ti, hCont->h225_1.ett_h225_GatewayInfo_protocol );
    m_protocol.showEthereal( protocol_tree, tvb, offset );
  }

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_GatewayInfo_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// H310Caps
//

H225_H310Caps::H225_H310Caps(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 2)
{
  IncludeOptionalField(e_supportedPrefixes);
}


#ifndef PASN_NOPRINTON
void H225_H310Caps::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_dataRatesSupported))
    strm << setw(indent+21) << "dataRatesSupported = " << setprecision(indent) << m_dataRatesSupported << '\n';
  if (HasOptionalField(e_supportedPrefixes))
    strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_H310Caps::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_H310Caps::Class()), PInvalidCast);
#endif
  const H225_H310Caps & other = (const H225_H310Caps &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_H310Caps::GetDataLength() const
{
  return m_nonStandardData.GetObjectLength();
}


BOOL H225_H310Caps::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_dataRatesSupported, m_dataRatesSupported ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_supportedPrefixes, m_supportedPrefixes ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_H310Caps::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_dataRatesSupported, m_dataRatesSupported);
  KnownExtensionEncode(strm, e_supportedPrefixes, m_supportedPrefixes);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_H310Caps::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_H310Caps::Class()), PInvalidCast);
#endif
  return new H225_H310Caps(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_H310Caps::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_dataRatesSupported ) ) 
      m_dataRatesSupported.preShowEthereal( );
  if ( HasOptionalField( e_supportedPrefixes ) ) 
      m_supportedPrefixes.preShowEthereal( );
}

PString H225_H310Caps::getSummary( void ) 
{
  return PString( "H310Caps" );
}

void H225_H310Caps::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_H310Caps_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_dataRatesSupported ) ) {
    proto_tree *dataRatesSupported_tree = (proto_tree*) NULL;
    proto_item *dataRatesSupported_ti = (proto_item*) NULL;
    dataRatesSupported_ti = proto_tree_add_text( tree, tvb, offset + m_dataRatesSupported.GetStartByte(), m_dataRatesSupported.GetByteLength(), "dataRatesSupported (DataRate)" );
    dataRatesSupported_tree = proto_item_add_subtree( dataRatesSupported_ti, hCont->h225_1.ett_h225_H310Caps_dataRatesSupported );
    m_dataRatesSupported.showEthereal( dataRatesSupported_tree, tvb, offset );
  }

  if ( HasOptionalField( e_supportedPrefixes ) ) {
    proto_tree *supportedPrefixes_tree = (proto_tree*) NULL;
    proto_item *supportedPrefixes_ti = (proto_item*) NULL;
    supportedPrefixes_ti = proto_tree_add_text( tree, tvb, offset + m_supportedPrefixes.GetStartByte(), m_supportedPrefixes.GetByteLength(), "supportedPrefixes (SupportedPrefix)" );
    supportedPrefixes_tree = proto_item_add_subtree( supportedPrefixes_ti, hCont->h225_1.ett_h225_H310Caps_supportedPrefixes );
    m_supportedPrefixes.showEthereal( supportedPrefixes_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// H320Caps
//

H225_H320Caps::H225_H320Caps(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 2)
{
  IncludeOptionalField(e_supportedPrefixes);
}


#ifndef PASN_NOPRINTON
void H225_H320Caps::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_dataRatesSupported))
    strm << setw(indent+21) << "dataRatesSupported = " << setprecision(indent) << m_dataRatesSupported << '\n';
  if (HasOptionalField(e_supportedPrefixes))
    strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_H320Caps::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_H320Caps::Class()), PInvalidCast);
#endif
  const H225_H320Caps & other = (const H225_H320Caps &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_H320Caps::GetDataLength() const
{
  return m_nonStandardData.GetObjectLength();
}


BOOL H225_H320Caps::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_dataRatesSupported, m_dataRatesSupported ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_supportedPrefixes, m_supportedPrefixes ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_H320Caps::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_dataRatesSupported, m_dataRatesSupported);
  KnownExtensionEncode(strm, e_supportedPrefixes, m_supportedPrefixes);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_H320Caps::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_H320Caps::Class()), PInvalidCast);
#endif
  return new H225_H320Caps(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_H320Caps::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_dataRatesSupported ) ) 
      m_dataRatesSupported.preShowEthereal( );
  if ( HasOptionalField( e_supportedPrefixes ) ) 
      m_supportedPrefixes.preShowEthereal( );
}

PString H225_H320Caps::getSummary( void ) 
{
  return PString( "H320Caps" );
}

void H225_H320Caps::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_H320Caps_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_dataRatesSupported ) ) {
    proto_tree *dataRatesSupported_tree = (proto_tree*) NULL;
    proto_item *dataRatesSupported_ti = (proto_item*) NULL;
    dataRatesSupported_ti = proto_tree_add_text( tree, tvb, offset + m_dataRatesSupported.GetStartByte(), m_dataRatesSupported.GetByteLength(), "dataRatesSupported (DataRate)" );
    dataRatesSupported_tree = proto_item_add_subtree( dataRatesSupported_ti, hCont->h225_1.ett_h225_H320Caps_dataRatesSupported );
    m_dataRatesSupported.showEthereal( dataRatesSupported_tree, tvb, offset );
  }

  if ( HasOptionalField( e_supportedPrefixes ) ) {
    proto_tree *supportedPrefixes_tree = (proto_tree*) NULL;
    proto_item *supportedPrefixes_ti = (proto_item*) NULL;
    supportedPrefixes_ti = proto_tree_add_text( tree, tvb, offset + m_supportedPrefixes.GetStartByte(), m_supportedPrefixes.GetByteLength(), "supportedPrefixes (SupportedPrefix)" );
    supportedPrefixes_tree = proto_item_add_subtree( supportedPrefixes_ti, hCont->h225_1.ett_h225_H320Caps_supportedPrefixes );
    m_supportedPrefixes.showEthereal( supportedPrefixes_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// H321Caps
//

H225_H321Caps::H225_H321Caps(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 2)
{
  IncludeOptionalField(e_supportedPrefixes);
}


#ifndef PASN_NOPRINTON
void H225_H321Caps::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_dataRatesSupported))
    strm << setw(indent+21) << "dataRatesSupported = " << setprecision(indent) << m_dataRatesSupported << '\n';
  if (HasOptionalField(e_supportedPrefixes))
    strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_H321Caps::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_H321Caps::Class()), PInvalidCast);
#endif
  const H225_H321Caps & other = (const H225_H321Caps &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_H321Caps::GetDataLength() const
{
  return m_nonStandardData.GetObjectLength();
}


BOOL H225_H321Caps::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_dataRatesSupported, m_dataRatesSupported ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_supportedPrefixes, m_supportedPrefixes ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_H321Caps::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_dataRatesSupported, m_dataRatesSupported);
  KnownExtensionEncode(strm, e_supportedPrefixes, m_supportedPrefixes);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_H321Caps::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_H321Caps::Class()), PInvalidCast);
#endif
  return new H225_H321Caps(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_H321Caps::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_dataRatesSupported ) ) 
      m_dataRatesSupported.preShowEthereal( );
  if ( HasOptionalField( e_supportedPrefixes ) ) 
      m_supportedPrefixes.preShowEthereal( );
}

PString H225_H321Caps::getSummary( void ) 
{
  return PString( "H321Caps" );
}

void H225_H321Caps::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_H321Caps_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_dataRatesSupported ) ) {
    proto_tree *dataRatesSupported_tree = (proto_tree*) NULL;
    proto_item *dataRatesSupported_ti = (proto_item*) NULL;
    dataRatesSupported_ti = proto_tree_add_text( tree, tvb, offset + m_dataRatesSupported.GetStartByte(), m_dataRatesSupported.GetByteLength(), "dataRatesSupported (DataRate)" );
    dataRatesSupported_tree = proto_item_add_subtree( dataRatesSupported_ti, hCont->h225_1.ett_h225_H321Caps_dataRatesSupported );
    m_dataRatesSupported.showEthereal( dataRatesSupported_tree, tvb, offset );
  }

  if ( HasOptionalField( e_supportedPrefixes ) ) {
    proto_tree *supportedPrefixes_tree = (proto_tree*) NULL;
    proto_item *supportedPrefixes_ti = (proto_item*) NULL;
    supportedPrefixes_ti = proto_tree_add_text( tree, tvb, offset + m_supportedPrefixes.GetStartByte(), m_supportedPrefixes.GetByteLength(), "supportedPrefixes (SupportedPrefix)" );
    supportedPrefixes_tree = proto_item_add_subtree( supportedPrefixes_ti, hCont->h225_1.ett_h225_H321Caps_supportedPrefixes );
    m_supportedPrefixes.showEthereal( supportedPrefixes_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// H322Caps
//

H225_H322Caps::H225_H322Caps(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 2)
{
  IncludeOptionalField(e_supportedPrefixes);
}


#ifndef PASN_NOPRINTON
void H225_H322Caps::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_dataRatesSupported))
    strm << setw(indent+21) << "dataRatesSupported = " << setprecision(indent) << m_dataRatesSupported << '\n';
  if (HasOptionalField(e_supportedPrefixes))
    strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_H322Caps::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_H322Caps::Class()), PInvalidCast);
#endif
  const H225_H322Caps & other = (const H225_H322Caps &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_H322Caps::GetDataLength() const
{
  return m_nonStandardData.GetObjectLength();
}


BOOL H225_H322Caps::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_dataRatesSupported, m_dataRatesSupported ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_supportedPrefixes, m_supportedPrefixes ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_H322Caps::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_dataRatesSupported, m_dataRatesSupported);
  KnownExtensionEncode(strm, e_supportedPrefixes, m_supportedPrefixes);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_H322Caps::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_H322Caps::Class()), PInvalidCast);
#endif
  return new H225_H322Caps(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_H322Caps::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_dataRatesSupported ) ) 
      m_dataRatesSupported.preShowEthereal( );
  if ( HasOptionalField( e_supportedPrefixes ) ) 
      m_supportedPrefixes.preShowEthereal( );
}

PString H225_H322Caps::getSummary( void ) 
{
  return PString( "H322Caps" );
}

void H225_H322Caps::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_H322Caps_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_dataRatesSupported ) ) {
    proto_tree *dataRatesSupported_tree = (proto_tree*) NULL;
    proto_item *dataRatesSupported_ti = (proto_item*) NULL;
    dataRatesSupported_ti = proto_tree_add_text( tree, tvb, offset + m_dataRatesSupported.GetStartByte(), m_dataRatesSupported.GetByteLength(), "dataRatesSupported (DataRate)" );
    dataRatesSupported_tree = proto_item_add_subtree( dataRatesSupported_ti, hCont->h225_1.ett_h225_H322Caps_dataRatesSupported );
    m_dataRatesSupported.showEthereal( dataRatesSupported_tree, tvb, offset );
  }

  if ( HasOptionalField( e_supportedPrefixes ) ) {
    proto_tree *supportedPrefixes_tree = (proto_tree*) NULL;
    proto_item *supportedPrefixes_ti = (proto_item*) NULL;
    supportedPrefixes_ti = proto_tree_add_text( tree, tvb, offset + m_supportedPrefixes.GetStartByte(), m_supportedPrefixes.GetByteLength(), "supportedPrefixes (SupportedPrefix)" );
    supportedPrefixes_tree = proto_item_add_subtree( supportedPrefixes_ti, hCont->h225_1.ett_h225_H322Caps_supportedPrefixes );
    m_supportedPrefixes.showEthereal( supportedPrefixes_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// H323Caps
//

H225_H323Caps::H225_H323Caps(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 2)
{
  IncludeOptionalField(e_supportedPrefixes);
}


#ifndef PASN_NOPRINTON
void H225_H323Caps::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_dataRatesSupported))
    strm << setw(indent+21) << "dataRatesSupported = " << setprecision(indent) << m_dataRatesSupported << '\n';
  if (HasOptionalField(e_supportedPrefixes))
    strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_H323Caps::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_H323Caps::Class()), PInvalidCast);
#endif
  const H225_H323Caps & other = (const H225_H323Caps &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_H323Caps::GetDataLength() const
{
  return m_nonStandardData.GetObjectLength();
}


BOOL H225_H323Caps::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_dataRatesSupported, m_dataRatesSupported ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_supportedPrefixes, m_supportedPrefixes ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_H323Caps::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_dataRatesSupported, m_dataRatesSupported);
  KnownExtensionEncode(strm, e_supportedPrefixes, m_supportedPrefixes);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_H323Caps::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_H323Caps::Class()), PInvalidCast);
#endif
  return new H225_H323Caps(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_H323Caps::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_dataRatesSupported ) ) 
      m_dataRatesSupported.preShowEthereal( );
  if ( HasOptionalField( e_supportedPrefixes ) ) 
      m_supportedPrefixes.preShowEthereal( );
}

PString H225_H323Caps::getSummary( void ) 
{
  return PString( "H323Caps" );
}

void H225_H323Caps::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_H323Caps_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_dataRatesSupported ) ) {
    proto_tree *dataRatesSupported_tree = (proto_tree*) NULL;
    proto_item *dataRatesSupported_ti = (proto_item*) NULL;
    dataRatesSupported_ti = proto_tree_add_text( tree, tvb, offset + m_dataRatesSupported.GetStartByte(), m_dataRatesSupported.GetByteLength(), "dataRatesSupported (DataRate)" );
    dataRatesSupported_tree = proto_item_add_subtree( dataRatesSupported_ti, hCont->h225_1.ett_h225_H323Caps_dataRatesSupported );
    m_dataRatesSupported.showEthereal( dataRatesSupported_tree, tvb, offset );
  }

  if ( HasOptionalField( e_supportedPrefixes ) ) {
    proto_tree *supportedPrefixes_tree = (proto_tree*) NULL;
    proto_item *supportedPrefixes_ti = (proto_item*) NULL;
    supportedPrefixes_ti = proto_tree_add_text( tree, tvb, offset + m_supportedPrefixes.GetStartByte(), m_supportedPrefixes.GetByteLength(), "supportedPrefixes (SupportedPrefix)" );
    supportedPrefixes_tree = proto_item_add_subtree( supportedPrefixes_ti, hCont->h225_1.ett_h225_H323Caps_supportedPrefixes );
    m_supportedPrefixes.showEthereal( supportedPrefixes_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// H324Caps
//

H225_H324Caps::H225_H324Caps(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 2)
{
  IncludeOptionalField(e_supportedPrefixes);
}


#ifndef PASN_NOPRINTON
void H225_H324Caps::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_dataRatesSupported))
    strm << setw(indent+21) << "dataRatesSupported = " << setprecision(indent) << m_dataRatesSupported << '\n';
  if (HasOptionalField(e_supportedPrefixes))
    strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_H324Caps::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_H324Caps::Class()), PInvalidCast);
#endif
  const H225_H324Caps & other = (const H225_H324Caps &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_H324Caps::GetDataLength() const
{
  return m_nonStandardData.GetObjectLength();
}


BOOL H225_H324Caps::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_dataRatesSupported, m_dataRatesSupported ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_supportedPrefixes, m_supportedPrefixes ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_H324Caps::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_dataRatesSupported, m_dataRatesSupported);
  KnownExtensionEncode(strm, e_supportedPrefixes, m_supportedPrefixes);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_H324Caps::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_H324Caps::Class()), PInvalidCast);
#endif
  return new H225_H324Caps(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_H324Caps::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_dataRatesSupported ) ) 
      m_dataRatesSupported.preShowEthereal( );
  if ( HasOptionalField( e_supportedPrefixes ) ) 
      m_supportedPrefixes.preShowEthereal( );
}

PString H225_H324Caps::getSummary( void ) 
{
  return PString( "H324Caps" );
}

void H225_H324Caps::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_H324Caps_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_dataRatesSupported ) ) {
    proto_tree *dataRatesSupported_tree = (proto_tree*) NULL;
    proto_item *dataRatesSupported_ti = (proto_item*) NULL;
    dataRatesSupported_ti = proto_tree_add_text( tree, tvb, offset + m_dataRatesSupported.GetStartByte(), m_dataRatesSupported.GetByteLength(), "dataRatesSupported (DataRate)" );
    dataRatesSupported_tree = proto_item_add_subtree( dataRatesSupported_ti, hCont->h225_1.ett_h225_H324Caps_dataRatesSupported );
    m_dataRatesSupported.showEthereal( dataRatesSupported_tree, tvb, offset );
  }

  if ( HasOptionalField( e_supportedPrefixes ) ) {
    proto_tree *supportedPrefixes_tree = (proto_tree*) NULL;
    proto_item *supportedPrefixes_ti = (proto_item*) NULL;
    supportedPrefixes_ti = proto_tree_add_text( tree, tvb, offset + m_supportedPrefixes.GetStartByte(), m_supportedPrefixes.GetByteLength(), "supportedPrefixes (SupportedPrefix)" );
    supportedPrefixes_tree = proto_item_add_subtree( supportedPrefixes_ti, hCont->h225_1.ett_h225_H324Caps_supportedPrefixes );
    m_supportedPrefixes.showEthereal( supportedPrefixes_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// VoiceCaps
//

H225_VoiceCaps::H225_VoiceCaps(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 2)
{
  IncludeOptionalField(e_supportedPrefixes);
}


#ifndef PASN_NOPRINTON
void H225_VoiceCaps::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_dataRatesSupported))
    strm << setw(indent+21) << "dataRatesSupported = " << setprecision(indent) << m_dataRatesSupported << '\n';
  if (HasOptionalField(e_supportedPrefixes))
    strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_VoiceCaps::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_VoiceCaps::Class()), PInvalidCast);
#endif
  const H225_VoiceCaps & other = (const H225_VoiceCaps &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_VoiceCaps::GetDataLength() const
{
  return m_nonStandardData.GetObjectLength();
}


BOOL H225_VoiceCaps::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_dataRatesSupported, m_dataRatesSupported ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_supportedPrefixes, m_supportedPrefixes ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_VoiceCaps::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_dataRatesSupported, m_dataRatesSupported);
  KnownExtensionEncode(strm, e_supportedPrefixes, m_supportedPrefixes);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_VoiceCaps::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_VoiceCaps::Class()), PInvalidCast);
#endif
  return new H225_VoiceCaps(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_VoiceCaps::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_dataRatesSupported ) ) 
      m_dataRatesSupported.preShowEthereal( );
  if ( HasOptionalField( e_supportedPrefixes ) ) 
      m_supportedPrefixes.preShowEthereal( );
}

PString H225_VoiceCaps::getSummary( void ) 
{
  return PString( "VoiceCaps" );
}

void H225_VoiceCaps::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_VoiceCaps_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_dataRatesSupported ) ) {
    proto_tree *dataRatesSupported_tree = (proto_tree*) NULL;
    proto_item *dataRatesSupported_ti = (proto_item*) NULL;
    dataRatesSupported_ti = proto_tree_add_text( tree, tvb, offset + m_dataRatesSupported.GetStartByte(), m_dataRatesSupported.GetByteLength(), "dataRatesSupported (DataRate)" );
    dataRatesSupported_tree = proto_item_add_subtree( dataRatesSupported_ti, hCont->h225_1.ett_h225_VoiceCaps_dataRatesSupported );
    m_dataRatesSupported.showEthereal( dataRatesSupported_tree, tvb, offset );
  }

  if ( HasOptionalField( e_supportedPrefixes ) ) {
    proto_tree *supportedPrefixes_tree = (proto_tree*) NULL;
    proto_item *supportedPrefixes_ti = (proto_item*) NULL;
    supportedPrefixes_ti = proto_tree_add_text( tree, tvb, offset + m_supportedPrefixes.GetStartByte(), m_supportedPrefixes.GetByteLength(), "supportedPrefixes (SupportedPrefix)" );
    supportedPrefixes_tree = proto_item_add_subtree( supportedPrefixes_ti, hCont->h225_1.ett_h225_VoiceCaps_supportedPrefixes );
    m_supportedPrefixes.showEthereal( supportedPrefixes_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// T120OnlyCaps
//

H225_T120OnlyCaps::H225_T120OnlyCaps(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 2)
{
  IncludeOptionalField(e_supportedPrefixes);
}


#ifndef PASN_NOPRINTON
void H225_T120OnlyCaps::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_dataRatesSupported))
    strm << setw(indent+21) << "dataRatesSupported = " << setprecision(indent) << m_dataRatesSupported << '\n';
  if (HasOptionalField(e_supportedPrefixes))
    strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_T120OnlyCaps::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_T120OnlyCaps::Class()), PInvalidCast);
#endif
  const H225_T120OnlyCaps & other = (const H225_T120OnlyCaps &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_T120OnlyCaps::GetDataLength() const
{
  return m_nonStandardData.GetObjectLength();
}


BOOL H225_T120OnlyCaps::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_dataRatesSupported, m_dataRatesSupported ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_supportedPrefixes, m_supportedPrefixes ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_T120OnlyCaps::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_dataRatesSupported, m_dataRatesSupported);
  KnownExtensionEncode(strm, e_supportedPrefixes, m_supportedPrefixes);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_T120OnlyCaps::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_T120OnlyCaps::Class()), PInvalidCast);
#endif
  return new H225_T120OnlyCaps(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_T120OnlyCaps::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_dataRatesSupported ) ) 
      m_dataRatesSupported.preShowEthereal( );
  if ( HasOptionalField( e_supportedPrefixes ) ) 
      m_supportedPrefixes.preShowEthereal( );
}

PString H225_T120OnlyCaps::getSummary( void ) 
{
  return PString( "T120OnlyCaps" );
}

void H225_T120OnlyCaps::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_T120OnlyCaps_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_dataRatesSupported ) ) {
    proto_tree *dataRatesSupported_tree = (proto_tree*) NULL;
    proto_item *dataRatesSupported_ti = (proto_item*) NULL;
    dataRatesSupported_ti = proto_tree_add_text( tree, tvb, offset + m_dataRatesSupported.GetStartByte(), m_dataRatesSupported.GetByteLength(), "dataRatesSupported (DataRate)" );
    dataRatesSupported_tree = proto_item_add_subtree( dataRatesSupported_ti, hCont->h225_1.ett_h225_T120OnlyCaps_dataRatesSupported );
    m_dataRatesSupported.showEthereal( dataRatesSupported_tree, tvb, offset );
  }

  if ( HasOptionalField( e_supportedPrefixes ) ) {
    proto_tree *supportedPrefixes_tree = (proto_tree*) NULL;
    proto_item *supportedPrefixes_ti = (proto_item*) NULL;
    supportedPrefixes_ti = proto_tree_add_text( tree, tvb, offset + m_supportedPrefixes.GetStartByte(), m_supportedPrefixes.GetByteLength(), "supportedPrefixes (SupportedPrefix)" );
    supportedPrefixes_tree = proto_item_add_subtree( supportedPrefixes_ti, hCont->h225_1.ett_h225_T120OnlyCaps_supportedPrefixes );
    m_supportedPrefixes.showEthereal( supportedPrefixes_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// NonStandardProtocol
//

H225_NonStandardProtocol::H225_NonStandardProtocol(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_NonStandardProtocol::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_dataRatesSupported))
    strm << setw(indent+21) << "dataRatesSupported = " << setprecision(indent) << m_dataRatesSupported << '\n';
  strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_NonStandardProtocol::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_NonStandardProtocol::Class()), PInvalidCast);
#endif
  const H225_NonStandardProtocol & other = (const H225_NonStandardProtocol &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_dataRatesSupported.Compare(other.m_dataRatesSupported)) != EqualTo)
    return result;
  if ((result = m_supportedPrefixes.Compare(other.m_supportedPrefixes)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_NonStandardProtocol::GetDataLength() const
{
  return m_nonStandardData.GetObjectLength() +
         m_dataRatesSupported.GetObjectLength() +
         m_supportedPrefixes.GetObjectLength();
}


BOOL H225_NonStandardProtocol::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_dataRatesSupported ) && !m_dataRatesSupported.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_supportedPrefixes.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_NonStandardProtocol::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_dataRatesSupported))
    m_dataRatesSupported.Encode(strm);
  m_supportedPrefixes.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_dataRatesSupported))
    m_dataRatesSupported.Encode(strm);
  m_supportedPrefixes.Encode(strm);
}


PObject * H225_NonStandardProtocol::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_NonStandardProtocol::Class()), PInvalidCast);
#endif
  return new H225_NonStandardProtocol(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_NonStandardProtocol::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_dataRatesSupported ) ) 
      m_dataRatesSupported.preShowEthereal( );
  m_supportedPrefixes.preShowEthereal( );
}

PString H225_NonStandardProtocol::getSummary( void ) 
{
  return PString( "NonStandardProtocol" );
}

void H225_NonStandardProtocol::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_NonStandardProtocol_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_dataRatesSupported ) ) {
    proto_tree *dataRatesSupported_tree = (proto_tree*) NULL;
    proto_item *dataRatesSupported_ti = (proto_item*) NULL;
    dataRatesSupported_ti = proto_tree_add_text( tree, tvb, offset + m_dataRatesSupported.GetStartByte(), m_dataRatesSupported.GetByteLength(), "dataRatesSupported (DataRate)" );
    dataRatesSupported_tree = proto_item_add_subtree( dataRatesSupported_ti, hCont->h225_1.ett_h225_NonStandardProtocol_dataRatesSupported );
    m_dataRatesSupported.showEthereal( dataRatesSupported_tree, tvb, offset );
  }

  proto_tree *supportedPrefixes_tree = (proto_tree*) NULL;
  proto_item *supportedPrefixes_ti = (proto_item*) NULL;
  supportedPrefixes_ti = proto_tree_add_text( tree, tvb, offset + m_supportedPrefixes.GetStartByte(), m_supportedPrefixes.GetByteLength(), "supportedPrefixes (SupportedPrefix)" );
  supportedPrefixes_tree = proto_item_add_subtree( supportedPrefixes_ti, hCont->h225_1.ett_h225_NonStandardProtocol_supportedPrefixes );

  m_supportedPrefixes.showEthereal( supportedPrefixes_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// T38FaxAnnexbOnlyCaps
//

H225_T38FaxAnnexbOnlyCaps::H225_T38FaxAnnexbOnlyCaps(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_T38FaxAnnexbOnlyCaps::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_dataRatesSupported))
    strm << setw(indent+21) << "dataRatesSupported = " << setprecision(indent) << m_dataRatesSupported << '\n';
  strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  strm << setw(indent+17) << "t38FaxProtocol = " << setprecision(indent) << m_t38FaxProtocol << '\n';
  strm << setw(indent+16) << "t38FaxProfile = " << setprecision(indent) << m_t38FaxProfile << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_T38FaxAnnexbOnlyCaps::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_T38FaxAnnexbOnlyCaps::Class()), PInvalidCast);
#endif
  const H225_T38FaxAnnexbOnlyCaps & other = (const H225_T38FaxAnnexbOnlyCaps &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_dataRatesSupported.Compare(other.m_dataRatesSupported)) != EqualTo)
    return result;
  if ((result = m_supportedPrefixes.Compare(other.m_supportedPrefixes)) != EqualTo)
    return result;
  if ((result = m_t38FaxProtocol.Compare(other.m_t38FaxProtocol)) != EqualTo)
    return result;
  if ((result = m_t38FaxProfile.Compare(other.m_t38FaxProfile)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_T38FaxAnnexbOnlyCaps::GetDataLength() const
{
  return m_nonStandardData.GetObjectLength() +
         m_dataRatesSupported.GetObjectLength() +
         m_supportedPrefixes.GetObjectLength() +
         m_t38FaxProtocol.GetObjectLength() +
         m_t38FaxProfile.GetObjectLength();
}


BOOL H225_T38FaxAnnexbOnlyCaps::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_dataRatesSupported ) && !m_dataRatesSupported.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_supportedPrefixes.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_t38FaxProtocol.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_t38FaxProfile.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_T38FaxAnnexbOnlyCaps::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_dataRatesSupported))
    m_dataRatesSupported.Encode(strm);
  m_supportedPrefixes.Encode(strm);
  m_t38FaxProtocol.Encode(strm);
  m_t38FaxProfile.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_dataRatesSupported))
    m_dataRatesSupported.Encode(strm);
  m_supportedPrefixes.Encode(strm);
  m_t38FaxProtocol.Encode(strm);
  m_t38FaxProfile.Encode(strm);
}


PObject * H225_T38FaxAnnexbOnlyCaps::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_T38FaxAnnexbOnlyCaps::Class()), PInvalidCast);
#endif
  return new H225_T38FaxAnnexbOnlyCaps(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_T38FaxAnnexbOnlyCaps::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_dataRatesSupported ) ) 
      m_dataRatesSupported.preShowEthereal( );
  m_supportedPrefixes.preShowEthereal( );
  m_t38FaxProtocol.preShowEthereal( );
  m_t38FaxProfile.preShowEthereal( );
}

PString H225_T38FaxAnnexbOnlyCaps::getSummary( void ) 
{
  return PString( "T38FaxAnnexbOnlyCaps" );
}

void H225_T38FaxAnnexbOnlyCaps::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_T38FaxAnnexbOnlyCaps_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_dataRatesSupported ) ) {
    proto_tree *dataRatesSupported_tree = (proto_tree*) NULL;
    proto_item *dataRatesSupported_ti = (proto_item*) NULL;
    dataRatesSupported_ti = proto_tree_add_text( tree, tvb, offset + m_dataRatesSupported.GetStartByte(), m_dataRatesSupported.GetByteLength(), "dataRatesSupported (DataRate)" );
    dataRatesSupported_tree = proto_item_add_subtree( dataRatesSupported_ti, hCont->h225_1.ett_h225_T38FaxAnnexbOnlyCaps_dataRatesSupported );
    m_dataRatesSupported.showEthereal( dataRatesSupported_tree, tvb, offset );
  }

  proto_tree *supportedPrefixes_tree = (proto_tree*) NULL;
  proto_item *supportedPrefixes_ti = (proto_item*) NULL;
  supportedPrefixes_ti = proto_tree_add_text( tree, tvb, offset + m_supportedPrefixes.GetStartByte(), m_supportedPrefixes.GetByteLength(), "supportedPrefixes (SupportedPrefix)" );
  supportedPrefixes_tree = proto_item_add_subtree( supportedPrefixes_ti, hCont->h225_1.ett_h225_T38FaxAnnexbOnlyCaps_supportedPrefixes );

  m_supportedPrefixes.showEthereal( supportedPrefixes_tree, tvb, offset );

  /* This member is defined outside the current ASN.1 file, 
   * therefore it's not known what type it is. The safest
   * solution is to add another subtree and let the class handle itself
   */
  proto_tree *t38FaxProtocol_tree = (proto_tree*) NULL;
  proto_item *t38FaxProtocol_ti = (proto_item*) NULL;
  t38FaxProtocol_ti = proto_tree_add_text( tree, tvb, offset + m_t38FaxProtocol.GetStartByte(), m_t38FaxProtocol.GetByteLength(), "t38FaxProtocol (MULTIMEDIA-DataProtocolCapability)" );
  t38FaxProtocol_tree = proto_item_add_subtree( t38FaxProtocol_ti, hCont->h225_1.ett_h225_T38FaxAnnexbOnlyCaps_t38FaxProtocol );

  m_t38FaxProtocol.showEthereal( t38FaxProtocol_tree, tvb, offset );

  /* This member is defined outside the current ASN.1 file, 
   * therefore it's not known what type it is. The safest
   * solution is to add another subtree and let the class handle itself
   */
  proto_tree *t38FaxProfile_tree = (proto_tree*) NULL;
  proto_item *t38FaxProfile_ti = (proto_item*) NULL;
  t38FaxProfile_ti = proto_tree_add_text( tree, tvb, offset + m_t38FaxProfile.GetStartByte(), m_t38FaxProfile.GetByteLength(), "t38FaxProfile (MULTIMEDIA-T38FaxProfile)" );
  t38FaxProfile_tree = proto_item_add_subtree( t38FaxProfile_ti, hCont->h225_1.ett_h225_T38FaxAnnexbOnlyCaps_t38FaxProfile );

  m_t38FaxProfile.showEthereal( t38FaxProfile_tree, tvb, offset );

}
#endif  //USE_FOR_ETHEREAL

//
// McuInfo
//

H225_McuInfo::H225_McuInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_McuInfo::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_McuInfo::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_McuInfo::Class()), PInvalidCast);
#endif
  const H225_McuInfo & other = (const H225_McuInfo &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_McuInfo::GetDataLength() const
{
  return m_nonStandardData.GetObjectLength();
}


BOOL H225_McuInfo::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_McuInfo::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_McuInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_McuInfo::Class()), PInvalidCast);
#endif
  return new H225_McuInfo(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_McuInfo::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
}

PString H225_McuInfo::getSummary( void ) 
{
  return PString( "McuInfo" );
}

void H225_McuInfo::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_McuInfo_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// TerminalInfo
//

H225_TerminalInfo::H225_TerminalInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_TerminalInfo::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_TerminalInfo::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_TerminalInfo::Class()), PInvalidCast);
#endif
  const H225_TerminalInfo & other = (const H225_TerminalInfo &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_TerminalInfo::GetDataLength() const
{
  return m_nonStandardData.GetObjectLength();
}


BOOL H225_TerminalInfo::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_TerminalInfo::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_TerminalInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_TerminalInfo::Class()), PInvalidCast);
#endif
  return new H225_TerminalInfo(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_TerminalInfo::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
}

PString H225_TerminalInfo::getSummary( void ) 
{
  return PString( "TerminalInfo" );
}

void H225_TerminalInfo::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_TerminalInfo_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// GatekeeperInfo
//

H225_GatekeeperInfo::H225_GatekeeperInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_GatekeeperInfo::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_GatekeeperInfo::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_GatekeeperInfo::Class()), PInvalidCast);
#endif
  const H225_GatekeeperInfo & other = (const H225_GatekeeperInfo &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_GatekeeperInfo::GetDataLength() const
{
  return m_nonStandardData.GetObjectLength();
}


BOOL H225_GatekeeperInfo::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_GatekeeperInfo::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_GatekeeperInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_GatekeeperInfo::Class()), PInvalidCast);
#endif
  return new H225_GatekeeperInfo(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_GatekeeperInfo::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
}

PString H225_GatekeeperInfo::getSummary( void ) 
{
  return PString( "GatekeeperInfo" );
}

void H225_GatekeeperInfo::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_GatekeeperInfo_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// RegistrationConfirm
//

H225_RegistrationConfirm::H225_RegistrationConfirm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 8)
{
  IncludeOptionalField(e_willRespondToIRR);
  IncludeOptionalField(e_maintainConnection);
}


#ifndef PASN_NOPRINTON
void H225_RegistrationConfirm::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+20) << "callSignalAddress = " << setprecision(indent) << m_callSignalAddress << '\n';
  if (HasOptionalField(e_terminalAlias))
    strm << setw(indent+16) << "terminalAlias = " << setprecision(indent) << m_terminalAlias << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  strm << setw(indent+21) << "endpointIdentifier = " << setprecision(indent) << m_endpointIdentifier << '\n';
  if (HasOptionalField(e_alternateGatekeeper))
    strm << setw(indent+22) << "alternateGatekeeper = " << setprecision(indent) << m_alternateGatekeeper << '\n';
  if (HasOptionalField(e_timeToLive))
    strm << setw(indent+13) << "timeToLive = " << setprecision(indent) << m_timeToLive << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_willRespondToIRR))
    strm << setw(indent+19) << "willRespondToIRR = " << setprecision(indent) << m_willRespondToIRR << '\n';
  if (HasOptionalField(e_preGrantedARQ))
    strm << setw(indent+16) << "preGrantedARQ = " << setprecision(indent) << m_preGrantedARQ << '\n';
  if (HasOptionalField(e_maintainConnection))
    strm << setw(indent+21) << "maintainConnection = " << setprecision(indent) << m_maintainConnection << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_RegistrationConfirm::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_RegistrationConfirm::Class()), PInvalidCast);
#endif
  const H225_RegistrationConfirm & other = (const H225_RegistrationConfirm &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_callSignalAddress.Compare(other.m_callSignalAddress)) != EqualTo)
    return result;
  if ((result = m_terminalAlias.Compare(other.m_terminalAlias)) != EqualTo)
    return result;
  if ((result = m_gatekeeperIdentifier.Compare(other.m_gatekeeperIdentifier)) != EqualTo)
    return result;
  if ((result = m_endpointIdentifier.Compare(other.m_endpointIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_RegistrationConfirm::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_protocolIdentifier.GetObjectLength() +
         m_nonStandardData.GetObjectLength() +
         m_callSignalAddress.GetObjectLength() +
         m_terminalAlias.GetObjectLength() +
         m_gatekeeperIdentifier.GetObjectLength() +
         m_endpointIdentifier.GetObjectLength();
}


BOOL H225_RegistrationConfirm::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_protocolIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callSignalAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_terminalAlias ) && !m_terminalAlias.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_gatekeeperIdentifier ) && !m_gatekeeperIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_endpointIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_alternateGatekeeper, m_alternateGatekeeper ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_timeToLive, m_timeToLive ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_willRespondToIRR, m_willRespondToIRR ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_preGrantedARQ, m_preGrantedARQ ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_maintainConnection, m_maintainConnection ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_RegistrationConfirm::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_callSignalAddress.Encode(strm);
  if (HasOptionalField(e_terminalAlias))
    m_terminalAlias.Encode(strm);
  if (HasOptionalField(e_gatekeeperIdentifier))
    m_gatekeeperIdentifier.Encode(strm);
  m_endpointIdentifier.Encode(strm);
  KnownExtensionEncode(strm, e_alternateGatekeeper, m_alternateGatekeeper);
  KnownExtensionEncode(strm, e_timeToLive, m_timeToLive);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_willRespondToIRR, m_willRespondToIRR);
  KnownExtensionEncode(strm, e_preGrantedARQ, m_preGrantedARQ);
  KnownExtensionEncode(strm, e_maintainConnection, m_maintainConnection);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_callSignalAddress.Encode(strm);
  if (HasOptionalField(e_terminalAlias))
    m_terminalAlias.Encode(strm);
  if (HasOptionalField(e_gatekeeperIdentifier))
    m_gatekeeperIdentifier.Encode(strm);
  m_endpointIdentifier.Encode(strm);
}


PObject * H225_RegistrationConfirm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_RegistrationConfirm::Class()), PInvalidCast);
#endif
  return new H225_RegistrationConfirm(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_RegistrationConfirm::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  m_protocolIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  m_callSignalAddress.preShowEthereal( );
  if ( HasOptionalField( e_terminalAlias ) ) 
      m_terminalAlias.preShowEthereal( );
  if ( HasOptionalField( e_gatekeeperIdentifier ) ) 
      m_gatekeeperIdentifier.preShowEthereal( );
  m_endpointIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_alternateGatekeeper ) ) 
      m_alternateGatekeeper.preShowEthereal( );
  if ( HasOptionalField( e_timeToLive ) ) 
      m_timeToLive.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
  if ( HasOptionalField( e_willRespondToIRR ) ) 
      m_willRespondToIRR.preShowEthereal( );
  if ( HasOptionalField( e_preGrantedARQ ) ) 
      m_preGrantedARQ.preShowEthereal( );
  if ( HasOptionalField( e_maintainConnection ) ) 
      m_maintainConnection.preShowEthereal( );
}

PString H225_RegistrationConfirm::getSummary( void ) 
{
  return PString( "RegistrationConfirm" );
}

void H225_RegistrationConfirm::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_RegistrationConfirm_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  char* pprotocolIdentifier = m_protocolIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h225_1.hf_h225_RegistrationConfirm_protocolIdentifier, tvb, offset + m_protocolIdentifier.GetStartByte(), m_protocolIdentifier.GetByteLength() , pprotocolIdentifier );
  delete[] pprotocolIdentifier;

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_RegistrationConfirm_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  proto_tree *callSignalAddress_tree = (proto_tree*) NULL;
  proto_item *callSignalAddress_ti = (proto_item*) NULL;
  callSignalAddress_ti = proto_tree_add_text( tree, tvb, offset + m_callSignalAddress.GetStartByte(), m_callSignalAddress.GetByteLength(), "callSignalAddress (TransportAddress)" );
  callSignalAddress_tree = proto_item_add_subtree( callSignalAddress_ti, hCont->h225_1.ett_h225_RegistrationConfirm_callSignalAddress );

  m_callSignalAddress.showEthereal( callSignalAddress_tree, tvb, offset );

  if ( HasOptionalField( e_terminalAlias ) ) {
    proto_tree *terminalAlias_tree = (proto_tree*) NULL;
    proto_item *terminalAlias_ti = (proto_item*) NULL;
    terminalAlias_ti = proto_tree_add_text( tree, tvb, offset + m_terminalAlias.GetStartByte(), m_terminalAlias.GetByteLength(), "terminalAlias (AliasAddress)" );
    terminalAlias_tree = proto_item_add_subtree( terminalAlias_ti, hCont->h225_1.ett_h225_RegistrationConfirm_terminalAlias );
    m_terminalAlias.showEthereal( terminalAlias_tree, tvb, offset );
  }

  if ( HasOptionalField( e_gatekeeperIdentifier ) ) {
    char* pgatekeeperIdentifier = m_gatekeeperIdentifier.getValue();
    proto_tree_add_string( tree, hCont->h225_1.hf_h225_RegistrationConfirm_gatekeeperIdentifier, tvb, offset + m_gatekeeperIdentifier.GetStartByte(), m_gatekeeperIdentifier.GetByteLength() , pgatekeeperIdentifier );
    delete[] pgatekeeperIdentifier;
  }

  char* pendpointIdentifier = m_endpointIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h225_1.hf_h225_RegistrationConfirm_endpointIdentifier, tvb, offset + m_endpointIdentifier.GetStartByte(), m_endpointIdentifier.GetByteLength() , pendpointIdentifier );
  delete[] pendpointIdentifier;

  if ( HasOptionalField( e_alternateGatekeeper ) ) {
    proto_tree *alternateGatekeeper_tree = (proto_tree*) NULL;
    proto_item *alternateGatekeeper_ti = (proto_item*) NULL;
    alternateGatekeeper_ti = proto_tree_add_text( tree, tvb, offset + m_alternateGatekeeper.GetStartByte(), m_alternateGatekeeper.GetByteLength(), "alternateGatekeeper (AlternateGK)" );
    alternateGatekeeper_tree = proto_item_add_subtree( alternateGatekeeper_ti, hCont->h225_1.ett_h225_RegistrationConfirm_alternateGatekeeper );
    m_alternateGatekeeper.showEthereal( alternateGatekeeper_tree, tvb, offset );
  }

  if ( HasOptionalField( e_timeToLive ) ) {
    proto_tree_add_uint( tree, hCont->h225_1.hf_h225_RegistrationConfirm_timeToLive, tvb, offset + m_timeToLive.GetStartByte(), m_timeToLive.GetByteLength() , m_timeToLive.GetValue() );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_RegistrationConfirm_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_RegistrationConfirm_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_1.ett_h225_RegistrationConfirm_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

  if ( HasOptionalField( e_willRespondToIRR ) ) {
    proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_RegistrationConfirm_willRespondToIRR, tvb, offset + m_willRespondToIRR.GetStartByte(), m_willRespondToIRR.GetByteLength() , m_willRespondToIRR.GetValue() );
  }

  if ( HasOptionalField( e_preGrantedARQ ) ) {
    proto_tree *preGrantedARQ_tree = (proto_tree*) NULL;
    proto_item *preGrantedARQ_ti = (proto_item*) NULL;
    preGrantedARQ_ti = proto_tree_add_text( tree, tvb, offset + m_preGrantedARQ.GetStartByte(), m_preGrantedARQ.GetByteLength(), "preGrantedARQ (RegistrationConfirm-preGrantedARQ)" );
    preGrantedARQ_tree = proto_item_add_subtree( preGrantedARQ_ti, hCont->h225_1.ett_h225_RegistrationConfirm_preGrantedARQ );
    m_preGrantedARQ.showEthereal( preGrantedARQ_tree, tvb, offset );
  }

  if ( HasOptionalField( e_maintainConnection ) ) {
    proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_RegistrationConfirm_maintainConnection, tvb, offset + m_maintainConnection.GetStartByte(), m_maintainConnection.GetByteLength() , m_maintainConnection.GetValue() );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// InfoRequestResponse_perCallInfo_subtype_pdu_subtype
//

H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype::H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "h323pdu = " << setprecision(indent) << m_h323pdu << '\n';
  strm << setw(indent+7) << "sent = " << setprecision(indent) << m_sent << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype::Class()), PInvalidCast);
#endif
  const H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype & other = (const H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype &)obj;

  Comparison result;

  if ((result = m_h323pdu.Compare(other.m_h323pdu)) != EqualTo)
    return result;
  if ((result = m_sent.Compare(other.m_sent)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype::GetDataLength() const
{
  return m_h323pdu.GetObjectLength() +
         m_sent.GetObjectLength();
}


BOOL H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_h323pdu.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sent.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_h323pdu.Encode(strm);
  m_sent.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_h323pdu.Encode(strm);
  m_sent.Encode(strm);
}


PObject * H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype::Class()), PInvalidCast);
#endif
  return new H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype::preShowEthereal( void )
{
  m_h323pdu.preShowEthereal( );
  m_sent.preShowEthereal( );
}

PString H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype::getSummary( void ) 
{
  return PString( "InfoRequestResponse_perCallInfo_subtype_pdu_subtype" );
}

void H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *h323pdu_tree = (proto_tree*) NULL;
  proto_item *h323pdu_ti = (proto_item*) NULL;
  h323pdu_ti = proto_tree_add_text( tree, tvb, offset + m_h323pdu.GetStartByte(), m_h323pdu.GetByteLength(), "h323pdu (H323-UU-PDU)" );
  h323pdu_tree = proto_item_add_subtree( h323pdu_ti, hCont->h225_1.ett_h225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype_h323pdu );

  m_h323pdu.showEthereal( h323pdu_tree, tvb, offset );

  proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype_sent, tvb, offset + m_sent.GetStartByte(), m_sent.GetByteLength() , m_sent.GetValue() );

}
#endif  //USE_FOR_ETHEREAL

//
// H323-UserInformation
//

H225_H323_UserInformation::H225_H323_UserInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_H323_UserInformation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "h323_uu_pdu = " << setprecision(indent) << m_h323_uu_pdu << '\n';
  if (HasOptionalField(e_user_data))
    strm << setw(indent+12) << "user_data = " << setprecision(indent) << m_user_data << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_H323_UserInformation::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_H323_UserInformation::Class()), PInvalidCast);
#endif
  const H225_H323_UserInformation & other = (const H225_H323_UserInformation &)obj;

  Comparison result;

  if ((result = m_h323_uu_pdu.Compare(other.m_h323_uu_pdu)) != EqualTo)
    return result;
  if ((result = m_user_data.Compare(other.m_user_data)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_H323_UserInformation::GetDataLength() const
{
  return m_h323_uu_pdu.GetObjectLength() +
         m_user_data.GetObjectLength();
}


BOOL H225_H323_UserInformation::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_h323_uu_pdu.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_user_data ) && !m_user_data.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_H323_UserInformation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_h323_uu_pdu.Encode(strm);
  if (HasOptionalField(e_user_data))
    m_user_data.Encode(strm);

  UnknownExtensionsEncode(strm);
  m_h323_uu_pdu.Encode(strm);
  if (HasOptionalField(e_user_data))
    m_user_data.Encode(strm);
}


PObject * H225_H323_UserInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_H323_UserInformation::Class()), PInvalidCast);
#endif
  return new H225_H323_UserInformation(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_H323_UserInformation::preShowEthereal( void )
{
  m_h323_uu_pdu.preShowEthereal( );
  if ( HasOptionalField( e_user_data ) ) 
      m_user_data.preShowEthereal( );
}

PString H225_H323_UserInformation::getSummary( void ) 
{
  return m_h323_uu_pdu.getSummary();
}

void H225_H323_UserInformation::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree *h323_uu_pdu_tree = (proto_tree*) NULL;
  proto_item *h323_uu_pdu_ti = (proto_item*) NULL;
  h323_uu_pdu_ti = proto_tree_add_text( tree, tvb, offset + m_h323_uu_pdu.GetStartByte(), m_h323_uu_pdu.GetByteLength(), "h323_uu_pdu (H323-UU-PDU)" );
  h323_uu_pdu_tree = proto_item_add_subtree( h323_uu_pdu_ti, hCont->h225_1.ett_h225_H323_UserInformation_h323_uu_pdu );

  m_h323_uu_pdu.showEthereal( h323_uu_pdu_tree, tvb, offset );

  if ( HasOptionalField( e_user_data ) ) {
    proto_tree *user_data_tree = (proto_tree*) NULL;
    proto_item *user_data_ti = (proto_item*) NULL;
    user_data_ti = proto_tree_add_text( tree, tvb, offset + m_user_data.GetStartByte(), m_user_data.GetByteLength(), "user_data (H323-UserInformation-user-data)" );
    user_data_tree = proto_item_add_subtree( user_data_ti, hCont->h225_1.ett_h225_H323_UserInformation_user_data );
    m_user_data.showEthereal( user_data_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// EndpointType
//

H225_EndpointType::H225_EndpointType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 6, TRUE, 1)
{
  m_set.SetConstraints(PASN_Object::FixedConstraint, 32, 32);
}


#ifndef PASN_NOPRINTON
void H225_EndpointType::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_vendor))
    strm << setw(indent+9) << "vendor = " << setprecision(indent) << m_vendor << '\n';
  if (HasOptionalField(e_gatekeeper))
    strm << setw(indent+13) << "gatekeeper = " << setprecision(indent) << m_gatekeeper << '\n';
  if (HasOptionalField(e_gateway))
    strm << setw(indent+10) << "gateway = " << setprecision(indent) << m_gateway << '\n';
  if (HasOptionalField(e_mcu))
    strm << setw(indent+6) << "mcu = " << setprecision(indent) << m_mcu << '\n';
  if (HasOptionalField(e_terminal))
    strm << setw(indent+11) << "terminal = " << setprecision(indent) << m_terminal << '\n';
  strm << setw(indent+5) << "mc = " << setprecision(indent) << m_mc << '\n';
  strm << setw(indent+16) << "undefinedNode = " << setprecision(indent) << m_undefinedNode << '\n';
  if (HasOptionalField(e_set))
    strm << setw(indent+6) << "set = " << setprecision(indent) << m_set << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_EndpointType::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_EndpointType::Class()), PInvalidCast);
#endif
  const H225_EndpointType & other = (const H225_EndpointType &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_vendor.Compare(other.m_vendor)) != EqualTo)
    return result;
  if ((result = m_gatekeeper.Compare(other.m_gatekeeper)) != EqualTo)
    return result;
  if ((result = m_gateway.Compare(other.m_gateway)) != EqualTo)
    return result;
  if ((result = m_mcu.Compare(other.m_mcu)) != EqualTo)
    return result;
  if ((result = m_terminal.Compare(other.m_terminal)) != EqualTo)
    return result;
  if ((result = m_mc.Compare(other.m_mc)) != EqualTo)
    return result;
  if ((result = m_undefinedNode.Compare(other.m_undefinedNode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_EndpointType::GetDataLength() const
{
  return m_nonStandardData.GetObjectLength() +
         m_vendor.GetObjectLength() +
         m_gatekeeper.GetObjectLength() +
         m_gateway.GetObjectLength() +
         m_mcu.GetObjectLength() +
         m_terminal.GetObjectLength() +
         m_mc.GetObjectLength() +
         m_undefinedNode.GetObjectLength();
}


BOOL H225_EndpointType::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_vendor ) && !m_vendor.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_gatekeeper ) && !m_gatekeeper.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_gateway ) && !m_gateway.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_mcu ) && !m_mcu.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_terminal ) && !m_terminal.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_mc.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_undefinedNode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_set, m_set ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_EndpointType::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_vendor))
    m_vendor.Encode(strm);
  if (HasOptionalField(e_gatekeeper))
    m_gatekeeper.Encode(strm);
  if (HasOptionalField(e_gateway))
    m_gateway.Encode(strm);
  if (HasOptionalField(e_mcu))
    m_mcu.Encode(strm);
  if (HasOptionalField(e_terminal))
    m_terminal.Encode(strm);
  m_mc.Encode(strm);
  m_undefinedNode.Encode(strm);
  KnownExtensionEncode(strm, e_set, m_set);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_vendor))
    m_vendor.Encode(strm);
  if (HasOptionalField(e_gatekeeper))
    m_gatekeeper.Encode(strm);
  if (HasOptionalField(e_gateway))
    m_gateway.Encode(strm);
  if (HasOptionalField(e_mcu))
    m_mcu.Encode(strm);
  if (HasOptionalField(e_terminal))
    m_terminal.Encode(strm);
  m_mc.Encode(strm);
  m_undefinedNode.Encode(strm);
}


PObject * H225_EndpointType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_EndpointType::Class()), PInvalidCast);
#endif
  return new H225_EndpointType(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_EndpointType::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_vendor ) ) 
      m_vendor.preShowEthereal( );
  if ( HasOptionalField( e_gatekeeper ) ) 
      m_gatekeeper.preShowEthereal( );
  if ( HasOptionalField( e_gateway ) ) 
      m_gateway.preShowEthereal( );
  if ( HasOptionalField( e_mcu ) ) 
      m_mcu.preShowEthereal( );
  if ( HasOptionalField( e_terminal ) ) 
      m_terminal.preShowEthereal( );
  m_mc.preShowEthereal( );
  m_undefinedNode.preShowEthereal( );
  if ( HasOptionalField( e_set ) ) 
      m_set.preShowEthereal( );
}

PString H225_EndpointType::getSummary( void ) 
{
  return PString( "EndpointType" );
}

void H225_EndpointType::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_EndpointType_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_vendor ) ) {
    proto_tree *vendor_tree = (proto_tree*) NULL;
    proto_item *vendor_ti = (proto_item*) NULL;
    vendor_ti = proto_tree_add_text( tree, tvb, offset + m_vendor.GetStartByte(), m_vendor.GetByteLength(), "vendor (VendorIdentifier)" );
    vendor_tree = proto_item_add_subtree( vendor_ti, hCont->h225_1.ett_h225_EndpointType_vendor );
    m_vendor.showEthereal( vendor_tree, tvb, offset );
  }

  if ( HasOptionalField( e_gatekeeper ) ) {
    proto_tree *gatekeeper_tree = (proto_tree*) NULL;
    proto_item *gatekeeper_ti = (proto_item*) NULL;
    gatekeeper_ti = proto_tree_add_text( tree, tvb, offset + m_gatekeeper.GetStartByte(), m_gatekeeper.GetByteLength(), "gatekeeper (GatekeeperInfo)" );
    gatekeeper_tree = proto_item_add_subtree( gatekeeper_ti, hCont->h225_1.ett_h225_EndpointType_gatekeeper );
    m_gatekeeper.showEthereal( gatekeeper_tree, tvb, offset );
  }

  if ( HasOptionalField( e_gateway ) ) {
    proto_tree *gateway_tree = (proto_tree*) NULL;
    proto_item *gateway_ti = (proto_item*) NULL;
    gateway_ti = proto_tree_add_text( tree, tvb, offset + m_gateway.GetStartByte(), m_gateway.GetByteLength(), "gateway (GatewayInfo)" );
    gateway_tree = proto_item_add_subtree( gateway_ti, hCont->h225_1.ett_h225_EndpointType_gateway );
    m_gateway.showEthereal( gateway_tree, tvb, offset );
  }

  if ( HasOptionalField( e_mcu ) ) {
    proto_tree *mcu_tree = (proto_tree*) NULL;
    proto_item *mcu_ti = (proto_item*) NULL;
    mcu_ti = proto_tree_add_text( tree, tvb, offset + m_mcu.GetStartByte(), m_mcu.GetByteLength(), "mcu (McuInfo)" );
    mcu_tree = proto_item_add_subtree( mcu_ti, hCont->h225_1.ett_h225_EndpointType_mcu );
    m_mcu.showEthereal( mcu_tree, tvb, offset );
  }

  if ( HasOptionalField( e_terminal ) ) {
    proto_tree *terminal_tree = (proto_tree*) NULL;
    proto_item *terminal_ti = (proto_item*) NULL;
    terminal_ti = proto_tree_add_text( tree, tvb, offset + m_terminal.GetStartByte(), m_terminal.GetByteLength(), "terminal (TerminalInfo)" );
    terminal_tree = proto_item_add_subtree( terminal_ti, hCont->h225_1.ett_h225_EndpointType_terminal );
    m_terminal.showEthereal( terminal_tree, tvb, offset );
  }

  proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_EndpointType_mc, tvb, offset + m_mc.GetStartByte(), m_mc.GetByteLength() , m_mc.GetValue() );

  proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_EndpointType_undefinedNode, tvb, offset + m_undefinedNode.GetStartByte(), m_undefinedNode.GetByteLength() , m_undefinedNode.GetValue() );

  if ( HasOptionalField( e_set ) ) {
    char* pset = m_set.getValue();
    proto_tree_add_string( tree, hCont->h225_1.hf_h225_EndpointType_set, tvb, offset + m_set.GetStartByte(), m_set.GetByteLength() , pset );
    delete[] pset;
  }

}
#endif  //USE_FOR_ETHEREAL

//
// Endpoint
//

H225_Endpoint::H225_Endpoint(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 10, TRUE, 1)
{
  m_priority.SetConstraints(PASN_Object::FixedConstraint, 0, 127);
}


#ifndef PASN_NOPRINTON
void H225_Endpoint::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_aliasAddress))
    strm << setw(indent+15) << "aliasAddress = " << setprecision(indent) << m_aliasAddress << '\n';
  if (HasOptionalField(e_callSignalAddress))
    strm << setw(indent+20) << "callSignalAddress = " << setprecision(indent) << m_callSignalAddress << '\n';
  if (HasOptionalField(e_rasAddress))
    strm << setw(indent+13) << "rasAddress = " << setprecision(indent) << m_rasAddress << '\n';
  if (HasOptionalField(e_endpointType))
    strm << setw(indent+15) << "endpointType = " << setprecision(indent) << m_endpointType << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_priority))
    strm << setw(indent+11) << "priority = " << setprecision(indent) << m_priority << '\n';
  if (HasOptionalField(e_remoteExtensionAddress))
    strm << setw(indent+25) << "remoteExtensionAddress = " << setprecision(indent) << m_remoteExtensionAddress << '\n';
  if (HasOptionalField(e_destExtraCallInfo))
    strm << setw(indent+20) << "destExtraCallInfo = " << setprecision(indent) << m_destExtraCallInfo << '\n';
  if (HasOptionalField(e_alternateTransportAddresses))
    strm << setw(indent+30) << "alternateTransportAddresses = " << setprecision(indent) << m_alternateTransportAddresses << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_Endpoint::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_Endpoint::Class()), PInvalidCast);
#endif
  const H225_Endpoint & other = (const H225_Endpoint &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_aliasAddress.Compare(other.m_aliasAddress)) != EqualTo)
    return result;
  if ((result = m_callSignalAddress.Compare(other.m_callSignalAddress)) != EqualTo)
    return result;
  if ((result = m_rasAddress.Compare(other.m_rasAddress)) != EqualTo)
    return result;
  if ((result = m_endpointType.Compare(other.m_endpointType)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;
  if ((result = m_priority.Compare(other.m_priority)) != EqualTo)
    return result;
  if ((result = m_remoteExtensionAddress.Compare(other.m_remoteExtensionAddress)) != EqualTo)
    return result;
  if ((result = m_destExtraCallInfo.Compare(other.m_destExtraCallInfo)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_Endpoint::GetDataLength() const
{
  return m_nonStandardData.GetObjectLength() +
         m_aliasAddress.GetObjectLength() +
         m_callSignalAddress.GetObjectLength() +
         m_rasAddress.GetObjectLength() +
         m_endpointType.GetObjectLength() +
         m_tokens.GetObjectLength() +
         m_cryptoTokens.GetObjectLength() +
         m_priority.GetObjectLength() +
         m_remoteExtensionAddress.GetObjectLength() +
         m_destExtraCallInfo.GetObjectLength();
}


BOOL H225_Endpoint::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_aliasAddress ) && !m_aliasAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_callSignalAddress ) && !m_callSignalAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_rasAddress ) && !m_rasAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_endpointType ) && !m_endpointType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_tokens ) && !m_tokens.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_cryptoTokens ) && !m_cryptoTokens.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_priority ) && !m_priority.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_remoteExtensionAddress ) && !m_remoteExtensionAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_destExtraCallInfo ) && !m_destExtraCallInfo.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_alternateTransportAddresses, m_alternateTransportAddresses ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_Endpoint::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_aliasAddress))
    m_aliasAddress.Encode(strm);
  if (HasOptionalField(e_callSignalAddress))
    m_callSignalAddress.Encode(strm);
  if (HasOptionalField(e_rasAddress))
    m_rasAddress.Encode(strm);
  if (HasOptionalField(e_endpointType))
    m_endpointType.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_priority))
    m_priority.Encode(strm);
  if (HasOptionalField(e_remoteExtensionAddress))
    m_remoteExtensionAddress.Encode(strm);
  if (HasOptionalField(e_destExtraCallInfo))
    m_destExtraCallInfo.Encode(strm);
  KnownExtensionEncode(strm, e_alternateTransportAddresses, m_alternateTransportAddresses);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_aliasAddress))
    m_aliasAddress.Encode(strm);
  if (HasOptionalField(e_callSignalAddress))
    m_callSignalAddress.Encode(strm);
  if (HasOptionalField(e_rasAddress))
    m_rasAddress.Encode(strm);
  if (HasOptionalField(e_endpointType))
    m_endpointType.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_priority))
    m_priority.Encode(strm);
  if (HasOptionalField(e_remoteExtensionAddress))
    m_remoteExtensionAddress.Encode(strm);
  if (HasOptionalField(e_destExtraCallInfo))
    m_destExtraCallInfo.Encode(strm);
}


PObject * H225_Endpoint::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_Endpoint::Class()), PInvalidCast);
#endif
  return new H225_Endpoint(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_Endpoint::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_aliasAddress ) ) 
      m_aliasAddress.preShowEthereal( );
  if ( HasOptionalField( e_callSignalAddress ) ) 
      m_callSignalAddress.preShowEthereal( );
  if ( HasOptionalField( e_rasAddress ) ) 
      m_rasAddress.preShowEthereal( );
  if ( HasOptionalField( e_endpointType ) ) 
      m_endpointType.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_priority ) ) 
      m_priority.preShowEthereal( );
  if ( HasOptionalField( e_remoteExtensionAddress ) ) 
      m_remoteExtensionAddress.preShowEthereal( );
  if ( HasOptionalField( e_destExtraCallInfo ) ) 
      m_destExtraCallInfo.preShowEthereal( );
  if ( HasOptionalField( e_alternateTransportAddresses ) ) 
      m_alternateTransportAddresses.preShowEthereal( );
}

PString H225_Endpoint::getSummary( void ) 
{
  return PString( "Endpoint" );
}

void H225_Endpoint::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_Endpoint_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_aliasAddress ) ) {
    proto_tree *aliasAddress_tree = (proto_tree*) NULL;
    proto_item *aliasAddress_ti = (proto_item*) NULL;
    aliasAddress_ti = proto_tree_add_text( tree, tvb, offset + m_aliasAddress.GetStartByte(), m_aliasAddress.GetByteLength(), "aliasAddress (AliasAddress)" );
    aliasAddress_tree = proto_item_add_subtree( aliasAddress_ti, hCont->h225_1.ett_h225_Endpoint_aliasAddress );
    m_aliasAddress.showEthereal( aliasAddress_tree, tvb, offset );
  }

  if ( HasOptionalField( e_callSignalAddress ) ) {
    proto_tree *callSignalAddress_tree = (proto_tree*) NULL;
    proto_item *callSignalAddress_ti = (proto_item*) NULL;
    callSignalAddress_ti = proto_tree_add_text( tree, tvb, offset + m_callSignalAddress.GetStartByte(), m_callSignalAddress.GetByteLength(), "callSignalAddress (TransportAddress)" );
    callSignalAddress_tree = proto_item_add_subtree( callSignalAddress_ti, hCont->h225_1.ett_h225_Endpoint_callSignalAddress );
    m_callSignalAddress.showEthereal( callSignalAddress_tree, tvb, offset );
  }

  if ( HasOptionalField( e_rasAddress ) ) {
    proto_tree *rasAddress_tree = (proto_tree*) NULL;
    proto_item *rasAddress_ti = (proto_item*) NULL;
    rasAddress_ti = proto_tree_add_text( tree, tvb, offset + m_rasAddress.GetStartByte(), m_rasAddress.GetByteLength(), "rasAddress (TransportAddress)" );
    rasAddress_tree = proto_item_add_subtree( rasAddress_ti, hCont->h225_1.ett_h225_Endpoint_rasAddress );
    m_rasAddress.showEthereal( rasAddress_tree, tvb, offset );
  }

  if ( HasOptionalField( e_endpointType ) ) {
    proto_tree *endpointType_tree = (proto_tree*) NULL;
    proto_item *endpointType_ti = (proto_item*) NULL;
    endpointType_ti = proto_tree_add_text( tree, tvb, offset + m_endpointType.GetStartByte(), m_endpointType.GetByteLength(), "endpointType (EndpointType)" );
    endpointType_tree = proto_item_add_subtree( endpointType_ti, hCont->h225_1.ett_h225_Endpoint_endpointType );
    m_endpointType.showEthereal( endpointType_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_Endpoint_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_Endpoint_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_priority ) ) {
    proto_tree_add_uint( tree, hCont->h225_1.hf_h225_Endpoint_priority, tvb, offset + m_priority.GetStartByte(), m_priority.GetByteLength() , m_priority.GetValue() );
  }

  if ( HasOptionalField( e_remoteExtensionAddress ) ) {
    proto_tree *remoteExtensionAddress_tree = (proto_tree*) NULL;
    proto_item *remoteExtensionAddress_ti = (proto_item*) NULL;
    remoteExtensionAddress_ti = proto_tree_add_text( tree, tvb, offset + m_remoteExtensionAddress.GetStartByte(), m_remoteExtensionAddress.GetByteLength(), "remoteExtensionAddress (AliasAddress)" );
    remoteExtensionAddress_tree = proto_item_add_subtree( remoteExtensionAddress_ti, hCont->h225_1.ett_h225_Endpoint_remoteExtensionAddress );
    m_remoteExtensionAddress.showEthereal( remoteExtensionAddress_tree, tvb, offset );
  }

  if ( HasOptionalField( e_destExtraCallInfo ) ) {
    proto_tree *destExtraCallInfo_tree = (proto_tree*) NULL;
    proto_item *destExtraCallInfo_ti = (proto_item*) NULL;
    destExtraCallInfo_ti = proto_tree_add_text( tree, tvb, offset + m_destExtraCallInfo.GetStartByte(), m_destExtraCallInfo.GetByteLength(), "destExtraCallInfo (AliasAddress)" );
    destExtraCallInfo_tree = proto_item_add_subtree( destExtraCallInfo_ti, hCont->h225_1.ett_h225_Endpoint_destExtraCallInfo );
    m_destExtraCallInfo.showEthereal( destExtraCallInfo_tree, tvb, offset );
  }

  if ( HasOptionalField( e_alternateTransportAddresses ) ) {
    proto_tree *alternateTransportAddresses_tree = (proto_tree*) NULL;
    proto_item *alternateTransportAddresses_ti = (proto_item*) NULL;
    alternateTransportAddresses_ti = proto_tree_add_text( tree, tvb, offset + m_alternateTransportAddresses.GetStartByte(), m_alternateTransportAddresses.GetByteLength(), "alternateTransportAddresses (AlternateTransportAddresses)" );
    alternateTransportAddresses_tree = proto_item_add_subtree( alternateTransportAddresses_ti, hCont->h225_1.ett_h225_Endpoint_alternateTransportAddresses );
    m_alternateTransportAddresses.showEthereal( alternateTransportAddresses_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// GatekeeperRequest
//

H225_GatekeeperRequest::H225_GatekeeperRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 4, TRUE, 7)
{
}


#ifndef PASN_NOPRINTON
void H225_GatekeeperRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+13) << "rasAddress = " << setprecision(indent) << m_rasAddress << '\n';
  strm << setw(indent+15) << "endpointType = " << setprecision(indent) << m_endpointType << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  if (HasOptionalField(e_callServices))
    strm << setw(indent+15) << "callServices = " << setprecision(indent) << m_callServices << '\n';
  if (HasOptionalField(e_endpointAlias))
    strm << setw(indent+16) << "endpointAlias = " << setprecision(indent) << m_endpointAlias << '\n';
  if (HasOptionalField(e_alternateEndpoints))
    strm << setw(indent+21) << "alternateEndpoints = " << setprecision(indent) << m_alternateEndpoints << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_authenticationCapability))
    strm << setw(indent+27) << "authenticationCapability = " << setprecision(indent) << m_authenticationCapability << '\n';
  if (HasOptionalField(e_algorithmOIDs))
    strm << setw(indent+16) << "algorithmOIDs = " << setprecision(indent) << m_algorithmOIDs << '\n';
  if (HasOptionalField(e_integrity))
    strm << setw(indent+12) << "integrity = " << setprecision(indent) << m_integrity << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_GatekeeperRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_GatekeeperRequest::Class()), PInvalidCast);
#endif
  const H225_GatekeeperRequest & other = (const H225_GatekeeperRequest &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_rasAddress.Compare(other.m_rasAddress)) != EqualTo)
    return result;
  if ((result = m_endpointType.Compare(other.m_endpointType)) != EqualTo)
    return result;
  if ((result = m_gatekeeperIdentifier.Compare(other.m_gatekeeperIdentifier)) != EqualTo)
    return result;
  if ((result = m_callServices.Compare(other.m_callServices)) != EqualTo)
    return result;
  if ((result = m_endpointAlias.Compare(other.m_endpointAlias)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_GatekeeperRequest::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_protocolIdentifier.GetObjectLength() +
         m_nonStandardData.GetObjectLength() +
         m_rasAddress.GetObjectLength() +
         m_endpointType.GetObjectLength() +
         m_gatekeeperIdentifier.GetObjectLength() +
         m_callServices.GetObjectLength() +
         m_endpointAlias.GetObjectLength();
}


BOOL H225_GatekeeperRequest::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_protocolIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_rasAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_endpointType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_gatekeeperIdentifier ) && !m_gatekeeperIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_callServices ) && !m_callServices.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_endpointAlias ) && !m_endpointAlias.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_alternateEndpoints, m_alternateEndpoints ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_authenticationCapability, m_authenticationCapability ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_algorithmOIDs, m_algorithmOIDs ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrity, m_integrity ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_GatekeeperRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_rasAddress.Encode(strm);
  m_endpointType.Encode(strm);
  if (HasOptionalField(e_gatekeeperIdentifier))
    m_gatekeeperIdentifier.Encode(strm);
  if (HasOptionalField(e_callServices))
    m_callServices.Encode(strm);
  if (HasOptionalField(e_endpointAlias))
    m_endpointAlias.Encode(strm);
  KnownExtensionEncode(strm, e_alternateEndpoints, m_alternateEndpoints);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_authenticationCapability, m_authenticationCapability);
  KnownExtensionEncode(strm, e_algorithmOIDs, m_algorithmOIDs);
  KnownExtensionEncode(strm, e_integrity, m_integrity);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_rasAddress.Encode(strm);
  m_endpointType.Encode(strm);
  if (HasOptionalField(e_gatekeeperIdentifier))
    m_gatekeeperIdentifier.Encode(strm);
  if (HasOptionalField(e_callServices))
    m_callServices.Encode(strm);
  if (HasOptionalField(e_endpointAlias))
    m_endpointAlias.Encode(strm);
}


PObject * H225_GatekeeperRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_GatekeeperRequest::Class()), PInvalidCast);
#endif
  return new H225_GatekeeperRequest(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_GatekeeperRequest::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  m_protocolIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  m_rasAddress.preShowEthereal( );
  m_endpointType.preShowEthereal( );
  if ( HasOptionalField( e_gatekeeperIdentifier ) ) 
      m_gatekeeperIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_callServices ) ) 
      m_callServices.preShowEthereal( );
  if ( HasOptionalField( e_endpointAlias ) ) 
      m_endpointAlias.preShowEthereal( );
  if ( HasOptionalField( e_alternateEndpoints ) ) 
      m_alternateEndpoints.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_authenticationCapability ) ) 
      m_authenticationCapability.preShowEthereal( );
  if ( HasOptionalField( e_algorithmOIDs ) ) 
      m_algorithmOIDs.preShowEthereal( );
  if ( HasOptionalField( e_integrity ) ) 
      m_integrity.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
}

PString H225_GatekeeperRequest::getSummary( void ) 
{
  return PString( "GatekeeperRequest" );
}

void H225_GatekeeperRequest::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_GatekeeperRequest_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  char* pprotocolIdentifier = m_protocolIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h225_1.hf_h225_GatekeeperRequest_protocolIdentifier, tvb, offset + m_protocolIdentifier.GetStartByte(), m_protocolIdentifier.GetByteLength() , pprotocolIdentifier );
  delete[] pprotocolIdentifier;

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_GatekeeperRequest_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  proto_tree *rasAddress_tree = (proto_tree*) NULL;
  proto_item *rasAddress_ti = (proto_item*) NULL;
  rasAddress_ti = proto_tree_add_text( tree, tvb, offset + m_rasAddress.GetStartByte(), m_rasAddress.GetByteLength(), "rasAddress (%s)", ( const char* ) m_rasAddress.GetTagName() );
  rasAddress_tree = proto_item_add_subtree( rasAddress_ti, hCont->h225_1.ett_h225_GatekeeperRequest_rasAddress );

  m_rasAddress.showEthereal( rasAddress_tree, tvb, offset );

  proto_tree *endpointType_tree = (proto_tree*) NULL;
  proto_item *endpointType_ti = (proto_item*) NULL;
  endpointType_ti = proto_tree_add_text( tree, tvb, offset + m_endpointType.GetStartByte(), m_endpointType.GetByteLength(), "endpointType (EndpointType)" );
  endpointType_tree = proto_item_add_subtree( endpointType_ti, hCont->h225_1.ett_h225_GatekeeperRequest_endpointType );

  m_endpointType.showEthereal( endpointType_tree, tvb, offset );

  if ( HasOptionalField( e_gatekeeperIdentifier ) ) {
    char* pgatekeeperIdentifier = m_gatekeeperIdentifier.getValue();
    proto_tree_add_string( tree, hCont->h225_1.hf_h225_GatekeeperRequest_gatekeeperIdentifier, tvb, offset + m_gatekeeperIdentifier.GetStartByte(), m_gatekeeperIdentifier.GetByteLength() , pgatekeeperIdentifier );
    delete[] pgatekeeperIdentifier;
  }

  if ( HasOptionalField( e_callServices ) ) {
    proto_tree *callServices_tree = (proto_tree*) NULL;
    proto_item *callServices_ti = (proto_item*) NULL;
    callServices_ti = proto_tree_add_text( tree, tvb, offset + m_callServices.GetStartByte(), m_callServices.GetByteLength(), "callServices (QseriesOptions)" );
    callServices_tree = proto_item_add_subtree( callServices_ti, hCont->h225_1.ett_h225_GatekeeperRequest_callServices );
    m_callServices.showEthereal( callServices_tree, tvb, offset );
  }

  if ( HasOptionalField( e_endpointAlias ) ) {
    proto_tree *endpointAlias_tree = (proto_tree*) NULL;
    proto_item *endpointAlias_ti = (proto_item*) NULL;
    endpointAlias_ti = proto_tree_add_text( tree, tvb, offset + m_endpointAlias.GetStartByte(), m_endpointAlias.GetByteLength(), "endpointAlias (AliasAddress)" );
    endpointAlias_tree = proto_item_add_subtree( endpointAlias_ti, hCont->h225_1.ett_h225_GatekeeperRequest_endpointAlias );
    m_endpointAlias.showEthereal( endpointAlias_tree, tvb, offset );
  }

  if ( HasOptionalField( e_alternateEndpoints ) ) {
    proto_tree *alternateEndpoints_tree = (proto_tree*) NULL;
    proto_item *alternateEndpoints_ti = (proto_item*) NULL;
    alternateEndpoints_ti = proto_tree_add_text( tree, tvb, offset + m_alternateEndpoints.GetStartByte(), m_alternateEndpoints.GetByteLength(), "alternateEndpoints (Endpoint)" );
    alternateEndpoints_tree = proto_item_add_subtree( alternateEndpoints_ti, hCont->h225_1.ett_h225_GatekeeperRequest_alternateEndpoints );
    m_alternateEndpoints.showEthereal( alternateEndpoints_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_GatekeeperRequest_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_GatekeeperRequest_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_authenticationCapability ) ) {
    proto_tree *authenticationCapability_tree = (proto_tree*) NULL;
    proto_item *authenticationCapability_ti = (proto_item*) NULL;
    authenticationCapability_ti = proto_tree_add_text( tree, tvb, offset + m_authenticationCapability.GetStartByte(), m_authenticationCapability.GetByteLength(), "authenticationCapability (AuthenticationMechanism)" );
    authenticationCapability_tree = proto_item_add_subtree( authenticationCapability_ti, hCont->h225_1.ett_h225_GatekeeperRequest_authenticationCapability );
    m_authenticationCapability.showEthereal( authenticationCapability_tree, tvb, offset );
  }

  if ( HasOptionalField( e_algorithmOIDs ) ) {
    proto_tree *algorithmOIDs_tree = (proto_tree*) NULL;
    proto_item *algorithmOIDs_ti = (proto_item*) NULL;
    algorithmOIDs_ti = proto_tree_add_text( tree, tvb, offset + m_algorithmOIDs.GetStartByte(), m_algorithmOIDs.GetByteLength(), "algorithmOIDs (ObjectId)" );
    algorithmOIDs_tree = proto_item_add_subtree( algorithmOIDs_ti, hCont->h225_1.ett_h225_GatekeeperRequest_algorithmOIDs );
    m_algorithmOIDs.showEthereal( algorithmOIDs_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrity ) ) {
    proto_tree *integrity_tree = (proto_tree*) NULL;
    proto_item *integrity_ti = (proto_item*) NULL;
    integrity_ti = proto_tree_add_text( tree, tvb, offset + m_integrity.GetStartByte(), m_integrity.GetByteLength(), "integrity (IntegrityMechanism)" );
    integrity_tree = proto_item_add_subtree( integrity_ti, hCont->h225_1.ett_h225_GatekeeperRequest_integrity );
    m_integrity.showEthereal( integrity_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_1.ett_h225_GatekeeperRequest_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// RegistrationRequest
//

H225_RegistrationRequest::H225_RegistrationRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 10)
{
  IncludeOptionalField(e_keepAlive);
  IncludeOptionalField(e_willSupplyUUIEs);
  IncludeOptionalField(e_maintainConnection);
}


#ifndef PASN_NOPRINTON
void H225_RegistrationRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+20) << "discoveryComplete = " << setprecision(indent) << m_discoveryComplete << '\n';
  strm << setw(indent+20) << "callSignalAddress = " << setprecision(indent) << m_callSignalAddress << '\n';
  strm << setw(indent+13) << "rasAddress = " << setprecision(indent) << m_rasAddress << '\n';
  strm << setw(indent+15) << "terminalType = " << setprecision(indent) << m_terminalType << '\n';
  if (HasOptionalField(e_terminalAlias))
    strm << setw(indent+16) << "terminalAlias = " << setprecision(indent) << m_terminalAlias << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  strm << setw(indent+17) << "endpointVendor = " << setprecision(indent) << m_endpointVendor << '\n';
  if (HasOptionalField(e_alternateEndpoints))
    strm << setw(indent+21) << "alternateEndpoints = " << setprecision(indent) << m_alternateEndpoints << '\n';
  if (HasOptionalField(e_timeToLive))
    strm << setw(indent+13) << "timeToLive = " << setprecision(indent) << m_timeToLive << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_keepAlive))
    strm << setw(indent+12) << "keepAlive = " << setprecision(indent) << m_keepAlive << '\n';
  if (HasOptionalField(e_endpointIdentifier))
    strm << setw(indent+21) << "endpointIdentifier = " << setprecision(indent) << m_endpointIdentifier << '\n';
  if (HasOptionalField(e_willSupplyUUIEs))
    strm << setw(indent+18) << "willSupplyUUIEs = " << setprecision(indent) << m_willSupplyUUIEs << '\n';
  if (HasOptionalField(e_maintainConnection))
    strm << setw(indent+21) << "maintainConnection = " << setprecision(indent) << m_maintainConnection << '\n';
  if (HasOptionalField(e_alternateTransportAddresses))
    strm << setw(indent+30) << "alternateTransportAddresses = " << setprecision(indent) << m_alternateTransportAddresses << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_RegistrationRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_RegistrationRequest::Class()), PInvalidCast);
#endif
  const H225_RegistrationRequest & other = (const H225_RegistrationRequest &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_discoveryComplete.Compare(other.m_discoveryComplete)) != EqualTo)
    return result;
  if ((result = m_callSignalAddress.Compare(other.m_callSignalAddress)) != EqualTo)
    return result;
  if ((result = m_rasAddress.Compare(other.m_rasAddress)) != EqualTo)
    return result;
  if ((result = m_terminalType.Compare(other.m_terminalType)) != EqualTo)
    return result;
  if ((result = m_terminalAlias.Compare(other.m_terminalAlias)) != EqualTo)
    return result;
  if ((result = m_gatekeeperIdentifier.Compare(other.m_gatekeeperIdentifier)) != EqualTo)
    return result;
  if ((result = m_endpointVendor.Compare(other.m_endpointVendor)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_RegistrationRequest::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_protocolIdentifier.GetObjectLength() +
         m_nonStandardData.GetObjectLength() +
         m_discoveryComplete.GetObjectLength() +
         m_callSignalAddress.GetObjectLength() +
         m_rasAddress.GetObjectLength() +
         m_terminalType.GetObjectLength() +
         m_terminalAlias.GetObjectLength() +
         m_gatekeeperIdentifier.GetObjectLength() +
         m_endpointVendor.GetObjectLength();
}


BOOL H225_RegistrationRequest::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_protocolIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_discoveryComplete.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callSignalAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_rasAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_terminalType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_terminalAlias ) && !m_terminalAlias.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_gatekeeperIdentifier ) && !m_gatekeeperIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_endpointVendor.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_alternateEndpoints, m_alternateEndpoints ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_timeToLive, m_timeToLive ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_keepAlive, m_keepAlive ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_endpointIdentifier, m_endpointIdentifier ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_willSupplyUUIEs, m_willSupplyUUIEs ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_maintainConnection, m_maintainConnection ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_alternateTransportAddresses, m_alternateTransportAddresses ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_RegistrationRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_discoveryComplete.Encode(strm);
  m_callSignalAddress.Encode(strm);
  m_rasAddress.Encode(strm);
  m_terminalType.Encode(strm);
  if (HasOptionalField(e_terminalAlias))
    m_terminalAlias.Encode(strm);
  if (HasOptionalField(e_gatekeeperIdentifier))
    m_gatekeeperIdentifier.Encode(strm);
  m_endpointVendor.Encode(strm);
  KnownExtensionEncode(strm, e_alternateEndpoints, m_alternateEndpoints);
  KnownExtensionEncode(strm, e_timeToLive, m_timeToLive);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_keepAlive, m_keepAlive);
  KnownExtensionEncode(strm, e_endpointIdentifier, m_endpointIdentifier);
  KnownExtensionEncode(strm, e_willSupplyUUIEs, m_willSupplyUUIEs);
  KnownExtensionEncode(strm, e_maintainConnection, m_maintainConnection);
  KnownExtensionEncode(strm, e_alternateTransportAddresses, m_alternateTransportAddresses);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_discoveryComplete.Encode(strm);
  m_callSignalAddress.Encode(strm);
  m_rasAddress.Encode(strm);
  m_terminalType.Encode(strm);
  if (HasOptionalField(e_terminalAlias))
    m_terminalAlias.Encode(strm);
  if (HasOptionalField(e_gatekeeperIdentifier))
    m_gatekeeperIdentifier.Encode(strm);
  m_endpointVendor.Encode(strm);
}


PObject * H225_RegistrationRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_RegistrationRequest::Class()), PInvalidCast);
#endif
  return new H225_RegistrationRequest(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_RegistrationRequest::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  m_protocolIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  m_discoveryComplete.preShowEthereal( );
  m_callSignalAddress.preShowEthereal( );
  m_rasAddress.preShowEthereal( );
  m_terminalType.preShowEthereal( );
  if ( HasOptionalField( e_terminalAlias ) ) 
      m_terminalAlias.preShowEthereal( );
  if ( HasOptionalField( e_gatekeeperIdentifier ) ) 
      m_gatekeeperIdentifier.preShowEthereal( );
  m_endpointVendor.preShowEthereal( );
  if ( HasOptionalField( e_alternateEndpoints ) ) 
      m_alternateEndpoints.preShowEthereal( );
  if ( HasOptionalField( e_timeToLive ) ) 
      m_timeToLive.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
  if ( HasOptionalField( e_keepAlive ) ) 
      m_keepAlive.preShowEthereal( );
  if ( HasOptionalField( e_endpointIdentifier ) ) 
      m_endpointIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_willSupplyUUIEs ) ) 
      m_willSupplyUUIEs.preShowEthereal( );
  if ( HasOptionalField( e_maintainConnection ) ) 
      m_maintainConnection.preShowEthereal( );
  if ( HasOptionalField( e_alternateTransportAddresses ) ) 
      m_alternateTransportAddresses.preShowEthereal( );
}

PString H225_RegistrationRequest::getSummary( void ) 
{
  return PString( "RegistrationRequest" );
}

void H225_RegistrationRequest::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_RegistrationRequest_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  char* pprotocolIdentifier = m_protocolIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h225_1.hf_h225_RegistrationRequest_protocolIdentifier, tvb, offset + m_protocolIdentifier.GetStartByte(), m_protocolIdentifier.GetByteLength() , pprotocolIdentifier );
  delete[] pprotocolIdentifier;

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_RegistrationRequest_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_RegistrationRequest_discoveryComplete, tvb, offset + m_discoveryComplete.GetStartByte(), m_discoveryComplete.GetByteLength() , m_discoveryComplete.GetValue() );

  proto_tree *callSignalAddress_tree = (proto_tree*) NULL;
  proto_item *callSignalAddress_ti = (proto_item*) NULL;
  callSignalAddress_ti = proto_tree_add_text( tree, tvb, offset + m_callSignalAddress.GetStartByte(), m_callSignalAddress.GetByteLength(), "callSignalAddress (TransportAddress)" );
  callSignalAddress_tree = proto_item_add_subtree( callSignalAddress_ti, hCont->h225_1.ett_h225_RegistrationRequest_callSignalAddress );

  m_callSignalAddress.showEthereal( callSignalAddress_tree, tvb, offset );

  proto_tree *rasAddress_tree = (proto_tree*) NULL;
  proto_item *rasAddress_ti = (proto_item*) NULL;
  rasAddress_ti = proto_tree_add_text( tree, tvb, offset + m_rasAddress.GetStartByte(), m_rasAddress.GetByteLength(), "rasAddress (TransportAddress)" );
  rasAddress_tree = proto_item_add_subtree( rasAddress_ti, hCont->h225_1.ett_h225_RegistrationRequest_rasAddress );

  m_rasAddress.showEthereal( rasAddress_tree, tvb, offset );

  proto_tree *terminalType_tree = (proto_tree*) NULL;
  proto_item *terminalType_ti = (proto_item*) NULL;
  terminalType_ti = proto_tree_add_text( tree, tvb, offset + m_terminalType.GetStartByte(), m_terminalType.GetByteLength(), "terminalType (EndpointType)" );
  terminalType_tree = proto_item_add_subtree( terminalType_ti, hCont->h225_1.ett_h225_RegistrationRequest_terminalType );

  m_terminalType.showEthereal( terminalType_tree, tvb, offset );

  if ( HasOptionalField( e_terminalAlias ) ) {
    proto_tree *terminalAlias_tree = (proto_tree*) NULL;
    proto_item *terminalAlias_ti = (proto_item*) NULL;
    terminalAlias_ti = proto_tree_add_text( tree, tvb, offset + m_terminalAlias.GetStartByte(), m_terminalAlias.GetByteLength(), "terminalAlias (AliasAddress)" );
    terminalAlias_tree = proto_item_add_subtree( terminalAlias_ti, hCont->h225_1.ett_h225_RegistrationRequest_terminalAlias );
    m_terminalAlias.showEthereal( terminalAlias_tree, tvb, offset );
  }

  if ( HasOptionalField( e_gatekeeperIdentifier ) ) {
    char* pgatekeeperIdentifier = m_gatekeeperIdentifier.getValue();
    proto_tree_add_string( tree, hCont->h225_1.hf_h225_RegistrationRequest_gatekeeperIdentifier, tvb, offset + m_gatekeeperIdentifier.GetStartByte(), m_gatekeeperIdentifier.GetByteLength() , pgatekeeperIdentifier );
    delete[] pgatekeeperIdentifier;
  }

  proto_tree *endpointVendor_tree = (proto_tree*) NULL;
  proto_item *endpointVendor_ti = (proto_item*) NULL;
  endpointVendor_ti = proto_tree_add_text( tree, tvb, offset + m_endpointVendor.GetStartByte(), m_endpointVendor.GetByteLength(), "endpointVendor (VendorIdentifier)" );
  endpointVendor_tree = proto_item_add_subtree( endpointVendor_ti, hCont->h225_1.ett_h225_RegistrationRequest_endpointVendor );

  m_endpointVendor.showEthereal( endpointVendor_tree, tvb, offset );

  if ( HasOptionalField( e_alternateEndpoints ) ) {
    proto_tree *alternateEndpoints_tree = (proto_tree*) NULL;
    proto_item *alternateEndpoints_ti = (proto_item*) NULL;
    alternateEndpoints_ti = proto_tree_add_text( tree, tvb, offset + m_alternateEndpoints.GetStartByte(), m_alternateEndpoints.GetByteLength(), "alternateEndpoints (Endpoint)" );
    alternateEndpoints_tree = proto_item_add_subtree( alternateEndpoints_ti, hCont->h225_1.ett_h225_RegistrationRequest_alternateEndpoints );
    m_alternateEndpoints.showEthereal( alternateEndpoints_tree, tvb, offset );
  }

  if ( HasOptionalField( e_timeToLive ) ) {
    proto_tree_add_uint( tree, hCont->h225_1.hf_h225_RegistrationRequest_timeToLive, tvb, offset + m_timeToLive.GetStartByte(), m_timeToLive.GetByteLength() , m_timeToLive.GetValue() );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_RegistrationRequest_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_RegistrationRequest_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_1.ett_h225_RegistrationRequest_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

  if ( HasOptionalField( e_keepAlive ) ) {
    proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_RegistrationRequest_keepAlive, tvb, offset + m_keepAlive.GetStartByte(), m_keepAlive.GetByteLength() , m_keepAlive.GetValue() );
  }

  if ( HasOptionalField( e_endpointIdentifier ) ) {
    char* pendpointIdentifier = m_endpointIdentifier.getValue();
    proto_tree_add_string( tree, hCont->h225_1.hf_h225_RegistrationRequest_endpointIdentifier, tvb, offset + m_endpointIdentifier.GetStartByte(), m_endpointIdentifier.GetByteLength() , pendpointIdentifier );
    delete[] pendpointIdentifier;
  }

  if ( HasOptionalField( e_willSupplyUUIEs ) ) {
    proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_RegistrationRequest_willSupplyUUIEs, tvb, offset + m_willSupplyUUIEs.GetStartByte(), m_willSupplyUUIEs.GetByteLength() , m_willSupplyUUIEs.GetValue() );
  }

  if ( HasOptionalField( e_maintainConnection ) ) {
    proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_RegistrationRequest_maintainConnection, tvb, offset + m_maintainConnection.GetStartByte(), m_maintainConnection.GetByteLength() , m_maintainConnection.GetValue() );
  }

  if ( HasOptionalField( e_alternateTransportAddresses ) ) {
    proto_tree *alternateTransportAddresses_tree = (proto_tree*) NULL;
    proto_item *alternateTransportAddresses_ti = (proto_item*) NULL;
    alternateTransportAddresses_ti = proto_tree_add_text( tree, tvb, offset + m_alternateTransportAddresses.GetStartByte(), m_alternateTransportAddresses.GetByteLength(), "alternateTransportAddresses (AlternateTransportAddresses)" );
    alternateTransportAddresses_tree = proto_item_add_subtree( alternateTransportAddresses_ti, hCont->h225_1.ett_h225_RegistrationRequest_alternateTransportAddresses );
    m_alternateTransportAddresses.showEthereal( alternateTransportAddresses_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// AdmissionConfirm
//

H225_AdmissionConfirm::H225_AdmissionConfirm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 14)
{
  m_irrFrequency.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
  IncludeOptionalField(e_willRespondToIRR);
  IncludeOptionalField(e_uuiesRequested);
}


#ifndef PASN_NOPRINTON
void H225_AdmissionConfirm::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+12) << "bandWidth = " << setprecision(indent) << m_bandWidth << '\n';
  strm << setw(indent+12) << "callModel = " << setprecision(indent) << m_callModel << '\n';
  strm << setw(indent+24) << "destCallSignalAddress = " << setprecision(indent) << m_destCallSignalAddress << '\n';
  if (HasOptionalField(e_irrFrequency))
    strm << setw(indent+15) << "irrFrequency = " << setprecision(indent) << m_irrFrequency << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_destinationInfo))
    strm << setw(indent+18) << "destinationInfo = " << setprecision(indent) << m_destinationInfo << '\n';
  if (HasOptionalField(e_destExtraCallInfo))
    strm << setw(indent+20) << "destExtraCallInfo = " << setprecision(indent) << m_destExtraCallInfo << '\n';
  if (HasOptionalField(e_destinationType))
    strm << setw(indent+18) << "destinationType = " << setprecision(indent) << m_destinationType << '\n';
  if (HasOptionalField(e_remoteExtensionAddress))
    strm << setw(indent+25) << "remoteExtensionAddress = " << setprecision(indent) << m_remoteExtensionAddress << '\n';
  if (HasOptionalField(e_alternateEndpoints))
    strm << setw(indent+21) << "alternateEndpoints = " << setprecision(indent) << m_alternateEndpoints << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_transportQOS))
    strm << setw(indent+15) << "transportQOS = " << setprecision(indent) << m_transportQOS << '\n';
  if (HasOptionalField(e_willRespondToIRR))
    strm << setw(indent+19) << "willRespondToIRR = " << setprecision(indent) << m_willRespondToIRR << '\n';
  if (HasOptionalField(e_uuiesRequested))
    strm << setw(indent+17) << "uuiesRequested = " << setprecision(indent) << m_uuiesRequested << '\n';
  if (HasOptionalField(e_language))
    strm << setw(indent+11) << "language = " << setprecision(indent) << m_language << '\n';
  if (HasOptionalField(e_alternateTransportAddresses))
    strm << setw(indent+30) << "alternateTransportAddresses = " << setprecision(indent) << m_alternateTransportAddresses << '\n';
  if (HasOptionalField(e_useSpecifiedTransport))
    strm << setw(indent+24) << "useSpecifiedTransport = " << setprecision(indent) << m_useSpecifiedTransport << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_AdmissionConfirm::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_AdmissionConfirm::Class()), PInvalidCast);
#endif
  const H225_AdmissionConfirm & other = (const H225_AdmissionConfirm &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_bandWidth.Compare(other.m_bandWidth)) != EqualTo)
    return result;
  if ((result = m_callModel.Compare(other.m_callModel)) != EqualTo)
    return result;
  if ((result = m_destCallSignalAddress.Compare(other.m_destCallSignalAddress)) != EqualTo)
    return result;
  if ((result = m_irrFrequency.Compare(other.m_irrFrequency)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_AdmissionConfirm::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_bandWidth.GetObjectLength() +
         m_callModel.GetObjectLength() +
         m_destCallSignalAddress.GetObjectLength() +
         m_irrFrequency.GetObjectLength() +
         m_nonStandardData.GetObjectLength();
}


BOOL H225_AdmissionConfirm::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_bandWidth.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callModel.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_destCallSignalAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_irrFrequency ) && !m_irrFrequency.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_destinationInfo, m_destinationInfo ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_destExtraCallInfo, m_destExtraCallInfo ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_destinationType, m_destinationType ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_remoteExtensionAddress, m_remoteExtensionAddress ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_alternateEndpoints, m_alternateEndpoints ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_transportQOS, m_transportQOS ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_willRespondToIRR, m_willRespondToIRR ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_uuiesRequested, m_uuiesRequested ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_language, m_language ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_alternateTransportAddresses, m_alternateTransportAddresses ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_useSpecifiedTransport, m_useSpecifiedTransport ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_AdmissionConfirm::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_bandWidth.Encode(strm);
  m_callModel.Encode(strm);
  m_destCallSignalAddress.Encode(strm);
  if (HasOptionalField(e_irrFrequency))
    m_irrFrequency.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_destinationInfo, m_destinationInfo);
  KnownExtensionEncode(strm, e_destExtraCallInfo, m_destExtraCallInfo);
  KnownExtensionEncode(strm, e_destinationType, m_destinationType);
  KnownExtensionEncode(strm, e_remoteExtensionAddress, m_remoteExtensionAddress);
  KnownExtensionEncode(strm, e_alternateEndpoints, m_alternateEndpoints);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_transportQOS, m_transportQOS);
  KnownExtensionEncode(strm, e_willRespondToIRR, m_willRespondToIRR);
  KnownExtensionEncode(strm, e_uuiesRequested, m_uuiesRequested);
  KnownExtensionEncode(strm, e_language, m_language);
  KnownExtensionEncode(strm, e_alternateTransportAddresses, m_alternateTransportAddresses);
  KnownExtensionEncode(strm, e_useSpecifiedTransport, m_useSpecifiedTransport);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  m_bandWidth.Encode(strm);
  m_callModel.Encode(strm);
  m_destCallSignalAddress.Encode(strm);
  if (HasOptionalField(e_irrFrequency))
    m_irrFrequency.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_AdmissionConfirm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_AdmissionConfirm::Class()), PInvalidCast);
#endif
  return new H225_AdmissionConfirm(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_AdmissionConfirm::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  m_bandWidth.preShowEthereal( );
  m_callModel.preShowEthereal( );
  m_destCallSignalAddress.preShowEthereal( );
  if ( HasOptionalField( e_irrFrequency ) ) 
      m_irrFrequency.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_destinationInfo ) ) 
      m_destinationInfo.preShowEthereal( );
  if ( HasOptionalField( e_destExtraCallInfo ) ) 
      m_destExtraCallInfo.preShowEthereal( );
  if ( HasOptionalField( e_destinationType ) ) 
      m_destinationType.preShowEthereal( );
  if ( HasOptionalField( e_remoteExtensionAddress ) ) 
      m_remoteExtensionAddress.preShowEthereal( );
  if ( HasOptionalField( e_alternateEndpoints ) ) 
      m_alternateEndpoints.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
  if ( HasOptionalField( e_transportQOS ) ) 
      m_transportQOS.preShowEthereal( );
  if ( HasOptionalField( e_willRespondToIRR ) ) 
      m_willRespondToIRR.preShowEthereal( );
  if ( HasOptionalField( e_uuiesRequested ) ) 
      m_uuiesRequested.preShowEthereal( );
  if ( HasOptionalField( e_language ) ) 
      m_language.preShowEthereal( );
  if ( HasOptionalField( e_alternateTransportAddresses ) ) 
      m_alternateTransportAddresses.preShowEthereal( );
  if ( HasOptionalField( e_useSpecifiedTransport ) ) 
      m_useSpecifiedTransport.preShowEthereal( );
}

PString H225_AdmissionConfirm::getSummary( void ) 
{
  return PString( "AdmissionConfirm" );
}

void H225_AdmissionConfirm::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_AdmissionConfirm_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_AdmissionConfirm_bandWidth, tvb, offset + m_bandWidth.GetStartByte(), m_bandWidth.GetByteLength() , m_bandWidth.GetValue() );

  proto_tree *callModel_tree = (proto_tree*) NULL;
  proto_item *callModel_ti = (proto_item*) NULL;
  callModel_ti = proto_tree_add_text( tree, tvb, offset + m_callModel.GetStartByte(), m_callModel.GetByteLength(), "callModel (%s)", ( const char* ) m_callModel.GetTagName() );
  callModel_tree = proto_item_add_subtree( callModel_ti, hCont->h225_1.ett_h225_AdmissionConfirm_callModel );

  m_callModel.showEthereal( callModel_tree, tvb, offset );

  proto_tree *destCallSignalAddress_tree = (proto_tree*) NULL;
  proto_item *destCallSignalAddress_ti = (proto_item*) NULL;
  destCallSignalAddress_ti = proto_tree_add_text( tree, tvb, offset + m_destCallSignalAddress.GetStartByte(), m_destCallSignalAddress.GetByteLength(), "destCallSignalAddress (%s)", ( const char* ) m_destCallSignalAddress.GetTagName() );
  destCallSignalAddress_tree = proto_item_add_subtree( destCallSignalAddress_ti, hCont->h225_1.ett_h225_AdmissionConfirm_destCallSignalAddress );

  m_destCallSignalAddress.showEthereal( destCallSignalAddress_tree, tvb, offset );

  if ( HasOptionalField( e_irrFrequency ) ) {
    proto_tree_add_uint( tree, hCont->h225_1.hf_h225_AdmissionConfirm_irrFrequency, tvb, offset + m_irrFrequency.GetStartByte(), m_irrFrequency.GetByteLength() , m_irrFrequency.GetValue() );
  }

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_AdmissionConfirm_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_destinationInfo ) ) {
    proto_tree *destinationInfo_tree = (proto_tree*) NULL;
    proto_item *destinationInfo_ti = (proto_item*) NULL;
    destinationInfo_ti = proto_tree_add_text( tree, tvb, offset + m_destinationInfo.GetStartByte(), m_destinationInfo.GetByteLength(), "destinationInfo (AliasAddress)" );
    destinationInfo_tree = proto_item_add_subtree( destinationInfo_ti, hCont->h225_1.ett_h225_AdmissionConfirm_destinationInfo );
    m_destinationInfo.showEthereal( destinationInfo_tree, tvb, offset );
  }

  if ( HasOptionalField( e_destExtraCallInfo ) ) {
    proto_tree *destExtraCallInfo_tree = (proto_tree*) NULL;
    proto_item *destExtraCallInfo_ti = (proto_item*) NULL;
    destExtraCallInfo_ti = proto_tree_add_text( tree, tvb, offset + m_destExtraCallInfo.GetStartByte(), m_destExtraCallInfo.GetByteLength(), "destExtraCallInfo (AliasAddress)" );
    destExtraCallInfo_tree = proto_item_add_subtree( destExtraCallInfo_ti, hCont->h225_1.ett_h225_AdmissionConfirm_destExtraCallInfo );
    m_destExtraCallInfo.showEthereal( destExtraCallInfo_tree, tvb, offset );
  }

  if ( HasOptionalField( e_destinationType ) ) {
    proto_tree *destinationType_tree = (proto_tree*) NULL;
    proto_item *destinationType_ti = (proto_item*) NULL;
    destinationType_ti = proto_tree_add_text( tree, tvb, offset + m_destinationType.GetStartByte(), m_destinationType.GetByteLength(), "destinationType (EndpointType)" );
    destinationType_tree = proto_item_add_subtree( destinationType_ti, hCont->h225_1.ett_h225_AdmissionConfirm_destinationType );
    m_destinationType.showEthereal( destinationType_tree, tvb, offset );
  }

  if ( HasOptionalField( e_remoteExtensionAddress ) ) {
    proto_tree *remoteExtensionAddress_tree = (proto_tree*) NULL;
    proto_item *remoteExtensionAddress_ti = (proto_item*) NULL;
    remoteExtensionAddress_ti = proto_tree_add_text( tree, tvb, offset + m_remoteExtensionAddress.GetStartByte(), m_remoteExtensionAddress.GetByteLength(), "remoteExtensionAddress (AliasAddress)" );
    remoteExtensionAddress_tree = proto_item_add_subtree( remoteExtensionAddress_ti, hCont->h225_1.ett_h225_AdmissionConfirm_remoteExtensionAddress );
    m_remoteExtensionAddress.showEthereal( remoteExtensionAddress_tree, tvb, offset );
  }

  if ( HasOptionalField( e_alternateEndpoints ) ) {
    proto_tree *alternateEndpoints_tree = (proto_tree*) NULL;
    proto_item *alternateEndpoints_ti = (proto_item*) NULL;
    alternateEndpoints_ti = proto_tree_add_text( tree, tvb, offset + m_alternateEndpoints.GetStartByte(), m_alternateEndpoints.GetByteLength(), "alternateEndpoints (Endpoint)" );
    alternateEndpoints_tree = proto_item_add_subtree( alternateEndpoints_ti, hCont->h225_1.ett_h225_AdmissionConfirm_alternateEndpoints );
    m_alternateEndpoints.showEthereal( alternateEndpoints_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_AdmissionConfirm_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_AdmissionConfirm_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_1.ett_h225_AdmissionConfirm_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

  if ( HasOptionalField( e_transportQOS ) ) {
    proto_tree *transportQOS_tree = (proto_tree*) NULL;
    proto_item *transportQOS_ti = (proto_item*) NULL;
    transportQOS_ti = proto_tree_add_text( tree, tvb, offset + m_transportQOS.GetStartByte(), m_transportQOS.GetByteLength(), "transportQOS (%s)", ( const char* ) m_transportQOS.GetTagName() );
    transportQOS_tree = proto_item_add_subtree( transportQOS_ti, hCont->h225_1.ett_h225_AdmissionConfirm_transportQOS );
    m_transportQOS.showEthereal( transportQOS_tree, tvb, offset );
  }

  if ( HasOptionalField( e_willRespondToIRR ) ) {
    proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_AdmissionConfirm_willRespondToIRR, tvb, offset + m_willRespondToIRR.GetStartByte(), m_willRespondToIRR.GetByteLength() , m_willRespondToIRR.GetValue() );
  }

  if ( HasOptionalField( e_uuiesRequested ) ) {
    proto_tree *uuiesRequested_tree = (proto_tree*) NULL;
    proto_item *uuiesRequested_ti = (proto_item*) NULL;
    uuiesRequested_ti = proto_tree_add_text( tree, tvb, offset + m_uuiesRequested.GetStartByte(), m_uuiesRequested.GetByteLength(), "uuiesRequested (UUIEsRequested)" );
    uuiesRequested_tree = proto_item_add_subtree( uuiesRequested_ti, hCont->h225_1.ett_h225_AdmissionConfirm_uuiesRequested );
    m_uuiesRequested.showEthereal( uuiesRequested_tree, tvb, offset );
  }

  if ( HasOptionalField( e_language ) ) {
    proto_tree *language_tree = (proto_tree*) NULL;
    proto_item *language_ti = (proto_item*) NULL;
    language_ti = proto_tree_add_text( tree, tvb, offset + m_language.GetStartByte(), m_language.GetByteLength(), "language (AdmissionConfirm-language)" );
    language_tree = proto_item_add_subtree( language_ti, hCont->h225_1.ett_h225_AdmissionConfirm_language );
    m_language.showEthereal( language_tree, tvb, offset );
  }

  if ( HasOptionalField( e_alternateTransportAddresses ) ) {
    proto_tree *alternateTransportAddresses_tree = (proto_tree*) NULL;
    proto_item *alternateTransportAddresses_ti = (proto_item*) NULL;
    alternateTransportAddresses_ti = proto_tree_add_text( tree, tvb, offset + m_alternateTransportAddresses.GetStartByte(), m_alternateTransportAddresses.GetByteLength(), "alternateTransportAddresses (AlternateTransportAddresses)" );
    alternateTransportAddresses_tree = proto_item_add_subtree( alternateTransportAddresses_ti, hCont->h225_1.ett_h225_AdmissionConfirm_alternateTransportAddresses );
    m_alternateTransportAddresses.showEthereal( alternateTransportAddresses_tree, tvb, offset );
  }

  if ( HasOptionalField( e_useSpecifiedTransport ) ) {
    proto_tree *useSpecifiedTransport_tree = (proto_tree*) NULL;
    proto_item *useSpecifiedTransport_ti = (proto_item*) NULL;
    useSpecifiedTransport_ti = proto_tree_add_text( tree, tvb, offset + m_useSpecifiedTransport.GetStartByte(), m_useSpecifiedTransport.GetByteLength(), "useSpecifiedTransport (%s)", ( const char* ) m_useSpecifiedTransport.GetTagName() );
    useSpecifiedTransport_tree = proto_item_add_subtree( useSpecifiedTransport_ti, hCont->h225_1.ett_h225_AdmissionConfirm_useSpecifiedTransport );
    m_useSpecifiedTransport.showEthereal( useSpecifiedTransport_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// LocationConfirm
//

H225_LocationConfirm::H225_LocationConfirm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 9)
{
}


#ifndef PASN_NOPRINTON
void H225_LocationConfirm::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+20) << "callSignalAddress = " << setprecision(indent) << m_callSignalAddress << '\n';
  strm << setw(indent+13) << "rasAddress = " << setprecision(indent) << m_rasAddress << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_destinationInfo))
    strm << setw(indent+18) << "destinationInfo = " << setprecision(indent) << m_destinationInfo << '\n';
  if (HasOptionalField(e_destExtraCallInfo))
    strm << setw(indent+20) << "destExtraCallInfo = " << setprecision(indent) << m_destExtraCallInfo << '\n';
  if (HasOptionalField(e_destinationType))
    strm << setw(indent+18) << "destinationType = " << setprecision(indent) << m_destinationType << '\n';
  if (HasOptionalField(e_remoteExtensionAddress))
    strm << setw(indent+25) << "remoteExtensionAddress = " << setprecision(indent) << m_remoteExtensionAddress << '\n';
  if (HasOptionalField(e_alternateEndpoints))
    strm << setw(indent+21) << "alternateEndpoints = " << setprecision(indent) << m_alternateEndpoints << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_alternateTransportAddresses))
    strm << setw(indent+30) << "alternateTransportAddresses = " << setprecision(indent) << m_alternateTransportAddresses << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_LocationConfirm::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_LocationConfirm::Class()), PInvalidCast);
#endif
  const H225_LocationConfirm & other = (const H225_LocationConfirm &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_callSignalAddress.Compare(other.m_callSignalAddress)) != EqualTo)
    return result;
  if ((result = m_rasAddress.Compare(other.m_rasAddress)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_LocationConfirm::GetDataLength() const
{
  return m_requestSeqNum.GetObjectLength() +
         m_callSignalAddress.GetObjectLength() +
         m_rasAddress.GetObjectLength() +
         m_nonStandardData.GetObjectLength();
}


BOOL H225_LocationConfirm::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callSignalAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_rasAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_destinationInfo, m_destinationInfo ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_destExtraCallInfo, m_destExtraCallInfo ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_destinationType, m_destinationType ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_remoteExtensionAddress, m_remoteExtensionAddress ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_alternateEndpoints, m_alternateEndpoints ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_alternateTransportAddresses, m_alternateTransportAddresses ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_LocationConfirm::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_callSignalAddress.Encode(strm);
  m_rasAddress.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_destinationInfo, m_destinationInfo);
  KnownExtensionEncode(strm, e_destExtraCallInfo, m_destExtraCallInfo);
  KnownExtensionEncode(strm, e_destinationType, m_destinationType);
  KnownExtensionEncode(strm, e_remoteExtensionAddress, m_remoteExtensionAddress);
  KnownExtensionEncode(strm, e_alternateEndpoints, m_alternateEndpoints);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_alternateTransportAddresses, m_alternateTransportAddresses);

  UnknownExtensionsEncode(strm);
  m_requestSeqNum.Encode(strm);
  m_callSignalAddress.Encode(strm);
  m_rasAddress.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
}


PObject * H225_LocationConfirm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_LocationConfirm::Class()), PInvalidCast);
#endif
  return new H225_LocationConfirm(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_LocationConfirm::preShowEthereal( void )
{
  m_requestSeqNum.preShowEthereal( );
  m_callSignalAddress.preShowEthereal( );
  m_rasAddress.preShowEthereal( );
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  if ( HasOptionalField( e_destinationInfo ) ) 
      m_destinationInfo.preShowEthereal( );
  if ( HasOptionalField( e_destExtraCallInfo ) ) 
      m_destExtraCallInfo.preShowEthereal( );
  if ( HasOptionalField( e_destinationType ) ) 
      m_destinationType.preShowEthereal( );
  if ( HasOptionalField( e_remoteExtensionAddress ) ) 
      m_remoteExtensionAddress.preShowEthereal( );
  if ( HasOptionalField( e_alternateEndpoints ) ) 
      m_alternateEndpoints.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
  if ( HasOptionalField( e_alternateTransportAddresses ) ) 
      m_alternateTransportAddresses.preShowEthereal( );
}

PString H225_LocationConfirm::getSummary( void ) 
{
  return PString( "LocationConfirm" );
}

void H225_LocationConfirm::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_LocationConfirm_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  proto_tree *callSignalAddress_tree = (proto_tree*) NULL;
  proto_item *callSignalAddress_ti = (proto_item*) NULL;
  callSignalAddress_ti = proto_tree_add_text( tree, tvb, offset + m_callSignalAddress.GetStartByte(), m_callSignalAddress.GetByteLength(), "callSignalAddress (%s)", ( const char* ) m_callSignalAddress.GetTagName() );
  callSignalAddress_tree = proto_item_add_subtree( callSignalAddress_ti, hCont->h225_1.ett_h225_LocationConfirm_callSignalAddress );

  m_callSignalAddress.showEthereal( callSignalAddress_tree, tvb, offset );

  proto_tree *rasAddress_tree = (proto_tree*) NULL;
  proto_item *rasAddress_ti = (proto_item*) NULL;
  rasAddress_ti = proto_tree_add_text( tree, tvb, offset + m_rasAddress.GetStartByte(), m_rasAddress.GetByteLength(), "rasAddress (%s)", ( const char* ) m_rasAddress.GetTagName() );
  rasAddress_tree = proto_item_add_subtree( rasAddress_ti, hCont->h225_1.ett_h225_LocationConfirm_rasAddress );

  m_rasAddress.showEthereal( rasAddress_tree, tvb, offset );

  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_LocationConfirm_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  if ( HasOptionalField( e_destinationInfo ) ) {
    proto_tree *destinationInfo_tree = (proto_tree*) NULL;
    proto_item *destinationInfo_ti = (proto_item*) NULL;
    destinationInfo_ti = proto_tree_add_text( tree, tvb, offset + m_destinationInfo.GetStartByte(), m_destinationInfo.GetByteLength(), "destinationInfo (AliasAddress)" );
    destinationInfo_tree = proto_item_add_subtree( destinationInfo_ti, hCont->h225_1.ett_h225_LocationConfirm_destinationInfo );
    m_destinationInfo.showEthereal( destinationInfo_tree, tvb, offset );
  }

  if ( HasOptionalField( e_destExtraCallInfo ) ) {
    proto_tree *destExtraCallInfo_tree = (proto_tree*) NULL;
    proto_item *destExtraCallInfo_ti = (proto_item*) NULL;
    destExtraCallInfo_ti = proto_tree_add_text( tree, tvb, offset + m_destExtraCallInfo.GetStartByte(), m_destExtraCallInfo.GetByteLength(), "destExtraCallInfo (AliasAddress)" );
    destExtraCallInfo_tree = proto_item_add_subtree( destExtraCallInfo_ti, hCont->h225_1.ett_h225_LocationConfirm_destExtraCallInfo );
    m_destExtraCallInfo.showEthereal( destExtraCallInfo_tree, tvb, offset );
  }

  if ( HasOptionalField( e_destinationType ) ) {
    proto_tree *destinationType_tree = (proto_tree*) NULL;
    proto_item *destinationType_ti = (proto_item*) NULL;
    destinationType_ti = proto_tree_add_text( tree, tvb, offset + m_destinationType.GetStartByte(), m_destinationType.GetByteLength(), "destinationType (EndpointType)" );
    destinationType_tree = proto_item_add_subtree( destinationType_ti, hCont->h225_1.ett_h225_LocationConfirm_destinationType );
    m_destinationType.showEthereal( destinationType_tree, tvb, offset );
  }

  if ( HasOptionalField( e_remoteExtensionAddress ) ) {
    proto_tree *remoteExtensionAddress_tree = (proto_tree*) NULL;
    proto_item *remoteExtensionAddress_ti = (proto_item*) NULL;
    remoteExtensionAddress_ti = proto_tree_add_text( tree, tvb, offset + m_remoteExtensionAddress.GetStartByte(), m_remoteExtensionAddress.GetByteLength(), "remoteExtensionAddress (AliasAddress)" );
    remoteExtensionAddress_tree = proto_item_add_subtree( remoteExtensionAddress_ti, hCont->h225_1.ett_h225_LocationConfirm_remoteExtensionAddress );
    m_remoteExtensionAddress.showEthereal( remoteExtensionAddress_tree, tvb, offset );
  }

  if ( HasOptionalField( e_alternateEndpoints ) ) {
    proto_tree *alternateEndpoints_tree = (proto_tree*) NULL;
    proto_item *alternateEndpoints_ti = (proto_item*) NULL;
    alternateEndpoints_ti = proto_tree_add_text( tree, tvb, offset + m_alternateEndpoints.GetStartByte(), m_alternateEndpoints.GetByteLength(), "alternateEndpoints (Endpoint)" );
    alternateEndpoints_tree = proto_item_add_subtree( alternateEndpoints_ti, hCont->h225_1.ett_h225_LocationConfirm_alternateEndpoints );
    m_alternateEndpoints.showEthereal( alternateEndpoints_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_LocationConfirm_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_LocationConfirm_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_1.ett_h225_LocationConfirm_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

  if ( HasOptionalField( e_alternateTransportAddresses ) ) {
    proto_tree *alternateTransportAddresses_tree = (proto_tree*) NULL;
    proto_item *alternateTransportAddresses_ti = (proto_item*) NULL;
    alternateTransportAddresses_ti = proto_tree_add_text( tree, tvb, offset + m_alternateTransportAddresses.GetStartByte(), m_alternateTransportAddresses.GetByteLength(), "alternateTransportAddresses (AlternateTransportAddresses)" );
    alternateTransportAddresses_tree = proto_item_add_subtree( alternateTransportAddresses_ti, hCont->h225_1.ett_h225_LocationConfirm_alternateTransportAddresses );
    m_alternateTransportAddresses.showEthereal( alternateTransportAddresses_tree, tvb, offset );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// InfoRequestResponse
//

H225_InfoRequestResponse::H225_InfoRequestResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 4)
{
  IncludeOptionalField(e_needResponse);
}


#ifndef PASN_NOPRINTON
void H225_InfoRequestResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+15) << "endpointType = " << setprecision(indent) << m_endpointType << '\n';
  strm << setw(indent+21) << "endpointIdentifier = " << setprecision(indent) << m_endpointIdentifier << '\n';
  strm << setw(indent+13) << "rasAddress = " << setprecision(indent) << m_rasAddress << '\n';
  strm << setw(indent+20) << "callSignalAddress = " << setprecision(indent) << m_callSignalAddress << '\n';
  if (HasOptionalField(e_endpointAlias))
    strm << setw(indent+16) << "endpointAlias = " << setprecision(indent) << m_endpointAlias << '\n';
  if (HasOptionalField(e_perCallInfo))
    strm << setw(indent+14) << "perCallInfo = " << setprecision(indent) << m_perCallInfo << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_needResponse))
    strm << setw(indent+15) << "needResponse = " << setprecision(indent) << m_needResponse << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_InfoRequestResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_InfoRequestResponse::Class()), PInvalidCast);
#endif
  const H225_InfoRequestResponse & other = (const H225_InfoRequestResponse &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_endpointType.Compare(other.m_endpointType)) != EqualTo)
    return result;
  if ((result = m_endpointIdentifier.Compare(other.m_endpointIdentifier)) != EqualTo)
    return result;
  if ((result = m_rasAddress.Compare(other.m_rasAddress)) != EqualTo)
    return result;
  if ((result = m_callSignalAddress.Compare(other.m_callSignalAddress)) != EqualTo)
    return result;
  if ((result = m_endpointAlias.Compare(other.m_endpointAlias)) != EqualTo)
    return result;
  if ((result = m_perCallInfo.Compare(other.m_perCallInfo)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_InfoRequestResponse::GetDataLength() const
{
  return m_nonStandardData.GetObjectLength() +
         m_requestSeqNum.GetObjectLength() +
         m_endpointType.GetObjectLength() +
         m_endpointIdentifier.GetObjectLength() +
         m_rasAddress.GetObjectLength() +
         m_callSignalAddress.GetObjectLength() +
         m_endpointAlias.GetObjectLength() +
         m_perCallInfo.GetObjectLength();
}


BOOL H225_InfoRequestResponse::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_nonStandardData ) && !m_nonStandardData.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_requestSeqNum.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_endpointType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_endpointIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_rasAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callSignalAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_endpointAlias ) && !m_endpointAlias.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_perCallInfo ) && !m_perCallInfo.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_integrityCheckValue, m_integrityCheckValue ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_needResponse, m_needResponse ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_InfoRequestResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_requestSeqNum.Encode(strm);
  m_endpointType.Encode(strm);
  m_endpointIdentifier.Encode(strm);
  m_rasAddress.Encode(strm);
  m_callSignalAddress.Encode(strm);
  if (HasOptionalField(e_endpointAlias))
    m_endpointAlias.Encode(strm);
  if (HasOptionalField(e_perCallInfo))
    m_perCallInfo.Encode(strm);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_needResponse, m_needResponse);

  UnknownExtensionsEncode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_requestSeqNum.Encode(strm);
  m_endpointType.Encode(strm);
  m_endpointIdentifier.Encode(strm);
  m_rasAddress.Encode(strm);
  m_callSignalAddress.Encode(strm);
  if (HasOptionalField(e_endpointAlias))
    m_endpointAlias.Encode(strm);
  if (HasOptionalField(e_perCallInfo))
    m_perCallInfo.Encode(strm);
}


PObject * H225_InfoRequestResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_InfoRequestResponse::Class()), PInvalidCast);
#endif
  return new H225_InfoRequestResponse(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_InfoRequestResponse::preShowEthereal( void )
{
  if ( HasOptionalField( e_nonStandardData ) ) 
      m_nonStandardData.preShowEthereal( );
  m_requestSeqNum.preShowEthereal( );
  m_endpointType.preShowEthereal( );
  m_endpointIdentifier.preShowEthereal( );
  m_rasAddress.preShowEthereal( );
  m_callSignalAddress.preShowEthereal( );
  if ( HasOptionalField( e_endpointAlias ) ) 
      m_endpointAlias.preShowEthereal( );
  if ( HasOptionalField( e_perCallInfo ) ) 
      m_perCallInfo.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_integrityCheckValue ) ) 
      m_integrityCheckValue.preShowEthereal( );
  if ( HasOptionalField( e_needResponse ) ) 
      m_needResponse.preShowEthereal( );
}

PString H225_InfoRequestResponse::getSummary( void ) 
{
  return PString( "InfoRequestResponse" );
}

void H225_InfoRequestResponse::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  if ( HasOptionalField( e_nonStandardData ) ) {
    proto_tree *nonStandardData_tree = (proto_tree*) NULL;
    proto_item *nonStandardData_ti = (proto_item*) NULL;
    nonStandardData_ti = proto_tree_add_text( tree, tvb, offset + m_nonStandardData.GetStartByte(), m_nonStandardData.GetByteLength(), "nonStandardData (NonStandardParameter)" );
    nonStandardData_tree = proto_item_add_subtree( nonStandardData_ti, hCont->h225_1.ett_h225_InfoRequestResponse_nonStandardData );
    m_nonStandardData.showEthereal( nonStandardData_tree, tvb, offset );
  }

  proto_tree_add_uint( tree, hCont->h225_1.hf_h225_InfoRequestResponse_requestSeqNum, tvb, offset + m_requestSeqNum.GetStartByte(), m_requestSeqNum.GetByteLength() , m_requestSeqNum.GetValue() );

  proto_tree *endpointType_tree = (proto_tree*) NULL;
  proto_item *endpointType_ti = (proto_item*) NULL;
  endpointType_ti = proto_tree_add_text( tree, tvb, offset + m_endpointType.GetStartByte(), m_endpointType.GetByteLength(), "endpointType (EndpointType)" );
  endpointType_tree = proto_item_add_subtree( endpointType_ti, hCont->h225_1.ett_h225_InfoRequestResponse_endpointType );

  m_endpointType.showEthereal( endpointType_tree, tvb, offset );

  char* pendpointIdentifier = m_endpointIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h225_1.hf_h225_InfoRequestResponse_endpointIdentifier, tvb, offset + m_endpointIdentifier.GetStartByte(), m_endpointIdentifier.GetByteLength() , pendpointIdentifier );
  delete[] pendpointIdentifier;

  proto_tree *rasAddress_tree = (proto_tree*) NULL;
  proto_item *rasAddress_ti = (proto_item*) NULL;
  rasAddress_ti = proto_tree_add_text( tree, tvb, offset + m_rasAddress.GetStartByte(), m_rasAddress.GetByteLength(), "rasAddress (%s)", ( const char* ) m_rasAddress.GetTagName() );
  rasAddress_tree = proto_item_add_subtree( rasAddress_ti, hCont->h225_1.ett_h225_InfoRequestResponse_rasAddress );

  m_rasAddress.showEthereal( rasAddress_tree, tvb, offset );

  proto_tree *callSignalAddress_tree = (proto_tree*) NULL;
  proto_item *callSignalAddress_ti = (proto_item*) NULL;
  callSignalAddress_ti = proto_tree_add_text( tree, tvb, offset + m_callSignalAddress.GetStartByte(), m_callSignalAddress.GetByteLength(), "callSignalAddress (TransportAddress)" );
  callSignalAddress_tree = proto_item_add_subtree( callSignalAddress_ti, hCont->h225_1.ett_h225_InfoRequestResponse_callSignalAddress );

  m_callSignalAddress.showEthereal( callSignalAddress_tree, tvb, offset );

  if ( HasOptionalField( e_endpointAlias ) ) {
    proto_tree *endpointAlias_tree = (proto_tree*) NULL;
    proto_item *endpointAlias_ti = (proto_item*) NULL;
    endpointAlias_ti = proto_tree_add_text( tree, tvb, offset + m_endpointAlias.GetStartByte(), m_endpointAlias.GetByteLength(), "endpointAlias (AliasAddress)" );
    endpointAlias_tree = proto_item_add_subtree( endpointAlias_ti, hCont->h225_1.ett_h225_InfoRequestResponse_endpointAlias );
    m_endpointAlias.showEthereal( endpointAlias_tree, tvb, offset );
  }

  if ( HasOptionalField( e_perCallInfo ) ) {
    proto_tree *perCallInfo_tree = (proto_tree*) NULL;
    proto_item *perCallInfo_ti = (proto_item*) NULL;
    perCallInfo_ti = proto_tree_add_text( tree, tvb, offset + m_perCallInfo.GetStartByte(), m_perCallInfo.GetByteLength(), "perCallInfo (InfoRequestResponse-perCallInfo)" );
    perCallInfo_tree = proto_item_add_subtree( perCallInfo_ti, hCont->h225_1.ett_h225_InfoRequestResponse_perCallInfo );
    m_perCallInfo.showEthereal( perCallInfo_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_InfoRequestResponse_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_InfoRequestResponse_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_integrityCheckValue ) ) {
    proto_tree *integrityCheckValue_tree = (proto_tree*) NULL;
    proto_item *integrityCheckValue_ti = (proto_item*) NULL;
    integrityCheckValue_ti = proto_tree_add_text( tree, tvb, offset + m_integrityCheckValue.GetStartByte(), m_integrityCheckValue.GetByteLength(), "integrityCheckValue (ICV)" );
    integrityCheckValue_tree = proto_item_add_subtree( integrityCheckValue_ti, hCont->h225_1.ett_h225_InfoRequestResponse_integrityCheckValue );
    m_integrityCheckValue.showEthereal( integrityCheckValue_tree, tvb, offset );
  }

  if ( HasOptionalField( e_needResponse ) ) {
    proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_InfoRequestResponse_needResponse, tvb, offset + m_needResponse.GetStartByte(), m_needResponse.GetByteLength() , m_needResponse.GetValue() );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// Alerting-UUIE
//

H225_Alerting_UUIE::H225_Alerting_UUIE(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 11)
{
  IncludeOptionalField(e_callIdentifier);
  IncludeOptionalField(e_multipleCalls);
  IncludeOptionalField(e_maintainConnection);
}


#ifndef PASN_NOPRINTON
void H225_Alerting_UUIE::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  strm << setw(indent+18) << "destinationInfo = " << setprecision(indent) << m_destinationInfo << '\n';
  if (HasOptionalField(e_h245Address))
    strm << setw(indent+14) << "h245Address = " << setprecision(indent) << m_h245Address << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_h245SecurityMode))
    strm << setw(indent+19) << "h245SecurityMode = " << setprecision(indent) << m_h245SecurityMode << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_fastStart))
    strm << setw(indent+12) << "fastStart = " << setprecision(indent) << m_fastStart << '\n';
  if (HasOptionalField(e_multipleCalls))
    strm << setw(indent+16) << "multipleCalls = " << setprecision(indent) << m_multipleCalls << '\n';
  if (HasOptionalField(e_maintainConnection))
    strm << setw(indent+21) << "maintainConnection = " << setprecision(indent) << m_maintainConnection << '\n';
  if (HasOptionalField(e_alertingAddress))
    strm << setw(indent+18) << "alertingAddress = " << setprecision(indent) << m_alertingAddress << '\n';
  if (HasOptionalField(e_presentationIndicator))
    strm << setw(indent+24) << "presentationIndicator = " << setprecision(indent) << m_presentationIndicator << '\n';
  if (HasOptionalField(e_screeningIndicator))
    strm << setw(indent+21) << "screeningIndicator = " << setprecision(indent) << m_screeningIndicator << '\n';
  if (HasOptionalField(e_fastConnectRefused))
    strm << setw(indent+21) << "fastConnectRefused = " << setprecision(indent) << m_fastConnectRefused << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_Alerting_UUIE::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_Alerting_UUIE::Class()), PInvalidCast);
#endif
  const H225_Alerting_UUIE & other = (const H225_Alerting_UUIE &)obj;

  Comparison result;

  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_destinationInfo.Compare(other.m_destinationInfo)) != EqualTo)
    return result;
  if ((result = m_h245Address.Compare(other.m_h245Address)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_Alerting_UUIE::GetDataLength() const
{
  return m_protocolIdentifier.GetObjectLength() +
         m_destinationInfo.GetObjectLength() +
         m_h245Address.GetObjectLength();
}


BOOL H225_Alerting_UUIE::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_protocolIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_destinationInfo.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_h245Address ) && !m_h245Address.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_callIdentifier, m_callIdentifier ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_h245SecurityMode, m_h245SecurityMode ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_fastStart, m_fastStart ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_multipleCalls, m_multipleCalls ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_maintainConnection, m_maintainConnection ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_alertingAddress, m_alertingAddress ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_presentationIndicator, m_presentationIndicator ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_screeningIndicator, m_screeningIndicator ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_fastConnectRefused, m_fastConnectRefused ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_Alerting_UUIE::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protocolIdentifier.Encode(strm);
  m_destinationInfo.Encode(strm);
  if (HasOptionalField(e_h245Address))
    m_h245Address.Encode(strm);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_h245SecurityMode, m_h245SecurityMode);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_fastStart, m_fastStart);
  KnownExtensionEncode(strm, e_multipleCalls, m_multipleCalls);
  KnownExtensionEncode(strm, e_maintainConnection, m_maintainConnection);
  KnownExtensionEncode(strm, e_alertingAddress, m_alertingAddress);
  KnownExtensionEncode(strm, e_presentationIndicator, m_presentationIndicator);
  KnownExtensionEncode(strm, e_screeningIndicator, m_screeningIndicator);
  KnownExtensionEncode(strm, e_fastConnectRefused, m_fastConnectRefused);

  UnknownExtensionsEncode(strm);
  m_protocolIdentifier.Encode(strm);
  m_destinationInfo.Encode(strm);
  if (HasOptionalField(e_h245Address))
    m_h245Address.Encode(strm);
}


PObject * H225_Alerting_UUIE::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_Alerting_UUIE::Class()), PInvalidCast);
#endif
  return new H225_Alerting_UUIE(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_Alerting_UUIE::preShowEthereal( void )
{
  m_protocolIdentifier.preShowEthereal( );
  m_destinationInfo.preShowEthereal( );
  if ( HasOptionalField( e_h245Address ) ) {
    m_h245Address.preShowEthereal( );

  	if ( m_h245Address.GetTagName() == "ipAddress" ) {
			H225_TransportAddress_ipAddress tmpAddr = (H225_TransportAddress_ipAddress) m_h245Address;
			//h245_add_address( (unsigned char*) tmpAddr.m_ip.GetPointer(), tmpAddr.m_port );
      address src_addr;
      conversation_t* pconv = ( conversation_t* ) NULL;
      
      src_addr.type = AT_IPv4;
      src_addr.len = 4;
      src_addr.data = (unsigned char*) tmpAddr.m_ip.GetPointer();
      
      pconv = conversation_new( &src_addr, &src_addr, PT_TCP, tmpAddr.m_port , 0, NO_ADDR2 + NO_PORT2 );
      
      conversation_set_dissector( pconv, find_dissector( "h245" ) );
		}
  }
  if ( HasOptionalField( e_callIdentifier ) ) 
      m_callIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_h245SecurityMode ) ) 
      m_h245SecurityMode.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_fastStart ) ) 
      m_fastStart.preShowEthereal( );
  if ( HasOptionalField( e_multipleCalls ) ) 
      m_multipleCalls.preShowEthereal( );
  if ( HasOptionalField( e_maintainConnection ) ) 
      m_maintainConnection.preShowEthereal( );
  if ( HasOptionalField( e_alertingAddress ) ) 
      m_alertingAddress.preShowEthereal( );
  if ( HasOptionalField( e_presentationIndicator ) ) 
      m_presentationIndicator.preShowEthereal( );
  if ( HasOptionalField( e_screeningIndicator ) ) 
      m_screeningIndicator.preShowEthereal( );
  if ( HasOptionalField( e_fastConnectRefused ) ) 
      m_fastConnectRefused.preShowEthereal( );
}

PString H225_Alerting_UUIE::getSummary( void ) 
{
  return PString( "Alerting-UUIE" );
}

void H225_Alerting_UUIE::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pprotocolIdentifier = m_protocolIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h225_1.hf_h225_Alerting_UUIE_protocolIdentifier, tvb, offset + m_protocolIdentifier.GetStartByte(), m_protocolIdentifier.GetByteLength() , pprotocolIdentifier );
  delete[] pprotocolIdentifier;

  proto_tree *destinationInfo_tree = (proto_tree*) NULL;
  proto_item *destinationInfo_ti = (proto_item*) NULL;
  destinationInfo_ti = proto_tree_add_text( tree, tvb, offset + m_destinationInfo.GetStartByte(), m_destinationInfo.GetByteLength(), "destinationInfo (EndpointType)" );
  destinationInfo_tree = proto_item_add_subtree( destinationInfo_ti, hCont->h225_1.ett_h225_Alerting_UUIE_destinationInfo );

  m_destinationInfo.showEthereal( destinationInfo_tree, tvb, offset );

  if ( HasOptionalField( e_h245Address ) ) {
    proto_tree *h245Address_tree = (proto_tree*) NULL;
    proto_item *h245Address_ti = (proto_item*) NULL;
    h245Address_ti = proto_tree_add_text( tree, tvb, offset + m_h245Address.GetStartByte(), m_h245Address.GetByteLength(), "h245Address (%s)", ( const char* ) m_h245Address.GetTagName() );
    h245Address_tree = proto_item_add_subtree( h245Address_ti, hCont->h225_1.ett_h225_Alerting_UUIE_h245Address );
    m_h245Address.showEthereal( h245Address_tree, tvb, offset );
  }

  if ( HasOptionalField( e_callIdentifier ) ) {
    proto_tree *callIdentifier_tree = (proto_tree*) NULL;
    proto_item *callIdentifier_ti = (proto_item*) NULL;
    callIdentifier_ti = proto_tree_add_text( tree, tvb, offset + m_callIdentifier.GetStartByte(), m_callIdentifier.GetByteLength(), "callIdentifier (CallIdentifier)" );
    callIdentifier_tree = proto_item_add_subtree( callIdentifier_ti, hCont->h225_1.ett_h225_Alerting_UUIE_callIdentifier );
    m_callIdentifier.showEthereal( callIdentifier_tree, tvb, offset );
  }

  if ( HasOptionalField( e_h245SecurityMode ) ) {
    proto_tree *h245SecurityMode_tree = (proto_tree*) NULL;
    proto_item *h245SecurityMode_ti = (proto_item*) NULL;
    h245SecurityMode_ti = proto_tree_add_text( tree, tvb, offset + m_h245SecurityMode.GetStartByte(), m_h245SecurityMode.GetByteLength(), "h245SecurityMode (%s)", ( const char* ) m_h245SecurityMode.GetTagName() );
    h245SecurityMode_tree = proto_item_add_subtree( h245SecurityMode_ti, hCont->h225_1.ett_h225_Alerting_UUIE_h245SecurityMode );
    m_h245SecurityMode.showEthereal( h245SecurityMode_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_Alerting_UUIE_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_Alerting_UUIE_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_fastStart ) ) {
    offset++;
    for( int i=0; i < m_fastStart.GetSize(); i++ )
    {
      PPER_Stream per = m_fastStart[ i ].GetValue();

      H245_OpenLogicalChannel olc;
      if ( olc.Decode( per ) )
      {
        proto_tree *fastStart_tree = (proto_tree*) NULL;
        proto_item *fastStart_ti = (proto_item*) NULL;
        fastStart_ti = proto_tree_add_text( tree, tvb, offset + m_fastStart[i].GetStartByte(), m_fastStart[i].GetByteLength(), "fastStart %d %s", i, (const unsigned char*) olc.getSummary() );
        fastStart_tree = proto_item_add_subtree( fastStart_ti, hCont->h225_0.ett_h225_Information_UUIE_fastStart );
        olc.showEthereal( fastStart_tree, tvb, offset + m_fastStart[i].GetStartByte() );
      }
      else
      {
        proto_tree_add_text( tree, tvb, offset + m_fastStart[i].GetStartByte(), m_fastStart.GetByteLength(), "Unable to decode fastStart element %d", i );
      }
    }
  }
  
  if ( HasOptionalField( e_multipleCalls ) ) {
    proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_Alerting_UUIE_multipleCalls, tvb, offset + m_multipleCalls.GetStartByte(), m_multipleCalls.GetByteLength() , m_multipleCalls.GetValue() );
  }

  if ( HasOptionalField( e_maintainConnection ) ) {
    proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_Alerting_UUIE_maintainConnection, tvb, offset + m_maintainConnection.GetStartByte(), m_maintainConnection.GetByteLength() , m_maintainConnection.GetValue() );
  }

  if ( HasOptionalField( e_alertingAddress ) ) {
    proto_tree *alertingAddress_tree = (proto_tree*) NULL;
    proto_item *alertingAddress_ti = (proto_item*) NULL;
    alertingAddress_ti = proto_tree_add_text( tree, tvb, offset + m_alertingAddress.GetStartByte(), m_alertingAddress.GetByteLength(), "alertingAddress (AliasAddress)" );
    alertingAddress_tree = proto_item_add_subtree( alertingAddress_ti, hCont->h225_1.ett_h225_Alerting_UUIE_alertingAddress );
    m_alertingAddress.showEthereal( alertingAddress_tree, tvb, offset );
  }

  if ( HasOptionalField( e_presentationIndicator ) ) {
    proto_tree *presentationIndicator_tree = (proto_tree*) NULL;
    proto_item *presentationIndicator_ti = (proto_item*) NULL;
    presentationIndicator_ti = proto_tree_add_text( tree, tvb, offset + m_presentationIndicator.GetStartByte(), m_presentationIndicator.GetByteLength(), "presentationIndicator (%s)", ( const char* ) m_presentationIndicator.GetTagName() );
    presentationIndicator_tree = proto_item_add_subtree( presentationIndicator_ti, hCont->h225_1.ett_h225_Alerting_UUIE_presentationIndicator );
    m_presentationIndicator.showEthereal( presentationIndicator_tree, tvb, offset );
  }

  if ( HasOptionalField( e_screeningIndicator ) ) {
    char* pscreeningIndicator = m_screeningIndicator.getValue();
    proto_tree_add_string( tree, hCont->h225_1.hf_h225_Alerting_UUIE_screeningIndicator, tvb, offset + m_screeningIndicator.GetStartByte(), m_screeningIndicator.GetByteLength() , pscreeningIndicator );
    delete[] pscreeningIndicator;
  }

  if ( HasOptionalField( e_fastConnectRefused ) ) {
    proto_tree_add_string( tree, hCont->h225_1.hf_h225_Alerting_UUIE_fastConnectRefused, tvb, offset + m_fastConnectRefused.GetStartByte(), m_fastConnectRefused.GetByteLength() , "fastConnectRefused: \"NULL\"" );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// CallProceeding-UUIE
//

H225_CallProceeding_UUIE::H225_CallProceeding_UUIE(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 8)
{
  IncludeOptionalField(e_callIdentifier);
  IncludeOptionalField(e_multipleCalls);
  IncludeOptionalField(e_maintainConnection);
}


#ifndef PASN_NOPRINTON
void H225_CallProceeding_UUIE::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  strm << setw(indent+18) << "destinationInfo = " << setprecision(indent) << m_destinationInfo << '\n';
  if (HasOptionalField(e_h245Address))
    strm << setw(indent+14) << "h245Address = " << setprecision(indent) << m_h245Address << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_h245SecurityMode))
    strm << setw(indent+19) << "h245SecurityMode = " << setprecision(indent) << m_h245SecurityMode << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_fastStart))
    strm << setw(indent+12) << "fastStart = " << setprecision(indent) << m_fastStart << '\n';
  if (HasOptionalField(e_multipleCalls))
    strm << setw(indent+16) << "multipleCalls = " << setprecision(indent) << m_multipleCalls << '\n';
  if (HasOptionalField(e_maintainConnection))
    strm << setw(indent+21) << "maintainConnection = " << setprecision(indent) << m_maintainConnection << '\n';
  if (HasOptionalField(e_fastConnectRefused))
    strm << setw(indent+21) << "fastConnectRefused = " << setprecision(indent) << m_fastConnectRefused << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_CallProceeding_UUIE::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_CallProceeding_UUIE::Class()), PInvalidCast);
#endif
  const H225_CallProceeding_UUIE & other = (const H225_CallProceeding_UUIE &)obj;

  Comparison result;

  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_destinationInfo.Compare(other.m_destinationInfo)) != EqualTo)
    return result;
  if ((result = m_h245Address.Compare(other.m_h245Address)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_CallProceeding_UUIE::GetDataLength() const
{
  return m_protocolIdentifier.GetObjectLength() +
         m_destinationInfo.GetObjectLength() +
         m_h245Address.GetObjectLength();
}


BOOL H225_CallProceeding_UUIE::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_protocolIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_destinationInfo.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_h245Address ) && !m_h245Address.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_callIdentifier, m_callIdentifier ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_h245SecurityMode, m_h245SecurityMode ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_fastStart, m_fastStart ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_multipleCalls, m_multipleCalls ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_maintainConnection, m_maintainConnection ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_fastConnectRefused, m_fastConnectRefused ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_CallProceeding_UUIE::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protocolIdentifier.Encode(strm);
  m_destinationInfo.Encode(strm);
  if (HasOptionalField(e_h245Address))
    m_h245Address.Encode(strm);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_h245SecurityMode, m_h245SecurityMode);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_fastStart, m_fastStart);
  KnownExtensionEncode(strm, e_multipleCalls, m_multipleCalls);
  KnownExtensionEncode(strm, e_maintainConnection, m_maintainConnection);
  KnownExtensionEncode(strm, e_fastConnectRefused, m_fastConnectRefused);

  UnknownExtensionsEncode(strm);
  m_protocolIdentifier.Encode(strm);
  m_destinationInfo.Encode(strm);
  if (HasOptionalField(e_h245Address))
    m_h245Address.Encode(strm);
}


PObject * H225_CallProceeding_UUIE::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_CallProceeding_UUIE::Class()), PInvalidCast);
#endif
  return new H225_CallProceeding_UUIE(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_CallProceeding_UUIE::preShowEthereal( void )
{
  m_protocolIdentifier.preShowEthereal( );
  m_destinationInfo.preShowEthereal( );
  if ( HasOptionalField( e_h245Address ) ) {
    m_h245Address.preShowEthereal( );

  	if ( m_h245Address.GetTagName() == "ipAddress" ) {
			H225_TransportAddress_ipAddress tmpAddr = (H225_TransportAddress_ipAddress) m_h245Address;
			//h245_add_address( (unsigned char*) tmpAddr.m_ip.GetPointer(), tmpAddr.m_port );
      address src_addr;
      conversation_t* pconv = ( conversation_t* ) NULL;
      
      src_addr.type = AT_IPv4;
      src_addr.len = 4;
      src_addr.data = (unsigned char*) tmpAddr.m_ip.GetPointer();
      
      pconv = conversation_new( &src_addr, &src_addr, PT_TCP, tmpAddr.m_port , 0, NO_ADDR2 + NO_PORT2 );
      
      conversation_set_dissector( pconv, find_dissector( "h245" ) );
		}
  }
  if ( HasOptionalField( e_callIdentifier ) ) 
      m_callIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_h245SecurityMode ) ) 
      m_h245SecurityMode.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_fastStart ) ) 
      m_fastStart.preShowEthereal( );
  if ( HasOptionalField( e_multipleCalls ) ) 
      m_multipleCalls.preShowEthereal( );
  if ( HasOptionalField( e_maintainConnection ) ) 
      m_maintainConnection.preShowEthereal( );
  if ( HasOptionalField( e_fastConnectRefused ) ) 
      m_fastConnectRefused.preShowEthereal( );
}

PString H225_CallProceeding_UUIE::getSummary( void ) 
{
  return PString( "CallProceeding-UUIE" );
}

void H225_CallProceeding_UUIE::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pprotocolIdentifier = m_protocolIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h225_1.hf_h225_CallProceeding_UUIE_protocolIdentifier, tvb, offset + m_protocolIdentifier.GetStartByte(), m_protocolIdentifier.GetByteLength() , pprotocolIdentifier );
  delete[] pprotocolIdentifier;

  proto_tree *destinationInfo_tree = (proto_tree*) NULL;
  proto_item *destinationInfo_ti = (proto_item*) NULL;
  destinationInfo_ti = proto_tree_add_text( tree, tvb, offset + m_destinationInfo.GetStartByte(), m_destinationInfo.GetByteLength(), "destinationInfo (EndpointType)" );
  destinationInfo_tree = proto_item_add_subtree( destinationInfo_ti, hCont->h225_1.ett_h225_CallProceeding_UUIE_destinationInfo );

  m_destinationInfo.showEthereal( destinationInfo_tree, tvb, offset );

  if ( HasOptionalField( e_h245Address ) ) {
    proto_tree *h245Address_tree = (proto_tree*) NULL;
    proto_item *h245Address_ti = (proto_item*) NULL;
    h245Address_ti = proto_tree_add_text( tree, tvb, offset + m_h245Address.GetStartByte(), m_h245Address.GetByteLength(), "h245Address (%s)", ( const char* ) m_h245Address.GetTagName() );
    h245Address_tree = proto_item_add_subtree( h245Address_ti, hCont->h225_1.ett_h225_CallProceeding_UUIE_h245Address );
    m_h245Address.showEthereal( h245Address_tree, tvb, offset );
  }

  if ( HasOptionalField( e_callIdentifier ) ) {
    proto_tree *callIdentifier_tree = (proto_tree*) NULL;
    proto_item *callIdentifier_ti = (proto_item*) NULL;
    callIdentifier_ti = proto_tree_add_text( tree, tvb, offset + m_callIdentifier.GetStartByte(), m_callIdentifier.GetByteLength(), "callIdentifier (CallIdentifier)" );
    callIdentifier_tree = proto_item_add_subtree( callIdentifier_ti, hCont->h225_1.ett_h225_CallProceeding_UUIE_callIdentifier );
    m_callIdentifier.showEthereal( callIdentifier_tree, tvb, offset );
  }

  if ( HasOptionalField( e_h245SecurityMode ) ) {
    proto_tree *h245SecurityMode_tree = (proto_tree*) NULL;
    proto_item *h245SecurityMode_ti = (proto_item*) NULL;
    h245SecurityMode_ti = proto_tree_add_text( tree, tvb, offset + m_h245SecurityMode.GetStartByte(), m_h245SecurityMode.GetByteLength(), "h245SecurityMode (%s)", ( const char* ) m_h245SecurityMode.GetTagName() );
    h245SecurityMode_tree = proto_item_add_subtree( h245SecurityMode_ti, hCont->h225_1.ett_h225_CallProceeding_UUIE_h245SecurityMode );
    m_h245SecurityMode.showEthereal( h245SecurityMode_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_CallProceeding_UUIE_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_CallProceeding_UUIE_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_fastStart ) ) {
    offset++;
    for( int i=0; i < m_fastStart.GetSize(); i++ )
    {
      PPER_Stream per = m_fastStart[ i ].GetValue();

      H245_OpenLogicalChannel olc;
      if ( olc.Decode( per ) )
      {
        proto_tree *fastStart_tree = (proto_tree*) NULL;
        proto_item *fastStart_ti = (proto_item*) NULL;
        fastStart_ti = proto_tree_add_text( tree, tvb, offset + m_fastStart[i].GetStartByte(), m_fastStart[i].GetByteLength(), "fastStart %d %s", i, (const unsigned char*) olc.getSummary() );
        fastStart_tree = proto_item_add_subtree( fastStart_ti, hCont->h225_0.ett_h225_Information_UUIE_fastStart );
        olc.showEthereal( fastStart_tree, tvb, offset + m_fastStart[i].GetStartByte() );
      }
      else
      {
        proto_tree_add_text( tree, tvb, offset + m_fastStart[i].GetStartByte(), m_fastStart.GetByteLength(), "Unable to decode fastStart element %d", i );
      }
    }
  }

  if ( HasOptionalField( e_multipleCalls ) ) {
    proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_CallProceeding_UUIE_multipleCalls, tvb, offset + m_multipleCalls.GetStartByte(), m_multipleCalls.GetByteLength() , m_multipleCalls.GetValue() );
  }

  if ( HasOptionalField( e_maintainConnection ) ) {
    proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_CallProceeding_UUIE_maintainConnection, tvb, offset + m_maintainConnection.GetStartByte(), m_maintainConnection.GetByteLength() , m_maintainConnection.GetValue() );
  }

  if ( HasOptionalField( e_fastConnectRefused ) ) {
    proto_tree_add_string( tree, hCont->h225_1.hf_h225_CallProceeding_UUIE_fastConnectRefused, tvb, offset + m_fastConnectRefused.GetStartByte(), m_fastConnectRefused.GetByteLength() , "fastConnectRefused: \"NULL\"" );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// Connect-UUIE
//

H225_Connect_UUIE::H225_Connect_UUIE(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 12)
{
  IncludeOptionalField(e_callIdentifier);
  IncludeOptionalField(e_multipleCalls);
  IncludeOptionalField(e_maintainConnection);
}


#ifndef PASN_NOPRINTON
void H225_Connect_UUIE::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_h245Address))
    strm << setw(indent+14) << "h245Address = " << setprecision(indent) << m_h245Address << '\n';
  strm << setw(indent+18) << "destinationInfo = " << setprecision(indent) << m_destinationInfo << '\n';
  strm << setw(indent+15) << "conferenceID = " << setprecision(indent) << m_conferenceID << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_h245SecurityMode))
    strm << setw(indent+19) << "h245SecurityMode = " << setprecision(indent) << m_h245SecurityMode << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_fastStart))
    strm << setw(indent+12) << "fastStart = " << setprecision(indent) << m_fastStart << '\n';
  if (HasOptionalField(e_multipleCalls))
    strm << setw(indent+16) << "multipleCalls = " << setprecision(indent) << m_multipleCalls << '\n';
  if (HasOptionalField(e_maintainConnection))
    strm << setw(indent+21) << "maintainConnection = " << setprecision(indent) << m_maintainConnection << '\n';
  if (HasOptionalField(e_language))
    strm << setw(indent+11) << "language = " << setprecision(indent) << m_language << '\n';
  if (HasOptionalField(e_connectedAddress))
    strm << setw(indent+19) << "connectedAddress = " << setprecision(indent) << m_connectedAddress << '\n';
  if (HasOptionalField(e_presentationIndicator))
    strm << setw(indent+24) << "presentationIndicator = " << setprecision(indent) << m_presentationIndicator << '\n';
  if (HasOptionalField(e_screeningIndicator))
    strm << setw(indent+21) << "screeningIndicator = " << setprecision(indent) << m_screeningIndicator << '\n';
  if (HasOptionalField(e_fastConnectRefused))
    strm << setw(indent+21) << "fastConnectRefused = " << setprecision(indent) << m_fastConnectRefused << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_Connect_UUIE::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_Connect_UUIE::Class()), PInvalidCast);
#endif
  const H225_Connect_UUIE & other = (const H225_Connect_UUIE &)obj;

  Comparison result;

  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_h245Address.Compare(other.m_h245Address)) != EqualTo)
    return result;
  if ((result = m_destinationInfo.Compare(other.m_destinationInfo)) != EqualTo)
    return result;
  if ((result = m_conferenceID.Compare(other.m_conferenceID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_Connect_UUIE::GetDataLength() const
{
  return m_protocolIdentifier.GetObjectLength() +
         m_h245Address.GetObjectLength() +
         m_destinationInfo.GetObjectLength() +
         m_conferenceID.GetObjectLength();
}


BOOL H225_Connect_UUIE::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_protocolIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_h245Address ) && !m_h245Address.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_destinationInfo.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_conferenceID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_callIdentifier, m_callIdentifier ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_h245SecurityMode, m_h245SecurityMode ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_fastStart, m_fastStart ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_multipleCalls, m_multipleCalls ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_maintainConnection, m_maintainConnection ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_language, m_language ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_connectedAddress, m_connectedAddress ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_presentationIndicator, m_presentationIndicator ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_screeningIndicator, m_screeningIndicator ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_fastConnectRefused, m_fastConnectRefused ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_Connect_UUIE::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_h245Address))
    m_h245Address.Encode(strm);
  m_destinationInfo.Encode(strm);
  m_conferenceID.Encode(strm);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_h245SecurityMode, m_h245SecurityMode);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_fastStart, m_fastStart);
  KnownExtensionEncode(strm, e_multipleCalls, m_multipleCalls);
  KnownExtensionEncode(strm, e_maintainConnection, m_maintainConnection);
  KnownExtensionEncode(strm, e_language, m_language);
  KnownExtensionEncode(strm, e_connectedAddress, m_connectedAddress);
  KnownExtensionEncode(strm, e_presentationIndicator, m_presentationIndicator);
  KnownExtensionEncode(strm, e_screeningIndicator, m_screeningIndicator);
  KnownExtensionEncode(strm, e_fastConnectRefused, m_fastConnectRefused);

  UnknownExtensionsEncode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_h245Address))
    m_h245Address.Encode(strm);
  m_destinationInfo.Encode(strm);
  m_conferenceID.Encode(strm);
}


PObject * H225_Connect_UUIE::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_Connect_UUIE::Class()), PInvalidCast);
#endif
  return new H225_Connect_UUIE(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_Connect_UUIE::preShowEthereal( void )
{
  m_protocolIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_h245Address ) ) {
    m_h245Address.preShowEthereal( );

    if ( m_h245Address.GetTagName() == "ipAddress" )
    {
      H225_TransportAddress_ipAddress tmpAddr = (H225_TransportAddress_ipAddress) m_h245Address;
      //h245_add_address( (unsigned char*) tmpAddr.m_ip.GetPointer(), tmpAddr.m_port );
      address src_addr;
      conversation_t* pconv = ( conversation_t* ) NULL;
      
      src_addr.type = AT_IPv4;
      src_addr.len = 4;
      src_addr.data = (unsigned char*) tmpAddr.m_ip.GetPointer();
      
      pconv = conversation_new( &src_addr, &src_addr, PT_TCP, tmpAddr.m_port , 0, NO_ADDR2 + NO_PORT2 );
      
      conversation_set_dissector( pconv, find_dissector( "h245" ) );
    }
    
	}
  m_destinationInfo.preShowEthereal( );
  m_conferenceID.preShowEthereal( );
  if ( HasOptionalField( e_callIdentifier ) ) 
      m_callIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_h245SecurityMode ) ) 
      m_h245SecurityMode.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_fastStart ) ) 
      m_fastStart.preShowEthereal( );
  if ( HasOptionalField( e_multipleCalls ) ) 
      m_multipleCalls.preShowEthereal( );
  if ( HasOptionalField( e_maintainConnection ) ) 
      m_maintainConnection.preShowEthereal( );
  if ( HasOptionalField( e_language ) ) 
      m_language.preShowEthereal( );
  if ( HasOptionalField( e_connectedAddress ) ) 
      m_connectedAddress.preShowEthereal( );
  if ( HasOptionalField( e_presentationIndicator ) ) 
      m_presentationIndicator.preShowEthereal( );
  if ( HasOptionalField( e_screeningIndicator ) ) 
      m_screeningIndicator.preShowEthereal( );
  if ( HasOptionalField( e_fastConnectRefused ) ) 
      m_fastConnectRefused.preShowEthereal( );
}

PString H225_Connect_UUIE::getSummary( void ) 
{
  return PString( "Connect-UUIE" );
}

void H225_Connect_UUIE::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pprotocolIdentifier = m_protocolIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h225_1.hf_h225_Connect_UUIE_protocolIdentifier, tvb, offset + m_protocolIdentifier.GetStartByte(), m_protocolIdentifier.GetByteLength() , pprotocolIdentifier );
  delete[] pprotocolIdentifier;

  if ( HasOptionalField( e_h245Address ) ) {
    proto_tree *h245Address_tree = (proto_tree*) NULL;
    proto_item *h245Address_ti = (proto_item*) NULL;
    h245Address_ti = proto_tree_add_text( tree, tvb, offset + m_h245Address.GetStartByte(), m_h245Address.GetByteLength(), "h245Address (%s)", ( const char* ) m_h245Address.GetTagName() );
    h245Address_tree = proto_item_add_subtree( h245Address_ti, hCont->h225_1.ett_h225_Connect_UUIE_h245Address );
    m_h245Address.showEthereal( h245Address_tree, tvb, offset );
  }

  proto_tree *destinationInfo_tree = (proto_tree*) NULL;
  proto_item *destinationInfo_ti = (proto_item*) NULL;
  destinationInfo_ti = proto_tree_add_text( tree, tvb, offset + m_destinationInfo.GetStartByte(), m_destinationInfo.GetByteLength(), "destinationInfo (EndpointType)" );
  destinationInfo_tree = proto_item_add_subtree( destinationInfo_ti, hCont->h225_1.ett_h225_Connect_UUIE_destinationInfo );

  m_destinationInfo.showEthereal( destinationInfo_tree, tvb, offset );

  char* pconferenceID = m_conferenceID.getValue();
  proto_tree_add_string( tree, hCont->h225_1.hf_h225_Connect_UUIE_conferenceID, tvb, offset + m_conferenceID.GetStartByte(), m_conferenceID.GetByteLength() , pconferenceID );
  delete[] pconferenceID;

  if ( HasOptionalField( e_callIdentifier ) ) {
    proto_tree *callIdentifier_tree = (proto_tree*) NULL;
    proto_item *callIdentifier_ti = (proto_item*) NULL;
    callIdentifier_ti = proto_tree_add_text( tree, tvb, offset + m_callIdentifier.GetStartByte(), m_callIdentifier.GetByteLength(), "callIdentifier (CallIdentifier)" );
    callIdentifier_tree = proto_item_add_subtree( callIdentifier_ti, hCont->h225_1.ett_h225_Connect_UUIE_callIdentifier );
    m_callIdentifier.showEthereal( callIdentifier_tree, tvb, offset );
  }

  if ( HasOptionalField( e_h245SecurityMode ) ) {
    proto_tree *h245SecurityMode_tree = (proto_tree*) NULL;
    proto_item *h245SecurityMode_ti = (proto_item*) NULL;
    h245SecurityMode_ti = proto_tree_add_text( tree, tvb, offset + m_h245SecurityMode.GetStartByte(), m_h245SecurityMode.GetByteLength(), "h245SecurityMode (%s)", ( const char* ) m_h245SecurityMode.GetTagName() );
    h245SecurityMode_tree = proto_item_add_subtree( h245SecurityMode_ti, hCont->h225_1.ett_h225_Connect_UUIE_h245SecurityMode );
    m_h245SecurityMode.showEthereal( h245SecurityMode_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_Connect_UUIE_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_Connect_UUIE_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_fastStart ) ) {
    offset++;
    for( int i=0; i < m_fastStart.GetSize(); i++ )
    {
      PPER_Stream per = m_fastStart[ i ].GetValue();

      H245_OpenLogicalChannel olc;
      if ( olc.Decode( per ) )
      {
        proto_tree *fastStart_tree = (proto_tree*) NULL;
        proto_item *fastStart_ti = (proto_item*) NULL;
        fastStart_ti = proto_tree_add_text( tree, tvb, offset + m_fastStart[i].GetStartByte(), m_fastStart[i].GetByteLength(), "fastStart %d %s", i, (const unsigned char*) olc.getSummary() );
        fastStart_tree = proto_item_add_subtree( fastStart_ti, hCont->h225_0.ett_h225_Information_UUIE_fastStart );
        olc.showEthereal( fastStart_tree, tvb, offset + m_fastStart[i].GetStartByte() );
      }
      else
      {
        proto_tree_add_text( tree, tvb, offset + m_fastStart[i].GetStartByte(), m_fastStart.GetByteLength(), "Unable to decode fastStart element %d", i );
      }
    }
  }

  if ( HasOptionalField( e_multipleCalls ) ) {
    proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_Connect_UUIE_multipleCalls, tvb, offset + m_multipleCalls.GetStartByte(), m_multipleCalls.GetByteLength() , m_multipleCalls.GetValue() );
  }

  if ( HasOptionalField( e_maintainConnection ) ) {
    proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_Connect_UUIE_maintainConnection, tvb, offset + m_maintainConnection.GetStartByte(), m_maintainConnection.GetByteLength() , m_maintainConnection.GetValue() );
  }

  if ( HasOptionalField( e_language ) ) {
    proto_tree *language_tree = (proto_tree*) NULL;
    proto_item *language_ti = (proto_item*) NULL;
    language_ti = proto_tree_add_text( tree, tvb, offset + m_language.GetStartByte(), m_language.GetByteLength(), "language (Connect-UUIE-language)" );
    language_tree = proto_item_add_subtree( language_ti, hCont->h225_1.ett_h225_Connect_UUIE_language );
    m_language.showEthereal( language_tree, tvb, offset );
  }

  if ( HasOptionalField( e_connectedAddress ) ) {
    proto_tree *connectedAddress_tree = (proto_tree*) NULL;
    proto_item *connectedAddress_ti = (proto_item*) NULL;
    connectedAddress_ti = proto_tree_add_text( tree, tvb, offset + m_connectedAddress.GetStartByte(), m_connectedAddress.GetByteLength(), "connectedAddress (AliasAddress)" );
    connectedAddress_tree = proto_item_add_subtree( connectedAddress_ti, hCont->h225_1.ett_h225_Connect_UUIE_connectedAddress );
    m_connectedAddress.showEthereal( connectedAddress_tree, tvb, offset );
  }

  if ( HasOptionalField( e_presentationIndicator ) ) {
    proto_tree *presentationIndicator_tree = (proto_tree*) NULL;
    proto_item *presentationIndicator_ti = (proto_item*) NULL;
    presentationIndicator_ti = proto_tree_add_text( tree, tvb, offset + m_presentationIndicator.GetStartByte(), m_presentationIndicator.GetByteLength(), "presentationIndicator (%s)", ( const char* ) m_presentationIndicator.GetTagName() );
    presentationIndicator_tree = proto_item_add_subtree( presentationIndicator_ti, hCont->h225_1.ett_h225_Connect_UUIE_presentationIndicator );
    m_presentationIndicator.showEthereal( presentationIndicator_tree, tvb, offset );
  }

  if ( HasOptionalField( e_screeningIndicator ) ) {
    char* pscreeningIndicator = m_screeningIndicator.getValue();
    proto_tree_add_string( tree, hCont->h225_1.hf_h225_Connect_UUIE_screeningIndicator, tvb, offset + m_screeningIndicator.GetStartByte(), m_screeningIndicator.GetByteLength() , pscreeningIndicator );
    delete[] pscreeningIndicator;
  }

  if ( HasOptionalField( e_fastConnectRefused ) ) {
    proto_tree_add_string( tree, hCont->h225_1.hf_h225_Connect_UUIE_fastConnectRefused, tvb, offset + m_fastConnectRefused.GetStartByte(), m_fastConnectRefused.GetByteLength() , "fastConnectRefused: \"NULL\"" );
  }

}
#endif  //USE_FOR_ETHEREAL

//
// Setup-UUIE
//

H225_Setup_UUIE::H225_Setup_UUIE(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 7, TRUE, 16)
{
  IncludeOptionalField(e_callIdentifier);
  IncludeOptionalField(e_mediaWaitForConnect);
  IncludeOptionalField(e_canOverlapSend);
  IncludeOptionalField(e_multipleCalls);
  IncludeOptionalField(e_maintainConnection);
}


#ifndef PASN_NOPRINTON
void H225_Setup_UUIE::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_h245Address))
    strm << setw(indent+14) << "h245Address = " << setprecision(indent) << m_h245Address << '\n';
  if (HasOptionalField(e_sourceAddress))
    strm << setw(indent+16) << "sourceAddress = " << setprecision(indent) << m_sourceAddress << '\n';
  strm << setw(indent+13) << "sourceInfo = " << setprecision(indent) << m_sourceInfo << '\n';
  if (HasOptionalField(e_destinationAddress))
    strm << setw(indent+21) << "destinationAddress = " << setprecision(indent) << m_destinationAddress << '\n';
  if (HasOptionalField(e_destCallSignalAddress))
    strm << setw(indent+24) << "destCallSignalAddress = " << setprecision(indent) << m_destCallSignalAddress << '\n';
  if (HasOptionalField(e_destExtraCallInfo))
    strm << setw(indent+20) << "destExtraCallInfo = " << setprecision(indent) << m_destExtraCallInfo << '\n';
  if (HasOptionalField(e_destExtraCRV))
    strm << setw(indent+15) << "destExtraCRV = " << setprecision(indent) << m_destExtraCRV << '\n';
  strm << setw(indent+11) << "activeMC = " << setprecision(indent) << m_activeMC << '\n';
  strm << setw(indent+15) << "conferenceID = " << setprecision(indent) << m_conferenceID << '\n';
  strm << setw(indent+17) << "conferenceGoal = " << setprecision(indent) << m_conferenceGoal << '\n';
  if (HasOptionalField(e_callServices))
    strm << setw(indent+15) << "callServices = " << setprecision(indent) << m_callServices << '\n';
  strm << setw(indent+11) << "callType = " << setprecision(indent) << m_callType << '\n';
  if (HasOptionalField(e_sourceCallSignalAddress))
    strm << setw(indent+26) << "sourceCallSignalAddress = " << setprecision(indent) << m_sourceCallSignalAddress << '\n';
  if (HasOptionalField(e_remoteExtensionAddress))
    strm << setw(indent+25) << "remoteExtensionAddress = " << setprecision(indent) << m_remoteExtensionAddress << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_h245SecurityCapability))
    strm << setw(indent+25) << "h245SecurityCapability = " << setprecision(indent) << m_h245SecurityCapability << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_fastStart))
    strm << setw(indent+12) << "fastStart = " << setprecision(indent) << m_fastStart << '\n';
  if (HasOptionalField(e_mediaWaitForConnect))
    strm << setw(indent+22) << "mediaWaitForConnect = " << setprecision(indent) << m_mediaWaitForConnect << '\n';
  if (HasOptionalField(e_canOverlapSend))
    strm << setw(indent+17) << "canOverlapSend = " << setprecision(indent) << m_canOverlapSend << '\n';
  if (HasOptionalField(e_endpointIdentifier))
    strm << setw(indent+21) << "endpointIdentifier = " << setprecision(indent) << m_endpointIdentifier << '\n';
  if (HasOptionalField(e_multipleCalls))
    strm << setw(indent+16) << "multipleCalls = " << setprecision(indent) << m_multipleCalls << '\n';
  if (HasOptionalField(e_maintainConnection))
    strm << setw(indent+21) << "maintainConnection = " << setprecision(indent) << m_maintainConnection << '\n';
  if (HasOptionalField(e_connectionParameters))
    strm << setw(indent+23) << "connectionParameters = " << setprecision(indent) << m_connectionParameters << '\n';
  if (HasOptionalField(e_language))
    strm << setw(indent+11) << "language = " << setprecision(indent) << m_language << '\n';
  if (HasOptionalField(e_presentationIndicator))
    strm << setw(indent+24) << "presentationIndicator = " << setprecision(indent) << m_presentationIndicator << '\n';
  if (HasOptionalField(e_screeningIndicator))
    strm << setw(indent+21) << "screeningIndicator = " << setprecision(indent) << m_screeningIndicator << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_Setup_UUIE::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_Setup_UUIE::Class()), PInvalidCast);
#endif
  const H225_Setup_UUIE & other = (const H225_Setup_UUIE &)obj;

  Comparison result;

  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_h245Address.Compare(other.m_h245Address)) != EqualTo)
    return result;
  if ((result = m_sourceAddress.Compare(other.m_sourceAddress)) != EqualTo)
    return result;
  if ((result = m_sourceInfo.Compare(other.m_sourceInfo)) != EqualTo)
    return result;
  if ((result = m_destinationAddress.Compare(other.m_destinationAddress)) != EqualTo)
    return result;
  if ((result = m_destCallSignalAddress.Compare(other.m_destCallSignalAddress)) != EqualTo)
    return result;
  if ((result = m_destExtraCallInfo.Compare(other.m_destExtraCallInfo)) != EqualTo)
    return result;
  if ((result = m_destExtraCRV.Compare(other.m_destExtraCRV)) != EqualTo)
    return result;
  if ((result = m_activeMC.Compare(other.m_activeMC)) != EqualTo)
    return result;
  if ((result = m_conferenceID.Compare(other.m_conferenceID)) != EqualTo)
    return result;
  if ((result = m_conferenceGoal.Compare(other.m_conferenceGoal)) != EqualTo)
    return result;
  if ((result = m_callServices.Compare(other.m_callServices)) != EqualTo)
    return result;
  if ((result = m_callType.Compare(other.m_callType)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_Setup_UUIE::GetDataLength() const
{
  return m_protocolIdentifier.GetObjectLength() +
         m_h245Address.GetObjectLength() +
         m_sourceAddress.GetObjectLength() +
         m_sourceInfo.GetObjectLength() +
         m_destinationAddress.GetObjectLength() +
         m_destCallSignalAddress.GetObjectLength() +
         m_destExtraCallInfo.GetObjectLength() +
         m_destExtraCRV.GetObjectLength() +
         m_activeMC.GetObjectLength() +
         m_conferenceID.GetObjectLength() +
         m_conferenceGoal.GetObjectLength() +
         m_callServices.GetObjectLength() +
         m_callType.GetObjectLength();
}


BOOL H225_Setup_UUIE::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_protocolIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_h245Address ) && !m_h245Address.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_sourceAddress ) && !m_sourceAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_sourceInfo.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_destinationAddress ) && !m_destinationAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_destCallSignalAddress ) && !m_destCallSignalAddress.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_destExtraCallInfo ) && !m_destExtraCallInfo.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_destExtraCRV ) && !m_destExtraCRV.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_activeMC.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_conferenceID.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_conferenceGoal.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_callServices ) && !m_callServices.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callType.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_sourceCallSignalAddress, m_sourceCallSignalAddress ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_remoteExtensionAddress, m_remoteExtensionAddress ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_callIdentifier, m_callIdentifier ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_h245SecurityCapability, m_h245SecurityCapability ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_tokens, m_tokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_cryptoTokens, m_cryptoTokens ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_fastStart, m_fastStart ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_mediaWaitForConnect, m_mediaWaitForConnect ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_canOverlapSend, m_canOverlapSend ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_endpointIdentifier, m_endpointIdentifier ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_multipleCalls, m_multipleCalls ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_maintainConnection, m_maintainConnection ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_connectionParameters, m_connectionParameters ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_language, m_language ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_presentationIndicator, m_presentationIndicator ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_screeningIndicator, m_screeningIndicator ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_Setup_UUIE::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_h245Address))
    m_h245Address.Encode(strm);
  if (HasOptionalField(e_sourceAddress))
    m_sourceAddress.Encode(strm);
  m_sourceInfo.Encode(strm);
  if (HasOptionalField(e_destinationAddress))
    m_destinationAddress.Encode(strm);
  if (HasOptionalField(e_destCallSignalAddress))
    m_destCallSignalAddress.Encode(strm);
  if (HasOptionalField(e_destExtraCallInfo))
    m_destExtraCallInfo.Encode(strm);
  if (HasOptionalField(e_destExtraCRV))
    m_destExtraCRV.Encode(strm);
  m_activeMC.Encode(strm);
  m_conferenceID.Encode(strm);
  m_conferenceGoal.Encode(strm);
  if (HasOptionalField(e_callServices))
    m_callServices.Encode(strm);
  m_callType.Encode(strm);
  KnownExtensionEncode(strm, e_sourceCallSignalAddress, m_sourceCallSignalAddress);
  KnownExtensionEncode(strm, e_remoteExtensionAddress, m_remoteExtensionAddress);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_h245SecurityCapability, m_h245SecurityCapability);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_fastStart, m_fastStart);
  KnownExtensionEncode(strm, e_mediaWaitForConnect, m_mediaWaitForConnect);
  KnownExtensionEncode(strm, e_canOverlapSend, m_canOverlapSend);
  KnownExtensionEncode(strm, e_endpointIdentifier, m_endpointIdentifier);
  KnownExtensionEncode(strm, e_multipleCalls, m_multipleCalls);
  KnownExtensionEncode(strm, e_maintainConnection, m_maintainConnection);
  KnownExtensionEncode(strm, e_connectionParameters, m_connectionParameters);
  KnownExtensionEncode(strm, e_language, m_language);
  KnownExtensionEncode(strm, e_presentationIndicator, m_presentationIndicator);
  KnownExtensionEncode(strm, e_screeningIndicator, m_screeningIndicator);

  UnknownExtensionsEncode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_h245Address))
    m_h245Address.Encode(strm);
  if (HasOptionalField(e_sourceAddress))
    m_sourceAddress.Encode(strm);
  m_sourceInfo.Encode(strm);
  if (HasOptionalField(e_destinationAddress))
    m_destinationAddress.Encode(strm);
  if (HasOptionalField(e_destCallSignalAddress))
    m_destCallSignalAddress.Encode(strm);
  if (HasOptionalField(e_destExtraCallInfo))
    m_destExtraCallInfo.Encode(strm);
  if (HasOptionalField(e_destExtraCRV))
    m_destExtraCRV.Encode(strm);
  m_activeMC.Encode(strm);
  m_conferenceID.Encode(strm);
  m_conferenceGoal.Encode(strm);
  if (HasOptionalField(e_callServices))
    m_callServices.Encode(strm);
  m_callType.Encode(strm);
}


PObject * H225_Setup_UUIE::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_Setup_UUIE::Class()), PInvalidCast);
#endif
  return new H225_Setup_UUIE(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_Setup_UUIE::preShowEthereal( void )
{
  m_protocolIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_h245Address ) ) {
    m_h245Address.preShowEthereal( );

  	if ( m_h245Address.GetTagName() == "ipAddress" ) {
			H225_TransportAddress_ipAddress tmpAddr = (H225_TransportAddress_ipAddress) m_h245Address;
			//h245_add_address( (unsigned char*) tmpAddr.m_ip.GetPointer(), tmpAddr.m_port );
      address src_addr;
      conversation_t* pconv = ( conversation_t* ) NULL;
      
      src_addr.type = AT_IPv4;
      src_addr.len = 4;
      src_addr.data = (unsigned char*) tmpAddr.m_ip.GetPointer();
      
      pconv = conversation_new( &src_addr, &src_addr, PT_TCP, tmpAddr.m_port , 0, NO_ADDR2 + NO_PORT2 );
      
      conversation_set_dissector( pconv, find_dissector( "h245" ) );
		}
  }
  if ( HasOptionalField( e_sourceAddress ) ) 
      m_sourceAddress.preShowEthereal( );
  m_sourceInfo.preShowEthereal( );
  if ( HasOptionalField( e_destinationAddress ) ) 
      m_destinationAddress.preShowEthereal( );
  if ( HasOptionalField( e_destCallSignalAddress ) ) 
      m_destCallSignalAddress.preShowEthereal( );
  if ( HasOptionalField( e_destExtraCallInfo ) ) 
      m_destExtraCallInfo.preShowEthereal( );
  if ( HasOptionalField( e_destExtraCRV ) ) 
      m_destExtraCRV.preShowEthereal( );
  m_activeMC.preShowEthereal( );
  m_conferenceID.preShowEthereal( );
  m_conferenceGoal.preShowEthereal( );
  if ( HasOptionalField( e_callServices ) ) 
      m_callServices.preShowEthereal( );
  m_callType.preShowEthereal( );
  if ( HasOptionalField( e_sourceCallSignalAddress ) ) 
      m_sourceCallSignalAddress.preShowEthereal( );
  if ( HasOptionalField( e_remoteExtensionAddress ) ) 
      m_remoteExtensionAddress.preShowEthereal( );
  if ( HasOptionalField( e_callIdentifier ) ) 
      m_callIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_h245SecurityCapability ) ) 
      m_h245SecurityCapability.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_fastStart ) ) 
      m_fastStart.preShowEthereal( );
  if ( HasOptionalField( e_mediaWaitForConnect ) ) 
      m_mediaWaitForConnect.preShowEthereal( );
  if ( HasOptionalField( e_canOverlapSend ) ) 
      m_canOverlapSend.preShowEthereal( );
  if ( HasOptionalField( e_endpointIdentifier ) ) 
      m_endpointIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_multipleCalls ) ) 
      m_multipleCalls.preShowEthereal( );
  if ( HasOptionalField( e_maintainConnection ) ) 
      m_maintainConnection.preShowEthereal( );
  if ( HasOptionalField( e_connectionParameters ) ) 
      m_connectionParameters.preShowEthereal( );
  if ( HasOptionalField( e_language ) ) 
      m_language.preShowEthereal( );
  if ( HasOptionalField( e_presentationIndicator ) ) 
      m_presentationIndicator.preShowEthereal( );
  if ( HasOptionalField( e_screeningIndicator ) ) 
      m_screeningIndicator.preShowEthereal( );
}

PString H225_Setup_UUIE::getSummary( void ) 
{
  return PString( "Setup-UUIE" );
}

void H225_Setup_UUIE::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pprotocolIdentifier = m_protocolIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h225_1.hf_h225_Setup_UUIE_protocolIdentifier, tvb, offset + m_protocolIdentifier.GetStartByte(), m_protocolIdentifier.GetByteLength() , pprotocolIdentifier );
  delete[] pprotocolIdentifier;

  if ( HasOptionalField( e_h245Address ) ) {
    proto_tree *h245Address_tree = (proto_tree*) NULL;
    proto_item *h245Address_ti = (proto_item*) NULL;
    h245Address_ti = proto_tree_add_text( tree, tvb, offset + m_h245Address.GetStartByte(), m_h245Address.GetByteLength(), "h245Address (%s)", ( const char* ) m_h245Address.GetTagName() );
    h245Address_tree = proto_item_add_subtree( h245Address_ti, hCont->h225_1.ett_h225_Setup_UUIE_h245Address );
    m_h245Address.showEthereal( h245Address_tree, tvb, offset );
  }

  if ( HasOptionalField( e_sourceAddress ) ) {
    proto_tree *sourceAddress_tree = (proto_tree*) NULL;
    proto_item *sourceAddress_ti = (proto_item*) NULL;
    sourceAddress_ti = proto_tree_add_text( tree, tvb, offset + m_sourceAddress.GetStartByte(), m_sourceAddress.GetByteLength(), "sourceAddress (AliasAddress)" );
    sourceAddress_tree = proto_item_add_subtree( sourceAddress_ti, hCont->h225_1.ett_h225_Setup_UUIE_sourceAddress );
    m_sourceAddress.showEthereal( sourceAddress_tree, tvb, offset );
  }

  proto_tree *sourceInfo_tree = (proto_tree*) NULL;
  proto_item *sourceInfo_ti = (proto_item*) NULL;
  sourceInfo_ti = proto_tree_add_text( tree, tvb, offset + m_sourceInfo.GetStartByte(), m_sourceInfo.GetByteLength(), "sourceInfo (EndpointType)" );
  sourceInfo_tree = proto_item_add_subtree( sourceInfo_ti, hCont->h225_1.ett_h225_Setup_UUIE_sourceInfo );

  m_sourceInfo.showEthereal( sourceInfo_tree, tvb, offset );

  if ( HasOptionalField( e_destinationAddress ) ) {
    proto_tree *destinationAddress_tree = (proto_tree*) NULL;
    proto_item *destinationAddress_ti = (proto_item*) NULL;
    destinationAddress_ti = proto_tree_add_text( tree, tvb, offset + m_destinationAddress.GetStartByte(), m_destinationAddress.GetByteLength(), "destinationAddress (AliasAddress)" );
    destinationAddress_tree = proto_item_add_subtree( destinationAddress_ti, hCont->h225_1.ett_h225_Setup_UUIE_destinationAddress );
    m_destinationAddress.showEthereal( destinationAddress_tree, tvb, offset );
  }

  if ( HasOptionalField( e_destCallSignalAddress ) ) {
    proto_tree *destCallSignalAddress_tree = (proto_tree*) NULL;
    proto_item *destCallSignalAddress_ti = (proto_item*) NULL;
    destCallSignalAddress_ti = proto_tree_add_text( tree, tvb, offset + m_destCallSignalAddress.GetStartByte(), m_destCallSignalAddress.GetByteLength(), "destCallSignalAddress (%s)", ( const char* ) m_destCallSignalAddress.GetTagName() );
    destCallSignalAddress_tree = proto_item_add_subtree( destCallSignalAddress_ti, hCont->h225_1.ett_h225_Setup_UUIE_destCallSignalAddress );
    m_destCallSignalAddress.showEthereal( destCallSignalAddress_tree, tvb, offset );
  }

  if ( HasOptionalField( e_destExtraCallInfo ) ) {
    proto_tree *destExtraCallInfo_tree = (proto_tree*) NULL;
    proto_item *destExtraCallInfo_ti = (proto_item*) NULL;
    destExtraCallInfo_ti = proto_tree_add_text( tree, tvb, offset + m_destExtraCallInfo.GetStartByte(), m_destExtraCallInfo.GetByteLength(), "destExtraCallInfo (AliasAddress)" );
    destExtraCallInfo_tree = proto_item_add_subtree( destExtraCallInfo_ti, hCont->h225_1.ett_h225_Setup_UUIE_destExtraCallInfo );
    m_destExtraCallInfo.showEthereal( destExtraCallInfo_tree, tvb, offset );
  }

  if ( HasOptionalField( e_destExtraCRV ) ) {
    proto_tree *destExtraCRV_tree = (proto_tree*) NULL;
    proto_item *destExtraCRV_ti = (proto_item*) NULL;
    destExtraCRV_ti = proto_tree_add_text( tree, tvb, offset + m_destExtraCRV.GetStartByte(), m_destExtraCRV.GetByteLength(), "destExtraCRV (CallReferenceValue)" );
    destExtraCRV_tree = proto_item_add_subtree( destExtraCRV_ti, hCont->h225_1.ett_h225_Setup_UUIE_destExtraCRV );
    m_destExtraCRV.showEthereal( destExtraCRV_tree, tvb, offset );
  }

  proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_Setup_UUIE_activeMC, tvb, offset + m_activeMC.GetStartByte(), m_activeMC.GetByteLength() , m_activeMC.GetValue() );

  char* pconferenceID = m_conferenceID.getValue();
  proto_tree_add_string( tree, hCont->h225_1.hf_h225_Setup_UUIE_conferenceID, tvb, offset + m_conferenceID.GetStartByte(), m_conferenceID.GetByteLength() , pconferenceID );
  delete[] pconferenceID;

  proto_tree *conferenceGoal_tree = (proto_tree*) NULL;
  proto_item *conferenceGoal_ti = (proto_item*) NULL;
  conferenceGoal_ti = proto_tree_add_text( tree, tvb, offset + m_conferenceGoal.GetStartByte(), m_conferenceGoal.GetByteLength(), "conferenceGoal (%s)", ( const char* ) m_conferenceGoal.GetTagName() );
  conferenceGoal_tree = proto_item_add_subtree( conferenceGoal_ti, hCont->h225_1.ett_h225_Setup_UUIE_conferenceGoal );

  m_conferenceGoal.showEthereal( conferenceGoal_tree, tvb, offset );

  if ( HasOptionalField( e_callServices ) ) {
    proto_tree *callServices_tree = (proto_tree*) NULL;
    proto_item *callServices_ti = (proto_item*) NULL;
    callServices_ti = proto_tree_add_text( tree, tvb, offset + m_callServices.GetStartByte(), m_callServices.GetByteLength(), "callServices (QseriesOptions)" );
    callServices_tree = proto_item_add_subtree( callServices_ti, hCont->h225_1.ett_h225_Setup_UUIE_callServices );
    m_callServices.showEthereal( callServices_tree, tvb, offset );
  }

  proto_tree *callType_tree = (proto_tree*) NULL;
  proto_item *callType_ti = (proto_item*) NULL;
  callType_ti = proto_tree_add_text( tree, tvb, offset + m_callType.GetStartByte(), m_callType.GetByteLength(), "callType (%s)", ( const char* ) m_callType.GetTagName() );
  callType_tree = proto_item_add_subtree( callType_ti, hCont->h225_1.ett_h225_Setup_UUIE_callType );

  m_callType.showEthereal( callType_tree, tvb, offset );

  if ( HasOptionalField( e_sourceCallSignalAddress ) ) {
    proto_tree *sourceCallSignalAddress_tree = (proto_tree*) NULL;
    proto_item *sourceCallSignalAddress_ti = (proto_item*) NULL;
    sourceCallSignalAddress_ti = proto_tree_add_text( tree, tvb, offset + m_sourceCallSignalAddress.GetStartByte(), m_sourceCallSignalAddress.GetByteLength(), "sourceCallSignalAddress (%s)", ( const char* ) m_sourceCallSignalAddress.GetTagName() );
    sourceCallSignalAddress_tree = proto_item_add_subtree( sourceCallSignalAddress_ti, hCont->h225_1.ett_h225_Setup_UUIE_sourceCallSignalAddress );
    m_sourceCallSignalAddress.showEthereal( sourceCallSignalAddress_tree, tvb, offset );
  }

  if ( HasOptionalField( e_remoteExtensionAddress ) ) {
    proto_tree *remoteExtensionAddress_tree = (proto_tree*) NULL;
    proto_item *remoteExtensionAddress_ti = (proto_item*) NULL;
    remoteExtensionAddress_ti = proto_tree_add_text( tree, tvb, offset + m_remoteExtensionAddress.GetStartByte(), m_remoteExtensionAddress.GetByteLength(), "remoteExtensionAddress (%s)", ( const char* ) m_remoteExtensionAddress.GetTagName() );
    remoteExtensionAddress_tree = proto_item_add_subtree( remoteExtensionAddress_ti, hCont->h225_1.ett_h225_Setup_UUIE_remoteExtensionAddress );
    m_remoteExtensionAddress.showEthereal( remoteExtensionAddress_tree, tvb, offset );
  }

  if ( HasOptionalField( e_callIdentifier ) ) {
    proto_tree *callIdentifier_tree = (proto_tree*) NULL;
    proto_item *callIdentifier_ti = (proto_item*) NULL;
    callIdentifier_ti = proto_tree_add_text( tree, tvb, offset + m_callIdentifier.GetStartByte(), m_callIdentifier.GetByteLength(), "callIdentifier (CallIdentifier)" );
    callIdentifier_tree = proto_item_add_subtree( callIdentifier_ti, hCont->h225_1.ett_h225_Setup_UUIE_callIdentifier );
    m_callIdentifier.showEthereal( callIdentifier_tree, tvb, offset );
  }

  if ( HasOptionalField( e_h245SecurityCapability ) ) {
    proto_tree *h245SecurityCapability_tree = (proto_tree*) NULL;
    proto_item *h245SecurityCapability_ti = (proto_item*) NULL;
    h245SecurityCapability_ti = proto_tree_add_text( tree, tvb, offset + m_h245SecurityCapability.GetStartByte(), m_h245SecurityCapability.GetByteLength(), "h245SecurityCapability (H245Security)" );
    h245SecurityCapability_tree = proto_item_add_subtree( h245SecurityCapability_ti, hCont->h225_1.ett_h225_Setup_UUIE_h245SecurityCapability );
    m_h245SecurityCapability.showEthereal( h245SecurityCapability_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_Setup_UUIE_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_Setup_UUIE_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_fastStart ) ) {
    offset++;
    for( int i=0; i < m_fastStart.GetSize(); i++ )
    {
      PPER_Stream per = m_fastStart[ i ].GetValue();

      H245_OpenLogicalChannel olc;
      if ( olc.Decode( per ) )
      {
        proto_tree *fastStart_tree = (proto_tree*) NULL;
        proto_item *fastStart_ti = (proto_item*) NULL;
        fastStart_ti = proto_tree_add_text( tree, tvb, offset + m_fastStart[i].GetStartByte(), m_fastStart[i].GetByteLength(), "fastStart %d %s", i, (const unsigned char*) olc.getSummary() );
        fastStart_tree = proto_item_add_subtree( fastStart_ti, hCont->h225_0.ett_h225_Information_UUIE_fastStart );
        olc.showEthereal( fastStart_tree, tvb, offset + m_fastStart[i].GetStartByte() );
      }
      else
      {
        proto_tree_add_text( tree, tvb, offset + m_fastStart[i].GetStartByte(), m_fastStart.GetByteLength(), "Unable to decode fastStart element %d", i );
      }
    }
  }

  if ( HasOptionalField( e_mediaWaitForConnect ) ) {
    proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_Setup_UUIE_mediaWaitForConnect, tvb, offset + m_mediaWaitForConnect.GetStartByte(), m_mediaWaitForConnect.GetByteLength() , m_mediaWaitForConnect.GetValue() );
  }

  if ( HasOptionalField( e_canOverlapSend ) ) {
    proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_Setup_UUIE_canOverlapSend, tvb, offset + m_canOverlapSend.GetStartByte(), m_canOverlapSend.GetByteLength() , m_canOverlapSend.GetValue() );
  }

  if ( HasOptionalField( e_endpointIdentifier ) ) {
    char* pendpointIdentifier = m_endpointIdentifier.getValue();
    proto_tree_add_string( tree, hCont->h225_1.hf_h225_Setup_UUIE_endpointIdentifier, tvb, offset + m_endpointIdentifier.GetStartByte(), m_endpointIdentifier.GetByteLength() , pendpointIdentifier );
    delete[] pendpointIdentifier;
  }

  if ( HasOptionalField( e_multipleCalls ) ) {
    proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_Setup_UUIE_multipleCalls, tvb, offset + m_multipleCalls.GetStartByte(), m_multipleCalls.GetByteLength() , m_multipleCalls.GetValue() );
  }

  if ( HasOptionalField( e_maintainConnection ) ) {
    proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_Setup_UUIE_maintainConnection, tvb, offset + m_maintainConnection.GetStartByte(), m_maintainConnection.GetByteLength() , m_maintainConnection.GetValue() );
  }

  if ( HasOptionalField( e_connectionParameters ) ) {
    proto_tree *connectionParameters_tree = (proto_tree*) NULL;
    proto_item *connectionParameters_ti = (proto_item*) NULL;
    connectionParameters_ti = proto_tree_add_text( tree, tvb, offset + m_connectionParameters.GetStartByte(), m_connectionParameters.GetByteLength(), "connectionParameters (Setup-UUIE-connectionParameters)" );
    connectionParameters_tree = proto_item_add_subtree( connectionParameters_ti, hCont->h225_1.ett_h225_Setup_UUIE_connectionParameters );
    m_connectionParameters.showEthereal( connectionParameters_tree, tvb, offset );
  }

  if ( HasOptionalField( e_language ) ) {
    proto_tree *language_tree = (proto_tree*) NULL;
    proto_item *language_ti = (proto_item*) NULL;
    language_ti = proto_tree_add_text( tree, tvb, offset + m_language.GetStartByte(), m_language.GetByteLength(), "language (Setup-UUIE-language)" );
    language_tree = proto_item_add_subtree( language_ti, hCont->h225_1.ett_h225_Setup_UUIE_language );
    m_language.showEthereal( language_tree, tvb, offset );
  }

  if ( HasOptionalField( e_presentationIndicator ) ) {
    proto_tree *presentationIndicator_tree = (proto_tree*) NULL;
    proto_item *presentationIndicator_ti = (proto_item*) NULL;
    presentationIndicator_ti = proto_tree_add_text( tree, tvb, offset + m_presentationIndicator.GetStartByte(), m_presentationIndicator.GetByteLength(), "presentationIndicator (%s)", ( const char* ) m_presentationIndicator.GetTagName() );
    presentationIndicator_tree = proto_item_add_subtree( presentationIndicator_ti, hCont->h225_1.ett_h225_Setup_UUIE_presentationIndicator );
    m_presentationIndicator.showEthereal( presentationIndicator_tree, tvb, offset );
  }

  if ( HasOptionalField( e_screeningIndicator ) ) {
    char* pscreeningIndicator = m_screeningIndicator.getValue();
    proto_tree_add_string( tree, hCont->h225_1.hf_h225_Setup_UUIE_screeningIndicator, tvb, offset + m_screeningIndicator.GetStartByte(), m_screeningIndicator.GetByteLength() , pscreeningIndicator );
    delete[] pscreeningIndicator;
  }

}
#endif  //USE_FOR_ETHEREAL

//
// Progress-UUIE
//

H225_Progress_UUIE::H225_Progress_UUIE(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 5, TRUE, 3)
{
  IncludeOptionalField(e_multipleCalls);
  IncludeOptionalField(e_maintainConnection);
}


#ifndef PASN_NOPRINTON
void H225_Progress_UUIE::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  strm << setw(indent+18) << "destinationInfo = " << setprecision(indent) << m_destinationInfo << '\n';
  if (HasOptionalField(e_h245Address))
    strm << setw(indent+14) << "h245Address = " << setprecision(indent) << m_h245Address << '\n';
  strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_h245SecurityMode))
    strm << setw(indent+19) << "h245SecurityMode = " << setprecision(indent) << m_h245SecurityMode << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_fastStart))
    strm << setw(indent+12) << "fastStart = " << setprecision(indent) << m_fastStart << '\n';
  if (HasOptionalField(e_multipleCalls))
    strm << setw(indent+16) << "multipleCalls = " << setprecision(indent) << m_multipleCalls << '\n';
  if (HasOptionalField(e_maintainConnection))
    strm << setw(indent+21) << "maintainConnection = " << setprecision(indent) << m_maintainConnection << '\n';
  if (HasOptionalField(e_fastConnectRefused))
    strm << setw(indent+21) << "fastConnectRefused = " << setprecision(indent) << m_fastConnectRefused << '\n';
  strm << setw(indent-1) << "}";
}
#endif


PObject::Comparison H225_Progress_UUIE::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsDescendant(H225_Progress_UUIE::Class()), PInvalidCast);
#endif
  const H225_Progress_UUIE & other = (const H225_Progress_UUIE &)obj;

  Comparison result;

  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_destinationInfo.Compare(other.m_destinationInfo)) != EqualTo)
    return result;
  if ((result = m_h245Address.Compare(other.m_h245Address)) != EqualTo)
    return result;
  if ((result = m_callIdentifier.Compare(other.m_callIdentifier)) != EqualTo)
    return result;
  if ((result = m_h245SecurityMode.Compare(other.m_h245SecurityMode)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;
  if ((result = m_fastStart.Compare(other.m_fastStart)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_Progress_UUIE::GetDataLength() const
{
  return m_protocolIdentifier.GetObjectLength() +
         m_destinationInfo.GetObjectLength() +
         m_h245Address.GetObjectLength() +
         m_callIdentifier.GetObjectLength() +
         m_h245SecurityMode.GetObjectLength() +
         m_tokens.GetObjectLength() +
         m_cryptoTokens.GetObjectLength() +
         m_fastStart.GetObjectLength();
}


BOOL H225_Progress_UUIE::Decode(PASN_Stream & strm)
{
  int result;
  SetStartbyte( strm.GetPosition() );
  if ( !PreambleDecode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_protocolIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_destinationInfo.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_h245Address ) && !m_h245Address.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if (!m_callIdentifier.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_h245SecurityMode ) && !m_h245SecurityMode.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_tokens ) && !m_tokens.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_cryptoTokens ) && !m_cryptoTokens.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( HasOptionalField( e_fastStart ) && !m_fastStart.Decode( strm ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_multipleCalls, m_multipleCalls ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_maintainConnection, m_maintainConnection ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }

  if ( !KnownExtensionDecode( strm, e_fastConnectRefused, m_fastConnectRefused ) ) {
    SetStopbyte( strm.GetPosition() );
    return FALSE;
  }


  result = UnknownExtensionsDecode(strm);
  SetStopbyte( strm.GetPosition() );
  return result;
}


void H225_Progress_UUIE::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protocolIdentifier.Encode(strm);
  m_destinationInfo.Encode(strm);
  if (HasOptionalField(e_h245Address))
    m_h245Address.Encode(strm);
  m_callIdentifier.Encode(strm);
  if (HasOptionalField(e_h245SecurityMode))
    m_h245SecurityMode.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_fastStart))
    m_fastStart.Encode(strm);
  KnownExtensionEncode(strm, e_multipleCalls, m_multipleCalls);
  KnownExtensionEncode(strm, e_maintainConnection, m_maintainConnection);
  KnownExtensionEncode(strm, e_fastConnectRefused, m_fastConnectRefused);

  UnknownExtensionsEncode(strm);
  m_protocolIdentifier.Encode(strm);
  m_destinationInfo.Encode(strm);
  if (HasOptionalField(e_h245Address))
    m_h245Address.Encode(strm);
  m_callIdentifier.Encode(strm);
  if (HasOptionalField(e_h245SecurityMode))
    m_h245SecurityMode.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_fastStart))
    m_fastStart.Encode(strm);
}


PObject * H225_Progress_UUIE::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_Progress_UUIE::Class()), PInvalidCast);
#endif
  return new H225_Progress_UUIE(*this);
}


#ifdef USE_FOR_ETHEREAL
void H225_Progress_UUIE::preShowEthereal( void )
{
  m_protocolIdentifier.preShowEthereal( );
  m_destinationInfo.preShowEthereal( );
  if ( HasOptionalField( e_h245Address ) ) {
    m_h245Address.preShowEthereal( );

  	if ( m_h245Address.GetTagName() == "ipAddress" ) {
			H225_TransportAddress_ipAddress tmpAddr = (H225_TransportAddress_ipAddress) m_h245Address;
			//h245_add_address( (unsigned char*) tmpAddr.m_ip.GetPointer(), tmpAddr.m_port );
      address src_addr;
      conversation_t* pconv = ( conversation_t* ) NULL;
      
      src_addr.type = AT_IPv4;
      src_addr.len = 4;
      src_addr.data = (unsigned char*) tmpAddr.m_ip.GetPointer();
      
      pconv = conversation_new( &src_addr, &src_addr, PT_TCP, tmpAddr.m_port , 0, NO_ADDR2 + NO_PORT2 );
      
      conversation_set_dissector( pconv, find_dissector( "h245" ) );
}
  }
  m_callIdentifier.preShowEthereal( );
  if ( HasOptionalField( e_h245SecurityMode ) ) 
      m_h245SecurityMode.preShowEthereal( );
  if ( HasOptionalField( e_tokens ) ) 
      m_tokens.preShowEthereal( );
  if ( HasOptionalField( e_cryptoTokens ) ) 
      m_cryptoTokens.preShowEthereal( );
  if ( HasOptionalField( e_fastStart ) ) 
      m_fastStart.preShowEthereal( );
  if ( HasOptionalField( e_multipleCalls ) ) 
      m_multipleCalls.preShowEthereal( );
  if ( HasOptionalField( e_maintainConnection ) ) 
      m_maintainConnection.preShowEthereal( );
  if ( HasOptionalField( e_fastConnectRefused ) ) 
      m_fastConnectRefused.preShowEthereal( );
}

PString H225_Progress_UUIE::getSummary( void ) 
{
  return PString( "Progress-UUIE" );
}

void H225_Progress_UUIE::showEthereal( proto_tree *tree, tvbuff_t *tvb, unsigned int offset ) const
{
  char* pprotocolIdentifier = m_protocolIdentifier.getValue();
  proto_tree_add_string( tree, hCont->h225_1.hf_h225_Progress_UUIE_protocolIdentifier, tvb, offset + m_protocolIdentifier.GetStartByte(), m_protocolIdentifier.GetByteLength() , pprotocolIdentifier );
  delete[] pprotocolIdentifier;

  proto_tree *destinationInfo_tree = (proto_tree*) NULL;
  proto_item *destinationInfo_ti = (proto_item*) NULL;
  destinationInfo_ti = proto_tree_add_text( tree, tvb, offset + m_destinationInfo.GetStartByte(), m_destinationInfo.GetByteLength(), "destinationInfo (EndpointType)" );
  destinationInfo_tree = proto_item_add_subtree( destinationInfo_ti, hCont->h225_1.ett_h225_Progress_UUIE_destinationInfo );

  m_destinationInfo.showEthereal( destinationInfo_tree, tvb, offset );

  if ( HasOptionalField( e_h245Address ) ) {
    proto_tree *h245Address_tree = (proto_tree*) NULL;
    proto_item *h245Address_ti = (proto_item*) NULL;
    h245Address_ti = proto_tree_add_text( tree, tvb, offset + m_h245Address.GetStartByte(), m_h245Address.GetByteLength(), "h245Address (%s)", ( const char* ) m_h245Address.GetTagName() );
    h245Address_tree = proto_item_add_subtree( h245Address_ti, hCont->h225_1.ett_h225_Progress_UUIE_h245Address );
    m_h245Address.showEthereal( h245Address_tree, tvb, offset );
  }

  proto_tree *callIdentifier_tree = (proto_tree*) NULL;
  proto_item *callIdentifier_ti = (proto_item*) NULL;
  callIdentifier_ti = proto_tree_add_text( tree, tvb, offset + m_callIdentifier.GetStartByte(), m_callIdentifier.GetByteLength(), "callIdentifier (CallIdentifier)" );
  callIdentifier_tree = proto_item_add_subtree( callIdentifier_ti, hCont->h225_1.ett_h225_Progress_UUIE_callIdentifier );

  m_callIdentifier.showEthereal( callIdentifier_tree, tvb, offset );

  if ( HasOptionalField( e_h245SecurityMode ) ) {
    proto_tree *h245SecurityMode_tree = (proto_tree*) NULL;
    proto_item *h245SecurityMode_ti = (proto_item*) NULL;
    h245SecurityMode_ti = proto_tree_add_text( tree, tvb, offset + m_h245SecurityMode.GetStartByte(), m_h245SecurityMode.GetByteLength(), "h245SecurityMode (%s)", ( const char* ) m_h245SecurityMode.GetTagName() );
    h245SecurityMode_tree = proto_item_add_subtree( h245SecurityMode_ti, hCont->h225_1.ett_h225_Progress_UUIE_h245SecurityMode );
    m_h245SecurityMode.showEthereal( h245SecurityMode_tree, tvb, offset );
  }

  if ( HasOptionalField( e_tokens ) ) {
    proto_tree *tokens_tree = (proto_tree*) NULL;
    proto_item *tokens_ti = (proto_item*) NULL;
    tokens_ti = proto_tree_add_text( tree, tvb, offset + m_tokens.GetStartByte(), m_tokens.GetByteLength(), "tokens (ClearToken)" );
    tokens_tree = proto_item_add_subtree( tokens_ti, hCont->h225_1.ett_h225_Progress_UUIE_tokens );
    m_tokens.showEthereal( tokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_cryptoTokens ) ) {
    proto_tree *cryptoTokens_tree = (proto_tree*) NULL;
    proto_item *cryptoTokens_ti = (proto_item*) NULL;
    cryptoTokens_ti = proto_tree_add_text( tree, tvb, offset + m_cryptoTokens.GetStartByte(), m_cryptoTokens.GetByteLength(), "cryptoTokens (CryptoH323Token)" );
    cryptoTokens_tree = proto_item_add_subtree( cryptoTokens_ti, hCont->h225_1.ett_h225_Progress_UUIE_cryptoTokens );
    m_cryptoTokens.showEthereal( cryptoTokens_tree, tvb, offset );
  }

  if ( HasOptionalField( e_fastStart ) ) {
    offset++;
    for( int i=0; i < m_fastStart.GetSize(); i++ )
    {
      PPER_Stream per = m_fastStart[ i ].GetValue();

      H245_OpenLogicalChannel olc;
      if ( olc.Decode( per ) )
      {
        proto_tree *fastStart_tree = (proto_tree*) NULL;
        proto_item *fastStart_ti = (proto_item*) NULL;
        fastStart_ti = proto_tree_add_text( tree, tvb, offset + m_fastStart[i].GetStartByte(), m_fastStart[i].GetByteLength(), "fastStart %d %s", i, (const unsigned char*) olc.getSummary() );
        fastStart_tree = proto_item_add_subtree( fastStart_ti, hCont->h225_0.ett_h225_Information_UUIE_fastStart );
        olc.showEthereal( fastStart_tree, tvb, offset + m_fastStart[i].GetStartByte() );
      }
      else
      {
        proto_tree_add_text( tree, tvb, offset + m_fastStart[i].GetStartByte(), m_fastStart.GetByteLength(), "Unable to decode fastStart element %d", i );
      }
    }
  }

  if ( HasOptionalField( e_multipleCalls ) ) {
    proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_Progress_UUIE_multipleCalls, tvb, offset + m_multipleCalls.GetStartByte(), m_multipleCalls.GetByteLength() , m_multipleCalls.GetValue() );
  }

  if ( HasOptionalField( e_maintainConnection ) ) {
    proto_tree_add_boolean( tree, hCont->h225_1.hf_h225_Progress_UUIE_maintainConnection, tvb, offset + m_maintainConnection.GetStartByte(), m_maintainConnection.GetByteLength() , m_maintainConnection.GetValue() );
  }

  if ( HasOptionalField( e_fastConnectRefused ) ) {
    proto_tree_add_string( tree, hCont->h225_1.hf_h225_Progress_UUIE_fastConnectRefused, tvb, offset + m_fastConnectRefused.GetStartByte(), m_fastConnectRefused.GetByteLength() , "fastConnectRefused: \"NULL\"" );
  }

}
#endif  //USE_FOR_ETHEREAL


// End of h225.cxx
